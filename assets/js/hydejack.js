(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

/*! modernizr 3.4.0 (Custom Build) | MIT *
 * https://modernizr.com/download/?-classlist-cssanimations-csspointerevents-cssremunit-csstransforms-documentfragment-eventlistener-history-matchmedia-opacity-queryselector-requestanimationframe-touchevents !*/
!function (e, t, n) {
  function r(e, t) {
    return typeof e === t;
  }function o() {
    var e, t, n, o, i, s, a;for (var u in g) if (g.hasOwnProperty(u)) {
      if (e = [], t = g[u], t.name && (e.push(t.name.toLowerCase()), t.options && t.options.aliases && t.options.aliases.length)) for (n = 0; n < t.options.aliases.length; n++) e.push(t.options.aliases[n].toLowerCase());for (o = r(t.fn, "function") ? t.fn() : t.fn, i = 0; i < e.length; i++) s = e[i], a = s.split("."), 1 === a.length ? Modernizr[a[0]] = o : (!Modernizr[a[0]] || Modernizr[a[0]] instanceof Boolean || (Modernizr[a[0]] = new Boolean(Modernizr[a[0]])), Modernizr[a[0]][a[1]] = o), S.push((o ? "" : "no-") + a.join("-"));
    }
  }function i(e) {
    return e.replace(/([a-z])-([a-z])/g, function (e, t, n) {
      return t + n.toUpperCase();
    }).replace(/^-/, "");
  }function s() {
    return "function" != typeof t.createElement ? t.createElement(arguments[0]) : w ? t.createElementNS.call(t, "http://www.w3.org/2000/svg", arguments[0]) : t.createElement.apply(t, arguments);
  }function a() {
    var e = t.body;return e || (e = s(w ? "svg" : "body"), e.fake = !0), e;
  }function u(e, n, r, o) {
    var i,
        u,
        l,
        f,
        d = "modernizr",
        c = s("div"),
        p = a();if (parseInt(r, 10)) for (; r--;) l = s("div"), l.id = o ? o[r] : d + (r + 1), c.appendChild(l);return i = s("style"), i.type = "text/css", i.id = "s" + d, (p.fake ? p : c).appendChild(i), p.appendChild(c), i.styleSheet ? i.styleSheet.cssText = e : i.appendChild(t.createTextNode(e)), c.id = d, p.fake && (p.style.background = "", p.style.overflow = "hidden", f = T.style.overflow, T.style.overflow = "hidden", T.appendChild(p)), u = n(c, e), p.fake ? (p.parentNode.removeChild(p), T.style.overflow = f, T.offsetHeight) : c.parentNode.removeChild(c), !!u;
  }function l(e, t) {
    return !!~("" + e).indexOf(t);
  }function f(e, t) {
    return function () {
      return e.apply(t, arguments);
    };
  }function d(e, t, n) {
    var o;for (var i in e) if (e[i] in t) return n === !1 ? e[i] : (o = t[e[i]], r(o, "function") ? f(o, n || t) : o);return !1;
  }function c(e) {
    return e.replace(/([A-Z])/g, function (e, t) {
      return "-" + t.toLowerCase();
    }).replace(/^ms-/, "-ms-");
  }function p(t, n, r) {
    var o;if ("getComputedStyle" in e) {
      o = getComputedStyle.call(e, t, n);var i = e.console;if (null !== o) r && (o = o.getPropertyValue(r));else if (i) {
        var s = i.error ? "error" : "log";i[s].call(i, "getComputedStyle returning null, its possible modernizr test results are inaccurate");
      }
    } else o = !n && t.currentStyle && t.currentStyle[r];return o;
  }function m(t, r) {
    var o = t.length;if ("CSS" in e && "supports" in e.CSS) {
      for (; o--;) if (e.CSS.supports(c(t[o]), r)) return !0;return !1;
    }if ("CSSSupportsRule" in e) {
      for (var i = []; o--;) i.push("(" + c(t[o]) + ":" + r + ")");return i = i.join(" or "), u("@supports (" + i + ") { #modernizr { position: absolute; } }", function (e) {
        return "absolute" == p(e, null, "position");
      });
    }return n;
  }function v(e, t, o, a) {
    function u() {
      d && (delete P.style, delete P.modElem);
    }if (a = r(a, "undefined") ? !1 : a, !r(o, "undefined")) {
      var f = m(e, o);if (!r(f, "undefined")) return f;
    }for (var d, c, p, v, y, h = ["modernizr", "tspan", "samp"]; !P.style && h.length;) d = !0, P.modElem = s(h.shift()), P.style = P.modElem.style;for (p = e.length, c = 0; p > c; c++) if (v = e[c], y = P.style[v], l(v, "-") && (v = i(v)), P.style[v] !== n) {
      if (a || r(o, "undefined")) return u(), "pfx" == t ? v : !0;try {
        P.style[v] = o;
      } catch (g) {}if (P.style[v] != y) return u(), "pfx" == t ? v : !0;
    }return u(), !1;
  }function y(e, t, n, o, i) {
    var s = e.charAt(0).toUpperCase() + e.slice(1),
        a = (e + " " + b.join(s + " ") + s).split(" ");return r(t, "string") || r(t, "undefined") ? v(a, t, o, i) : (a = (e + " " + E.join(s + " ") + s).split(" "), d(a, t, n));
  }function h(e, t, r) {
    return y(e, n, n, t, r);
  }var g = [],
      C = { _version: "3.4.0", _config: { classPrefix: "", enableClasses: !0, enableJSClass: !0, usePrefixes: !0 }, _q: [], on: function (e, t) {
      var n = this;setTimeout(function () {
        t(n[e]);
      }, 0);
    }, addTest: function (e, t, n) {
      g.push({ name: e, fn: t, options: n });
    }, addAsyncTest: function (e) {
      g.push({ name: null, fn: e });
    } },
      Modernizr = function () {};Modernizr.prototype = C, Modernizr = new Modernizr(), Modernizr.addTest("eventlistener", "addEventListener" in e), Modernizr.addTest("history", function () {
    var t = navigator.userAgent;return -1 === t.indexOf("Android 2.") && -1 === t.indexOf("Android 4.0") || -1 === t.indexOf("Mobile Safari") || -1 !== t.indexOf("Chrome") || -1 !== t.indexOf("Windows Phone") || "file:" === location.protocol ? e.history && "pushState" in e.history : !1;
  }), Modernizr.addTest("queryselector", "querySelector" in t && "querySelectorAll" in t);var S = [],
      x = C._config.usePrefixes ? " -webkit- -moz- -o- -ms- ".split(" ") : ["", ""];C._prefixes = x;var T = t.documentElement;Modernizr.addTest("classlist", "classList" in T), Modernizr.addTest("documentfragment", function () {
    return "createDocumentFragment" in t && "appendChild" in T;
  });var w = "svg" === T.nodeName.toLowerCase();Modernizr.addTest("opacity", function () {
    var e = s("a").style;return e.cssText = x.join("opacity:.55;"), /^0.55$/.test(e.opacity);
  }), Modernizr.addTest("csspointerevents", function () {
    var e = s("a").style;return e.cssText = "pointer-events:auto", "auto" === e.pointerEvents;
  }), Modernizr.addTest("cssremunit", function () {
    var e = s("a").style;try {
      e.fontSize = "3rem";
    } catch (t) {}return (/rem/.test(e.fontSize)
    );
  });var _ = C.testStyles = u;Modernizr.addTest("touchevents", function () {
    var n;if ("ontouchstart" in e || e.DocumentTouch && t instanceof DocumentTouch) n = !0;else {
      var r = ["@media (", x.join("touch-enabled),("), "heartz", ")", "{#modernizr{top:9px;position:absolute}}"].join("");_(r, function (e) {
        n = 9 === e.offsetTop;
      });
    }return n;
  });var z = "Moz O ms Webkit",
      b = C._config.usePrefixes ? z.split(" ") : [];C._cssomPrefixes = b;var A = function (t) {
    var r,
        o = x.length,
        i = e.CSSRule;if ("undefined" == typeof i) return n;if (!t) return !1;if (t = t.replace(/^@/, ""), r = t.replace(/-/g, "_").toUpperCase() + "_RULE", r in i) return "@" + t;for (var s = 0; o > s; s++) {
      var a = x[s],
          u = a.toUpperCase() + "_" + r;if (u in i) return "@-" + a.toLowerCase() + "-" + t;
    }return !1;
  };C.atRule = A;var E = C._config.usePrefixes ? z.toLowerCase().split(" ") : [];C._domPrefixes = E;var O = { elem: s("modernizr") };Modernizr._q.push(function () {
    delete O.elem;
  });var P = { style: O.elem.style };Modernizr._q.unshift(function () {
    delete P.style;
  }), C.testAllProps = y;var q = C.prefixed = function (e, t, n) {
    return 0 === e.indexOf("@") ? A(e) : (-1 != e.indexOf("-") && (e = i(e)), t ? y(e, t, n) : y(e, "pfx"));
  };Modernizr.addTest("requestanimationframe", !!q("requestAnimationFrame", e), { aliases: ["raf"] }), Modernizr.addTest("matchmedia", !!q("matchMedia", e)), C.testAllProps = h, Modernizr.addTest("cssanimations", h("animationName", "a", !0)), Modernizr.addTest("csstransforms", function () {
    return -1 === navigator.userAgent.indexOf("Android 2.") && h("transform", "scale(1)", !0);
  }), o(), delete C.addTest, delete C.addAsyncTest;for (var L = 0; L < Modernizr._q.length; L++) Modernizr._q[L]();e.Modernizr = Modernizr;
}(window, document);

},{}],2:[function(require,module,exports){
'use strict';

console.log(' __  __                __                                     __         \r\n\/\\ \\\/\\ \\              \/\\ \\             __                    \/\\ \\        \r\n\\ \\ \\_\\ \\   __  __    \\_\\ \\      __   \/\\_\\      __       ___ \\ \\ \\\/\'\\    \r\n \\ \\  _  \\ \/\\ \\\/\\ \\   \/\'_` \\   \/\'__`\\ \\\/\\ \\   \/\'__`\\    \/\'___\\\\ \\ , <    \r\n  \\ \\ \\ \\ \\\\ \\ \\_\\ \\ \/\\ \\L\\ \\ \/\\  __\/  \\ \\ \\ \/\\ \\L\\.\\_ \/\\ \\__\/ \\ \\ \\\\`\\  \r\n   \\ \\_\\ \\_\\\\\/`____ \\\\ \\___,_\\\\ \\____\\ _\\ \\ \\\\ \\__\/.\\_\\\\ \\____\\ \\ \\_\\ \\_\\\r\n    \\\/_\/\\\/_\/ `\/___\/> \\\\\/__,_ \/ \\\/____\/\/\\ \\_\\ \\\\\/__\/\\\/_\/ \\\/____\/  \\\/_\/\\\/_\/\r\n                \/\\___\/                \\ \\____\/                           \r\n                \\\/__\/                  \\\/___\/                            ');
console.log('Powered by Hydejack v6.4.0 (https://qwtel.com/hydejack/)');

},{}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unhide = undefined;
exports.hasFeatures = hasFeatures;
exports.show = show;
exports.hide = hide;
exports.unshow = unshow;
exports.matches = matches;
exports.animate = animate;

var _Observable = require('rxjs/Observable');

function hasFeatures(features) {
  let acc = true;
  for (let i = 0; i < features.length; i += 1) {
    const feature = features[i];
    const hasFeature = window.Modernizr[feature];
    // if (!hasFeature) console.warn('Feature "' + feature + '" missing!');
    acc = acc && hasFeature;
  }
  return acc;
} // Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

/* eslint-disable no-param-reassign */

function show(el) {
  el.style.display = 'block';
  el.style.visibility = 'visible';
}

function hide(el) {
  el.style.display = 'none';
  el.style.visibility = 'hidden';
}

function unshow(el) {
  el.style.display = '';
  el.style.visibility = '';
}

const unhide = exports.unhide = unshow;

function matches(el, selector) {
  return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);
}

function animate(el, keyframes, options) {
  return _Observable.Observable.create(observer => {
    const anim = el.animate(keyframes, options);

    anim.addEventListener('finish', e => {
      observer.next(e);
      observer.complete();
    });

    return () => {
      // if (anim.playState !== 'finished') anim.cancel();
    };
  });
}

},{"rxjs/Observable":116}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Observable = require('rxjs/Observable');

var _empty = require('rxjs/observable/empty');

var _fromEvent = require('rxjs/observable/fromEvent');

var _timer = require('rxjs/observable/timer');

var _color = require('color');

var _color2 = _interopRequireDefault(_color);

var _do = require('rxjs/operator/do');

var _finally = require('rxjs/operator/finally');

var _map = require('rxjs/operator/map');

var _zip = require('rxjs/operator/zip');

var _common = require('./common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

/*
eslint-disable
no-param-reassign,
import/no-extraneous-dependencies,
import/no-unresolved,
import/extensions,
class-methods-use-this,
*/

const { find } = Array.prototype;

const BORDER_COLOR_FADE = 0.8;

function updateStyle({ color = '#00f' } = {}) {
  this.rules[0].style.color = color; // .content a
  this.rules[0].style.borderColor = (0, _color2.default)(color).fade(BORDER_COLOR_FADE).string();
  this.rules[1].style.borderColor = color;
  this.rules[2].style.outlineColor = color; // :focus
  this.rules[3].style.backgroundColor = color; // ::selection
}

class CrossFader {
  constructor({ duration }) {
    var _context;

    const main = document.getElementById('_main');
    const pageStyle = document.getElementById('_pageStyle');
    const styleSheet = (_context = document.styleSheets, find).call(_context, ss => ss.ownerNode === pageStyle);

    this.sidebar = document.getElementById('_sidebar');

    this.duration = duration;
    this.rules = styleSheet.cssRules || styleSheet.rules;
    this.prevImage = main.getAttribute('data-image');
    this.prevColor = main.getAttribute('data-color');
  }

  fetchImage(dataset) {
    var _context3;

    const { color, image } = dataset;

    if (image === this.prevImage && color === this.prevColor) {
      return _empty.empty.call(_Observable.Observable);
    }

    let res$;

    if (image === '' || image === this.prevImage) {
      res$ = _timer.timer.call(_Observable.Observable, this.duration);
    } else {
      var _context2;

      const imgObj = new Image();

      res$ = (_context2 = (_context2 = _fromEvent.fromEvent.call(_Observable.Observable, imgObj, 'load'), _zip.zipProto).call(_context2, _timer.timer.call(_Observable.Observable, this.duration), x => x), _finally._finally).call(_context2, () => {
        imgObj.src = '';
      });

      imgObj.src = image;
    }

    return (_context3 = (_context3 = res$, _do._do).call(_context3, () => {
      updateStyle.call(this, dataset);
      this.prevImage = image;
      this.prevColor = color;
    }), _map.map).call(_context3, () => {
      const div = document.createElement('div');
      div.classList.add('sidebar-bg');
      div.style.backgroundColor = color;
      if (image !== '') div.style.backgroundImage = `url(${image})`;
      return div;
    });
  }

  crossFade([prevDiv, div]) {
    var _context4;

    prevDiv.parentNode.insertBefore(div, prevDiv.nextElementSibling);

    return (_context4 = (0, _common.animate)(div, [{ opacity: 0 }, { opacity: 1 }], {
      duration: this.duration
      // easing: 'cubic-bezier(0,0,0.32,1)',
    }), _finally._finally).call(_context4, () => prevDiv.parentNode.removeChild(prevDiv));
  }
}
exports.default = CrossFader;

},{"./common":3,"color":16,"rxjs/Observable":116,"rxjs/observable/empty":130,"rxjs/observable/fromEvent":131,"rxjs/observable/timer":132,"rxjs/operator/do":136,"rxjs/operator/finally":139,"rxjs/operator/map":140,"rxjs/operator/zip":149}],5:[function(require,module,exports){
'use strict';

var _vanilla = require('y-drawer/src/vanilla');

var _vanilla2 = _interopRequireDefault(_vanilla);

var _common = require('./common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

/* eslint-disable import/no-extraneous-dependencies, import/no-unresolved, import/extensions */

const REQUIREMENTS = ['eventlistener', 'queryselector', 'matchmedia', 'requestanimationframe', 'classlist', 'opacity', 'csstransforms', 'csspointerevents', 'cssremunit'];

const MEDIA_QUERY = '(min-width: 54em)';

function resizeCallback() {
  const hasChanged = window.isDesktop !== window.matchMedia(MEDIA_QUERY).matches;
  if (hasChanged) {
    window.isDesktop = !window.isDesktop;
    window.drawer.persistent = window.isDesktop;
    window.drawer.jumpTo(window.isDesktop);
  }
}

function menuClickClallback(e) {
  if (!window.isDesktop) {
    e.preventDefault();
    window.drawer.toggle();
  }
}

function addEventListeners(drawer) {
  window.drawer = drawer;
  window.addEventListener('resize', resizeCallback);
  document.getElementById('_menu').addEventListener('click', menuClickClallback);
}

if (!window.disableDrawer && (0, _common.hasFeatures)(REQUIREMENTS)) {
  window.isDesktop = window.matchMedia(MEDIA_QUERY).matches;
  const drawer = document.getElementById('_yDrawer');

  addEventListeners(new _vanilla2.default(drawer, {
    opened: window.isDesktop,
    persistent: window.isDesktop,
    transitionDuration: 150
  }));

  drawer.classList.add('loaded');
}

},{"./common":3,"y-drawer/src/vanilla":177}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Observable = require('rxjs/Observable');

var _empty = require('rxjs/observable/empty');

// Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

/*
eslint-disable
class-methods-use-this
*/

class Flip {
  static create(type, ...args) {
    return Flip.types[type] != null ? new Flip.types[type](...args) : new Flip(...args);
  }

  constructor({ animationMain, duration }) {
    this.animationMain = animationMain;
    this.duration = duration;
  }

  start() {
    // HACK: use proper cleanup instead
    this.animationMain.style.opacity = 0;
    this.animationMain.style.willChange = '';

    return _empty.empty.call(_Observable.Observable);
  }

  ready() {
    return _empty.empty.call(_Observable.Observable);
  }
}

exports.default = Flip;
Flip.types = {};

},{"rxjs/Observable":116,"rxjs/observable/empty":130}],7:[function(require,module,exports){
'use strict';

var _Observable = require('rxjs/Observable');

var _timer = require('rxjs/observable/timer');

var _do = require('rxjs/operator/do');

var _finally = require('rxjs/operator/finally');

var _common = require('../common');

var _flip = require('./flip');

var _flip2 = _interopRequireDefault(_flip);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

/*
eslint-disable
no-param-reassign,
import/no-extraneous-dependencies,
import/no-unresolved,
import/extensions,
class-methods-use-this,
*/

const TITLE_SELECTOR = '.page-title, .post-title';

class TitleFlip extends _flip2.default {
  start(currentTarget) {
    var _context;

    const title = document.createElement('h1');

    title.classList.add('page-title');
    title.textContent = currentTarget.textContent;
    title.style.transformOrigin = 'left top';

    this.animationMain.querySelector('.page').innerHTML = '';
    this.animationMain.querySelector('.page').appendChild(title);
    this.animationMain.style.position = 'fixed';
    this.animationMain.style.opacity = 1;

    const first = currentTarget.getBoundingClientRect();
    const firstFontSize = parseInt(getComputedStyle(currentTarget).fontSize, 10);
    const last = title.getBoundingClientRect();
    const lastFontSize = parseInt(getComputedStyle(title).fontSize, 10);

    const invertX = first.left - last.left;
    const invertY = first.top - last.top;
    const invertScale = firstFontSize / lastFontSize;

    currentTarget.style.opacity = 0;

    return (_context = (0, _common.animate)(title, [{ transform: `translate3d(${invertX}px, ${invertY}px, 0) scale(${invertScale})` }, { transform: 'translate3d(0, 0, 0) scale(1)' }], {
      duration: this.duration,
      // easing: 'ease',
      easing: 'cubic-bezier(0,0,0.32,1)'
    }), _do._do).call(_context, () => {
      this.animationMain.style.position = 'absolute';
    });
  }

  ready(main) {
    var _context2;

    this.animationMain.style.willChange = 'opacity';

    const title = main.querySelector(TITLE_SELECTOR);

    if (title != null) {
      title.style.opacity = 0;
      title.style.willChange = 'opacity';
    }

    // HACK: add some extra time to prevent hiccups
    return (_context2 = (_context2 = _timer.timer.call(_Observable.Observable, this.duration + 100), _do._do).call(_context2, () => {
      if (title != null) {
        title.style.opacity = 1;
        title.style.willChange = '';
      }
    }), _finally._finally).call(_context2, () => {
      this.animationMain.style.opacity = 0;
      this.animationMain.style.willChange = '';
    });
  }
}

_flip2.default.types.title = TitleFlip;

},{"../common":3,"./flip":6,"rxjs/Observable":116,"rxjs/observable/timer":132,"rxjs/operator/do":136,"rxjs/operator/finally":139}],8:[function(require,module,exports){
'use strict';

require('core-js/fn/array/for-each');

require('core-js/fn/array/find');

require('core-js/fn/function/bind');

require('core-js/fn/number/constructor');

require('core-js/fn/object/assign');

require('core-js/fn/object/define-property');

require('core-js/fn/object/keys');

require('core-js/fn/array/reduce');

require('web-animations-js');

require('../lib/modernizr');

require('../lib/version');

require('./katex');

require('./drawer');

require('./push-state');

},{"../lib/modernizr":1,"../lib/version":2,"./drawer":5,"./katex":9,"./push-state":10,"core-js/fn/array/find":17,"core-js/fn/array/for-each":18,"core-js/fn/array/reduce":19,"core-js/fn/function/bind":20,"core-js/fn/number/constructor":21,"core-js/fn/object/assign":22,"core-js/fn/object/define-property":23,"core-js/fn/object/keys":24,"web-animations-js":173}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = upgradeMathBlocks;

var _katex = require('katex');

var _katex2 = _interopRequireDefault(_katex);

var _common = require('./common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

/* eslint-disable no-param-reassign */

const REQUIREMENTS = ['eventlistener', 'queryselector'];

function willChangeContent(mathBlocks) {
  Array.prototype.forEach.call(mathBlocks, el => {
    el.style.willChange = 'content'; // eslint-disable-line no-param-reassign
  });
}

function replaceMathBlock(el, tex) {
  el.outerHTML = _katex2.default.renderToString(tex, {
    displayMode: el.type === 'math/tex; mode=display'
  });
}

function renderKatex(el, tex) {
  try {
    const prev = el.previousElementSibling;
    replaceMathBlock(el, tex);
    if (prev && (0, _common.matches)(prev, '.MathJax_Preview')) (0, _common.hide)(prev);
  } catch (e) {
    // TODO: remove in production builds?
    console.error(e); // eslint-disable-line no-console
  } finally {
    el.style.willChange = '';
  }
}

function readTexSource(el) {
  return el.textContent.replace('% <![CDATA[', '').replace('%]]>', '');
}

function changeContent(mathBlocks) {
  // kramdown generates script tags with type "math/tex"
  Array.prototype.forEach.call(mathBlocks, script => {
    const tex = readTexSource(script);
    renderKatex(script, tex);
  });
}

function upgradeMathBlocks() {
  if ((0, _common.hasFeatures)(REQUIREMENTS)) {
    const mathBlocks = document.querySelectorAll('script[type^="math/tex"]');
    if (mathBlocks.length) {
      willChangeContent(mathBlocks);
      changeContent(mathBlocks);
    }
  }
}

if ((0, _common.hasFeatures)(REQUIREMENTS)) {
  // TODO: load on demand?
  const ref = document.getElementsByTagName('style')[0];
  const style = loadCSS('https://unpkg.com/katex@0.7.1/dist/katex.min.css', ref);
  style.addEventListener('load', upgradeMathBlocks);
}

},{"./common":3,"katex":90}],10:[function(require,module,exports){
'use strict';

var _Observable = require('rxjs/Observable');

var _fromEvent = require('rxjs/observable/fromEvent');

var _catch = require('rxjs/operator/catch');

var _do = require('rxjs/operator/do');

var _debounceTime = require('rxjs/operator/debounceTime');

var _exhaustMap = require('rxjs/operator/exhaustMap');

var _filter = require('rxjs/operator/filter');

var _map = require('rxjs/operator/map');

var _mergeMap = require('rxjs/operator/mergeMap');

var _pairwise = require('rxjs/operator/pairwise');

var _share = require('rxjs/operator/share');

var _startWith = require('rxjs/operator/startWith');

var _switchMap = require('rxjs/operator/switchMap');

var _takeUntil = require('rxjs/operator/takeUntil');

var _zip = require('rxjs/operator/zip');

var _vanilla = require('y-push-state/src/vanilla');

var _vanilla2 = _interopRequireDefault(_vanilla);

var _elemDataset = require('elem-dataset');

var _elemDataset2 = _interopRequireDefault(_elemDataset);

var _common = require('./common');

var _crossFader = require('./cross-fader');

var _crossFader2 = _interopRequireDefault(_crossFader);

var _katex = require('./katex');

var _katex2 = _interopRequireDefault(_katex);

var _flip = require('./flip/flip');

var _flip2 = _interopRequireDefault(_flip);

require('./flip/title');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

/*
eslint-disable
no-param-reassign,
import/no-extraneous-dependencies,
import/no-unresolved,
import/extensions
*/

const REQUIREMENTS = ['eventlistener', 'queryselector', 'requestanimationframe', 'classlist', 'documentfragment', 'history', 'opacity', 'cssanimations'];

const DURATION = 250;
const FADE_DURATION = 500;

// whenever the source observable encounters an error,
// we log it to the console, but continue as if it never happend
function makeUnstoppable() {
  return _catch._catch.call(this, (error, caught) => {
    console.error(error); // eslint-disable-line
    return caught;
  });
}

if (!window.disablePushState && (0, _common.hasFeatures)(REQUIREMENTS)) {
  var _context;

  const ua = navigator.userAgent.toLowerCase();
  const isSafari = ua.indexOf('safari') > 0 && ua.indexOf('chrome') < 0;

  const crossFader = new _crossFader2.default({ duration: FADE_DURATION });

  const pushState = document.getElementById('_yPushState');

  const animationMain = document.createElement('div');
  animationMain.classList.add('animation-main');
  animationMain.classList.add('fixed-top');
  animationMain.innerHTML = `
    <div class="content">
      <div class="page"></div>
    </div>`;
  pushState.parentNode.insertBefore(animationMain, pushState);

  const loading = document.createElement('div');
  loading.classList.add('loading');
  loading.innerHTML = `
    <span class="sr-only">Loading...</span>
    <div class="sk-folding-cube">
      <div class="sk-cube1 sk-cube"></div>
      <div class="sk-cube2 sk-cube"></div>
      <div class="sk-cube4 sk-cube"></div>
      <div class="sk-cube3 sk-cube"></div>
    </div>
  `;
  document.querySelector('.navbar .content').appendChild(loading);

  const start$ = (_context = (_context = (_context = (_context = _fromEvent.fromEvent.call(_Observable.Observable, pushState, 'y-push-state-start'), _map.map).call(_context, ({ detail }) => detail), _map.map).call(_context, detail => [detail, document.getElementById('_main')]), _do._do).call(_context, () => {
    // If a link on the drawer has been clicked, close it
    if (!window.isDesktop && window.drawer.opened) {
      window.drawer.close();
    }
  }), _share.share).call(_context);

  const ready$ = (_context = (_context = _fromEvent.fromEvent.call(_Observable.Observable, pushState, 'y-push-state-ready'), _map.map).call(_context, ({ detail }) => detail), _share.share).call(_context);

  const progress$ = (_context = _fromEvent.fromEvent.call(_Observable.Observable, pushState, 'y-push-state-progress'), _map.map).call(_context, ({ detail }) => detail);
  // ::share();

  const after$ = (_context = (_context = _fromEvent.fromEvent.call(_Observable.Observable, pushState, 'y-push-state-after'), _map.map).call(_context, ({ detail }) => detail), _share.share).call(_context);

  // const error$ = Observable.fromEvent(pushState, 'y-push-state-error');

  // HACK
  if (isSafari) {
    _fromEvent.fromEvent.call(_Observable.Observable, window, 'popstate').subscribe(() => {
      document.body.style.minHeight = '999999px';
    });

    after$.subscribe(() => {
      document.body.style.minHeight = '';
    });
  }

  // FLIP animation (when applicable)
  (_context = _switchMap.switchMap.call(start$, ([detail]) => {
    const { event: { currentTarget } } = detail;

    const flip = _flip2.default.create(currentTarget.getAttribute && currentTarget.getAttribute('data-flip'), {
      animationMain,
      currentTarget,
      duration: DURATION
    });

    // HACK: This assumes knowledge of the internal rx pipeline.
    // Could possibly be replaced with `withLatestFrom` shinanigans,
    // but it's more convenient like that.
    detail.flip = flip;

    return flip.start(currentTarget);
  }), makeUnstoppable).call(_context).subscribe();

  // Fade main content out
  (_context = (_context = (_context = _do._do.call(start$, ([, main]) => {
    main.style.opacity = 0;
  }), _filter.filter).call(_context, ([{ type }]) => type === 'push' || !isSafari), _exhaustMap.exhaustMap).call(_context, ([{ type }, main]) => {
    var _context2;

    return (_context2 = (_context2 = (0, _common.animate)(main, [{ opacity: 1 }, { opacity: 0 }], {
      duration: DURATION,
      // easing: 'ease',
      easing: 'cubic-bezier(0,0,0.32,1)'
    }), _do._do).call(_context2, () => {
      if (type === 'push') window.scroll(0, 0);
    }), _zip.zipProto).call(_context2, after$);
  }), makeUnstoppable).call(_context).subscribe();

  // Show loading bar when taking longer than expected
  (_context = _do._do.call(progress$, () => {
    loading.style.display = 'block';
  }), makeUnstoppable).call(_context).subscribe();

  // TODO: error message!?
  // error$
  //   // .delay(DURATION) // HACK
  //   .do(() => {
  //     loading.style.display = 'none';
  //   })
  //   .subscribe();

  // Prepare showing the new content
  (_context = (_context = (_context = _do._do.call(ready$, () => {
    loading.style.display = 'none';
  }), _filter.filter).call(_context, ({ type }) => type === 'push' || !isSafari), _switchMap.switchMap).call(_context, ({ flip, content: [main] }) => {
    var _context3;

    return (_context3 = flip.ready(main), _takeUntil.takeUntil).call(_context3, start$);
  }), makeUnstoppable).call(_context).subscribe();

  (_context = (_context = (_context = (_context = _switchMap.switchMap.call(ready$, ({ content: [main] }) => {
    var _context4;

    return (_context4 = crossFader.fetchImage((0, _elemDataset2.default)(main)), _takeUntil.takeUntil).call(_context4, start$);
  }), _startWith.startWith).call(_context, document.querySelector('.sidebar-bg')), _pairwise.pairwise).call(_context), _mergeMap.mergeMap).call(_context, crossFader.crossFade.bind(crossFader)), makeUnstoppable).call(_context).subscribe();

  // Animate the new content
  (_context = (_context = (_context = _filter.filter.call(after$, ({ type }) => type === 'push' || !isSafari), _map.map).call(_context, kind => [kind, document.querySelector('main')]), _switchMap.switchMap).call(_context, ([, main]) => (0, _common.animate)(main, [{ transform: 'translateY(-2rem)', opacity: 0 }, { transform: 'translateY(0)', opacity: 1 }], {
    duration: DURATION,
    // easing: 'ease',
    easing: 'cubic-bezier(0,0,0.32,1)'
  })), makeUnstoppable).call(_context).subscribe();

  (_context = (_context =
  // Don't send a pageview when the user blasts through the history..
  _debounceTime.debounceTime.call(after$, 2 * DURATION), _do._do).call(_context, () => {
    // Send google analytics pageview
    if (window.ga) window.ga('send', 'pageview');

    // Upgrade math blocks
    (0, _katex2.default)();
  }), makeUnstoppable).call(_context).subscribe();

  new _vanilla2.default(pushState, {
    replaceIds: ['_main'],
    linkSelector: 'a[href^="/"]',
    scriptSelector: 'script:not([type^="math/tex"])',
    duration: DURATION,
    noPopDuration: isSafari,
    scrollRestoration: !isSafari
  }).startHistory();
}

},{"./common":3,"./cross-fader":4,"./flip/flip":6,"./flip/title":7,"./katex":9,"elem-dataset":88,"rxjs/Observable":116,"rxjs/observable/fromEvent":131,"rxjs/operator/catch":133,"rxjs/operator/debounceTime":135,"rxjs/operator/do":136,"rxjs/operator/exhaustMap":137,"rxjs/operator/filter":138,"rxjs/operator/map":140,"rxjs/operator/mergeMap":142,"rxjs/operator/pairwise":144,"rxjs/operator/share":145,"rxjs/operator/startWith":146,"rxjs/operator/switchMap":147,"rxjs/operator/takeUntil":148,"rxjs/operator/zip":149,"y-push-state/src/vanilla":290}],11:[function(require,module,exports){
/* MIT license */
var cssKeywords = require('color-name');

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

var reverseKeywords = {};
for (var key in cssKeywords) {
	if (cssKeywords.hasOwnProperty(key)) {
		reverseKeywords[cssKeywords[key]] = key;
	}
}

var convert = module.exports = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

// hide .channels and .labels properties
for (var model in convert) {
	if (convert.hasOwnProperty(model)) {
		if (!('channels' in convert[model])) {
			throw new Error('missing channels property: ' + model);
		}

		if (!('labels' in convert[model])) {
			throw new Error('missing channel labels property: ' + model);
		}

		if (convert[model].labels.length !== convert[model].channels) {
			throw new Error('channel and label counts mismatch: ' + model);
		}

		var channels = convert[model].channels;
		var labels = convert[model].labels;
		delete convert[model].channels;
		delete convert[model].labels;
		Object.defineProperty(convert[model], 'channels', {value: channels});
		Object.defineProperty(convert[model], 'labels', {value: labels});
	}
}

convert.rgb.hsl = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var l;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var v;

	if (max === 0) {
		s = 0;
	} else {
		s = (delta / max * 1000) / 10;
	}

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	v = ((max / 255) * 1000) / 10;

	return [h, s, v];
};

convert.rgb.hwb = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var h = convert.rgb.hsl(rgb)[0];
	var w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var c;
	var m;
	var y;
	var k;

	k = Math.min(1 - r, 1 - g, 1 - b);
	c = (1 - r - k) / (1 - k) || 0;
	m = (1 - g - k) / (1 - k) || 0;
	y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

/**
 * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
 * */
function comparativeDistance(x, y) {
	return (
		Math.pow(x[0] - y[0], 2) +
		Math.pow(x[1] - y[1], 2) +
		Math.pow(x[2] - y[2], 2)
	);
}

convert.rgb.keyword = function (rgb) {
	var reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	var currentClosestDistance = Infinity;
	var currentClosestKeyword;

	for (var keyword in cssKeywords) {
		if (cssKeywords.hasOwnProperty(keyword)) {
			var value = cssKeywords[keyword];

			// Compute comparative distance
			var distance = comparativeDistance(rgb, value);

			// Check if its less, if so set as closest
			if (distance < currentClosestDistance) {
				currentClosestDistance = distance;
				currentClosestKeyword = keyword;
			}
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;

	// assume sRGB
	r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	var xyz = convert.rgb.xyz(rgb);
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	var h = hsl[0] / 360;
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var t1;
	var t2;
	var t3;
	var rgb;
	var val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	t1 = 2 * l - t2;

	rgb = [0, 0, 0];
	for (var i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}
		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	var h = hsl[0];
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var smin = s;
	var lmin = Math.max(l, 0.01);
	var sv;
	var v;

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	v = (l + s) / 2;
	sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	var h = hsv[0] / 60;
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var hi = Math.floor(h) % 6;

	var f = h - Math.floor(h);
	var p = 255 * v * (1 - s);
	var q = 255 * v * (1 - (s * f));
	var t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	var h = hsv[0];
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var vmin = Math.max(v, 0.01);
	var lmin;
	var sl;
	var l;

	l = (2 - s) * v;
	lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	var h = hwb[0] / 360;
	var wh = hwb[1] / 100;
	var bl = hwb[2] / 100;
	var ratio = wh + bl;
	var i;
	var v;
	var f;
	var n;

	// wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	i = Math.floor(6 * h);
	v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	n = wh + f * (v - wh); // linear interpolation

	var r;
	var g;
	var b;
	switch (i) {
		default:
		case 6:
		case 0: r = v; g = n; b = wh; break;
		case 1: r = n; g = v; b = wh; break;
		case 2: r = wh; g = v; b = n; break;
		case 3: r = wh; g = n; b = v; break;
		case 4: r = n; g = wh; b = v; break;
		case 5: r = v; g = wh; b = n; break;
	}

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	var c = cmyk[0] / 100;
	var m = cmyk[1] / 100;
	var y = cmyk[2] / 100;
	var k = cmyk[3] / 100;
	var r;
	var g;
	var b;

	r = 1 - Math.min(1, c * (1 - k) + k);
	g = 1 - Math.min(1, m * (1 - k) + k);
	b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	var x = xyz[0] / 100;
	var y = xyz[1] / 100;
	var z = xyz[2] / 100;
	var r;
	var g;
	var b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// assume sRGB
	r = r > 0.0031308
		? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var x;
	var y;
	var z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	var y2 = Math.pow(y, 3);
	var x2 = Math.pow(x, 3);
	var z2 = Math.pow(z, 3);
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var hr;
	var h;
	var c;

	hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	var l = lch[0];
	var c = lch[1];
	var h = lch[2];
	var a;
	var b;
	var hr;

	hr = h / 360 * 2 * Math.PI;
	a = c * Math.cos(hr);
	b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];
	var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	var ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];

	// we use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	var ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	var color = args % 10;

	// handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	var mult = (~~(args > 50) + 1) * 0.5;
	var r = ((color & 1) * mult) * 255;
	var g = (((color >> 1) & 1) * mult) * 255;
	var b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// handle greyscale
	if (args >= 232) {
		var c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	var rem;
	var r = Math.floor(args / 36) / 5 * 255;
	var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	var b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	var integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	var colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(function (char) {
			return char + char;
		}).join('');
	}

	var integer = parseInt(colorString, 16);
	var r = (integer >> 16) & 0xFF;
	var g = (integer >> 8) & 0xFF;
	var b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var max = Math.max(Math.max(r, g), b);
	var min = Math.min(Math.min(r, g), b);
	var chroma = (max - min);
	var grayscale;
	var hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma + 4;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var c = 1;
	var f = 0;

	if (l < 0.5) {
		c = 2.0 * s * l;
	} else {
		c = 2.0 * s * (1.0 - l);
	}

	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;

	var c = s * v;
	var f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	var h = hcg[0] / 360;
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	var pure = [0, 0, 0];
	var hi = (h % 1) * 6;
	var v = hi % 1;
	var w = 1 - v;
	var mg = 0;

	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var v = c + g * (1.0 - c);
	var f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var l = g * (1.0 - c) + 0.5 * c;
	var s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;
	var v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	var w = hwb[1] / 100;
	var b = hwb[2] / 100;
	var v = 1 - b;
	var c = v - w;
	var g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = convert.gray.hsv = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	var val = Math.round(gray[0] / 100 * 255) & 0xFF;
	var integer = (val << 16) + (val << 8) + val;

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};

},{"color-name":14}],12:[function(require,module,exports){
var conversions = require('./conversions');
var route = require('./route');

var convert = {};

var models = Object.keys(conversions);

function wrapRaw(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		return fn(args);
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		var result = fn(args);

		// we're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (var len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(function (fromModel) {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	var routes = route(fromModel);
	var routeModels = Object.keys(routes);

	routeModels.forEach(function (toModel) {
		var fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

module.exports = convert;

},{"./conversions":11,"./route":13}],13:[function(require,module,exports){
var conversions = require('./conversions');

/*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

// https://jsperf.com/object-keys-vs-for-in-with-closure/3
var models = Object.keys(conversions);

function buildGraph() {
	var graph = {};

	for (var len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	var graph = buildGraph();
	var queue = [fromModel]; // unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		var current = queue.pop();
		var adjacents = Object.keys(conversions[current]);

		for (var len = adjacents.length, i = 0; i < len; i++) {
			var adjacent = adjacents[i];
			var node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	var path = [graph[toModel].parent, toModel];
	var fn = conversions[graph[toModel].parent][toModel];

	var cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	var graph = deriveBFS(fromModel);
	var conversion = {};

	var models = Object.keys(graph);
	for (var len = models.length, i = 0; i < len; i++) {
		var toModel = models[i];
		var node = graph[toModel];

		if (node.parent === null) {
			// no possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};


},{"./conversions":11}],14:[function(require,module,exports){
module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};
},{}],15:[function(require,module,exports){
/* MIT license */
var colorNames = require('color-name');
var swizzle = require('simple-swizzle');

var reverseNames = {};

// create a list of reverse color names
for (var name in colorNames) {
	if (colorNames.hasOwnProperty(name)) {
		reverseNames[colorNames[name]] = name;
	}
}

var cs = module.exports = {
	to: {}
};

cs.get = function (string) {
	var prefix = string.substring(0, 3).toLowerCase();
	var val;
	var model;
	switch (prefix) {
		case 'hsl':
			val = cs.get.hsl(string);
			model = 'hsl';
			break;
		case 'hwb':
			val = cs.get.hwb(string);
			model = 'hwb';
			break;
		default:
			val = cs.get.rgb(string);
			model = 'rgb';
			break;
	}

	if (!val) {
		return null;
	}

	return {model: model, value: val};
};

cs.get.rgb = function (string) {
	if (!string) {
		return null;
	}

	var abbr = /^#([a-f0-9]{3,4})$/i;
	var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
	var rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var keyword = /(\D+)/;

	var rgb = [0, 0, 0, 1];
	var match;
	var i;
	var hexAlpha;

	if (match = string.match(hex)) {
		hexAlpha = match[2];
		match = match[1];

		for (i = 0; i < 3; i++) {
			// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
			var i2 = i * 2;
			rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
		}

		if (hexAlpha) {
			rgb[3] = Math.round((parseInt(hexAlpha, 16) / 255) * 100) / 100;
		}
	} else if (match = string.match(abbr)) {
		match = match[1];
		hexAlpha = match[3];

		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i] + match[i], 16);
		}

		if (hexAlpha) {
			rgb[3] = Math.round((parseInt(hexAlpha + hexAlpha, 16) / 255) * 100) / 100;
		}
	} else if (match = string.match(rgba)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i + 1], 0);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(per)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(keyword)) {
		if (match[1] === 'transparent') {
			return [0, 0, 0, 0];
		}

		rgb = colorNames[match[1]];

		if (!rgb) {
			return null;
		}

		rgb[3] = 1;

		return rgb;
	} else {
		return null;
	}

	for (i = 0; i < 3; i++) {
		rgb[i] = clamp(rgb[i], 0, 255);
	}
	rgb[3] = clamp(rgb[3], 0, 1);

	return rgb;
};

cs.get.hsl = function (string) {
	if (!string) {
		return null;
	}

	var hsl = /^hsla?\(\s*([+-]?\d*[\.]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var match = string.match(hsl);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var s = clamp(parseFloat(match[2]), 0, 100);
		var l = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);

		return [h, s, l, a];
	}

	return null;
};

cs.get.hwb = function (string) {
	if (!string) {
		return null;
	}

	var hwb = /^hwb\(\s*([+-]?\d*[\.]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var match = string.match(hwb);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var w = clamp(parseFloat(match[2]), 0, 100);
		var b = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
		return [h, w, b, a];
	}

	return null;
};

cs.to.hex = function () {
	var rgba = swizzle(arguments);

	return (
		'#' +
		hexDouble(rgba[0]) +
		hexDouble(rgba[1]) +
		hexDouble(rgba[2]) +
		(rgba[3] < 1
			? (hexDouble(Math.round(rgba[3] * 255)))
			: '')
	);
};

cs.to.rgb = function () {
	var rgba = swizzle(arguments);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'
		: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
};

cs.to.rgb.percent = function () {
	var rgba = swizzle(arguments);

	var r = Math.round(rgba[0] / 255 * 100);
	var g = Math.round(rgba[1] / 255 * 100);
	var b = Math.round(rgba[2] / 255 * 100);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
		: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
};

cs.to.hsl = function () {
	var hsla = swizzle(arguments);
	return hsla.length < 4 || hsla[3] === 1
		? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
		: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
};

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
cs.to.hwb = function () {
	var hwba = swizzle(arguments);

	var a = '';
	if (hwba.length >= 4 && hwba[3] !== 1) {
		a = ', ' + hwba[3];
	}

	return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
};

cs.to.keyword = function (rgb) {
	return reverseNames[rgb.slice(0, 3)];
};

// helpers
function clamp(num, min, max) {
	return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
	var str = num.toString(16).toUpperCase();
	return (str.length < 2) ? '0' + str : str;
}

},{"color-name":14,"simple-swizzle":172}],16:[function(require,module,exports){
'use strict';

var colorString = require('color-string');
var convert = require('color-convert');

var _slice = [].slice;

var skippedModels = [
	// to be honest, I don't really feel like keyword belongs in color convert, but eh.
	'keyword',

	// gray conflicts with some method names, and has its own method defined.
	'gray',

	// shouldn't really be in color-convert either...
	'hex'
];

var hashedModelKeys = {};
Object.keys(convert).forEach(function (model) {
	hashedModelKeys[_slice.call(convert[model].labels).sort().join('')] = model;
});

var limiters = {};

function Color(obj, model) {
	if (!(this instanceof Color)) {
		return new Color(obj, model);
	}

	if (model && model in skippedModels) {
		model = null;
	}

	if (model && !(model in convert)) {
		throw new Error('Unknown model: ' + model);
	}

	var i;
	var channels;

	if (!obj) {
		this.model = 'rgb';
		this.color = [0, 0, 0];
		this.valpha = 1;
	} else if (obj instanceof Color) {
		this.model = obj.model;
		this.color = obj.color.slice();
		this.valpha = obj.valpha;
	} else if (typeof obj === 'string') {
		var result = colorString.get(obj);
		if (result === null) {
			throw new Error('Unable to parse color from string: ' + obj);
		}

		this.model = result.model;
		channels = convert[this.model].channels;
		this.color = result.value.slice(0, channels);
		this.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;
	} else if (obj.length) {
		this.model = model || 'rgb';
		channels = convert[this.model].channels;
		var newArr = _slice.call(obj, 0, channels);
		this.color = zeroArray(newArr, channels);
		this.valpha = typeof obj[channels] === 'number' ? obj[channels] : 1;
	} else if (typeof obj === 'number') {
		// this is always RGB - can be converted later on.
		obj &= 0xFFFFFF;
		this.model = 'rgb';
		this.color = [
			(obj >> 16) & 0xFF,
			(obj >> 8) & 0xFF,
			obj & 0xFF
		];
		this.valpha = 1;
	} else {
		this.valpha = 1;

		var keys = Object.keys(obj);
		if ('alpha' in obj) {
			keys.splice(keys.indexOf('alpha'), 1);
			this.valpha = typeof obj.alpha === 'number' ? obj.alpha : 0;
		}

		var hashedKeys = keys.sort().join('');
		if (!(hashedKeys in hashedModelKeys)) {
			throw new Error('Unable to parse color from object: ' + JSON.stringify(obj));
		}

		this.model = hashedModelKeys[hashedKeys];

		var labels = convert[this.model].labels;
		var color = [];
		for (i = 0; i < labels.length; i++) {
			color.push(obj[labels[i]]);
		}

		this.color = zeroArray(color);
	}

	// perform limitations (clamping, etc.)
	if (limiters[this.model]) {
		channels = convert[this.model].channels;
		for (i = 0; i < channels; i++) {
			var limit = limiters[this.model][i];
			if (limit) {
				this.color[i] = limit(this.color[i]);
			}
		}
	}

	this.valpha = Math.max(0, Math.min(1, this.valpha));

	if (Object.freeze) {
		Object.freeze(this);
	}
}

Color.prototype = {
	toString: function () {
		return this.string();
	},

	toJSON: function () {
		return this[this.model]();
	},

	string: function (places) {
		var self = this.model in colorString.to ? this : this.rgb();
		self = self.round(typeof places === 'number' ? places : 1);
		var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
		return colorString.to[self.model](args);
	},

	percentString: function (places) {
		var self = this.rgb().round(typeof places === 'number' ? places : 1);
		var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
		return colorString.to.rgb.percent(args);
	},

	array: function () {
		return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
	},

	object: function () {
		var result = {};
		var channels = convert[this.model].channels;
		var labels = convert[this.model].labels;

		for (var i = 0; i < channels; i++) {
			result[labels[i]] = this.color[i];
		}

		if (this.valpha !== 1) {
			result.alpha = this.valpha;
		}

		return result;
	},

	unitArray: function () {
		var rgb = this.rgb().color;
		rgb[0] /= 255;
		rgb[1] /= 255;
		rgb[2] /= 255;

		if (this.valpha !== 1) {
			rgb.push(this.valpha);
		}

		return rgb;
	},

	unitObject: function () {
		var rgb = this.rgb().object();
		rgb.r /= 255;
		rgb.g /= 255;
		rgb.b /= 255;

		if (this.valpha !== 1) {
			rgb.alpha = this.valpha;
		}

		return rgb;
	},

	round: function (places) {
		places = Math.max(places || 0, 0);
		return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
	},

	alpha: function (val) {
		if (arguments.length) {
			return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
		}

		return this.valpha;
	},

	// rgb
	red: getset('rgb', 0, maxfn(255)),
	green: getset('rgb', 1, maxfn(255)),
	blue: getset('rgb', 2, maxfn(255)),

	hue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, function (val) { return ((val % 360) + 360) % 360; }), // eslint-disable-line brace-style

	saturationl: getset('hsl', 1, maxfn(100)),
	lightness: getset('hsl', 2, maxfn(100)),

	saturationv: getset('hsv', 1, maxfn(100)),
	value: getset('hsv', 2, maxfn(100)),

	chroma: getset('hcg', 1, maxfn(100)),
	gray: getset('hcg', 2, maxfn(100)),

	white: getset('hwb', 1, maxfn(100)),
	wblack: getset('hwb', 2, maxfn(100)),

	cyan: getset('cmyk', 0, maxfn(100)),
	magenta: getset('cmyk', 1, maxfn(100)),
	yellow: getset('cmyk', 2, maxfn(100)),
	black: getset('cmyk', 3, maxfn(100)),

	x: getset('xyz', 0, maxfn(100)),
	y: getset('xyz', 1, maxfn(100)),
	z: getset('xyz', 2, maxfn(100)),

	l: getset('lab', 0, maxfn(100)),
	a: getset('lab', 1),
	b: getset('lab', 2),

	keyword: function (val) {
		if (arguments.length) {
			return new Color(val);
		}

		return convert[this.model].keyword(this.color);
	},

	hex: function (val) {
		if (arguments.length) {
			return new Color(val);
		}

		return colorString.to.hex(this.rgb().round().color);
	},

	rgbNumber: function () {
		var rgb = this.rgb().color;
		return ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);
	},

	luminosity: function () {
		// http://www.w3.org/TR/WCAG20/#relativeluminancedef
		var rgb = this.rgb().color;

		var lum = [];
		for (var i = 0; i < rgb.length; i++) {
			var chan = rgb[i] / 255;
			lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
		}

		return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
	},

	contrast: function (color2) {
		// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
		var lum1 = this.luminosity();
		var lum2 = color2.luminosity();

		if (lum1 > lum2) {
			return (lum1 + 0.05) / (lum2 + 0.05);
		}

		return (lum2 + 0.05) / (lum1 + 0.05);
	},

	level: function (color2) {
		var contrastRatio = this.contrast(color2);
		if (contrastRatio >= 7.1) {
			return 'AAA';
		}

		return (contrastRatio >= 4.5) ? 'AA' : '';
	},

	dark: function () {
		// YIQ equation from http://24ways.org/2010/calculating-color-contrast
		var rgb = this.rgb().color;
		var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
		return yiq < 128;
	},

	light: function () {
		return !this.dark();
	},

	negate: function () {
		var rgb = this.rgb();
		for (var i = 0; i < 3; i++) {
			rgb.color[i] = 255 - rgb.color[i];
		}
		return rgb;
	},

	lighten: function (ratio) {
		var hsl = this.hsl();
		hsl.color[2] += hsl.color[2] * ratio;
		return hsl;
	},

	darken: function (ratio) {
		var hsl = this.hsl();
		hsl.color[2] -= hsl.color[2] * ratio;
		return hsl;
	},

	saturate: function (ratio) {
		var hsl = this.hsl();
		hsl.color[1] += hsl.color[1] * ratio;
		return hsl;
	},

	desaturate: function (ratio) {
		var hsl = this.hsl();
		hsl.color[1] -= hsl.color[1] * ratio;
		return hsl;
	},

	whiten: function (ratio) {
		var hwb = this.hwb();
		hwb.color[1] += hwb.color[1] * ratio;
		return hwb;
	},

	blacken: function (ratio) {
		var hwb = this.hwb();
		hwb.color[2] += hwb.color[2] * ratio;
		return hwb;
	},

	grayscale: function () {
		// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
		var rgb = this.rgb().color;
		var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
		return Color.rgb(val, val, val);
	},

	fade: function (ratio) {
		return this.alpha(this.valpha - (this.valpha * ratio));
	},

	opaquer: function (ratio) {
		return this.alpha(this.valpha + (this.valpha * ratio));
	},

	rotate: function (degrees) {
		var hsl = this.hsl();
		var hue = hsl.color[0];
		hue = (hue + degrees) % 360;
		hue = hue < 0 ? 360 + hue : hue;
		hsl.color[0] = hue;
		return hsl;
	},

	mix: function (mixinColor, weight) {
		// ported from sass implementation in C
		// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
		var color1 = this.rgb();
		var color2 = mixinColor.rgb();
		var p = weight === undefined ? 0.5 : weight;

		var w = 2 * p - 1;
		var a = color1.alpha() - color2.alpha();

		var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
		var w2 = 1 - w1;

		return Color.rgb(
				w1 * color1.red() + w2 * color2.red(),
				w1 * color1.green() + w2 * color2.green(),
				w1 * color1.blue() + w2 * color2.blue(),
				color1.alpha() * p + color2.alpha() * (1 - p));
	}
};

// model conversion methods and static constructors
Object.keys(convert).forEach(function (model) {
	if (skippedModels.indexOf(model) !== -1) {
		return;
	}

	var channels = convert[model].channels;

	// conversion methods
	Color.prototype[model] = function () {
		if (this.model === model) {
			return new Color(this);
		}

		if (arguments.length) {
			return new Color(arguments, model);
		}

		var newAlpha = typeof arguments[channels] === 'number' ? channels : this.valpha;
		return new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);
	};

	// 'static' construction methods
	Color[model] = function (color) {
		if (typeof color === 'number') {
			color = zeroArray(_slice.call(arguments), channels);
		}
		return new Color(color, model);
	};
});

function roundTo(num, places) {
	return Number(num.toFixed(places));
}

function roundToPlace(places) {
	return function (num) {
		return roundTo(num, places);
	};
}

function getset(model, channel, modifier) {
	model = Array.isArray(model) ? model : [model];

	model.forEach(function (m) {
		(limiters[m] || (limiters[m] = []))[channel] = modifier;
	});

	model = model[0];

	return function (val) {
		var result;

		if (arguments.length) {
			if (modifier) {
				val = modifier(val);
			}

			result = this[model]();
			result.color[channel] = val;
			return result;
		}

		result = this[model]().color[channel];
		if (modifier) {
			result = modifier(result);
		}

		return result;
	};
}

function maxfn(max) {
	return function (v) {
		return Math.max(0, Math.min(max, v));
	};
}

function assertArray(val) {
	return Array.isArray(val) ? val : [val];
}

function zeroArray(arr, length) {
	for (var i = 0; i < length; i++) {
		if (typeof arr[i] !== 'number') {
			arr[i] = 0;
		}
	}

	return arr;
}

module.exports = Color;

},{"color-convert":12,"color-string":15}],17:[function(require,module,exports){
require('../../modules/es6.array.find');
module.exports = require('../../modules/_core').Array.find;
},{"../../modules/_core":35,"../../modules/es6.array.find":80}],18:[function(require,module,exports){
require('../../modules/es6.array.for-each');
module.exports = require('../../modules/_core').Array.forEach;
},{"../../modules/_core":35,"../../modules/es6.array.for-each":81}],19:[function(require,module,exports){
require('../../modules/es6.array.reduce');
module.exports = require('../../modules/_core').Array.reduce;
},{"../../modules/_core":35,"../../modules/es6.array.reduce":82}],20:[function(require,module,exports){
require('../../modules/es6.function.bind');
module.exports = require('../../modules/_core').Function.bind;
},{"../../modules/_core":35,"../../modules/es6.function.bind":83}],21:[function(require,module,exports){
require('../../modules/es6.number.constructor');
module.exports = Number;
},{"../../modules/es6.number.constructor":84}],22:[function(require,module,exports){
require('../../modules/es6.object.assign');
module.exports = require('../../modules/_core').Object.assign;
},{"../../modules/_core":35,"../../modules/es6.object.assign":85}],23:[function(require,module,exports){
require('../../modules/es6.object.define-property');
var $Object = require('../../modules/_core').Object;
module.exports = function defineProperty(it, key, desc){
  return $Object.defineProperty(it, key, desc);
};
},{"../../modules/_core":35,"../../modules/es6.object.define-property":86}],24:[function(require,module,exports){
require('../../modules/es6.object.keys');
module.exports = require('../../modules/_core').Object.keys;
},{"../../modules/_core":35,"../../modules/es6.object.keys":87}],25:[function(require,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],26:[function(require,module,exports){
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./_wks')('unscopables')
  , ArrayProto  = Array.prototype;
if(ArrayProto[UNSCOPABLES] == undefined)require('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function(key){
  ArrayProto[UNSCOPABLES][key] = true;
};
},{"./_hide":45,"./_wks":79}],27:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
},{"./_is-object":52}],28:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject')
  , toLength  = require('./_to-length')
  , toIndex   = require('./_to-index');
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};
},{"./_to-index":72,"./_to-iobject":74,"./_to-length":75}],29:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx      = require('./_ctx')
  , IObject  = require('./_iobject')
  , toObject = require('./_to-object')
  , toLength = require('./_to-length')
  , asc      = require('./_array-species-create');
module.exports = function(TYPE, $create){
  var IS_MAP        = TYPE == 1
    , IS_FILTER     = TYPE == 2
    , IS_SOME       = TYPE == 3
    , IS_EVERY      = TYPE == 4
    , IS_FIND_INDEX = TYPE == 6
    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
    , create        = $create || asc;
  return function($this, callbackfn, that){
    var O      = toObject($this)
      , self   = IObject(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
      , val, res;
    for(;length > index; index++)if(NO_HOLES || index in self){
      val = self[index];
      res = f(val, index, O);
      if(TYPE){
        if(IS_MAP)result[index] = res;            // map
        else if(res)switch(TYPE){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(IS_EVERY)return false;          // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};
},{"./_array-species-create":32,"./_ctx":36,"./_iobject":50,"./_to-length":75,"./_to-object":76}],30:[function(require,module,exports){
var aFunction = require('./_a-function')
  , toObject  = require('./_to-object')
  , IObject   = require('./_iobject')
  , toLength  = require('./_to-length');

module.exports = function(that, callbackfn, aLen, memo, isRight){
  aFunction(callbackfn);
  var O      = toObject(that)
    , self   = IObject(O)
    , length = toLength(O.length)
    , index  = isRight ? length - 1 : 0
    , i      = isRight ? -1 : 1;
  if(aLen < 2)for(;;){
    if(index in self){
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if(isRight ? index < 0 : length <= index){
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for(;isRight ? index >= 0 : length > index; index += i)if(index in self){
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};
},{"./_a-function":25,"./_iobject":50,"./_to-length":75,"./_to-object":76}],31:[function(require,module,exports){
var isObject = require('./_is-object')
  , isArray  = require('./_is-array')
  , SPECIES  = require('./_wks')('species');

module.exports = function(original){
  var C;
  if(isArray(original)){
    C = original.constructor;
    // cross-realm fallback
    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
    if(isObject(C)){
      C = C[SPECIES];
      if(C === null)C = undefined;
    }
  } return C === undefined ? Array : C;
};
},{"./_is-array":51,"./_is-object":52,"./_wks":79}],32:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function(original, length){
  return new (speciesConstructor(original))(length);
};
},{"./_array-species-constructor":31}],33:[function(require,module,exports){
'use strict';
var aFunction  = require('./_a-function')
  , isObject   = require('./_is-object')
  , invoke     = require('./_invoke')
  , arraySlice = [].slice
  , factories  = {};

var construct = function(F, len, args){
  if(!(len in factories)){
    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /*, args... */){
  var fn       = aFunction(this)
    , partArgs = arraySlice.call(arguments, 1);
  var bound = function(/* args... */){
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if(isObject(fn.prototype))bound.prototype = fn.prototype;
  return bound;
};
},{"./_a-function":25,"./_invoke":49,"./_is-object":52}],34:[function(require,module,exports){
var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};
},{}],35:[function(require,module,exports){
var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],36:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};
},{"./_a-function":25}],37:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};
},{}],38:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_fails":42}],39:[function(require,module,exports){
var isObject = require('./_is-object')
  , document = require('./_global').document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./_global":43,"./_is-object":52}],40:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');
},{}],41:[function(require,module,exports){
var global    = require('./_global')
  , core      = require('./_core')
  , hide      = require('./_hide')
  , redefine  = require('./_redefine')
  , ctx       = require('./_ctx')
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
    , key, own, out, exp;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if(target)redefine(target, key, out, type & $export.U);
    // export
    if(exports[key] != out)hide(exports, key, exp);
    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;
},{"./_core":35,"./_ctx":36,"./_global":43,"./_hide":45,"./_redefine":65}],42:[function(require,module,exports){
module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};
},{}],43:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],44:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};
},{}],45:[function(require,module,exports){
var dP         = require('./_object-dp')
  , createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};
},{"./_descriptors":38,"./_object-dp":55,"./_property-desc":64}],46:[function(require,module,exports){
module.exports = require('./_global').document && document.documentElement;
},{"./_global":43}],47:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function(){
  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_descriptors":38,"./_dom-create":39,"./_fails":42}],48:[function(require,module,exports){
var isObject       = require('./_is-object')
  , setPrototypeOf = require('./_set-proto').set;
module.exports = function(that, target, C){
  var P, S = target.constructor;
  if(S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf){
    setPrototypeOf(that, P);
  } return that;
};
},{"./_is-object":52,"./_set-proto":66}],49:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return              fn.apply(that, args);
};
},{}],50:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};
},{"./_cof":34}],51:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};
},{"./_cof":34}],52:[function(require,module,exports){
module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};
},{}],53:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys  = require('./_object-keys')
  , gOPS     = require('./_object-gops')
  , pIE      = require('./_object-pie')
  , toObject = require('./_to-object')
  , IObject  = require('./_iobject')
  , $assign  = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function(){
  var A = {}
    , B = {}
    , S = Symbol()
    , K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function(k){ B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
  var T     = toObject(target)
    , aLen  = arguments.length
    , index = 1
    , getSymbols = gOPS.f
    , isEnum     = pIE.f;
  while(aLen > index){
    var S      = IObject(arguments[index++])
      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
  } return T;
} : $assign;
},{"./_fails":42,"./_iobject":50,"./_object-gops":59,"./_object-keys":61,"./_object-pie":62,"./_to-object":76}],54:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject    = require('./_an-object')
  , dPs         = require('./_object-dps')
  , enumBugKeys = require('./_enum-bug-keys')
  , IE_PROTO    = require('./_shared-key')('IE_PROTO')
  , Empty       = function(){ /* empty */ }
  , PROTOTYPE   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe')
    , i      = enumBugKeys.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty;
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":27,"./_dom-create":39,"./_enum-bug-keys":40,"./_html":46,"./_object-dps":56,"./_shared-key":67}],55:[function(require,module,exports){
var anObject       = require('./_an-object')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , toPrimitive    = require('./_to-primitive')
  , dP             = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};
},{"./_an-object":27,"./_descriptors":38,"./_ie8-dom-define":47,"./_to-primitive":77}],56:[function(require,module,exports){
var dP       = require('./_object-dp')
  , anObject = require('./_an-object')
  , getKeys  = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties){
  anObject(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
  return O;
};
},{"./_an-object":27,"./_descriptors":38,"./_object-dp":55,"./_object-keys":61}],57:[function(require,module,exports){
var pIE            = require('./_object-pie')
  , createDesc     = require('./_property-desc')
  , toIObject      = require('./_to-iobject')
  , toPrimitive    = require('./_to-primitive')
  , has            = require('./_has')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , gOPD           = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P){
  O = toIObject(O);
  P = toPrimitive(P, true);
  if(IE8_DOM_DEFINE)try {
    return gOPD(O, P);
  } catch(e){ /* empty */ }
  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
};
},{"./_descriptors":38,"./_has":44,"./_ie8-dom-define":47,"./_object-pie":62,"./_property-desc":64,"./_to-iobject":74,"./_to-primitive":77}],58:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys      = require('./_object-keys-internal')
  , hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
  return $keys(O, hiddenKeys);
};
},{"./_enum-bug-keys":40,"./_object-keys-internal":60}],59:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;
},{}],60:[function(require,module,exports){
var has          = require('./_has')
  , toIObject    = require('./_to-iobject')
  , arrayIndexOf = require('./_array-includes')(false)
  , IE_PROTO     = require('./_shared-key')('IE_PROTO');

module.exports = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};
},{"./_array-includes":28,"./_has":44,"./_shared-key":67,"./_to-iobject":74}],61:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys       = require('./_object-keys-internal')
  , enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O){
  return $keys(O, enumBugKeys);
};
},{"./_enum-bug-keys":40,"./_object-keys-internal":60}],62:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;
},{}],63:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export')
  , core    = require('./_core')
  , fails   = require('./_fails');
module.exports = function(KEY, exec){
  var fn  = (core.Object || {})[KEY] || Object[KEY]
    , exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
};
},{"./_core":35,"./_export":41,"./_fails":42}],64:[function(require,module,exports){
module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};
},{}],65:[function(require,module,exports){
var global    = require('./_global')
  , hide      = require('./_hide')
  , has       = require('./_has')
  , SRC       = require('./_uid')('src')
  , TO_STRING = 'toString'
  , $toString = Function[TO_STRING]
  , TPL       = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function(it){
  return $toString.call(it);
};

(module.exports = function(O, key, val, safe){
  var isFunction = typeof val == 'function';
  if(isFunction)has(val, 'name') || hide(val, 'name', key);
  if(O[key] === val)return;
  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if(O === global){
    O[key] = val;
  } else {
    if(!safe){
      delete O[key];
      hide(O, key, val);
    } else {
      if(O[key])O[key] = val;
      else hide(O, key, val);
    }
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString(){
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});
},{"./_core":35,"./_global":43,"./_has":44,"./_hide":45,"./_uid":78}],66:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object')
  , anObject = require('./_an-object');
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};
},{"./_an-object":27,"./_ctx":36,"./_is-object":52,"./_object-gopd":57}],67:[function(require,module,exports){
var shared = require('./_shared')('keys')
  , uid    = require('./_uid');
module.exports = function(key){
  return shared[key] || (shared[key] = uid(key));
};
},{"./_shared":68,"./_uid":78}],68:[function(require,module,exports){
var global = require('./_global')
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};
},{"./_global":43}],69:[function(require,module,exports){
var fails = require('./_fails');

module.exports = function(method, arg){
  return !!method && fails(function(){
    arg ? method.call(null, function(){}, 1) : method.call(null);
  });
};
},{"./_fails":42}],70:[function(require,module,exports){
var $export = require('./_export')
  , defined = require('./_defined')
  , fails   = require('./_fails')
  , spaces  = require('./_string-ws')
  , space   = '[' + spaces + ']'
  , non     = '\u200b\u0085'
  , ltrim   = RegExp('^' + space + space + '*')
  , rtrim   = RegExp(space + space + '*$');

var exporter = function(KEY, exec, ALIAS){
  var exp   = {};
  var FORCE = fails(function(){
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if(ALIAS)exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function(string, TYPE){
  string = String(defined(string));
  if(TYPE & 1)string = string.replace(ltrim, '');
  if(TYPE & 2)string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;
},{"./_defined":37,"./_export":41,"./_fails":42,"./_string-ws":71}],71:[function(require,module,exports){
module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';
},{}],72:[function(require,module,exports){
var toInteger = require('./_to-integer')
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};
},{"./_to-integer":73}],73:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};
},{}],74:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject')
  , defined = require('./_defined');
module.exports = function(it){
  return IObject(defined(it));
};
},{"./_defined":37,"./_iobject":50}],75:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer')
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};
},{"./_to-integer":73}],76:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function(it){
  return Object(defined(it));
};
},{"./_defined":37}],77:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};
},{"./_is-object":52}],78:[function(require,module,exports){
var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};
},{}],79:[function(require,module,exports){
var store      = require('./_shared')('wks')
  , uid        = require('./_uid')
  , Symbol     = require('./_global').Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;
},{"./_global":43,"./_shared":68,"./_uid":78}],80:[function(require,module,exports){
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = require('./_export')
  , $find   = require('./_array-methods')(5)
  , KEY     = 'find'
  , forced  = true;
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);
},{"./_add-to-unscopables":26,"./_array-methods":29,"./_export":41}],81:[function(require,module,exports){
'use strict';
var $export  = require('./_export')
  , $forEach = require('./_array-methods')(0)
  , STRICT   = require('./_strict-method')([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */){
    return $forEach(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":29,"./_export":41,"./_strict-method":69}],82:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */){
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});
},{"./_array-reduce":30,"./_export":41,"./_strict-method":69}],83:[function(require,module,exports){
// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = require('./_export');

$export($export.P, 'Function', {bind: require('./_bind')});
},{"./_bind":33,"./_export":41}],84:[function(require,module,exports){
'use strict';
var global            = require('./_global')
  , has               = require('./_has')
  , cof               = require('./_cof')
  , inheritIfRequired = require('./_inherit-if-required')
  , toPrimitive       = require('./_to-primitive')
  , fails             = require('./_fails')
  , gOPN              = require('./_object-gopn').f
  , gOPD              = require('./_object-gopd').f
  , dP                = require('./_object-dp').f
  , $trim             = require('./_string-trim').trim
  , NUMBER            = 'Number'
  , $Number           = global[NUMBER]
  , Base              = $Number
  , proto             = $Number.prototype
  // Opera ~12 has broken Object#toString
  , BROKEN_COF        = cof(require('./_object-create')(proto)) == NUMBER
  , TRIM              = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function(argument){
  var it = toPrimitive(argument, false);
  if(typeof it == 'string' && it.length > 2){
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0)
      , third, radix, maxCode;
    if(first === 43 || first === 45){
      third = it.charCodeAt(2);
      if(third === 88 || third === 120)return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if(first === 48){
      switch(it.charCodeAt(1)){
        case 66 : case 98  : radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79 : case 111 : radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default : return +it;
      }
      for(var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++){
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if(code < 48 || code > maxCode)return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if(!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')){
  $Number = function Number(value){
    var it = arguments.length < 1 ? 0 : value
      , that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function(){ proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for(var keys = require('./_descriptors') ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++){
    if(has(Base, key = keys[j]) && !has($Number, key)){
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./_redefine')(global, NUMBER, $Number);
}
},{"./_cof":34,"./_descriptors":38,"./_fails":42,"./_global":43,"./_has":44,"./_inherit-if-required":48,"./_object-create":54,"./_object-dp":55,"./_object-gopd":57,"./_object-gopn":58,"./_redefine":65,"./_string-trim":70,"./_to-primitive":77}],85:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', {assign: require('./_object-assign')});
},{"./_export":41,"./_object-assign":53}],86:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', {defineProperty: require('./_object-dp').f});
},{"./_descriptors":38,"./_export":41,"./_object-dp":55}],87:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object')
  , $keys    = require('./_object-keys');

require('./_object-sap')('keys', function(){
  return function keys(it){
    return $keys(toObject(it));
  };
});
},{"./_object-keys":61,"./_object-sap":63,"./_to-object":76}],88:[function(require,module,exports){
'use strict';

// <3 Modernizr
// https://raw.githubusercontent.com/Modernizr/Modernizr/master/feature-detects/dom/dataset.js

function useNative() {
	var elem = document.createElement('div');
	elem.setAttribute('data-a-b', 'c');

	return Boolean(elem.dataset && elem.dataset.aB === 'c');
}

function nativeDataset(element) {
	return element.dataset;
}

module.exports = useNative() ? nativeDataset : function (element) {
	var map = {};
	var attributes = element.attributes;

	function getter() {
		return this.value;
	}

	function setter(name, value) {
		if (typeof value === 'undefined') {
			this.removeAttribute(name);
		} else {
			this.setAttribute(name, value);
		}
	}

	for (var i = 0, j = attributes.length; i < j; i++) {
		var attribute = attributes[i];

		if (attribute) {
			var name = attribute.name;

			if (name.indexOf('data-') === 0) {
				var prop = name.slice(5).replace(/-./g, function (u) {
					return u.charAt(1).toUpperCase();
				});

				var value = attribute.value;

				Object.defineProperty(map, prop, {
					enumerable: true,
					get: getter.bind({ value: value || '' }),
					set: setter.bind(element, name)
				});
			}
		}
	}

	return map;
};

},{}],89:[function(require,module,exports){
'use strict';

module.exports = function isArrayish(obj) {
	if (!obj || typeof obj === 'string') {
		return false;
	}

	return obj instanceof Array || Array.isArray(obj) ||
		(obj.length >= 0 && (obj.splice instanceof Function ||
			(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));
};

},{}],90:[function(require,module,exports){
/* eslint no-console:0 */
/**
 * This is the main entry point for KaTeX. Here, we expose functions for
 * rendering expressions either to DOM nodes or to markup strings.
 *
 * We also expose the ParseError class to check if errors thrown from KaTeX are
 * errors in the expression, or errors in javascript handling.
 */

var ParseError = require("./src/ParseError");
var Settings = require("./src/Settings");

var buildTree = require("./src/buildTree");
var parseTree = require("./src/parseTree");
var utils = require("./src/utils");

/**
 * Parse and build an expression, and place that expression in the DOM node
 * given.
 */
var render = function(expression, baseNode, options) {
    utils.clearNode(baseNode);

    var settings = new Settings(options);

    var tree = parseTree(expression, settings);
    var node = buildTree(tree, expression, settings).toNode();

    baseNode.appendChild(node);
};

// KaTeX's styles don't work properly in quirks mode. Print out an error, and
// disable rendering.
if (typeof document !== "undefined") {
    if (document.compatMode !== "CSS1Compat") {
        typeof console !== "undefined" && console.warn(
            "Warning: KaTeX doesn't work in quirks mode. Make sure your " +
                "website has a suitable doctype.");

        render = function() {
            throw new ParseError("KaTeX doesn't work in quirks mode.");
        };
    }
}

/**
 * Parse and build an expression, and return the markup for that.
 */
var renderToString = function(expression, options) {
    var settings = new Settings(options);

    var tree = parseTree(expression, settings);
    return buildTree(tree, expression, settings).toMarkup();
};

/**
 * Parse an expression and return the parse tree.
 */
var generateParseTree = function(expression, options) {
    var settings = new Settings(options);
    return parseTree(expression, settings);
};

module.exports = {
    render: render,
    renderToString: renderToString,
    /**
     * NOTE: This method is not currently recommended for public use.
     * The internal tree representation is unstable and is very likely
     * to change. Use at your own risk.
     */
    __parse: generateParseTree,
    ParseError: ParseError
};

},{"./src/ParseError":94,"./src/Settings":96,"./src/buildTree":101,"./src/parseTree":110,"./src/utils":113}],91:[function(require,module,exports){
/**
 * The Lexer class handles tokenizing the input in various ways. Since our
 * parser expects us to be able to backtrack, the lexer allows lexing from any
 * given starting point.
 *
 * Its main exposed function is the `lex` function, which takes a position to
 * lex from and a type of token to lex. It defers to the appropriate `_innerLex`
 * function.
 *
 * The various `_innerLex` functions perform the actual lexing of different
 * kinds.
 */

var matchAt = require("match-at");

var ParseError = require("./ParseError");

// The main lexer class
function Lexer(input) {
    this.input = input;
    this.pos = 0;
}

/**
 * The resulting token returned from `lex`.
 *
 * It consists of the token text plus some position information.
 * The position information is essentially a range in an input string,
 * but instead of referencing the bare input string, we refer to the lexer.
 * That way it is possible to attach extra metadata to the input string,
 * like for example a file name or similar.
 *
 * The position information (all three parameters) is optional,
 * so it is OK to construct synthetic tokens if appropriate.
 * Not providing available position information may lead to
 * degraded error reporting, though.
 *
 * @param {string}  text   the text of this token
 * @param {number=} start  the start offset, zero-based inclusive
 * @param {number=} end    the end offset, zero-based exclusive
 * @param {Lexer=}  lexer  the lexer which in turn holds the input string
 */
function Token(text, start, end, lexer) {
    this.text = text;
    this.start = start;
    this.end = end;
    this.lexer = lexer;
}

/**
 * Given a pair of tokens (this and endToken), compute a “Token” encompassing
 * the whole input range enclosed by these two.
 *
 * @param {Token}  endToken  last token of the range, inclusive
 * @param {string} text      the text of the newly constructed token
 */
Token.prototype.range = function(endToken, text) {
    if (endToken.lexer !== this.lexer) {
        return new Token(text); // sorry, no position information available
    }
    return new Token(text, this.start, endToken.end, this.lexer);
};

/* The following tokenRegex
 * - matches typical whitespace (but not NBSP etc.) using its first group
 * - does not match any control character \x00-\x1f except whitespace
 * - does not match a bare backslash
 * - matches any ASCII character except those just mentioned
 * - does not match the BMP private use area \uE000-\uF8FF
 * - does not match bare surrogate code units
 * - matches any BMP character except for those just described
 * - matches any valid Unicode surrogate pair
 * - matches a backslash followed by one or more letters
 * - matches a backslash followed by any BMP character, including newline
 * Just because the Lexer matches something doesn't mean it's valid input:
 * If there is no matching function or symbol definition, the Parser will
 * still reject the input.
 */
var tokenRegex = new RegExp(
    "([ \r\n\t]+)|" +                                 // whitespace
    "([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" +  // single codepoint
    "|[\uD800-\uDBFF][\uDC00-\uDFFF]" +               // surrogate pair
    "|\\\\(?:[a-zA-Z]+|[^\uD800-\uDFFF])" +           // function name
    ")"
);

/**
 * This function lexes a single token.
 */
Lexer.prototype.lex = function() {
    var input = this.input;
    var pos = this.pos;
    if (pos === input.length) {
        return new Token("EOF", pos, pos, this);
    }
    var match = matchAt(tokenRegex, input, pos);
    if (match === null) {
        throw new ParseError(
            "Unexpected character: '" + input[pos] + "'",
            new Token(input[pos], pos, pos + 1, this));
    }
    var text = match[2] || " ";
    var start = this.pos;
    this.pos += match[0].length;
    var end = this.pos;
    return new Token(text, start, end, this);
};

module.exports = Lexer;

},{"./ParseError":94,"match-at":114}],92:[function(require,module,exports){
/**
 * This file contains the “gullet” where macros are expanded
 * until only non-macro tokens remain.
 */

var Lexer = require("./Lexer");

function MacroExpander(input, macros) {
    this.lexer = new Lexer(input);
    this.macros = macros;
    this.stack = []; // contains tokens in REVERSE order
    this.discardedWhiteSpace = [];
}

/**
 * Recursively expand first token, then return first non-expandable token.
 */
MacroExpander.prototype.nextToken = function() {
    for (;;) {
        if (this.stack.length === 0) {
            this.stack.push(this.lexer.lex());
        }
        var topToken = this.stack.pop();
        var name = topToken.text;
        if (!(name.charAt(0) === "\\" && this.macros.hasOwnProperty(name))) {
            return topToken;
        }
        var expansion = this.macros[name];
        if (typeof expansion === "string") {
            var bodyLexer = new Lexer(expansion);
            expansion = [];
            var tok = bodyLexer.lex();
            while (tok.text !== "EOF") {
                expansion.push(tok);
                tok = bodyLexer.lex();
            }
            expansion.reverse(); // to fit in with stack using push and pop
            this.macros[name] = expansion;
        }
        this.stack = this.stack.concat(expansion);
    }
};

MacroExpander.prototype.get = function(ignoreSpace) {
    this.discardedWhiteSpace = [];
    var token = this.nextToken();
    if (ignoreSpace) {
        while (token.text === " ") {
            this.discardedWhiteSpace.push(token);
            token = this.nextToken();
        }
    }
    return token;
};

/**
 * Undo the effect of the preceding call to the get method.
 * A call to this method MUST be immediately preceded and immediately followed
 * by a call to get.  Only used during mode switching, i.e. after one token
 * was got in the old mode but should get got again in a new mode
 * with possibly different whitespace handling.
 */
MacroExpander.prototype.unget = function(token) {
    this.stack.push(token);
    while (this.discardedWhiteSpace.length !== 0) {
        this.stack.push(this.discardedWhiteSpace.pop());
    }
};

module.exports = MacroExpander;

},{"./Lexer":91}],93:[function(require,module,exports){
/**
 * This file contains information about the options that the Parser carries
 * around with it while parsing. Data is held in an `Options` object, and when
 * recursing, a new `Options` object can be created with the `.with*` and
 * `.reset` functions.
 */

/**
 * This is the main options class. It contains the style, size, color, and font
 * of the current parse level. It also contains the style and size of the parent
 * parse level, so size changes can be handled efficiently.
 *
 * Each of the `.with*` and `.reset` functions passes its current style and size
 * as the parentStyle and parentSize of the new options class, so parent
 * handling is taken care of automatically.
 */
function Options(data) {
    this.style = data.style;
    this.color = data.color;
    this.size = data.size;
    this.phantom = data.phantom;
    this.font = data.font;

    if (data.parentStyle === undefined) {
        this.parentStyle = data.style;
    } else {
        this.parentStyle = data.parentStyle;
    }

    if (data.parentSize === undefined) {
        this.parentSize = data.size;
    } else {
        this.parentSize = data.parentSize;
    }
}

/**
 * Returns a new options object with the same properties as "this".  Properties
 * from "extension" will be copied to the new options object.
 */
Options.prototype.extend = function(extension) {
    var data = {
        style: this.style,
        size: this.size,
        color: this.color,
        parentStyle: this.style,
        parentSize: this.size,
        phantom: this.phantom,
        font: this.font
    };

    for (var key in extension) {
        if (extension.hasOwnProperty(key)) {
            data[key] = extension[key];
        }
    }

    return new Options(data);
};

/**
 * Create a new options object with the given style.
 */
Options.prototype.withStyle = function(style) {
    return this.extend({
        style: style
    });
};

/**
 * Create a new options object with the given size.
 */
Options.prototype.withSize = function(size) {
    return this.extend({
        size: size
    });
};

/**
 * Create a new options object with the given color.
 */
Options.prototype.withColor = function(color) {
    return this.extend({
        color: color
    });
};

/**
 * Create a new options object with "phantom" set to true.
 */
Options.prototype.withPhantom = function() {
    return this.extend({
        phantom: true
    });
};

/**
 * Create a new options objects with the give font.
 */
Options.prototype.withFont = function(font) {
    return this.extend({
        font: font || this.font
    });
};

/**
 * Create a new options object with the same style, size, and color. This is
 * used so that parent style and size changes are handled correctly.
 */
Options.prototype.reset = function() {
    return this.extend({});
};

/**
 * A map of color names to CSS colors.
 * TODO(emily): Remove this when we have real macros
 */
var colorMap = {
    "katex-blue": "#6495ed",
    "katex-orange": "#ffa500",
    "katex-pink": "#ff00af",
    "katex-red": "#df0030",
    "katex-green": "#28ae7b",
    "katex-gray": "gray",
    "katex-purple": "#9d38bd",
    "katex-blueA": "#ccfaff",
    "katex-blueB": "#80f6ff",
    "katex-blueC": "#63d9ea",
    "katex-blueD": "#11accd",
    "katex-blueE": "#0c7f99",
    "katex-tealA": "#94fff5",
    "katex-tealB": "#26edd5",
    "katex-tealC": "#01d1c1",
    "katex-tealD": "#01a995",
    "katex-tealE": "#208170",
    "katex-greenA": "#b6ffb0",
    "katex-greenB": "#8af281",
    "katex-greenC": "#74cf70",
    "katex-greenD": "#1fab54",
    "katex-greenE": "#0d923f",
    "katex-goldA": "#ffd0a9",
    "katex-goldB": "#ffbb71",
    "katex-goldC": "#ff9c39",
    "katex-goldD": "#e07d10",
    "katex-goldE": "#a75a05",
    "katex-redA": "#fca9a9",
    "katex-redB": "#ff8482",
    "katex-redC": "#f9685d",
    "katex-redD": "#e84d39",
    "katex-redE": "#bc2612",
    "katex-maroonA": "#ffbde0",
    "katex-maroonB": "#ff92c6",
    "katex-maroonC": "#ed5fa6",
    "katex-maroonD": "#ca337c",
    "katex-maroonE": "#9e034e",
    "katex-purpleA": "#ddd7ff",
    "katex-purpleB": "#c6b9fc",
    "katex-purpleC": "#aa87ff",
    "katex-purpleD": "#7854ab",
    "katex-purpleE": "#543b78",
    "katex-mintA": "#f5f9e8",
    "katex-mintB": "#edf2df",
    "katex-mintC": "#e0e5cc",
    "katex-grayA": "#f6f7f7",
    "katex-grayB": "#f0f1f2",
    "katex-grayC": "#e3e5e6",
    "katex-grayD": "#d6d8da",
    "katex-grayE": "#babec2",
    "katex-grayF": "#888d93",
    "katex-grayG": "#626569",
    "katex-grayH": "#3b3e40",
    "katex-grayI": "#21242c",
    "katex-kaBlue": "#314453",
    "katex-kaGreen": "#71B307"
};

/**
 * Gets the CSS color of the current options object, accounting for the
 * `colorMap`.
 */
Options.prototype.getColor = function() {
    if (this.phantom) {
        return "transparent";
    } else {
        return colorMap[this.color] || this.color;
    }
};

module.exports = Options;

},{}],94:[function(require,module,exports){
/**
 * This is the ParseError class, which is the main error thrown by KaTeX
 * functions when something has gone wrong. This is used to distinguish internal
 * errors from errors in the expression that the user provided.
 *
 * If possible, a caller should provide a Token or ParseNode with information
 * about where in the source string the problem occurred.
 *
 * @param {string} message  The error message
 * @param {(Token|ParseNode)=} token  An object providing position information
 */
function ParseError(message, token) {
    var error = "KaTeX parse error: " + message;
    var start;
    var end;

    if (token && token.lexer && token.start <= token.end) {
        // If we have the input and a position, make the error a bit fancier

        // Get the input
        var input = token.lexer.input;

        // Prepend some information
        start = token.start;
        end = token.end;
        if (start === input.length) {
            error += " at end of input: ";
        } else {
            error += " at position " + (start + 1) + ": ";
        }

        // Underline token in question using combining underscores
        var underlined = input.slice(start, end).replace(/[^]/g, "$&\u0332");

        // Extract some context from the input and add it to the error
        var left;
        if (start > 15) {
            left = "…" + input.slice(start - 15, start);
        } else {
            left = input.slice(0, start);
        }
        var right;
        if (end + 15 < input.length) {
            right = input.slice(end, end + 15) + "…";
        } else {
            right = input.slice(end);
        }
        error += left + underlined + right;
    }

    // Some hackery to make ParseError a prototype of Error
    // See http://stackoverflow.com/a/8460753
    var self = new Error(error);
    self.name = "ParseError";
    self.__proto__ = ParseError.prototype;

    self.position = start;
    return self;
}

// More hackery
ParseError.prototype.__proto__ = Error.prototype;

module.exports = ParseError;

},{}],95:[function(require,module,exports){
/* eslint no-constant-condition:0 */
var functions = require("./functions");
var environments = require("./environments");
var MacroExpander = require("./MacroExpander");
var symbols = require("./symbols");
var utils = require("./utils");
var cjkRegex = require("./unicodeRegexes").cjkRegex;

var parseData = require("./parseData");
var ParseError = require("./ParseError");

/**
 * This file contains the parser used to parse out a TeX expression from the
 * input. Since TeX isn't context-free, standard parsers don't work particularly
 * well.
 *
 * The strategy of this parser is as such:
 *
 * The main functions (the `.parse...` ones) take a position in the current
 * parse string to parse tokens from. The lexer (found in Lexer.js, stored at
 * this.lexer) also supports pulling out tokens at arbitrary places. When
 * individual tokens are needed at a position, the lexer is called to pull out a
 * token, which is then used.
 *
 * The parser has a property called "mode" indicating the mode that
 * the parser is currently in. Currently it has to be one of "math" or
 * "text", which denotes whether the current environment is a math-y
 * one or a text-y one (e.g. inside \text). Currently, this serves to
 * limit the functions which can be used in text mode.
 *
 * The main functions then return an object which contains the useful data that
 * was parsed at its given point, and a new position at the end of the parsed
 * data. The main functions can call each other and continue the parsing by
 * using the returned position as a new starting point.
 *
 * There are also extra `.handle...` functions, which pull out some reused
 * functionality into self-contained functions.
 *
 * The earlier functions return ParseNodes.
 * The later functions (which are called deeper in the parse) sometimes return
 * ParseFuncOrArgument, which contain a ParseNode as well as some data about
 * whether the parsed object is a function which is missing some arguments, or a
 * standalone object which can be used as an argument to another function.
 */

/**
 * Main Parser class
 */
function Parser(input, settings) {
    // Create a new macro expander (gullet) and (indirectly via that) also a
    // new lexer (mouth) for this parser (stomach, in the language of TeX)
    this.gullet = new MacroExpander(input, settings.macros);
    // Store the settings for use in parsing
    this.settings = settings;
    // Count leftright depth (for \middle errors)
    this.leftrightDepth = 0;
}

var ParseNode = parseData.ParseNode;

/**
 * An initial function (without its arguments), or an argument to a function.
 * The `result` argument should be a ParseNode.
 */
function ParseFuncOrArgument(result, isFunction, token) {
    this.result = result;
    // Is this a function (i.e. is it something defined in functions.js)?
    this.isFunction = isFunction;
    this.token = token;
}

/**
 * Checks a result to make sure it has the right type, and throws an
 * appropriate error otherwise.
 *
 * @param {boolean=} consume whether to consume the expected token,
 *                           defaults to true
 */
Parser.prototype.expect = function(text, consume) {
    if (this.nextToken.text !== text) {
        throw new ParseError(
            "Expected '" + text + "', got '" + this.nextToken.text + "'",
            this.nextToken
        );
    }
    if (consume !== false) {
        this.consume();
    }
};

/**
 * Considers the current look ahead token as consumed,
 * and fetches the one after that as the new look ahead.
 */
Parser.prototype.consume = function() {
    this.nextToken = this.gullet.get(this.mode === "math");
};

Parser.prototype.switchMode = function(newMode) {
    this.gullet.unget(this.nextToken);
    this.mode = newMode;
    this.consume();
};

/**
 * Main parsing function, which parses an entire input.
 *
 * @return {?Array.<ParseNode>}
 */
Parser.prototype.parse = function() {
    // Try to parse the input
    this.mode = "math";
    this.consume();
    var parse = this.parseInput();
    return parse;
};

/**
 * Parses an entire input tree.
 */
Parser.prototype.parseInput = function() {
    // Parse an expression
    var expression = this.parseExpression(false);
    // If we succeeded, make sure there's an EOF at the end
    this.expect("EOF", false);
    return expression;
};

var endOfExpression = ["}", "\\end", "\\right", "&", "\\\\", "\\cr"];

/**
 * Parses an "expression", which is a list of atoms.
 *
 * @param {boolean} breakOnInfix  Should the parsing stop when we hit infix
 *                  nodes? This happens when functions have higher precendence
 *                  than infix nodes in implicit parses.
 *
 * @param {?string} breakOnTokenText  The text of the token that the expression
 *                  should end with, or `null` if something else should end the
 *                  expression.
 *
 * @return {ParseNode}
 */
Parser.prototype.parseExpression = function(breakOnInfix, breakOnTokenText) {
    var body = [];
    // Keep adding atoms to the body until we can't parse any more atoms (either
    // we reached the end, a }, or a \right)
    while (true) {
        var lex = this.nextToken;
        if (endOfExpression.indexOf(lex.text) !== -1) {
            break;
        }
        if (breakOnTokenText && lex.text === breakOnTokenText) {
            break;
        }
        if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {
            break;
        }
        var atom = this.parseAtom();
        if (!atom) {
            if (!this.settings.throwOnError && lex.text[0] === "\\") {
                var errorNode = this.handleUnsupportedCmd();
                body.push(errorNode);
                continue;
            }

            break;
        }
        body.push(atom);
    }
    return this.handleInfixNodes(body);
};

/**
 * Rewrites infix operators such as \over with corresponding commands such
 * as \frac.
 *
 * There can only be one infix operator per group.  If there's more than one
 * then the expression is ambiguous.  This can be resolved by adding {}.
 *
 * @returns {Array}
 */
Parser.prototype.handleInfixNodes = function(body) {
    var overIndex = -1;
    var funcName;

    for (var i = 0; i < body.length; i++) {
        var node = body[i];
        if (node.type === "infix") {
            if (overIndex !== -1) {
                throw new ParseError(
                    "only one infix operator per group",
                    node.value.token);
            }
            overIndex = i;
            funcName = node.value.replaceWith;
        }
    }

    if (overIndex !== -1) {
        var numerNode;
        var denomNode;

        var numerBody = body.slice(0, overIndex);
        var denomBody = body.slice(overIndex + 1);

        if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
            numerNode = numerBody[0];
        } else {
            numerNode = new ParseNode("ordgroup", numerBody, this.mode);
        }

        if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
            denomNode = denomBody[0];
        } else {
            denomNode = new ParseNode("ordgroup", denomBody, this.mode);
        }

        var value = this.callFunction(
            funcName, [numerNode, denomNode], null);
        return [new ParseNode(value.type, value, this.mode)];
    } else {
        return body;
    }
};

// The greediness of a superscript or subscript
var SUPSUB_GREEDINESS = 1;

/**
 * Handle a subscript or superscript with nice errors.
 */
Parser.prototype.handleSupSubscript = function(name) {
    var symbolToken = this.nextToken;
    var symbol = symbolToken.text;
    this.consume();
    var group = this.parseGroup();

    if (!group) {
        if (!this.settings.throwOnError && this.nextToken.text[0] === "\\") {
            return this.handleUnsupportedCmd();
        } else {
            throw new ParseError(
                "Expected group after '" + symbol + "'",
                symbolToken
            );
        }
    } else if (group.isFunction) {
        // ^ and _ have a greediness, so handle interactions with functions'
        // greediness
        var funcGreediness = functions[group.result].greediness;
        if (funcGreediness > SUPSUB_GREEDINESS) {
            return this.parseFunction(group);
        } else {
            throw new ParseError(
                "Got function '" + group.result + "' with no arguments " +
                    "as " + name, symbolToken);
        }
    } else {
        return group.result;
    }
};

/**
 * Converts the textual input of an unsupported command into a text node
 * contained within a color node whose color is determined by errorColor
 */
Parser.prototype.handleUnsupportedCmd = function() {
    var text = this.nextToken.text;
    var textordArray = [];

    for (var i = 0; i < text.length; i++) {
        textordArray.push(new ParseNode("textord", text[i], "text"));
    }

    var textNode = new ParseNode(
        "text",
        {
            body: textordArray,
            type: "text"
        },
        this.mode);

    var colorNode = new ParseNode(
        "color",
        {
            color: this.settings.errorColor,
            value: [textNode],
            type: "color"
        },
        this.mode);

    this.consume();
    return colorNode;
};

/**
 * Parses a group with optional super/subscripts.
 *
 * @return {?ParseNode}
 */
Parser.prototype.parseAtom = function() {
    // The body of an atom is an implicit group, so that things like
    // \left(x\right)^2 work correctly.
    var base = this.parseImplicitGroup();

    // In text mode, we don't have superscripts or subscripts
    if (this.mode === "text") {
        return base;
    }

    // Note that base may be empty (i.e. null) at this point.

    var superscript;
    var subscript;
    while (true) {
        // Lex the first token
        var lex = this.nextToken;

        if (lex.text === "\\limits" || lex.text === "\\nolimits") {
            // We got a limit control
            if (!base || base.type !== "op") {
                throw new ParseError(
                    "Limit controls must follow a math operator",
                    lex);
            } else {
                var limits = lex.text === "\\limits";
                base.value.limits = limits;
                base.value.alwaysHandleSupSub = true;
            }
            this.consume();
        } else if (lex.text === "^") {
            // We got a superscript start
            if (superscript) {
                throw new ParseError("Double superscript", lex);
            }
            superscript = this.handleSupSubscript("superscript");
        } else if (lex.text === "_") {
            // We got a subscript start
            if (subscript) {
                throw new ParseError("Double subscript", lex);
            }
            subscript = this.handleSupSubscript("subscript");
        } else if (lex.text === "'") {
            // We got a prime
            var prime = new ParseNode("textord", "\\prime", this.mode);

            // Many primes can be grouped together, so we handle this here
            var primes = [prime];
            this.consume();
            // Keep lexing tokens until we get something that's not a prime
            while (this.nextToken.text === "'") {
                // For each one, add another prime to the list
                primes.push(prime);
                this.consume();
            }
            // Put them into an ordgroup as the superscript
            superscript = new ParseNode("ordgroup", primes, this.mode);
        } else {
            // If it wasn't ^, _, or ', stop parsing super/subscripts
            break;
        }
    }

    if (superscript || subscript) {
        // If we got either a superscript or subscript, create a supsub
        return new ParseNode("supsub", {
            base: base,
            sup: superscript,
            sub: subscript
        }, this.mode);
    } else {
        // Otherwise return the original body
        return base;
    }
};

// A list of the size-changing functions, for use in parseImplicitGroup
var sizeFuncs = [
    "\\tiny", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize",
    "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"
];

// A list of the style-changing functions, for use in parseImplicitGroup
var styleFuncs = [
    "\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"
];

/**
 * Parses an implicit group, which is a group that starts at the end of a
 * specified, and ends right before a higher explicit group ends, or at EOL. It
 * is used for functions that appear to affect the current style, like \Large or
 * \textrm, where instead of keeping a style we just pretend that there is an
 * implicit grouping after it until the end of the group. E.g.
 *   small text {\Large large text} small text again
 * It is also used for \left and \right to get the correct grouping.
 *
 * @return {?ParseNode}
 */
Parser.prototype.parseImplicitGroup = function() {
    var start = this.parseSymbol();

    if (start == null) {
        // If we didn't get anything we handle, fall back to parseFunction
        return this.parseFunction();
    }

    var func = start.result;
    var body;

    if (func === "\\left") {
        // If we see a left:
        // Parse the entire left function (including the delimiter)
        var left = this.parseFunction(start);
        // Parse out the implicit body
        ++this.leftrightDepth;
        body = this.parseExpression(false);
        --this.leftrightDepth;
        // Check the next token
        this.expect("\\right", false);
        var right = this.parseFunction();
        return new ParseNode("leftright", {
            body: body,
            left: left.value.value,
            right: right.value.value
        }, this.mode);
    } else if (func === "\\begin") {
        // begin...end is similar to left...right
        var begin = this.parseFunction(start);
        var envName = begin.value.name;
        if (!environments.hasOwnProperty(envName)) {
            throw new ParseError(
                "No such environment: " + envName, begin.value.nameGroup);
        }
        // Build the environment object. Arguments and other information will
        // be made available to the begin and end methods using properties.
        var env = environments[envName];
        var args = this.parseArguments("\\begin{" + envName + "}", env);
        var context = {
            mode: this.mode,
            envName: envName,
            parser: this,
            positions: args.pop()
        };
        var result = env.handler(context, args);
        this.expect("\\end", false);
        var endNameToken = this.nextToken;
        var end = this.parseFunction();
        if (end.value.name !== envName) {
            throw new ParseError(
                "Mismatch: \\begin{" + envName + "} matched " +
                "by \\end{" + end.value.name + "}",
                endNameToken);
        }
        result.position = end.position;
        return result;
    } else if (utils.contains(sizeFuncs, func)) {
        // If we see a sizing function, parse out the implict body
        body = this.parseExpression(false);
        return new ParseNode("sizing", {
            // Figure out what size to use based on the list of functions above
            size: "size" + (utils.indexOf(sizeFuncs, func) + 1),
            value: body
        }, this.mode);
    } else if (utils.contains(styleFuncs, func)) {
        // If we see a styling function, parse out the implict body
        body = this.parseExpression(true);
        return new ParseNode("styling", {
            // Figure out what style to use by pulling out the style from
            // the function name
            style: func.slice(1, func.length - 5),
            value: body
        }, this.mode);
    } else {
        // Defer to parseFunction if it's not a function we handle
        return this.parseFunction(start);
    }
};

/**
 * Parses an entire function, including its base and all of its arguments.
 * The base might either have been parsed already, in which case
 * it is provided as an argument, or it's the next group in the input.
 *
 * @param {ParseFuncOrArgument=} baseGroup optional as described above
 * @return {?ParseNode}
 */
Parser.prototype.parseFunction = function(baseGroup) {
    if (!baseGroup) {
        baseGroup = this.parseGroup();
    }

    if (baseGroup) {
        if (baseGroup.isFunction) {
            var func = baseGroup.result;
            var funcData = functions[func];
            if (this.mode === "text" && !funcData.allowedInText) {
                throw new ParseError(
                    "Can't use function '" + func + "' in text mode",
                    baseGroup.token);
            }

            var args = this.parseArguments(func, funcData);
            var token = baseGroup.token;
            var result = this.callFunction(func, args, args.pop(), token);
            return new ParseNode(result.type, result, this.mode);
        } else {
            return baseGroup.result;
        }
    } else {
        return null;
    }
};

/**
 * Call a function handler with a suitable context and arguments.
 */
Parser.prototype.callFunction = function(name, args, positions, token) {
    var context = {
        funcName: name,
        parser: this,
        positions: positions,
        token: token
    };
    return functions[name].handler(context, args);
};

/**
 * Parses the arguments of a function or environment
 *
 * @param {string} func  "\name" or "\begin{name}"
 * @param {{numArgs:number,numOptionalArgs:number|undefined}} funcData
 * @return the array of arguments, with the list of positions as last element
 */
Parser.prototype.parseArguments = function(func, funcData) {
    var totalArgs = funcData.numArgs + funcData.numOptionalArgs;
    if (totalArgs === 0) {
        return [[this.pos]];
    }

    var baseGreediness = funcData.greediness;
    var positions = [this.pos];
    var args = [];

    for (var i = 0; i < totalArgs; i++) {
        var nextToken = this.nextToken;
        var argType = funcData.argTypes && funcData.argTypes[i];
        var arg;
        if (i < funcData.numOptionalArgs) {
            if (argType) {
                arg = this.parseGroupOfType(argType, true);
            } else {
                arg = this.parseGroup(true);
            }
            if (!arg) {
                args.push(null);
                positions.push(this.pos);
                continue;
            }
        } else {
            if (argType) {
                arg = this.parseGroupOfType(argType);
            } else {
                arg = this.parseGroup();
            }
            if (!arg) {
                if (!this.settings.throwOnError &&
                    this.nextToken.text[0] === "\\") {
                    arg = new ParseFuncOrArgument(
                        this.handleUnsupportedCmd(this.nextToken.text),
                        false);
                } else {
                    throw new ParseError(
                        "Expected group after '" + func + "'", nextToken);
                }
            }
        }
        var argNode;
        if (arg.isFunction) {
            var argGreediness =
                functions[arg.result].greediness;
            if (argGreediness > baseGreediness) {
                argNode = this.parseFunction(arg);
            } else {
                throw new ParseError(
                    "Got function '" + arg.result + "' as " +
                    "argument to '" + func + "'", nextToken);
            }
        } else {
            argNode = arg.result;
        }
        args.push(argNode);
        positions.push(this.pos);
    }

    args.push(positions);

    return args;
};


/**
 * Parses a group when the mode is changing.
 *
 * @return {?ParseFuncOrArgument}
 */
Parser.prototype.parseGroupOfType = function(innerMode, optional) {
    var outerMode = this.mode;
    // Handle `original` argTypes
    if (innerMode === "original") {
        innerMode = outerMode;
    }

    if (innerMode === "color") {
        return this.parseColorGroup(optional);
    }
    if (innerMode === "size") {
        return this.parseSizeGroup(optional);
    }

    this.switchMode(innerMode);
    if (innerMode === "text") {
        // text mode is special because it should ignore the whitespace before
        // it
        while (this.nextToken.text === " ") {
            this.consume();
        }
    }
    // By the time we get here, innerMode is one of "text" or "math".
    // We switch the mode of the parser, recurse, then restore the old mode.
    var res = this.parseGroup(optional);
    this.switchMode(outerMode);
    return res;
};

/**
 * Parses a group, essentially returning the string formed by the
 * brace-enclosed tokens plus some position information.
 *
 * @param {string} modeName  Used to describe the mode in error messages
 * @param {boolean=} optional  Whether the group is optional or required
 */
Parser.prototype.parseStringGroup = function(modeName, optional) {
    if (optional && this.nextToken.text !== "[") {
        return null;
    }
    var outerMode = this.mode;
    this.mode = "text";
    this.expect(optional ? "[" : "{");
    var str = "";
    var firstToken = this.nextToken;
    var lastToken = firstToken;
    while (this.nextToken.text !== (optional ? "]" : "}")) {
        if (this.nextToken.text === "EOF") {
            throw new ParseError(
                "Unexpected end of input in " + modeName,
                firstToken.range(this.nextToken, str));
        }
        lastToken = this.nextToken;
        str += lastToken.text;
        this.consume();
    }
    this.mode = outerMode;
    this.expect(optional ? "]" : "}");
    return firstToken.range(lastToken, str);
};

/**
 * Parses a regex-delimited group: the largest sequence of tokens
 * whose concatenated strings match `regex`. Returns the string
 * formed by the tokens plus some position information.
 *
 * @param {RegExp} regex
 * @param {string} modeName  Used to describe the mode in error messages
 */
Parser.prototype.parseRegexGroup = function(regex, modeName) {
    var outerMode = this.mode;
    this.mode = "text";
    var firstToken = this.nextToken;
    var lastToken = firstToken;
    var str = "";
    while (this.nextToken.text !== "EOF"
           && regex.test(str + this.nextToken.text)) {
        lastToken = this.nextToken;
        str += lastToken.text;
        this.consume();
    }
    if (str === "") {
        throw new ParseError(
            "Invalid " + modeName + ": '" + firstToken.text + "'",
            firstToken);
    }
    this.mode = outerMode;
    return firstToken.range(lastToken, str);
};

/**
 * Parses a color description.
 */
Parser.prototype.parseColorGroup = function(optional) {
    var res = this.parseStringGroup("color", optional);
    if (!res) {
        return null;
    }
    var match = (/^(#[a-z0-9]+|[a-z]+)$/i).exec(res.text);
    if (!match) {
        throw new ParseError("Invalid color: '" + res.text + "'", res);
    }
    return new ParseFuncOrArgument(
        new ParseNode("color", match[0], this.mode),
        false);
};

/**
 * Parses a size specification, consisting of magnitude and unit.
 */
Parser.prototype.parseSizeGroup = function(optional) {
    var res;
    if (!optional && this.nextToken.text !== "{") {
        res = this.parseRegexGroup(
            /^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2}$/, "size");
    } else {
        res = this.parseStringGroup("size", optional);
    }
    if (!res) {
        return null;
    }
    var match = (/([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/).exec(res.text);
    if (!match) {
        throw new ParseError("Invalid size: '" + res.text + "'", res);
    }
    var data = {
        number: +(match[1] + match[2]), // sign + magnitude, cast to number
        unit: match[3]
    };
    if (data.unit !== "em" && data.unit !== "ex" && data.unit !== "mu") {
        throw new ParseError("Invalid unit: '" + data.unit + "'", res);
    }
    return new ParseFuncOrArgument(
        new ParseNode("color", data, this.mode),
        false);
};

/**
 * If the argument is false or absent, this parses an ordinary group,
 * which is either a single nucleus (like "x") or an expression
 * in braces (like "{x+y}").
 * If the argument is true, it parses either a bracket-delimited expression
 * (like "[x+y]") or returns null to indicate the absence of a
 * bracket-enclosed group.
 *
 * @param {boolean=} optional  Whether the group is optional or required
 * @return {?ParseFuncOrArgument}
 */
Parser.prototype.parseGroup = function(optional) {
    var firstToken = this.nextToken;
    // Try to parse an open brace
    if (this.nextToken.text === (optional ? "[" : "{")) {
        // If we get a brace, parse an expression
        this.consume();
        var expression = this.parseExpression(false, optional ? "]" : null);
        var lastToken = this.nextToken;
        // Make sure we get a close brace
        this.expect(optional ? "]" : "}");
        if (this.mode === "text") {
            this.formLigatures(expression);
        }
        return new ParseFuncOrArgument(
            new ParseNode("ordgroup", expression, this.mode,
                          firstToken, lastToken),
            false);
    } else {
        // Otherwise, just return a nucleus, or nothing for an optional group
        return optional ? null : this.parseSymbol();
    }
};

/**
 * Form ligature-like combinations of characters for text mode.
 * This includes inputs like "--", "---", "``" and "''".
 * The result will simply replace multiple textord nodes with a single
 * character in each value by a single textord node having multiple
 * characters in its value.  The representation is still ASCII source.
 *
 * @param {Array.<ParseNode>} group  the nodes of this group,
 *                                   list will be moified in place
 */
Parser.prototype.formLigatures = function(group) {
    var i;
    var n = group.length - 1;
    for (i = 0; i < n; ++i) {
        var a = group[i];
        var v = a.value;
        if (v === "-" && group[i + 1].value === "-") {
            if (i + 1 < n && group[i + 2].value === "-") {
                group.splice(i, 3, new ParseNode(
                    "textord", "---", "text", a, group[i + 2]));
                n -= 2;
            } else {
                group.splice(i, 2, new ParseNode(
                    "textord", "--", "text", a, group[i + 1]));
                n -= 1;
            }
        }
        if ((v === "'" || v === "`") && group[i + 1].value === v) {
            group.splice(i, 2, new ParseNode(
                "textord", v + v, "text", a, group[i + 1]));
            n -= 1;
        }
    }
};

/**
 * Parse a single symbol out of the string. Here, we handle both the functions
 * we have defined, as well as the single character symbols
 *
 * @return {?ParseFuncOrArgument}
 */
Parser.prototype.parseSymbol = function() {
    var nucleus = this.nextToken;

    if (functions[nucleus.text]) {
        this.consume();
        // If there exists a function with this name, we return the function and
        // say that it is a function.
        return new ParseFuncOrArgument(
            nucleus.text,
            true, nucleus);
    } else if (symbols[this.mode][nucleus.text]) {
        this.consume();
        // Otherwise if this is a no-argument function, find the type it
        // corresponds to in the symbols map
        return new ParseFuncOrArgument(
            new ParseNode(symbols[this.mode][nucleus.text].group,
                          nucleus.text, this.mode, nucleus),
            false, nucleus);
    } else if (this.mode === "text" && cjkRegex.test(nucleus.text)) {
        this.consume();
        return new ParseFuncOrArgument(
            new ParseNode("textord", nucleus.text, this.mode, nucleus),
            false, nucleus);
    } else {
        return null;
    }
};

Parser.prototype.ParseNode = ParseNode;

module.exports = Parser;

},{"./MacroExpander":92,"./ParseError":94,"./environments":104,"./functions":107,"./parseData":109,"./symbols":111,"./unicodeRegexes":112,"./utils":113}],96:[function(require,module,exports){
/**
 * This is a module for storing settings passed into KaTeX. It correctly handles
 * default settings.
 */

/**
 * Helper function for getting a default value if the value is undefined
 */
function get(option, defaultValue) {
    return option === undefined ? defaultValue : option;
}

/**
 * The main Settings object
 *
 * The current options stored are:
 *  - displayMode: Whether the expression should be typeset by default in
 *                 textstyle or displaystyle (default false)
 */
function Settings(options) {
    // allow null options
    options = options || {};
    this.displayMode = get(options.displayMode, false);
    this.throwOnError = get(options.throwOnError, true);
    this.errorColor = get(options.errorColor, "#cc0000");
    this.macros = options.macros || {};
}

module.exports = Settings;

},{}],97:[function(require,module,exports){
/**
 * This file contains information and classes for the various kinds of styles
 * used in TeX. It provides a generic `Style` class, which holds information
 * about a specific style. It then provides instances of all the different kinds
 * of styles possible, and provides functions to move between them and get
 * information about them.
 */

var sigmas = require("./fontMetrics.js").sigmas;

var metrics = [{}, {}, {}];
var i;
for (var key in sigmas) {
    if (sigmas.hasOwnProperty(key)) {
        for (i = 0; i < 3; i++) {
            metrics[i][key] = sigmas[key][i];
        }
    }
}
for (i = 0; i < 3; i++) {
    metrics[i].emPerEx = sigmas.xHeight[i] / sigmas.quad[i];
}

/**
 * The main style class. Contains a unique id for the style, a size (which is
 * the same for cramped and uncramped version of a style), a cramped flag, and a
 * size multiplier, which gives the size difference between a style and
 * textstyle.
 */
function Style(id, size, multiplier, cramped) {
    this.id = id;
    this.size = size;
    this.cramped = cramped;
    this.sizeMultiplier = multiplier;
    this.metrics = metrics[size > 0 ? size - 1 : 0];
}

/**
 * Get the style of a superscript given a base in the current style.
 */
Style.prototype.sup = function() {
    return styles[sup[this.id]];
};

/**
 * Get the style of a subscript given a base in the current style.
 */
Style.prototype.sub = function() {
    return styles[sub[this.id]];
};

/**
 * Get the style of a fraction numerator given the fraction in the current
 * style.
 */
Style.prototype.fracNum = function() {
    return styles[fracNum[this.id]];
};

/**
 * Get the style of a fraction denominator given the fraction in the current
 * style.
 */
Style.prototype.fracDen = function() {
    return styles[fracDen[this.id]];
};

/**
 * Get the cramped version of a style (in particular, cramping a cramped style
 * doesn't change the style).
 */
Style.prototype.cramp = function() {
    return styles[cramp[this.id]];
};

/**
 * HTML class name, like "displaystyle cramped"
 */
Style.prototype.cls = function() {
    return sizeNames[this.size] + (this.cramped ? " cramped" : " uncramped");
};

/**
 * HTML Reset class name, like "reset-textstyle"
 */
Style.prototype.reset = function() {
    return resetNames[this.size];
};

/**
 * Return if this style is tightly spaced (scriptstyle/scriptscriptstyle)
 */
Style.prototype.isTight = function() {
    return this.size >= 2;
};

// IDs of the different styles
var D = 0;
var Dc = 1;
var T = 2;
var Tc = 3;
var S = 4;
var Sc = 5;
var SS = 6;
var SSc = 7;

// String names for the different sizes
var sizeNames = [
    "displaystyle textstyle",
    "textstyle",
    "scriptstyle",
    "scriptscriptstyle"
];

// Reset names for the different sizes
var resetNames = [
    "reset-textstyle",
    "reset-textstyle",
    "reset-scriptstyle",
    "reset-scriptscriptstyle"
];

// Instances of the different styles
var styles = [
    new Style(D, 0, 1.0, false),
    new Style(Dc, 0, 1.0, true),
    new Style(T, 1, 1.0, false),
    new Style(Tc, 1, 1.0, true),
    new Style(S, 2, 0.7, false),
    new Style(Sc, 2, 0.7, true),
    new Style(SS, 3, 0.5, false),
    new Style(SSc, 3, 0.5, true)
];

// Lookup tables for switching from one style to another
var sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
var sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
var fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];
var fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
var cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];

// We only export some of the styles. Also, we don't export the `Style` class so
// no more styles can be generated.
module.exports = {
    DISPLAY: styles[D],
    TEXT: styles[T],
    SCRIPT: styles[S],
    SCRIPTSCRIPT: styles[SS]
};

},{"./fontMetrics.js":105}],98:[function(require,module,exports){
/* eslint no-console:0 */
/**
 * This module contains general functions that can be used for building
 * different kinds of domTree nodes in a consistent manner.
 */

var domTree = require("./domTree");
var fontMetrics = require("./fontMetrics");
var symbols = require("./symbols");
var utils = require("./utils");

var greekCapitals = [
    "\\Gamma",
    "\\Delta",
    "\\Theta",
    "\\Lambda",
    "\\Xi",
    "\\Pi",
    "\\Sigma",
    "\\Upsilon",
    "\\Phi",
    "\\Psi",
    "\\Omega"
];

// The following have to be loaded from Main-Italic font, using class mainit
var mainitLetters = [
    "\u0131",   // dotless i, \imath
    "\u0237",   // dotless j, \jmath
    "\u00a3"   // \pounds
];

/**
 * Makes a symbolNode after translation via the list of symbols in symbols.js.
 * Correctly pulls out metrics for the character, and optionally takes a list of
 * classes to be attached to the node.
 *
 * TODO: make argument order closer to makeSpan
 * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which
 * should if present come first in `classes`.
 */
var makeSymbol = function(value, fontFamily, mode, options, classes) {
    // Replace the value with its replaced value from symbol.js
    if (symbols[mode][value] && symbols[mode][value].replace) {
        value = symbols[mode][value].replace;
    }

    var metrics = fontMetrics.getCharacterMetrics(value, fontFamily);

    var symbolNode;
    if (metrics) {
        var italic = metrics.italic;
        if (mode === "text") {
            italic = 0;
        }
        symbolNode = new domTree.symbolNode(
            value, metrics.height, metrics.depth, italic, metrics.skew,
            classes);
    } else {
        // TODO(emily): Figure out a good way to only print this in development
        typeof console !== "undefined" && console.warn(
            "No character metrics for '" + value + "' in style '" +
                fontFamily + "'");
        symbolNode = new domTree.symbolNode(value, 0, 0, 0, 0, classes);
    }

    if (options) {
        if (options.style.isTight()) {
            symbolNode.classes.push("mtight");
        }
        if (options.getColor()) {
            symbolNode.style.color = options.getColor();
        }
    }

    return symbolNode;
};

/**
 * Makes a symbol in Main-Regular or AMS-Regular.
 * Used for rel, bin, open, close, inner, and punct.
 */
var mathsym = function(value, mode, options, classes) {
    // Decide what font to render the symbol in by its entry in the symbols
    // table.
    // Have a special case for when the value = \ because the \ is used as a
    // textord in unsupported command errors but cannot be parsed as a regular
    // text ordinal and is therefore not present as a symbol in the symbols
    // table for text
    if (value === "\\" || symbols[mode][value].font === "main") {
        return makeSymbol(value, "Main-Regular", mode, options, classes);
    } else {
        return makeSymbol(
            value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
    }
};

/**
 * Makes a symbol in the default font for mathords and textords.
 */
var mathDefault = function(value, mode, options, classes, type) {
    if (type === "mathord") {
        return mathit(value, mode, options, classes);
    } else if (type === "textord") {
        return makeSymbol(
            value, "Main-Regular", mode, options, classes.concat(["mathrm"]));
    } else {
        throw new Error("unexpected type: " + type + " in mathDefault");
    }
};

/**
 * Makes a symbol in the italic math font.
 */
var mathit = function(value, mode, options, classes) {
    if (/[0-9]/.test(value.charAt(0)) ||
            // glyphs for \imath and \jmath do not exist in Math-Italic so we
            // need to use Main-Italic instead
            utils.contains(mainitLetters, value) ||
            utils.contains(greekCapitals, value)) {
        return makeSymbol(
            value, "Main-Italic", mode, options, classes.concat(["mainit"]));
    } else {
        return makeSymbol(
            value, "Math-Italic", mode, options, classes.concat(["mathit"]));
    }
};

/**
 * Makes either a mathord or textord in the correct font and color.
 */
var makeOrd = function(group, options, type) {
    var mode = group.mode;
    var value = group.value;
    if (symbols[mode][value] && symbols[mode][value].replace) {
        value = symbols[mode][value].replace;
    }

    var classes = ["mord"];

    var font = options.font;
    if (font) {
        if (font === "mathit" || utils.contains(mainitLetters, value)) {
            return mathit(value, mode, options, classes);
        } else {
            var fontName = fontMap[font].fontName;
            if (fontMetrics.getCharacterMetrics(value, fontName)) {
                return makeSymbol(
                    value, fontName, mode, options, classes.concat([font]));
            } else {
                return mathDefault(value, mode, options, classes, type);
            }
        }
    } else {
        return mathDefault(value, mode, options, classes, type);
    }
};

/**
 * Calculate the height, depth, and maxFontSize of an element based on its
 * children.
 */
var sizeElementFromChildren = function(elem) {
    var height = 0;
    var depth = 0;
    var maxFontSize = 0;

    if (elem.children) {
        for (var i = 0; i < elem.children.length; i++) {
            if (elem.children[i].height > height) {
                height = elem.children[i].height;
            }
            if (elem.children[i].depth > depth) {
                depth = elem.children[i].depth;
            }
            if (elem.children[i].maxFontSize > maxFontSize) {
                maxFontSize = elem.children[i].maxFontSize;
            }
        }
    }

    elem.height = height;
    elem.depth = depth;
    elem.maxFontSize = maxFontSize;
};

/**
 * Makes a span with the given list of classes, list of children, and options.
 *
 * TODO: Ensure that `options` is always provided (currently some call sites
 * don't pass it).
 * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which
 * should if present come first in `classes`.
 */
var makeSpan = function(classes, children, options) {
    var span = new domTree.span(classes, children, options);

    sizeElementFromChildren(span);

    return span;
};

/**
 * Prepends the given children to the given span, updating height, depth, and
 * maxFontSize.
 */
var prependChildren = function(span, children) {
    span.children = children.concat(span.children);

    sizeElementFromChildren(span);
};

/**
 * Makes a document fragment with the given list of children.
 */
var makeFragment = function(children) {
    var fragment = new domTree.documentFragment(children);

    sizeElementFromChildren(fragment);

    return fragment;
};

/**
 * Makes an element placed in each of the vlist elements to ensure that each
 * element has the same max font size. To do this, we create a zero-width space
 * with the correct font size.
 */
var makeFontSizer = function(options, fontSize) {
    var fontSizeInner = makeSpan([], [new domTree.symbolNode("\u200b")]);
    fontSizeInner.style.fontSize =
        (fontSize / options.style.sizeMultiplier) + "em";

    var fontSizer = makeSpan(
        ["fontsize-ensurer", "reset-" + options.size, "size5"],
        [fontSizeInner]);

    return fontSizer;
};

/**
 * Makes a vertical list by stacking elements and kerns on top of each other.
 * Allows for many different ways of specifying the positioning method.
 *
 * Arguments:
 *  - children: A list of child or kern nodes to be stacked on top of each other
 *              (i.e. the first element will be at the bottom, and the last at
 *              the top). Element nodes are specified as
 *                {type: "elem", elem: node}
 *              while kern nodes are specified as
 *                {type: "kern", size: size}
 *  - positionType: The method by which the vlist should be positioned. Valid
 *                  values are:
 *                   - "individualShift": The children list only contains elem
 *                                        nodes, and each node contains an extra
 *                                        "shift" value of how much it should be
 *                                        shifted (note that shifting is always
 *                                        moving downwards). positionData is
 *                                        ignored.
 *                   - "top": The positionData specifies the topmost point of
 *                            the vlist (note this is expected to be a height,
 *                            so positive values move up)
 *                   - "bottom": The positionData specifies the bottommost point
 *                               of the vlist (note this is expected to be a
 *                               depth, so positive values move down
 *                   - "shift": The vlist will be positioned such that its
 *                              baseline is positionData away from the baseline
 *                              of the first child. Positive values move
 *                              downwards.
 *                   - "firstBaseline": The vlist will be positioned such that
 *                                      its baseline is aligned with the
 *                                      baseline of the first child.
 *                                      positionData is ignored. (this is
 *                                      equivalent to "shift" with
 *                                      positionData=0)
 *  - positionData: Data used in different ways depending on positionType
 *  - options: An Options object
 *
 */
var makeVList = function(children, positionType, positionData, options) {
    var depth;
    var currPos;
    var i;
    if (positionType === "individualShift") {
        var oldChildren = children;
        children = [oldChildren[0]];

        // Add in kerns to the list of children to get each element to be
        // shifted to the correct specified shift
        depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
        currPos = depth;
        for (i = 1; i < oldChildren.length; i++) {
            var diff = -oldChildren[i].shift - currPos -
                oldChildren[i].elem.depth;
            var size = diff -
                (oldChildren[i - 1].elem.height +
                 oldChildren[i - 1].elem.depth);

            currPos = currPos + diff;

            children.push({type: "kern", size: size});
            children.push(oldChildren[i]);
        }
    } else if (positionType === "top") {
        // We always start at the bottom, so calculate the bottom by adding up
        // all the sizes
        var bottom = positionData;
        for (i = 0; i < children.length; i++) {
            if (children[i].type === "kern") {
                bottom -= children[i].size;
            } else {
                bottom -= children[i].elem.height + children[i].elem.depth;
            }
        }
        depth = bottom;
    } else if (positionType === "bottom") {
        depth = -positionData;
    } else if (positionType === "shift") {
        depth = -children[0].elem.depth - positionData;
    } else if (positionType === "firstBaseline") {
        depth = -children[0].elem.depth;
    } else {
        depth = 0;
    }

    // Make the fontSizer
    var maxFontSize = 0;
    for (i = 0; i < children.length; i++) {
        if (children[i].type === "elem") {
            maxFontSize = Math.max(maxFontSize, children[i].elem.maxFontSize);
        }
    }
    var fontSizer = makeFontSizer(options, maxFontSize);

    // Create a new list of actual children at the correct offsets
    var realChildren = [];
    currPos = depth;
    for (i = 0; i < children.length; i++) {
        if (children[i].type === "kern") {
            currPos += children[i].size;
        } else {
            var child = children[i].elem;

            var shift = -child.depth - currPos;
            currPos += child.height + child.depth;

            var childWrap = makeSpan([], [fontSizer, child]);
            childWrap.height -= shift;
            childWrap.depth += shift;
            childWrap.style.top = shift + "em";

            realChildren.push(childWrap);
        }
    }

    // Add in an element at the end with no offset to fix the calculation of
    // baselines in some browsers (namely IE, sometimes safari)
    var baselineFix = makeSpan(
        ["baseline-fix"], [fontSizer, new domTree.symbolNode("\u200b")]);
    realChildren.push(baselineFix);

    var vlist = makeSpan(["vlist"], realChildren);
    // Fix the final height and depth, in case there were kerns at the ends
    // since the makeSpan calculation won't take that in to account.
    vlist.height = Math.max(currPos, vlist.height);
    vlist.depth = Math.max(-depth, vlist.depth);
    return vlist;
};

// A table of size -> font size for the different sizing functions
var sizingMultiplier = {
    size1: 0.5,
    size2: 0.7,
    size3: 0.8,
    size4: 0.9,
    size5: 1.0,
    size6: 1.2,
    size7: 1.44,
    size8: 1.73,
    size9: 2.07,
    size10: 2.49
};

// A map of spacing functions to their attributes, like size and corresponding
// CSS class
var spacingFunctions = {
    "\\qquad": {
        size: "2em",
        className: "qquad"
    },
    "\\quad": {
        size: "1em",
        className: "quad"
    },
    "\\enspace": {
        size: "0.5em",
        className: "enspace"
    },
    "\\;": {
        size: "0.277778em",
        className: "thickspace"
    },
    "\\:": {
        size: "0.22222em",
        className: "mediumspace"
    },
    "\\,": {
        size: "0.16667em",
        className: "thinspace"
    },
    "\\!": {
        size: "-0.16667em",
        className: "negativethinspace"
    }
};

/**
 * Maps TeX font commands to objects containing:
 * - variant: string used for "mathvariant" attribute in buildMathML.js
 * - fontName: the "style" parameter to fontMetrics.getCharacterMetrics
 */
// A map between tex font commands an MathML mathvariant attribute values
var fontMap = {
    // styles
    "mathbf": {
        variant: "bold",
        fontName: "Main-Bold"
    },
    "mathrm": {
        variant: "normal",
        fontName: "Main-Regular"
    },
    "textit": {
        variant: "italic",
        fontName: "Main-Italic"
    },

    // "mathit" is missing because it requires the use of two fonts: Main-Italic
    // and Math-Italic.  This is handled by a special case in makeOrd which ends
    // up calling mathit.

    // families
    "mathbb": {
        variant: "double-struck",
        fontName: "AMS-Regular"
    },
    "mathcal": {
        variant: "script",
        fontName: "Caligraphic-Regular"
    },
    "mathfrak": {
        variant: "fraktur",
        fontName: "Fraktur-Regular"
    },
    "mathscr": {
        variant: "script",
        fontName: "Script-Regular"
    },
    "mathsf": {
        variant: "sans-serif",
        fontName: "SansSerif-Regular"
    },
    "mathtt": {
        variant: "monospace",
        fontName: "Typewriter-Regular"
    }
};

module.exports = {
    fontMap: fontMap,
    makeSymbol: makeSymbol,
    mathsym: mathsym,
    makeSpan: makeSpan,
    makeFragment: makeFragment,
    makeVList: makeVList,
    makeOrd: makeOrd,
    prependChildren: prependChildren,
    sizingMultiplier: sizingMultiplier,
    spacingFunctions: spacingFunctions
};

},{"./domTree":103,"./fontMetrics":105,"./symbols":111,"./utils":113}],99:[function(require,module,exports){
/* eslint no-console:0 */
/**
 * This file does the main work of building a domTree structure from a parse
 * tree. The entry point is the `buildHTML` function, which takes a parse tree.
 * Then, the buildExpression, buildGroup, and various groupTypes functions are
 * called, to produce a final HTML tree.
 */

var ParseError = require("./ParseError");
var Style = require("./Style");

var buildCommon = require("./buildCommon");
var delimiter = require("./delimiter");
var domTree = require("./domTree");
var fontMetrics = require("./fontMetrics");
var utils = require("./utils");

var makeSpan = buildCommon.makeSpan;

var isSpace = function(node) {
    return node instanceof domTree.span && node.classes[0] === "mspace";
};

// Binary atoms (first class `mbin`) change into ordinary atoms (`mord`)
// depending on their surroundings. See TeXbook pg. 442-446, Rules 5 and 6,
// and the text before Rule 19.

var isBin = function(node) {
    return node && node.classes[0] === "mbin";
};

var isBinLeftCanceller = function(node, isRealGroup) {
    // TODO: This code assumes that a node's math class is the first element
    // of its `classes` array. A later cleanup should ensure this, for
    // instance by changing the signature of `makeSpan`.
    if (node) {
        return utils.contains(["mbin", "mopen", "mrel", "mop", "mpunct"],
                              node.classes[0]);
    } else {
        return isRealGroup;
    }
};

var isBinRightCanceller = function(node, isRealGroup) {
    if (node) {
        return utils.contains(["mrel", "mclose", "mpunct"], node.classes[0]);
    } else {
        return isRealGroup;
    }
};

/**
 * Take a list of nodes, build them in order, and return a list of the built
 * nodes. documentFragments are flattened into their contents, so the
 * returned list contains no fragments. `isRealGroup` is true if `expression`
 * is a real group (no atoms will be added on either side), as opposed to
 * a partial group (e.g. one created by \color).
 */
var buildExpression = function(expression, options, isRealGroup) {
    // Parse expressions into `groups`.
    var groups = [];
    for (var i = 0; i < expression.length; i++) {
        var group = expression[i];
        var output = buildGroup(group, options);
        if (output instanceof domTree.documentFragment) {
            Array.prototype.push.apply(groups, output.children);
        } else {
            groups.push(output);
        }
    }
    // At this point `groups` consists entirely of `symbolNode`s and `span`s.

    // Explicit spaces (e.g., \;, \,) should be ignored with respect to atom
    // spacing (e.g., "add thick space between mord and mrel"). Since CSS
    // adjacency rules implement atom spacing, spaces should be invisible to
    // CSS. So we splice them out of `groups` and into the atoms themselves.
    var spaces = null;
    for (i = 0; i < groups.length; i++) {
        if (isSpace(groups[i])) {
            spaces = spaces || [];
            spaces.push(groups[i]);
            groups.splice(i, 1);
            i--;
        } else if (spaces) {
            if (groups[i] instanceof domTree.symbolNode) {
                groups[i] = makeSpan([].concat(groups[i].classes), [groups[i]]);
            }
            buildCommon.prependChildren(groups[i], spaces);
            spaces = null;
        }
    }
    if (spaces) {
        Array.prototype.push.apply(groups, spaces);
    }

    // Binary operators change to ordinary symbols in some contexts.
    for (i = 0; i < groups.length; i++) {
        if (isBin(groups[i])
            && (isBinLeftCanceller(groups[i - 1], isRealGroup)
                || isBinRightCanceller(groups[i + 1], isRealGroup))) {
            groups[i].classes[0] = "mord";
        }
    }

    return groups;
};

// Return math atom class (mclass) of a domTree.
var getTypeOfDomTree = function(node) {
    if (node instanceof domTree.documentFragment) {
        if (node.children.length) {
            return getTypeOfDomTree(
                node.children[node.children.length - 1]);
        }
    } else {
        if (utils.contains(["mord", "mop", "mbin", "mrel", "mopen", "mclose",
            "mpunct", "minner"], node.classes[0])) {
            return node.classes[0];
        }
    }
    return null;
};

/**
 * Sometimes, groups perform special rules when they have superscripts or
 * subscripts attached to them. This function lets the `supsub` group know that
 * its inner element should handle the superscripts and subscripts instead of
 * handling them itself.
 */
var shouldHandleSupSub = function(group, options) {
    if (!group) {
        return false;
    } else if (group.type === "op") {
        // Operators handle supsubs differently when they have limits
        // (e.g. `\displaystyle\sum_2^3`)
        return group.value.limits &&
            (options.style.size === Style.DISPLAY.size ||
            group.value.alwaysHandleSupSub);
    } else if (group.type === "accent") {
        return isCharacterBox(group.value.base);
    } else {
        return null;
    }
};

/**
 * Sometimes we want to pull out the innermost element of a group. In most
 * cases, this will just be the group itself, but when ordgroups and colors have
 * a single element, we want to pull that out.
 */
var getBaseElem = function(group) {
    if (!group) {
        return false;
    } else if (group.type === "ordgroup") {
        if (group.value.length === 1) {
            return getBaseElem(group.value[0]);
        } else {
            return group;
        }
    } else if (group.type === "color") {
        if (group.value.value.length === 1) {
            return getBaseElem(group.value.value[0]);
        } else {
            return group;
        }
    } else if (group.type === "font") {
        return getBaseElem(group.value.body);
    } else {
        return group;
    }
};

/**
 * TeXbook algorithms often reference "character boxes", which are simply groups
 * with a single character in them. To decide if something is a character box,
 * we find its innermost group, and see if it is a single character.
 */
var isCharacterBox = function(group) {
    var baseElem = getBaseElem(group);

    // These are all they types of groups which hold single characters
    return baseElem.type === "mathord" ||
        baseElem.type === "textord" ||
        baseElem.type === "bin" ||
        baseElem.type === "rel" ||
        baseElem.type === "inner" ||
        baseElem.type === "open" ||
        baseElem.type === "close" ||
        baseElem.type === "punct";
};

var makeNullDelimiter = function(options, classes) {
    return makeSpan(classes.concat([
        "sizing", "reset-" + options.size, "size5",
        options.style.reset(), Style.TEXT.cls(),
        "nulldelimiter"]));
};

/**
 * This is a map of group types to the function used to handle that type.
 * Simpler types come at the beginning, while complicated types come afterwards.
 */
var groupTypes = {};

groupTypes.mathord = function(group, options) {
    return buildCommon.makeOrd(group, options, "mathord");
};

groupTypes.textord = function(group, options) {
    return buildCommon.makeOrd(group, options, "textord");
};

groupTypes.bin = function(group, options) {
    return buildCommon.mathsym(
        group.value, group.mode, options, ["mbin"]);
};

groupTypes.rel = function(group, options) {
    return buildCommon.mathsym(
        group.value, group.mode, options, ["mrel"]);
};

groupTypes.open = function(group, options) {
    return buildCommon.mathsym(
        group.value, group.mode, options, ["mopen"]);
};

groupTypes.close = function(group, options) {
    return buildCommon.mathsym(
        group.value, group.mode, options, ["mclose"]);
};

groupTypes.inner = function(group, options) {
    return buildCommon.mathsym(
        group.value, group.mode, options, ["minner"]);
};

groupTypes.punct = function(group, options) {
    return buildCommon.mathsym(
        group.value, group.mode, options, ["mpunct"]);
};

groupTypes.ordgroup = function(group, options) {
    return makeSpan(
        ["mord", options.style.cls()],
        buildExpression(group.value, options.reset(), true),
        options
    );
};

groupTypes.text = function(group, options) {
    var newOptions = options.withFont(group.value.style);
    var inner = buildExpression(group.value.body, newOptions, true);
    for (var i = 0; i < inner.length - 1; i++) {
        if (inner[i].tryCombine(inner[i + 1])) {
            inner.splice(i + 1, 1);
            i--;
        }
    }
    return makeSpan(["mord", "text", newOptions.style.cls()],
        inner, newOptions);
};

groupTypes.color = function(group, options) {
    var elements = buildExpression(
        group.value.value,
        options.withColor(group.value.color),
        false
    );

    // \color isn't supposed to affect the type of the elements it contains.
    // To accomplish this, we wrap the results in a fragment, so the inner
    // elements will be able to directly interact with their neighbors. For
    // example, `\color{red}{2 +} 3` has the same spacing as `2 + 3`
    return new buildCommon.makeFragment(elements);
};

groupTypes.supsub = function(group, options) {
    // Superscript and subscripts are handled in the TeXbook on page
    // 445-446, rules 18(a-f).

    // Here is where we defer to the inner group if it should handle
    // superscripts and subscripts itself.
    if (shouldHandleSupSub(group.value.base, options)) {
        return groupTypes[group.value.base.type](group, options);
    }

    var base = buildGroup(group.value.base, options.reset());
    var supmid;
    var submid;
    var sup;
    var sub;

    var style = options.style;
    var newOptions;

    if (group.value.sup) {
        newOptions = options.withStyle(style.sup());
        sup = buildGroup(group.value.sup, newOptions);
        supmid = makeSpan([style.reset(), style.sup().cls()],
            [sup], newOptions);
    }

    if (group.value.sub) {
        newOptions = options.withStyle(style.sub());
        sub = buildGroup(group.value.sub, newOptions);
        submid = makeSpan([style.reset(), style.sub().cls()],
            [sub], newOptions);
    }

    // Rule 18a
    var supShift;
    var subShift;
    if (isCharacterBox(group.value.base)) {
        supShift = 0;
        subShift = 0;
    } else {
        supShift = base.height - style.metrics.supDrop;
        subShift = base.depth + style.metrics.subDrop;
    }

    // Rule 18c
    var minSupShift;
    if (style === Style.DISPLAY) {
        minSupShift = style.metrics.sup1;
    } else if (style.cramped) {
        minSupShift = style.metrics.sup3;
    } else {
        minSupShift = style.metrics.sup2;
    }

    // scriptspace is a font-size-independent size, so scale it
    // appropriately
    var multiplier = Style.TEXT.sizeMultiplier *
            style.sizeMultiplier;
    var scriptspace =
        (0.5 / fontMetrics.metrics.ptPerEm) / multiplier + "em";

    var supsub;
    if (!group.value.sup) {
        // Rule 18b
        subShift = Math.max(
            subShift, style.metrics.sub1,
            sub.height - 0.8 * style.metrics.xHeight);

        supsub = buildCommon.makeVList([
            {type: "elem", elem: submid}
        ], "shift", subShift, options);

        supsub.children[0].style.marginRight = scriptspace;

        // Subscripts shouldn't be shifted by the base's italic correction.
        // Account for that by shifting the subscript back the appropriate
        // amount. Note we only do this when the base is a single symbol.
        if (base instanceof domTree.symbolNode) {
            supsub.children[0].style.marginLeft = -base.italic + "em";
        }
    } else if (!group.value.sub) {
        // Rule 18c, d
        supShift = Math.max(supShift, minSupShift,
            sup.depth + 0.25 * style.metrics.xHeight);

        supsub = buildCommon.makeVList([
            {type: "elem", elem: supmid}
        ], "shift", -supShift, options);

        supsub.children[0].style.marginRight = scriptspace;
    } else {
        supShift = Math.max(
            supShift, minSupShift, sup.depth + 0.25 * style.metrics.xHeight);
        subShift = Math.max(subShift, style.metrics.sub2);

        var ruleWidth = fontMetrics.metrics.defaultRuleThickness;

        // Rule 18e
        if ((supShift - sup.depth) - (sub.height - subShift) <
                4 * ruleWidth) {
            subShift = 4 * ruleWidth - (supShift - sup.depth) + sub.height;
            var psi = 0.8 * style.metrics.xHeight - (supShift - sup.depth);
            if (psi > 0) {
                supShift += psi;
                subShift -= psi;
            }
        }

        supsub = buildCommon.makeVList([
            {type: "elem", elem: submid, shift: subShift},
            {type: "elem", elem: supmid, shift: -supShift}
        ], "individualShift", null, options);

        // See comment above about subscripts not being shifted
        if (base instanceof domTree.symbolNode) {
            supsub.children[0].style.marginLeft = -base.italic + "em";
        }

        supsub.children[0].style.marginRight = scriptspace;
        supsub.children[1].style.marginRight = scriptspace;
    }

    // We ensure to wrap the supsub vlist in a span.msupsub to reset text-align
    var mclass = getTypeOfDomTree(base) || "mord";
    return makeSpan([mclass],
        [base, makeSpan(["msupsub"], [supsub])],
        options);
};

groupTypes.genfrac = function(group, options) {
    // Fractions are handled in the TeXbook on pages 444-445, rules 15(a-e).
    // Figure out what style this fraction should be in based on the
    // function used
    var style = options.style;
    if (group.value.size === "display") {
        style = Style.DISPLAY;
    } else if (group.value.size === "text") {
        style = Style.TEXT;
    }

    var nstyle = style.fracNum();
    var dstyle = style.fracDen();
    var newOptions;

    newOptions = options.withStyle(nstyle);
    var numer = buildGroup(group.value.numer, newOptions);
    var numerreset = makeSpan([style.reset(), nstyle.cls()],
        [numer], newOptions);

    newOptions = options.withStyle(dstyle);
    var denom = buildGroup(group.value.denom, newOptions);
    var denomreset = makeSpan([style.reset(), dstyle.cls()],
        [denom], newOptions);

    var ruleWidth;
    if (group.value.hasBarLine) {
        ruleWidth = fontMetrics.metrics.defaultRuleThickness /
            options.style.sizeMultiplier;
    } else {
        ruleWidth = 0;
    }

    // Rule 15b
    var numShift;
    var clearance;
    var denomShift;
    if (style.size === Style.DISPLAY.size) {
        numShift = style.metrics.num1;
        if (ruleWidth > 0) {
            clearance = 3 * ruleWidth;
        } else {
            clearance = 7 * fontMetrics.metrics.defaultRuleThickness;
        }
        denomShift = style.metrics.denom1;
    } else {
        if (ruleWidth > 0) {
            numShift = style.metrics.num2;
            clearance = ruleWidth;
        } else {
            numShift = style.metrics.num3;
            clearance = 3 * fontMetrics.metrics.defaultRuleThickness;
        }
        denomShift = style.metrics.denom2;
    }

    var frac;
    if (ruleWidth === 0) {
        // Rule 15c
        var candidateClearance =
            (numShift - numer.depth) - (denom.height - denomShift);
        if (candidateClearance < clearance) {
            numShift += 0.5 * (clearance - candidateClearance);
            denomShift += 0.5 * (clearance - candidateClearance);
        }

        frac = buildCommon.makeVList([
            {type: "elem", elem: denomreset, shift: denomShift},
            {type: "elem", elem: numerreset, shift: -numShift}
        ], "individualShift", null, options);
    } else {
        // Rule 15d
        var axisHeight = style.metrics.axisHeight;

        if ((numShift - numer.depth) - (axisHeight + 0.5 * ruleWidth) <
                clearance) {
            numShift +=
                clearance - ((numShift - numer.depth) -
                             (axisHeight + 0.5 * ruleWidth));
        }

        if ((axisHeight - 0.5 * ruleWidth) - (denom.height - denomShift) <
                clearance) {
            denomShift +=
                clearance - ((axisHeight - 0.5 * ruleWidth) -
                             (denom.height - denomShift));
        }

        var mid = makeSpan(
            [options.style.reset(), Style.TEXT.cls(), "frac-line"]);
        // Manually set the height of the line because its height is
        // created in CSS
        mid.height = ruleWidth;

        var midShift = -(axisHeight - 0.5 * ruleWidth);

        frac = buildCommon.makeVList([
            {type: "elem", elem: denomreset, shift: denomShift},
            {type: "elem", elem: mid,        shift: midShift},
            {type: "elem", elem: numerreset, shift: -numShift}
        ], "individualShift", null, options);
    }

    // Since we manually change the style sometimes (with \dfrac or \tfrac),
    // account for the possible size change here.
    frac.height *= style.sizeMultiplier / options.style.sizeMultiplier;
    frac.depth *= style.sizeMultiplier / options.style.sizeMultiplier;

    // Rule 15e
    var delimSize;
    if (style.size === Style.DISPLAY.size) {
        delimSize = style.metrics.delim1;
    } else {
        delimSize = style.metrics.delim2;
    }

    var leftDelim;
    var rightDelim;
    if (group.value.leftDelim == null) {
        leftDelim = makeNullDelimiter(options, ["mopen"]);
    } else {
        leftDelim = delimiter.customSizedDelim(
            group.value.leftDelim, delimSize, true,
            options.withStyle(style), group.mode, ["mopen"]);
    }
    if (group.value.rightDelim == null) {
        rightDelim = makeNullDelimiter(options, ["mclose"]);
    } else {
        rightDelim = delimiter.customSizedDelim(
            group.value.rightDelim, delimSize, true,
            options.withStyle(style), group.mode, ["mclose"]);
    }

    return makeSpan(
        ["mord", options.style.reset(), style.cls()],
        [leftDelim, makeSpan(["mfrac"], [frac]), rightDelim],
        options);
};

var calculateSize = function(sizeValue, style) {
    var x = sizeValue.number;
    if (sizeValue.unit === "ex") {
        x *= style.metrics.emPerEx;
    } else if (sizeValue.unit === "mu") {
        x /= 18;
    }
    return x;
};

groupTypes.array = function(group, options) {
    var r;
    var c;
    var nr = group.value.body.length;
    var nc = 0;
    var body = new Array(nr);

    var style = options.style;

    // Horizontal spacing
    var pt = 1 / fontMetrics.metrics.ptPerEm;
    var arraycolsep = 5 * pt; // \arraycolsep in article.cls

    // Vertical spacing
    var baselineskip = 12 * pt; // see size10.clo
    // Default \arraystretch from lttab.dtx
    // TODO(gagern): may get redefined once we have user-defined macros
    var arraystretch = utils.deflt(group.value.arraystretch, 1);
    var arrayskip = arraystretch * baselineskip;
    var arstrutHeight = 0.7 * arrayskip; // \strutbox in ltfsstrc.dtx and
    var arstrutDepth = 0.3 * arrayskip;  // \@arstrutbox in lttab.dtx

    var totalHeight = 0;
    for (r = 0; r < group.value.body.length; ++r) {
        var inrow = group.value.body[r];
        var height = arstrutHeight; // \@array adds an \@arstrut
        var depth = arstrutDepth;   // to each tow (via the template)

        if (nc < inrow.length) {
            nc = inrow.length;
        }

        var outrow = new Array(inrow.length);
        for (c = 0; c < inrow.length; ++c) {
            var elt = buildGroup(inrow[c], options);
            if (depth < elt.depth) {
                depth = elt.depth;
            }
            if (height < elt.height) {
                height = elt.height;
            }
            outrow[c] = elt;
        }

        var gap = 0;
        if (group.value.rowGaps[r]) {
            gap = calculateSize(group.value.rowGaps[r].value, style);
            if (gap > 0) { // \@argarraycr
                gap += arstrutDepth;
                if (depth < gap) {
                    depth = gap; // \@xargarraycr
                }
                gap = 0;
            }
        }

        outrow.height = height;
        outrow.depth = depth;
        totalHeight += height;
        outrow.pos = totalHeight;
        totalHeight += depth + gap; // \@yargarraycr
        body[r] = outrow;
    }

    var offset = totalHeight / 2 + style.metrics.axisHeight;
    var colDescriptions = group.value.cols || [];
    var cols = [];
    var colSep;
    var colDescrNum;
    for (c = 0, colDescrNum = 0;
         // Continue while either there are more columns or more column
         // descriptions, so trailing separators don't get lost.
         c < nc || colDescrNum < colDescriptions.length;
         ++c, ++colDescrNum) {

        var colDescr = colDescriptions[colDescrNum] || {};

        var firstSeparator = true;
        while (colDescr.type === "separator") {
            // If there is more than one separator in a row, add a space
            // between them.
            if (!firstSeparator) {
                colSep = makeSpan(["arraycolsep"], []);
                colSep.style.width =
                    fontMetrics.metrics.doubleRuleSep + "em";
                cols.push(colSep);
            }

            if (colDescr.separator === "|") {
                var separator = makeSpan(
                    ["vertical-separator"],
                    []);
                separator.style.height = totalHeight + "em";
                separator.style.verticalAlign =
                    -(totalHeight - offset) + "em";

                cols.push(separator);
            } else {
                throw new ParseError(
                    "Invalid separator type: " + colDescr.separator);
            }

            colDescrNum++;
            colDescr = colDescriptions[colDescrNum] || {};
            firstSeparator = false;
        }

        if (c >= nc) {
            continue;
        }

        var sepwidth;
        if (c > 0 || group.value.hskipBeforeAndAfter) {
            sepwidth = utils.deflt(colDescr.pregap, arraycolsep);
            if (sepwidth !== 0) {
                colSep = makeSpan(["arraycolsep"], []);
                colSep.style.width = sepwidth + "em";
                cols.push(colSep);
            }
        }

        var col = [];
        for (r = 0; r < nr; ++r) {
            var row = body[r];
            var elem = row[c];
            if (!elem) {
                continue;
            }
            var shift = row.pos - offset;
            elem.depth = row.depth;
            elem.height = row.height;
            col.push({type: "elem", elem: elem, shift: shift});
        }

        col = buildCommon.makeVList(col, "individualShift", null, options);
        col = makeSpan(
            ["col-align-" + (colDescr.align || "c")],
            [col]);
        cols.push(col);

        if (c < nc - 1 || group.value.hskipBeforeAndAfter) {
            sepwidth = utils.deflt(colDescr.postgap, arraycolsep);
            if (sepwidth !== 0) {
                colSep = makeSpan(["arraycolsep"], []);
                colSep.style.width = sepwidth + "em";
                cols.push(colSep);
            }
        }
    }
    body = makeSpan(["mtable"], cols);
    return makeSpan(["mord"], [body], options);
};

groupTypes.spacing = function(group, options) {
    if (group.value === "\\ " || group.value === "\\space" ||
        group.value === " " || group.value === "~") {
        // Spaces are generated by adding an actual space. Each of these
        // things has an entry in the symbols table, so these will be turned
        // into appropriate outputs.
        if (group.mode === "text") {
            return buildCommon.makeOrd(group, options, "textord");
        } else {
            return makeSpan(["mspace"],
                [buildCommon.mathsym(group.value, group.mode, options)],
                options);
        }
    } else {
        // Other kinds of spaces are of arbitrary width. We use CSS to
        // generate these.
        return makeSpan(
            ["mspace",
                buildCommon.spacingFunctions[group.value].className],
            [], options);
    }
};

groupTypes.llap = function(group, options) {
    var inner = makeSpan(
        ["inner"], [buildGroup(group.value.body, options.reset())]);
    var fix = makeSpan(["fix"], []);
    return makeSpan(
        ["mord", "llap", options.style.cls()], [inner, fix], options);
};

groupTypes.rlap = function(group, options) {
    var inner = makeSpan(
        ["inner"], [buildGroup(group.value.body, options.reset())]);
    var fix = makeSpan(["fix"], []);
    return makeSpan(
        ["mord", "rlap", options.style.cls()], [inner, fix], options);
};

groupTypes.op = function(group, options) {
    // Operators are handled in the TeXbook pg. 443-444, rule 13(a).
    var supGroup;
    var subGroup;
    var hasLimits = false;
    if (group.type === "supsub") {
        // If we have limits, supsub will pass us its group to handle. Pull
        // out the superscript and subscript and set the group to the op in
        // its base.
        supGroup = group.value.sup;
        subGroup = group.value.sub;
        group = group.value.base;
        hasLimits = true;
    }

    var style = options.style;

    // Most operators have a large successor symbol, but these don't.
    var noSuccessor = [
        "\\smallint"
    ];

    var large = false;
    if (style.size === Style.DISPLAY.size &&
        group.value.symbol &&
        !utils.contains(noSuccessor, group.value.body)) {

        // Most symbol operators get larger in displaystyle (rule 13)
        large = true;
    }

    var base;
    var baseShift = 0;
    var slant = 0;
    if (group.value.symbol) {
        // If this is a symbol, create the symbol.
        var fontName = large ? "Size2-Regular" : "Size1-Regular";
        base = buildCommon.makeSymbol(
            group.value.body, fontName, "math", options,
            ["mop", "op-symbol", large ? "large-op" : "small-op"]);

        // Shift the symbol so its center lies on the axis (rule 13). It
        // appears that our fonts have the centers of the symbols already
        // almost on the axis, so these numbers are very small. Note we
        // don't actually apply this here, but instead it is used either in
        // the vlist creation or separately when there are no limits.
        baseShift = (base.height - base.depth) / 2 -
            style.metrics.axisHeight * style.sizeMultiplier;

        // The slant of the symbol is just its italic correction.
        slant = base.italic;
    } else if (group.value.value) {
        // If this is a list, compose that list.
        var inner = buildExpression(group.value.value, options, true);

        base = makeSpan(["mop"], inner, options);
    } else {
        // Otherwise, this is a text operator. Build the text from the
        // operator's name.
        // TODO(emily): Add a space in the middle of some of these
        // operators, like \limsup
        var output = [];
        for (var i = 1; i < group.value.body.length; i++) {
            output.push(buildCommon.mathsym(group.value.body[i], group.mode));
        }
        base = makeSpan(["mop"], output, options);
    }

    if (hasLimits) {
        // IE 8 clips \int if it is in a display: inline-block. We wrap it
        // in a new span so it is an inline, and works.
        base = makeSpan([], [base]);

        var supmid;
        var supKern;
        var submid;
        var subKern;
        var newOptions;
        // We manually have to handle the superscripts and subscripts. This,
        // aside from the kern calculations, is copied from supsub.
        if (supGroup) {
            newOptions = options.withStyle(style.sup());
            var sup = buildGroup(supGroup, newOptions);
            supmid = makeSpan([style.reset(), style.sup().cls()],
                [sup], newOptions);

            supKern = Math.max(
                fontMetrics.metrics.bigOpSpacing1,
                fontMetrics.metrics.bigOpSpacing3 - sup.depth);
        }

        if (subGroup) {
            newOptions = options.withStyle(style.sub());
            var sub = buildGroup(subGroup, newOptions);
            submid = makeSpan([style.reset(), style.sub().cls()],
                [sub], newOptions);

            subKern = Math.max(
                fontMetrics.metrics.bigOpSpacing2,
                fontMetrics.metrics.bigOpSpacing4 - sub.height);
        }

        // Build the final group as a vlist of the possible subscript, base,
        // and possible superscript.
        var finalGroup;
        var top;
        var bottom;
        if (!supGroup) {
            top = base.height - baseShift;

            finalGroup = buildCommon.makeVList([
                {type: "kern", size: fontMetrics.metrics.bigOpSpacing5},
                {type: "elem", elem: submid},
                {type: "kern", size: subKern},
                {type: "elem", elem: base}
            ], "top", top, options);

            // Here, we shift the limits by the slant of the symbol. Note
            // that we are supposed to shift the limits by 1/2 of the slant,
            // but since we are centering the limits adding a full slant of
            // margin will shift by 1/2 that.
            finalGroup.children[0].style.marginLeft = -slant + "em";
        } else if (!subGroup) {
            bottom = base.depth + baseShift;

            finalGroup = buildCommon.makeVList([
                {type: "elem", elem: base},
                {type: "kern", size: supKern},
                {type: "elem", elem: supmid},
                {type: "kern", size: fontMetrics.metrics.bigOpSpacing5}
            ], "bottom", bottom, options);

            // See comment above about slants
            finalGroup.children[1].style.marginLeft = slant + "em";
        } else if (!supGroup && !subGroup) {
            // This case probably shouldn't occur (this would mean the
            // supsub was sending us a group with no superscript or
            // subscript) but be safe.
            return base;
        } else {
            bottom = fontMetrics.metrics.bigOpSpacing5 +
                submid.height + submid.depth +
                subKern +
                base.depth + baseShift;

            finalGroup = buildCommon.makeVList([
                {type: "kern", size: fontMetrics.metrics.bigOpSpacing5},
                {type: "elem", elem: submid},
                {type: "kern", size: subKern},
                {type: "elem", elem: base},
                {type: "kern", size: supKern},
                {type: "elem", elem: supmid},
                {type: "kern", size: fontMetrics.metrics.bigOpSpacing5}
            ], "bottom", bottom, options);

            // See comment above about slants
            finalGroup.children[0].style.marginLeft = -slant + "em";
            finalGroup.children[2].style.marginLeft = slant + "em";
        }

        return makeSpan(["mop", "op-limits"], [finalGroup], options);
    } else {
        if (group.value.symbol) {
            base.style.top = baseShift + "em";
        }

        return base;
    }
};

groupTypes.mod = function(group, options) {
    var inner = [];

    if (group.value.modType === "bmod") {
        // “\nonscript\mskip-\medmuskip\mkern5mu”
        if (!options.style.isTight()) {
            inner.push(makeSpan(
                ["mspace", "negativemediumspace"], [], options));
        }
        inner.push(makeSpan(["mspace", "thickspace"], [], options));
    } else if (options.style.size === Style.DISPLAY.size) {
        inner.push(makeSpan(["mspace", "quad"], [], options));
    } else if (group.value.modType === "mod") {
        inner.push(makeSpan(["mspace", "twelvemuspace"], [], options));
    } else {
        inner.push(makeSpan(["mspace", "eightmuspace"], [], options));
    }

    if (group.value.modType === "pod" || group.value.modType === "pmod") {
        inner.push(buildCommon.mathsym("(", group.mode));
    }

    if (group.value.modType !== "pod") {
        var modInner = [
            buildCommon.mathsym("m", group.mode),
            buildCommon.mathsym("o", group.mode),
            buildCommon.mathsym("d", group.mode)];
        if (group.value.modType === "bmod") {
            inner.push(makeSpan(["mbin"], modInner, options));
            // “\mkern5mu\nonscript\mskip-\medmuskip”
            inner.push(makeSpan(["mspace", "thickspace"], [], options));
            if (!options.style.isTight()) {
                inner.push(makeSpan(
                    ["mspace", "negativemediumspace"], [], options));
            }
        } else {
            Array.prototype.push.apply(inner, modInner);
            inner.push(makeSpan(["mspace", "sixmuspace"], [], options));
        }
    }

    if (group.value.value) {
        Array.prototype.push.apply(inner,
            buildExpression(group.value.value, options, false));
    }

    if (group.value.modType === "pod" || group.value.modType === "pmod") {
        inner.push(buildCommon.mathsym(")", group.mode));
    }

    return buildCommon.makeFragment(inner);
};

groupTypes.katex = function(group, options) {
    // The KaTeX logo. The offsets for the K and a were chosen to look
    // good, but the offsets for the T, E, and X were taken from the
    // definition of \TeX in TeX (see TeXbook pg. 356)
    var k = makeSpan(
        ["k"], [buildCommon.mathsym("K", group.mode)], options);
    var a = makeSpan(
        ["a"], [buildCommon.mathsym("A", group.mode)], options);

    a.height = (a.height + 0.2) * 0.75;
    a.depth = (a.height - 0.2) * 0.75;

    var t = makeSpan(
        ["t"], [buildCommon.mathsym("T", group.mode)], options);
    var e = makeSpan(
        ["e"], [buildCommon.mathsym("E", group.mode)], options);

    e.height = (e.height - 0.2155);
    e.depth = (e.depth + 0.2155);

    var x = makeSpan(
        ["x"], [buildCommon.mathsym("X", group.mode)], options);

    return makeSpan(
        ["mord", "katex-logo"], [k, a, t, e, x], options);
};

groupTypes.overline = function(group, options) {
    // Overlines are handled in the TeXbook pg 443, Rule 9.
    var style = options.style;

    // Build the inner group in the cramped style.
    var innerGroup = buildGroup(group.value.body,
            options.withStyle(style.cramp()));

    var ruleWidth = fontMetrics.metrics.defaultRuleThickness /
        style.sizeMultiplier;

    // Create the line above the body
    var line = makeSpan(
        [style.reset(), Style.TEXT.cls(), "overline-line"]);
    line.height = ruleWidth;
    line.maxFontSize = 1.0;

    // Generate the vlist, with the appropriate kerns
    var vlist = buildCommon.makeVList([
        {type: "elem", elem: innerGroup},
        {type: "kern", size: 3 * ruleWidth},
        {type: "elem", elem: line},
        {type: "kern", size: ruleWidth}
    ], "firstBaseline", null, options);

    return makeSpan(["mord", "overline"], [vlist], options);
};

groupTypes.underline = function(group, options) {
    // Underlines are handled in the TeXbook pg 443, Rule 10.
    var style = options.style;

    // Build the inner group.
    var innerGroup = buildGroup(group.value.body, options);

    var ruleWidth = fontMetrics.metrics.defaultRuleThickness /
        style.sizeMultiplier;

    // Create the line above the body
    var line = makeSpan([style.reset(), Style.TEXT.cls(), "underline-line"]);
    line.height = ruleWidth;
    line.maxFontSize = 1.0;

    // Generate the vlist, with the appropriate kerns
    var vlist = buildCommon.makeVList([
        {type: "kern", size: ruleWidth},
        {type: "elem", elem: line},
        {type: "kern", size: 3 * ruleWidth},
        {type: "elem", elem: innerGroup}
    ], "top", innerGroup.height, options);

    return makeSpan(["mord", "underline"], [vlist], options);
};

groupTypes.sqrt = function(group, options) {
    // Square roots are handled in the TeXbook pg. 443, Rule 11.
    var style = options.style;

    // First, we do the same steps as in overline to build the inner group
    // and line
    var inner = buildGroup(group.value.body, options.withStyle(style.cramp()));

    var ruleWidth = fontMetrics.metrics.defaultRuleThickness /
        style.sizeMultiplier;

    var line = makeSpan(
        [style.reset(), Style.TEXT.cls(), "sqrt-line"], [],
        options);
    line.height = ruleWidth;
    line.maxFontSize = 1.0;

    var phi = ruleWidth;
    if (style.id < Style.TEXT.id) {
        phi = style.metrics.xHeight;
    }

    // Calculate the clearance between the body and line
    var lineClearance = ruleWidth + phi / 4;

    var innerHeight = (inner.height + inner.depth) * style.sizeMultiplier;
    var minDelimiterHeight = innerHeight + lineClearance + ruleWidth;

    // Create a \surd delimiter of the required minimum size
    var delim = makeSpan(["sqrt-sign"], [
        delimiter.customSizedDelim("\\surd", minDelimiterHeight,
                                   false, options, group.mode)],
                         options);

    var delimDepth = (delim.height + delim.depth) - ruleWidth;

    // Adjust the clearance based on the delimiter size
    if (delimDepth > inner.height + inner.depth + lineClearance) {
        lineClearance =
            (lineClearance + delimDepth - inner.height - inner.depth) / 2;
    }

    // Shift the delimiter so that its top lines up with the top of the line
    var delimShift = -(inner.height + lineClearance + ruleWidth) + delim.height;
    delim.style.top = delimShift + "em";
    delim.height -= delimShift;
    delim.depth += delimShift;

    // We add a special case here, because even when `inner` is empty, we
    // still get a line. So, we use a simple heuristic to decide if we
    // should omit the body entirely. (note this doesn't work for something
    // like `\sqrt{\rlap{x}}`, but if someone is doing that they deserve for
    // it not to work.
    var body;
    if (inner.height === 0 && inner.depth === 0) {
        body = makeSpan();
    } else {
        body = buildCommon.makeVList([
            {type: "elem", elem: inner},
            {type: "kern", size: lineClearance},
            {type: "elem", elem: line},
            {type: "kern", size: ruleWidth}
        ], "firstBaseline", null, options);
    }

    if (!group.value.index) {
        return makeSpan(["mord", "sqrt"], [delim, body], options);
    } else {
        // Handle the optional root index

        // The index is always in scriptscript style
        var newOptions = options.withStyle(Style.SCRIPTSCRIPT);
        var root = buildGroup(group.value.index, newOptions);
        var rootWrap = makeSpan(
            [style.reset(), Style.SCRIPTSCRIPT.cls()],
            [root],
            newOptions);

        // Figure out the height and depth of the inner part
        var innerRootHeight = Math.max(delim.height, body.height);
        var innerRootDepth = Math.max(delim.depth, body.depth);

        // The amount the index is shifted by. This is taken from the TeX
        // source, in the definition of `\r@@t`.
        var toShift = 0.6 * (innerRootHeight - innerRootDepth);

        // Build a VList with the superscript shifted up correctly
        var rootVList = buildCommon.makeVList(
            [{type: "elem", elem: rootWrap}],
            "shift", -toShift, options);
        // Add a class surrounding it so we can add on the appropriate
        // kerning
        var rootVListWrap = makeSpan(["root"], [rootVList]);

        return makeSpan(["mord", "sqrt"],
            [rootVListWrap, delim, body], options);
    }
};

groupTypes.sizing = function(group, options) {
    // Handle sizing operators like \Huge. Real TeX doesn't actually allow
    // these functions inside of math expressions, so we do some special
    // handling.
    var inner = buildExpression(group.value.value,
            options.withSize(group.value.size), false);

    // Compute the correct maxFontSize.
    var style = options.style;
    var fontSize = buildCommon.sizingMultiplier[group.value.size];
    fontSize = fontSize * style.sizeMultiplier;

    // Add size-resetting classes to the inner list and set maxFontSize
    // manually. Handle nested size changes.
    for (var i = 0; i < inner.length; i++) {
        var pos = utils.indexOf(inner[i].classes, "sizing");
        if (pos < 0) {
            inner[i].classes.push("sizing", "reset-" + options.size,
                                  group.value.size, style.cls());
            inner[i].maxFontSize = fontSize;
        } else if (inner[i].classes[pos + 1] === "reset-" + group.value.size) {
            // This is a nested size change: e.g., inner[i] is the "b" in
            // `\Huge a \small b`. Override the old size (the `reset-` class)
            // but not the new size.
            inner[i].classes[pos + 1] = "reset-" + options.size;
        }
    }

    return buildCommon.makeFragment(inner);
};

groupTypes.styling = function(group, options) {
    // Style changes are handled in the TeXbook on pg. 442, Rule 3.

    // Figure out what style we're changing to.
    var styleMap = {
        "display": Style.DISPLAY,
        "text": Style.TEXT,
        "script": Style.SCRIPT,
        "scriptscript": Style.SCRIPTSCRIPT
    };

    var newStyle = styleMap[group.value.style];
    var newOptions = options.withStyle(newStyle);

    // Build the inner expression in the new style.
    var inner = buildExpression(
        group.value.value, newOptions, false);

    // Add style-resetting classes to the inner list. Handle nested changes.
    for (var i = 0; i < inner.length; i++) {
        var pos = utils.indexOf(inner[i].classes, newStyle.reset());
        if (pos < 0) {
            inner[i].classes.push(options.style.reset(), newStyle.cls());
        } else {
            // This is a nested style change, as `\textstyle a\scriptstyle b`.
            // Only override the old style (the reset class).
            inner[i].classes[pos] = options.style.reset();
        }
    }

    return new buildCommon.makeFragment(inner);
};

groupTypes.font = function(group, options) {
    var font = group.value.font;
    return buildGroup(group.value.body, options.withFont(font));
};

groupTypes.delimsizing = function(group, options) {
    var delim = group.value.value;

    if (delim === ".") {
        // Empty delimiters still count as elements, even though they don't
        // show anything.
        return makeSpan([group.value.mclass]);
    }

    // Use delimiter.sizedDelim to generate the delimiter.
    return delimiter.sizedDelim(
            delim, group.value.size, options, group.mode,
            [group.value.mclass]);
};

groupTypes.leftright = function(group, options) {
    // Build the inner expression
    var inner = buildExpression(group.value.body, options.reset(), true);

    var innerHeight = 0;
    var innerDepth = 0;
    var hadMiddle = false;

    // Calculate its height and depth
    for (var i = 0; i < inner.length; i++) {
        if (inner[i].isMiddle) {
            hadMiddle = true;
        } else {
            innerHeight = Math.max(inner[i].height, innerHeight);
            innerDepth = Math.max(inner[i].depth, innerDepth);
        }
    }

    var style = options.style;

    // The size of delimiters is the same, regardless of what style we are
    // in. Thus, to correctly calculate the size of delimiter we need around
    // a group, we scale down the inner size based on the size.
    innerHeight *= style.sizeMultiplier;
    innerDepth *= style.sizeMultiplier;

    var leftDelim;
    if (group.value.left === ".") {
        // Empty delimiters in \left and \right make null delimiter spaces.
        leftDelim = makeNullDelimiter(options, ["mopen"]);
    } else {
        // Otherwise, use leftRightDelim to generate the correct sized
        // delimiter.
        leftDelim = delimiter.leftRightDelim(
            group.value.left, innerHeight, innerDepth, options,
            group.mode, ["mopen"]);
    }
    // Add it to the beginning of the expression
    inner.unshift(leftDelim);

    // Handle middle delimiters
    if (hadMiddle) {
        for (i = 1; i < inner.length; i++) {
            if (inner[i].isMiddle) {
                // Apply the options that were active when \middle was called
                inner[i] = delimiter.leftRightDelim(
                    inner[i].isMiddle.value, innerHeight, innerDepth,
                    inner[i].isMiddle.options, group.mode, []);
            }
        }
    }

    var rightDelim;
    // Same for the right delimiter
    if (group.value.right === ".") {
        rightDelim = makeNullDelimiter(options, ["mclose"]);
    } else {
        rightDelim = delimiter.leftRightDelim(
            group.value.right, innerHeight, innerDepth, options,
            group.mode, ["mclose"]);
    }
    // Add it to the end of the expression.
    inner.push(rightDelim);

    return makeSpan(
        ["minner", style.cls()], inner, options);
};

groupTypes.middle = function(group, options) {
    var middleDelim;
    if (group.value.value === ".") {
        middleDelim = makeNullDelimiter(options, []);
    } else {
        middleDelim = delimiter.sizedDelim(
            group.value.value, 1, options,
            group.mode, []);
        middleDelim.isMiddle = {value: group.value.value, options: options};
    }
    return middleDelim;
};

groupTypes.rule = function(group, options) {
    // Make an empty span for the rule
    var rule = makeSpan(["mord", "rule"], [], options);
    var style = options.style;

    // Calculate the shift, width, and height of the rule, and account for units
    var shift = 0;
    if (group.value.shift) {
        shift = calculateSize(group.value.shift, style);
    }

    var width = calculateSize(group.value.width, style);
    var height = calculateSize(group.value.height, style);

    // The sizes of rules are absolute, so make it larger if we are in a
    // smaller style.
    shift /= style.sizeMultiplier;
    width /= style.sizeMultiplier;
    height /= style.sizeMultiplier;

    // Style the rule to the right size
    rule.style.borderRightWidth = width + "em";
    rule.style.borderTopWidth = height + "em";
    rule.style.bottom = shift + "em";

    // Record the height and width
    rule.width = width;
    rule.height = height + shift;
    rule.depth = -shift;

    return rule;
};

groupTypes.kern = function(group, options) {
    // Make an empty span for the rule
    var rule = makeSpan(["mord", "rule"], [], options);
    var style = options.style;

    var dimension = 0;
    if (group.value.dimension) {
        dimension = calculateSize(group.value.dimension, style);
    }

    dimension /= style.sizeMultiplier;

    rule.style.marginLeft = dimension + "em";

    return rule;
};

groupTypes.accent = function(group, options) {
    // Accents are handled in the TeXbook pg. 443, rule 12.
    var base = group.value.base;
    var style = options.style;

    var supsubGroup;
    if (group.type === "supsub") {
        // If our base is a character box, and we have superscripts and
        // subscripts, the supsub will defer to us. In particular, we want
        // to attach the superscripts and subscripts to the inner body (so
        // that the position of the superscripts and subscripts won't be
        // affected by the height of the accent). We accomplish this by
        // sticking the base of the accent into the base of the supsub, and
        // rendering that, while keeping track of where the accent is.

        // The supsub group is the group that was passed in
        var supsub = group;
        // The real accent group is the base of the supsub group
        group = supsub.value.base;
        // The character box is the base of the accent group
        base = group.value.base;
        // Stick the character box into the base of the supsub group
        supsub.value.base = base;

        // Rerender the supsub group with its new base, and store that
        // result.
        supsubGroup = buildGroup(
            supsub, options.reset());
    }

    // Build the base group
    var body = buildGroup(
        base, options.withStyle(style.cramp()));

    // Calculate the skew of the accent. This is based on the line "If the
    // nucleus is not a single character, let s = 0; otherwise set s to the
    // kern amount for the nucleus followed by the \skewchar of its font."
    // Note that our skew metrics are just the kern between each character
    // and the skewchar.
    var skew;
    if (isCharacterBox(base)) {
        // If the base is a character box, then we want the skew of the
        // innermost character. To do that, we find the innermost character:
        var baseChar = getBaseElem(base);
        // Then, we render its group to get the symbol inside it
        var baseGroup = buildGroup(
            baseChar, options.withStyle(style.cramp()));
        // Finally, we pull the skew off of the symbol.
        skew = baseGroup.skew;
        // Note that we now throw away baseGroup, because the layers we
        // removed with getBaseElem might contain things like \color which
        // we can't get rid of.
        // TODO(emily): Find a better way to get the skew
    } else {
        skew = 0;
    }

    // calculate the amount of space between the body and the accent
    var clearance = Math.min(
        body.height,
        style.metrics.xHeight);

    // Build the accent
    var accent = buildCommon.makeSymbol(
        group.value.accent, "Main-Regular", "math", options);
    // Remove the italic correction of the accent, because it only serves to
    // shift the accent over to a place we don't want.
    accent.italic = 0;

    // The \vec character that the fonts use is a combining character, and
    // thus shows up much too far to the left. To account for this, we add a
    // specific class which shifts the accent over to where we want it.
    // TODO(emily): Fix this in a better way, like by changing the font
    var vecClass = group.value.accent === "\\vec" ? "accent-vec" : null;

    var accentBody = makeSpan(["accent-body", vecClass], [
        makeSpan([], [accent])]);

    accentBody = buildCommon.makeVList([
        {type: "elem", elem: body},
        {type: "kern", size: -clearance},
        {type: "elem", elem: accentBody}
    ], "firstBaseline", null, options);

    // Shift the accent over by the skew. Note we shift by twice the skew
    // because we are centering the accent, so by adding 2*skew to the left,
    // we shift it to the right by 1*skew.
    accentBody.children[1].style.marginLeft = 2 * skew + "em";

    var accentWrap = makeSpan(["mord", "accent"], [accentBody], options);

    if (supsubGroup) {
        // Here, we replace the "base" child of the supsub with our newly
        // generated accent.
        supsubGroup.children[0] = accentWrap;

        // Since we don't rerun the height calculation after replacing the
        // accent, we manually recalculate height.
        supsubGroup.height = Math.max(accentWrap.height, supsubGroup.height);

        // Accents should always be ords, even when their innards are not.
        supsubGroup.classes[0] = "mord";

        return supsubGroup;
    } else {
        return accentWrap;
    }
};

groupTypes.phantom = function(group, options) {
    var elements = buildExpression(
        group.value.value,
        options.withPhantom(),
        false
    );

    // \phantom isn't supposed to affect the elements it contains.
    // See "color" for more details.
    return new buildCommon.makeFragment(elements);
};

groupTypes.mclass = function(group, options) {
    var elements = buildExpression(group.value.value, options, true);

    return makeSpan([group.value.mclass], elements, options);
};

/**
 * buildGroup is the function that takes a group and calls the correct groupType
 * function for it. It also handles the interaction of size and style changes
 * between parents and children.
 */
var buildGroup = function(group, options) {
    if (!group) {
        return makeSpan();
    }

    if (groupTypes[group.type]) {
        // Call the groupTypes function
        var groupNode = groupTypes[group.type](group, options);
        var multiplier;

        // If the style changed between the parent and the current group,
        // account for the size difference
        if (options.style !== options.parentStyle) {
            multiplier = options.style.sizeMultiplier /
                    options.parentStyle.sizeMultiplier;

            groupNode.height *= multiplier;
            groupNode.depth *= multiplier;
        }

        // If the size changed between the parent and the current group, account
        // for that size difference.
        if (options.size !== options.parentSize) {
            multiplier = buildCommon.sizingMultiplier[options.size] /
                    buildCommon.sizingMultiplier[options.parentSize];

            groupNode.height *= multiplier;
            groupNode.depth *= multiplier;
        }

        return groupNode;
    } else {
        throw new ParseError(
            "Got group of unknown type: '" + group.type + "'");
    }
};

/**
 * Take an entire parse tree, and build it into an appropriate set of HTML
 * nodes.
 */
var buildHTML = function(tree, options) {
    // buildExpression is destructive, so we need to make a clone
    // of the incoming tree so that it isn't accidentally changed
    tree = JSON.parse(JSON.stringify(tree));

    // Build the expression contained in the tree
    var expression = buildExpression(tree, options, true);
    var body = makeSpan(["base", options.style.cls()], expression, options);

    // Add struts, which ensure that the top of the HTML element falls at the
    // height of the expression, and the bottom of the HTML element falls at the
    // depth of the expression.
    var topStrut = makeSpan(["strut"]);
    var bottomStrut = makeSpan(["strut", "bottom"]);

    topStrut.style.height = body.height + "em";
    bottomStrut.style.height = (body.height + body.depth) + "em";
    // We'd like to use `vertical-align: top` but in IE 9 this lowers the
    // baseline of the box to the bottom of this strut (instead staying in the
    // normal place) so we use an absolute value for vertical-align instead
    bottomStrut.style.verticalAlign = -body.depth + "em";

    // Wrap the struts and body together
    var htmlNode = makeSpan(["katex-html"], [topStrut, bottomStrut, body]);

    htmlNode.setAttribute("aria-hidden", "true");

    return htmlNode;
};

module.exports = buildHTML;

},{"./ParseError":94,"./Style":97,"./buildCommon":98,"./delimiter":102,"./domTree":103,"./fontMetrics":105,"./utils":113}],100:[function(require,module,exports){
/**
 * This file converts a parse tree into a cooresponding MathML tree. The main
 * entry point is the `buildMathML` function, which takes a parse tree from the
 * parser.
 */

var buildCommon = require("./buildCommon");
var fontMetrics = require("./fontMetrics");
var mathMLTree = require("./mathMLTree");
var ParseError = require("./ParseError");
var symbols = require("./symbols");
var utils = require("./utils");

var makeSpan = buildCommon.makeSpan;
var fontMap = buildCommon.fontMap;

/**
 * Takes a symbol and converts it into a MathML text node after performing
 * optional replacement from symbols.js.
 */
var makeText = function(text, mode) {
    if (symbols[mode][text] && symbols[mode][text].replace) {
        text = symbols[mode][text].replace;
    }

    return new mathMLTree.TextNode(text);
};

/**
 * Returns the math variant as a string or null if none is required.
 */
var getVariant = function(group, options) {
    var font = options.font;
    if (!font) {
        return null;
    }

    var mode = group.mode;
    if (font === "mathit") {
        return "italic";
    }

    var value = group.value;
    if (utils.contains(["\\imath", "\\jmath"], value)) {
        return null;
    }

    if (symbols[mode][value] && symbols[mode][value].replace) {
        value = symbols[mode][value].replace;
    }

    var fontName = fontMap[font].fontName;
    if (fontMetrics.getCharacterMetrics(value, fontName)) {
        return fontMap[options.font].variant;
    }

    return null;
};

/**
 * Functions for handling the different types of groups found in the parse
 * tree. Each function should take a parse group and return a MathML node.
 */
var groupTypes = {};

groupTypes.mathord = function(group, options) {
    var node = new mathMLTree.MathNode(
        "mi",
        [makeText(group.value, group.mode)]);

    var variant = getVariant(group, options);
    if (variant) {
        node.setAttribute("mathvariant", variant);
    }
    return node;
};

groupTypes.textord = function(group, options) {
    var text = makeText(group.value, group.mode);

    var variant = getVariant(group, options) || "normal";

    var node;
    if (/[0-9]/.test(group.value)) {
        // TODO(kevinb) merge adjacent <mn> nodes
        // do it as a post processing step
        node = new mathMLTree.MathNode("mn", [text]);
        if (options.font) {
            node.setAttribute("mathvariant", variant);
        }
    } else {
        node = new mathMLTree.MathNode("mi", [text]);
        node.setAttribute("mathvariant", variant);
    }

    return node;
};

groupTypes.bin = function(group) {
    var node = new mathMLTree.MathNode(
        "mo", [makeText(group.value, group.mode)]);

    return node;
};

groupTypes.rel = function(group) {
    var node = new mathMLTree.MathNode(
        "mo", [makeText(group.value, group.mode)]);

    return node;
};

groupTypes.open = function(group) {
    var node = new mathMLTree.MathNode(
        "mo", [makeText(group.value, group.mode)]);

    return node;
};

groupTypes.close = function(group) {
    var node = new mathMLTree.MathNode(
        "mo", [makeText(group.value, group.mode)]);

    return node;
};

groupTypes.inner = function(group) {
    var node = new mathMLTree.MathNode(
        "mo", [makeText(group.value, group.mode)]);

    return node;
};

groupTypes.punct = function(group) {
    var node = new mathMLTree.MathNode(
        "mo", [makeText(group.value, group.mode)]);

    node.setAttribute("separator", "true");

    return node;
};

groupTypes.ordgroup = function(group, options) {
    var inner = buildExpression(group.value, options);

    var node = new mathMLTree.MathNode("mrow", inner);

    return node;
};

groupTypes.text = function(group, options) {
    var inner = buildExpression(group.value.body, options);

    var node = new mathMLTree.MathNode("mtext", inner);

    return node;
};

groupTypes.color = function(group, options) {
    var inner = buildExpression(group.value.value, options);

    var node = new mathMLTree.MathNode("mstyle", inner);

    node.setAttribute("mathcolor", group.value.color);

    return node;
};

groupTypes.supsub = function(group, options) {
    var children = [buildGroup(group.value.base, options)];

    if (group.value.sub) {
        children.push(buildGroup(group.value.sub, options));
    }

    if (group.value.sup) {
        children.push(buildGroup(group.value.sup, options));
    }

    var nodeType;
    if (!group.value.sub) {
        nodeType = "msup";
    } else if (!group.value.sup) {
        nodeType = "msub";
    } else {
        nodeType = "msubsup";
    }

    var node = new mathMLTree.MathNode(nodeType, children);

    return node;
};

groupTypes.genfrac = function(group, options) {
    var node = new mathMLTree.MathNode(
        "mfrac",
        [buildGroup(group.value.numer, options),
            buildGroup(group.value.denom, options)]);

    if (!group.value.hasBarLine) {
        node.setAttribute("linethickness", "0px");
    }

    if (group.value.leftDelim != null || group.value.rightDelim != null) {
        var withDelims = [];

        if (group.value.leftDelim != null) {
            var leftOp = new mathMLTree.MathNode(
                "mo", [new mathMLTree.TextNode(group.value.leftDelim)]);

            leftOp.setAttribute("fence", "true");

            withDelims.push(leftOp);
        }

        withDelims.push(node);

        if (group.value.rightDelim != null) {
            var rightOp = new mathMLTree.MathNode(
                "mo", [new mathMLTree.TextNode(group.value.rightDelim)]);

            rightOp.setAttribute("fence", "true");

            withDelims.push(rightOp);
        }

        var outerNode = new mathMLTree.MathNode("mrow", withDelims);

        return outerNode;
    }

    return node;
};

groupTypes.array = function(group, options) {
    return new mathMLTree.MathNode(
        "mtable", group.value.body.map(function(row) {
            return new mathMLTree.MathNode(
                "mtr", row.map(function(cell) {
                    return new mathMLTree.MathNode(
                        "mtd", [buildGroup(cell, options)]);
                }));
        }));
};

groupTypes.sqrt = function(group, options) {
    var node;
    if (group.value.index) {
        node = new mathMLTree.MathNode(
            "mroot", [
                buildGroup(group.value.body, options),
                buildGroup(group.value.index, options)
            ]);
    } else {
        node = new mathMLTree.MathNode(
            "msqrt", [buildGroup(group.value.body, options)]);
    }

    return node;
};

groupTypes.leftright = function(group, options) {
    var inner = buildExpression(group.value.body, options);

    if (group.value.left !== ".") {
        var leftNode = new mathMLTree.MathNode(
            "mo", [makeText(group.value.left, group.mode)]);

        leftNode.setAttribute("fence", "true");

        inner.unshift(leftNode);
    }

    if (group.value.right !== ".") {
        var rightNode = new mathMLTree.MathNode(
            "mo", [makeText(group.value.right, group.mode)]);

        rightNode.setAttribute("fence", "true");

        inner.push(rightNode);
    }

    var outerNode = new mathMLTree.MathNode("mrow", inner);

    return outerNode;
};

groupTypes.middle = function(group, options) {
    var middleNode = new mathMLTree.MathNode(
        "mo", [makeText(group.value.middle, group.mode)]);
    middleNode.setAttribute("fence", "true");
    return middleNode;
};

groupTypes.accent = function(group, options) {
    var accentNode = new mathMLTree.MathNode(
        "mo", [makeText(group.value.accent, group.mode)]);

    var node = new mathMLTree.MathNode(
        "mover",
        [buildGroup(group.value.base, options),
            accentNode]);

    node.setAttribute("accent", "true");

    return node;
};

groupTypes.spacing = function(group) {
    var node;

    if (group.value === "\\ " || group.value === "\\space" ||
        group.value === " " || group.value === "~") {
        node = new mathMLTree.MathNode(
            "mtext", [new mathMLTree.TextNode("\u00a0")]);
    } else {
        node = new mathMLTree.MathNode("mspace");

        node.setAttribute(
            "width", buildCommon.spacingFunctions[group.value].size);
    }

    return node;
};

groupTypes.op = function(group, options) {
    var node;

    // TODO(emily): handle big operators using the `largeop` attribute

    if (group.value.symbol) {
        // This is a symbol. Just add the symbol.
        node = new mathMLTree.MathNode(
            "mo", [makeText(group.value.body, group.mode)]);
    } else if (group.value.value) {
        // This is an operator with children. Add them.
        node = new mathMLTree.MathNode(
            "mo", buildExpression(group.value.value, options));
    } else {
        // This is a text operator. Add all of the characters from the
        // operator's name.
        // TODO(emily): Add a space in the middle of some of these
        // operators, like \limsup.
        node = new mathMLTree.MathNode(
            "mi", [new mathMLTree.TextNode(group.value.body.slice(1))]);
    }

    return node;
};

groupTypes.mod = function(group, options) {
    var inner = [];

    if (group.value.modType === "pod" || group.value.modType === "pmod") {
        inner.push(new mathMLTree.MathNode(
            "mo", [makeText("(", group.mode)]));
    }
    if (group.value.modType !== "pod") {
        inner.push(new mathMLTree.MathNode(
            "mo", [makeText("mod", group.mode)]));
    }
    if (group.value.value) {
        var space = new mathMLTree.MathNode("mspace");
        space.setAttribute("width", "0.333333em");
        inner.push(space);
        inner = inner.concat(buildExpression(group.value.value, options));
    }
    if (group.value.modType === "pod" || group.value.modType === "pmod") {
        inner.push(new mathMLTree.MathNode(
            "mo", [makeText(")", group.mode)]));
    }

    return new mathMLTree.MathNode("mo", inner);
};

groupTypes.katex = function(group) {
    var node = new mathMLTree.MathNode(
        "mtext", [new mathMLTree.TextNode("KaTeX")]);

    return node;
};

groupTypes.font = function(group, options) {
    var font = group.value.font;
    return buildGroup(group.value.body, options.withFont(font));
};

groupTypes.delimsizing = function(group) {
    var children = [];

    if (group.value.value !== ".") {
        children.push(makeText(group.value.value, group.mode));
    }

    var node = new mathMLTree.MathNode("mo", children);

    if (group.value.mclass === "mopen" ||
        group.value.mclass === "mclose") {
        // Only some of the delimsizing functions act as fences, and they
        // return "mopen" or "mclose" mclass.
        node.setAttribute("fence", "true");
    } else {
        // Explicitly disable fencing if it's not a fence, to override the
        // defaults.
        node.setAttribute("fence", "false");
    }

    return node;
};

groupTypes.styling = function(group, options) {
    var inner = buildExpression(group.value.value, options);

    var node = new mathMLTree.MathNode("mstyle", inner);

    var styleAttributes = {
        "display": ["0", "true"],
        "text": ["0", "false"],
        "script": ["1", "false"],
        "scriptscript": ["2", "false"]
    };

    var attr = styleAttributes[group.value.style];

    node.setAttribute("scriptlevel", attr[0]);
    node.setAttribute("displaystyle", attr[1]);

    return node;
};

groupTypes.sizing = function(group, options) {
    var inner = buildExpression(group.value.value, options);

    var node = new mathMLTree.MathNode("mstyle", inner);

    // TODO(emily): This doesn't produce the correct size for nested size
    // changes, because we don't keep state of what style we're currently
    // in, so we can't reset the size to normal before changing it.  Now
    // that we're passing an options parameter we should be able to fix
    // this.
    node.setAttribute(
        "mathsize", buildCommon.sizingMultiplier[group.value.size] + "em");

    return node;
};

groupTypes.overline = function(group, options) {
    var operator = new mathMLTree.MathNode(
        "mo", [new mathMLTree.TextNode("\u203e")]);
    operator.setAttribute("stretchy", "true");

    var node = new mathMLTree.MathNode(
        "mover",
        [buildGroup(group.value.body, options),
            operator]);
    node.setAttribute("accent", "true");

    return node;
};

groupTypes.underline = function(group, options) {
    var operator = new mathMLTree.MathNode(
        "mo", [new mathMLTree.TextNode("\u203e")]);
    operator.setAttribute("stretchy", "true");

    var node = new mathMLTree.MathNode(
        "munder",
        [buildGroup(group.value.body, options),
            operator]);
    node.setAttribute("accentunder", "true");

    return node;
};

groupTypes.rule = function(group) {
    // TODO(emily): Figure out if there's an actual way to draw black boxes
    // in MathML.
    var node = new mathMLTree.MathNode("mrow");

    return node;
};

groupTypes.kern = function(group) {
    // TODO(kevin): Figure out if there's a way to add space in MathML
    var node = new mathMLTree.MathNode("mrow");

    return node;
};

groupTypes.llap = function(group, options) {
    var node = new mathMLTree.MathNode(
        "mpadded", [buildGroup(group.value.body, options)]);

    node.setAttribute("lspace", "-1width");
    node.setAttribute("width", "0px");

    return node;
};

groupTypes.rlap = function(group, options) {
    var node = new mathMLTree.MathNode(
        "mpadded", [buildGroup(group.value.body, options)]);

    node.setAttribute("width", "0px");

    return node;
};

groupTypes.phantom = function(group, options) {
    var inner = buildExpression(group.value.value, options);
    return new mathMLTree.MathNode("mphantom", inner);
};

groupTypes.mclass = function(group, options) {
    var inner = buildExpression(group.value.value, options);
    return new mathMLTree.MathNode("mstyle", inner);
};

/**
 * Takes a list of nodes, builds them, and returns a list of the generated
 * MathML nodes. A little simpler than the HTML version because we don't do any
 * previous-node handling.
 */
var buildExpression = function(expression, options) {
    var groups = [];
    for (var i = 0; i < expression.length; i++) {
        var group = expression[i];
        groups.push(buildGroup(group, options));
    }
    return groups;
};

/**
 * Takes a group from the parser and calls the appropriate groupTypes function
 * on it to produce a MathML node.
 */
var buildGroup = function(group, options) {
    if (!group) {
        return new mathMLTree.MathNode("mrow");
    }

    if (groupTypes[group.type]) {
        // Call the groupTypes function
        return groupTypes[group.type](group, options);
    } else {
        throw new ParseError(
            "Got group of unknown type: '" + group.type + "'");
    }
};

/**
 * Takes a full parse tree and settings and builds a MathML representation of
 * it. In particular, we put the elements from building the parse tree into a
 * <semantics> tag so we can also include that TeX source as an annotation.
 *
 * Note that we actually return a domTree element with a `<math>` inside it so
 * we can do appropriate styling.
 */
var buildMathML = function(tree, texExpression, options) {
    var expression = buildExpression(tree, options);

    // Wrap up the expression in an mrow so it is presented in the semantics
    // tag correctly.
    var wrapper = new mathMLTree.MathNode("mrow", expression);

    // Build a TeX annotation of the source
    var annotation = new mathMLTree.MathNode(
        "annotation", [new mathMLTree.TextNode(texExpression)]);

    annotation.setAttribute("encoding", "application/x-tex");

    var semantics = new mathMLTree.MathNode(
        "semantics", [wrapper, annotation]);

    var math = new mathMLTree.MathNode("math", [semantics]);

    // You can't style <math> nodes, so we wrap the node in a span.
    return makeSpan(["katex-mathml"], [math]);
};

module.exports = buildMathML;

},{"./ParseError":94,"./buildCommon":98,"./fontMetrics":105,"./mathMLTree":108,"./symbols":111,"./utils":113}],101:[function(require,module,exports){
var buildHTML = require("./buildHTML");
var buildMathML = require("./buildMathML");
var buildCommon = require("./buildCommon");
var Options = require("./Options");
var Settings = require("./Settings");
var Style = require("./Style");

var makeSpan = buildCommon.makeSpan;

var buildTree = function(tree, expression, settings) {
    settings = settings || new Settings({});

    var startStyle = Style.TEXT;
    if (settings.displayMode) {
        startStyle = Style.DISPLAY;
    }

    // Setup the default options
    var options = new Options({
        style: startStyle,
        size: "size5"
    });

    // `buildHTML` sometimes messes with the parse tree (like turning bins ->
    // ords), so we build the MathML version first.
    var mathMLNode = buildMathML(tree, expression, options);
    var htmlNode = buildHTML(tree, options);

    var katexNode = makeSpan(["katex"], [
        mathMLNode, htmlNode
    ]);

    if (settings.displayMode) {
        return makeSpan(["katex-display"], [katexNode]);
    } else {
        return katexNode;
    }
};

module.exports = buildTree;

},{"./Options":93,"./Settings":96,"./Style":97,"./buildCommon":98,"./buildHTML":99,"./buildMathML":100}],102:[function(require,module,exports){
/**
 * This file deals with creating delimiters of various sizes. The TeXbook
 * discusses these routines on page 441-442, in the "Another subroutine sets box
 * x to a specified variable delimiter" paragraph.
 *
 * There are three main routines here. `makeSmallDelim` makes a delimiter in the
 * normal font, but in either text, script, or scriptscript style.
 * `makeLargeDelim` makes a delimiter in textstyle, but in one of the Size1,
 * Size2, Size3, or Size4 fonts. `makeStackedDelim` makes a delimiter out of
 * smaller pieces that are stacked on top of one another.
 *
 * The functions take a parameter `center`, which determines if the delimiter
 * should be centered around the axis.
 *
 * Then, there are three exposed functions. `sizedDelim` makes a delimiter in
 * one of the given sizes. This is used for things like `\bigl`.
 * `customSizedDelim` makes a delimiter with a given total height+depth. It is
 * called in places like `\sqrt`. `leftRightDelim` makes an appropriate
 * delimiter which surrounds an expression of a given height an depth. It is
 * used in `\left` and `\right`.
 */

var ParseError = require("./ParseError");
var Style = require("./Style");

var buildCommon = require("./buildCommon");
var fontMetrics = require("./fontMetrics");
var symbols = require("./symbols");
var utils = require("./utils");

var makeSpan = buildCommon.makeSpan;

/**
 * Get the metrics for a given symbol and font, after transformation (i.e.
 * after following replacement from symbols.js)
 */
var getMetrics = function(symbol, font) {
    if (symbols.math[symbol] && symbols.math[symbol].replace) {
        return fontMetrics.getCharacterMetrics(
            symbols.math[symbol].replace, font);
    } else {
        return fontMetrics.getCharacterMetrics(
            symbol, font);
    }
};

/**
 * Builds a symbol in the given font size (note size is an integer)
 */
var mathrmSize = function(value, size, mode, options) {
    return buildCommon.makeSymbol(value, "Size" + size + "-Regular",
        mode, options);
};

/**
 * Puts a delimiter span in a given style, and adds appropriate height, depth,
 * and maxFontSizes.
 */
var styleWrap = function(delim, toStyle, options, classes) {
    classes = classes || [];
    var span = makeSpan(
        classes.concat(["style-wrap", options.style.reset(), toStyle.cls()]),
        [delim], options);

    var multiplier = toStyle.sizeMultiplier / options.style.sizeMultiplier;

    span.height *= multiplier;
    span.depth *= multiplier;
    span.maxFontSize = toStyle.sizeMultiplier;

    return span;
};

/**
 * Makes a small delimiter. This is a delimiter that comes in the Main-Regular
 * font, but is restyled to either be in textstyle, scriptstyle, or
 * scriptscriptstyle.
 */
var makeSmallDelim = function(delim, style, center, options, mode, classes) {
    var text = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);

    var span = styleWrap(text, style, options, classes);

    if (center) {
        var shift =
            (1 - options.style.sizeMultiplier / style.sizeMultiplier) *
            options.style.metrics.axisHeight;

        span.style.top = shift + "em";
        span.height -= shift;
        span.depth += shift;
    }

    return span;
};

/**
 * Makes a large delimiter. This is a delimiter that comes in the Size1, Size2,
 * Size3, or Size4 fonts. It is always rendered in textstyle.
 */
var makeLargeDelim = function(delim, size, center, options, mode, classes) {
    var inner = mathrmSize(delim, size, mode, options);

    var span = styleWrap(
        makeSpan(["delimsizing", "size" + size], [inner], options),
        Style.TEXT, options, classes);

    if (center) {
        var shift = (1 - options.style.sizeMultiplier) *
            options.style.metrics.axisHeight;

        span.style.top = shift + "em";
        span.height -= shift;
        span.depth += shift;
    }

    return span;
};

/**
 * Make an inner span with the given offset and in the given font. This is used
 * in `makeStackedDelim` to make the stacking pieces for the delimiter.
 */
var makeInner = function(symbol, font, mode) {
    var sizeClass;
    // Apply the correct CSS class to choose the right font.
    if (font === "Size1-Regular") {
        sizeClass = "delim-size1";
    } else if (font === "Size4-Regular") {
        sizeClass = "delim-size4";
    }

    var inner = makeSpan(
        ["delimsizinginner", sizeClass],
        [makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);

    // Since this will be passed into `makeVList` in the end, wrap the element
    // in the appropriate tag that VList uses.
    return {type: "elem", elem: inner};
};

/**
 * Make a stacked delimiter out of a given delimiter, with the total height at
 * least `heightTotal`. This routine is mentioned on page 442 of the TeXbook.
 */
var makeStackedDelim = function(delim, heightTotal, center, options, mode,
                                classes) {
    // There are four parts, the top, an optional middle, a repeated part, and a
    // bottom.
    var top;
    var middle;
    var repeat;
    var bottom;
    top = repeat = bottom = delim;
    middle = null;
    // Also keep track of what font the delimiters are in
    var font = "Size1-Regular";

    // We set the parts and font based on the symbol. Note that we use
    // '\u23d0' instead of '|' and '\u2016' instead of '\\|' for the
    // repeats of the arrows
    if (delim === "\\uparrow") {
        repeat = bottom = "\u23d0";
    } else if (delim === "\\Uparrow") {
        repeat = bottom = "\u2016";
    } else if (delim === "\\downarrow") {
        top = repeat = "\u23d0";
    } else if (delim === "\\Downarrow") {
        top = repeat = "\u2016";
    } else if (delim === "\\updownarrow") {
        top = "\\uparrow";
        repeat = "\u23d0";
        bottom = "\\downarrow";
    } else if (delim === "\\Updownarrow") {
        top = "\\Uparrow";
        repeat = "\u2016";
        bottom = "\\Downarrow";
    } else if (delim === "[" || delim === "\\lbrack") {
        top = "\u23a1";
        repeat = "\u23a2";
        bottom = "\u23a3";
        font = "Size4-Regular";
    } else if (delim === "]" || delim === "\\rbrack") {
        top = "\u23a4";
        repeat = "\u23a5";
        bottom = "\u23a6";
        font = "Size4-Regular";
    } else if (delim === "\\lfloor") {
        repeat = top = "\u23a2";
        bottom = "\u23a3";
        font = "Size4-Regular";
    } else if (delim === "\\lceil") {
        top = "\u23a1";
        repeat = bottom = "\u23a2";
        font = "Size4-Regular";
    } else if (delim === "\\rfloor") {
        repeat = top = "\u23a5";
        bottom = "\u23a6";
        font = "Size4-Regular";
    } else if (delim === "\\rceil") {
        top = "\u23a4";
        repeat = bottom = "\u23a5";
        font = "Size4-Regular";
    } else if (delim === "(") {
        top = "\u239b";
        repeat = "\u239c";
        bottom = "\u239d";
        font = "Size4-Regular";
    } else if (delim === ")") {
        top = "\u239e";
        repeat = "\u239f";
        bottom = "\u23a0";
        font = "Size4-Regular";
    } else if (delim === "\\{" || delim === "\\lbrace") {
        top = "\u23a7";
        middle = "\u23a8";
        bottom = "\u23a9";
        repeat = "\u23aa";
        font = "Size4-Regular";
    } else if (delim === "\\}" || delim === "\\rbrace") {
        top = "\u23ab";
        middle = "\u23ac";
        bottom = "\u23ad";
        repeat = "\u23aa";
        font = "Size4-Regular";
    } else if (delim === "\\lgroup") {
        top = "\u23a7";
        bottom = "\u23a9";
        repeat = "\u23aa";
        font = "Size4-Regular";
    } else if (delim === "\\rgroup") {
        top = "\u23ab";
        bottom = "\u23ad";
        repeat = "\u23aa";
        font = "Size4-Regular";
    } else if (delim === "\\lmoustache") {
        top = "\u23a7";
        bottom = "\u23ad";
        repeat = "\u23aa";
        font = "Size4-Regular";
    } else if (delim === "\\rmoustache") {
        top = "\u23ab";
        bottom = "\u23a9";
        repeat = "\u23aa";
        font = "Size4-Regular";
    } else if (delim === "\\surd") {
        top = "\ue001";
        bottom = "\u23b7";
        repeat = "\ue000";
        font = "Size4-Regular";
    }

    // Get the metrics of the four sections
    var topMetrics = getMetrics(top, font);
    var topHeightTotal = topMetrics.height + topMetrics.depth;
    var repeatMetrics = getMetrics(repeat, font);
    var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
    var bottomMetrics = getMetrics(bottom, font);
    var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
    var middleHeightTotal = 0;
    var middleFactor = 1;
    if (middle !== null) {
        var middleMetrics = getMetrics(middle, font);
        middleHeightTotal = middleMetrics.height + middleMetrics.depth;
        middleFactor = 2; // repeat symmetrically above and below middle
    }

    // Calcuate the minimal height that the delimiter can have.
    // It is at least the size of the top, bottom, and optional middle combined.
    var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;

    // Compute the number of copies of the repeat symbol we will need
    var repeatCount = Math.ceil(
        (heightTotal - minHeight) / (middleFactor * repeatHeightTotal));

    // Compute the total height of the delimiter including all the symbols
    var realHeightTotal =
        minHeight + repeatCount * middleFactor * repeatHeightTotal;

    // The center of the delimiter is placed at the center of the axis. Note
    // that in this context, "center" means that the delimiter should be
    // centered around the axis in the current style, while normally it is
    // centered around the axis in textstyle.
    var axisHeight = options.style.metrics.axisHeight;
    if (center) {
        axisHeight *= options.style.sizeMultiplier;
    }
    // Calculate the depth
    var depth = realHeightTotal / 2 - axisHeight;

    // Now, we start building the pieces that will go into the vlist

    // Keep a list of the inner pieces
    var inners = [];

    // Add the bottom symbol
    inners.push(makeInner(bottom, font, mode));

    var i;
    if (middle === null) {
        // Add that many symbols
        for (i = 0; i < repeatCount; i++) {
            inners.push(makeInner(repeat, font, mode));
        }
    } else {
        // When there is a middle bit, we need the middle part and two repeated
        // sections
        for (i = 0; i < repeatCount; i++) {
            inners.push(makeInner(repeat, font, mode));
        }
        inners.push(makeInner(middle, font, mode));
        for (i = 0; i < repeatCount; i++) {
            inners.push(makeInner(repeat, font, mode));
        }
    }

    // Add the top symbol
    inners.push(makeInner(top, font, mode));

    // Finally, build the vlist
    var inner = buildCommon.makeVList(inners, "bottom", depth, options);

    return styleWrap(
        makeSpan(["delimsizing", "mult"], [inner], options),
        Style.TEXT, options, classes);
};

// There are three kinds of delimiters, delimiters that stack when they become
// too large
var stackLargeDelimiters = [
    "(", ")", "[", "\\lbrack", "]", "\\rbrack",
    "\\{", "\\lbrace", "\\}", "\\rbrace",
    "\\lfloor", "\\rfloor", "\\lceil", "\\rceil",
    "\\surd"
];

// delimiters that always stack
var stackAlwaysDelimiters = [
    "\\uparrow", "\\downarrow", "\\updownarrow",
    "\\Uparrow", "\\Downarrow", "\\Updownarrow",
    "|", "\\|", "\\vert", "\\Vert",
    "\\lvert", "\\rvert", "\\lVert", "\\rVert",
    "\\lgroup", "\\rgroup", "\\lmoustache", "\\rmoustache"
];

// and delimiters that never stack
var stackNeverDelimiters = [
    "<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"
];

// Metrics of the different sizes. Found by looking at TeX's output of
// $\bigl| // \Bigl| \biggl| \Biggl| \showlists$
// Used to create stacked delimiters of appropriate sizes in makeSizedDelim.
var sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3.0];

/**
 * Used to create a delimiter of a specific size, where `size` is 1, 2, 3, or 4.
 */
var makeSizedDelim = function(delim, size, options, mode, classes) {
    // < and > turn into \langle and \rangle in delimiters
    if (delim === "<" || delim === "\\lt") {
        delim = "\\langle";
    } else if (delim === ">" || delim === "\\gt") {
        delim = "\\rangle";
    }

    // Sized delimiters are never centered.
    if (utils.contains(stackLargeDelimiters, delim) ||
        utils.contains(stackNeverDelimiters, delim)) {
        return makeLargeDelim(delim, size, false, options, mode, classes);
    } else if (utils.contains(stackAlwaysDelimiters, delim)) {
        return makeStackedDelim(
            delim, sizeToMaxHeight[size], false, options, mode, classes);
    } else {
        throw new ParseError("Illegal delimiter: '" + delim + "'");
    }
};

/**
 * There are three different sequences of delimiter sizes that the delimiters
 * follow depending on the kind of delimiter. This is used when creating custom
 * sized delimiters to decide whether to create a small, large, or stacked
 * delimiter.
 *
 * In real TeX, these sequences aren't explicitly defined, but are instead
 * defined inside the font metrics. Since there are only three sequences that
 * are possible for the delimiters that TeX defines, it is easier to just encode
 * them explicitly here.
 */

// Delimiters that never stack try small delimiters and large delimiters only
var stackNeverDelimiterSequence = [
    {type: "small", style: Style.SCRIPTSCRIPT},
    {type: "small", style: Style.SCRIPT},
    {type: "small", style: Style.TEXT},
    {type: "large", size: 1},
    {type: "large", size: 2},
    {type: "large", size: 3},
    {type: "large", size: 4}
];

// Delimiters that always stack try the small delimiters first, then stack
var stackAlwaysDelimiterSequence = [
    {type: "small", style: Style.SCRIPTSCRIPT},
    {type: "small", style: Style.SCRIPT},
    {type: "small", style: Style.TEXT},
    {type: "stack"}
];

// Delimiters that stack when large try the small and then large delimiters, and
// stack afterwards
var stackLargeDelimiterSequence = [
    {type: "small", style: Style.SCRIPTSCRIPT},
    {type: "small", style: Style.SCRIPT},
    {type: "small", style: Style.TEXT},
    {type: "large", size: 1},
    {type: "large", size: 2},
    {type: "large", size: 3},
    {type: "large", size: 4},
    {type: "stack"}
];

/**
 * Get the font used in a delimiter based on what kind of delimiter it is.
 */
var delimTypeToFont = function(type) {
    if (type.type === "small") {
        return "Main-Regular";
    } else if (type.type === "large") {
        return "Size" + type.size + "-Regular";
    } else if (type.type === "stack") {
        return "Size4-Regular";
    }
};

/**
 * Traverse a sequence of types of delimiters to decide what kind of delimiter
 * should be used to create a delimiter of the given height+depth.
 */
var traverseSequence = function(delim, height, sequence, options) {
    // Here, we choose the index we should start at in the sequences. In smaller
    // sizes (which correspond to larger numbers in style.size) we start earlier
    // in the sequence. Thus, scriptscript starts at index 3-3=0, script starts
    // at index 3-2=1, text starts at 3-1=2, and display starts at min(2,3-0)=2
    var start = Math.min(2, 3 - options.style.size);
    for (var i = start; i < sequence.length; i++) {
        if (sequence[i].type === "stack") {
            // This is always the last delimiter, so we just break the loop now.
            break;
        }

        var metrics = getMetrics(delim, delimTypeToFont(sequence[i]));
        var heightDepth = metrics.height + metrics.depth;

        // Small delimiters are scaled down versions of the same font, so we
        // account for the style change size.

        if (sequence[i].type === "small") {
            heightDepth *= sequence[i].style.sizeMultiplier;
        }

        // Check if the delimiter at this size works for the given height.
        if (heightDepth > height) {
            return sequence[i];
        }
    }

    // If we reached the end of the sequence, return the last sequence element.
    return sequence[sequence.length - 1];
};

/**
 * Make a delimiter of a given height+depth, with optional centering. Here, we
 * traverse the sequences, and create a delimiter that the sequence tells us to.
 */
var makeCustomSizedDelim = function(delim, height, center, options, mode,
                                    classes) {
    if (delim === "<" || delim === "\\lt") {
        delim = "\\langle";
    } else if (delim === ">" || delim === "\\gt") {
        delim = "\\rangle";
    }

    // Decide what sequence to use
    var sequence;
    if (utils.contains(stackNeverDelimiters, delim)) {
        sequence = stackNeverDelimiterSequence;
    } else if (utils.contains(stackLargeDelimiters, delim)) {
        sequence = stackLargeDelimiterSequence;
    } else {
        sequence = stackAlwaysDelimiterSequence;
    }

    // Look through the sequence
    var delimType = traverseSequence(delim, height, sequence, options);

    // Depending on the sequence element we decided on, call the appropriate
    // function.
    if (delimType.type === "small") {
        return makeSmallDelim(delim, delimType.style, center, options, mode,
                              classes);
    } else if (delimType.type === "large") {
        return makeLargeDelim(delim, delimType.size, center, options, mode,
                              classes);
    } else if (delimType.type === "stack") {
        return makeStackedDelim(delim, height, center, options, mode, classes);
    }
};

/**
 * Make a delimiter for use with `\left` and `\right`, given a height and depth
 * of an expression that the delimiters surround.
 */
var makeLeftRightDelim = function(delim, height, depth, options, mode,
                                  classes) {
    // We always center \left/\right delimiters, so the axis is always shifted
    var axisHeight =
        options.style.metrics.axisHeight * options.style.sizeMultiplier;

    // Taken from TeX source, tex.web, function make_left_right
    var delimiterFactor = 901;
    var delimiterExtend = 5.0 / fontMetrics.metrics.ptPerEm;

    var maxDistFromAxis = Math.max(
        height - axisHeight, depth + axisHeight);

    var totalHeight = Math.max(
        // In real TeX, calculations are done using integral values which are
        // 65536 per pt, or 655360 per em. So, the division here truncates in
        // TeX but doesn't here, producing different results. If we wanted to
        // exactly match TeX's calculation, we could do
        //   Math.floor(655360 * maxDistFromAxis / 500) *
        //    delimiterFactor / 655360
        // (To see the difference, compare
        //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
        // in TeX and KaTeX)
        maxDistFromAxis / 500 * delimiterFactor,
        2 * maxDistFromAxis - delimiterExtend);

    // Finally, we defer to `makeCustomSizedDelim` with our calculated total
    // height
    return makeCustomSizedDelim(delim, totalHeight, true, options, mode,
                                classes);
};

module.exports = {
    sizedDelim: makeSizedDelim,
    customSizedDelim: makeCustomSizedDelim,
    leftRightDelim: makeLeftRightDelim
};

},{"./ParseError":94,"./Style":97,"./buildCommon":98,"./fontMetrics":105,"./symbols":111,"./utils":113}],103:[function(require,module,exports){
/**
 * These objects store the data about the DOM nodes we create, as well as some
 * extra data. They can then be transformed into real DOM nodes with the
 * `toNode` function or HTML markup using `toMarkup`. They are useful for both
 * storing extra properties on the nodes, as well as providing a way to easily
 * work with the DOM.
 *
 * Similar functions for working with MathML nodes exist in mathMLTree.js.
 */
var unicodeRegexes = require("./unicodeRegexes");
var utils = require("./utils");

/**
 * Create an HTML className based on a list of classes. In addition to joining
 * with spaces, we also remove null or empty classes.
 */
var createClass = function(classes) {
    classes = classes.slice();
    for (var i = classes.length - 1; i >= 0; i--) {
        if (!classes[i]) {
            classes.splice(i, 1);
        }
    }

    return classes.join(" ");
};

/**
 * This node represents a span node, with a className, a list of children, and
 * an inline style. It also contains information about its height, depth, and
 * maxFontSize.
 */
function span(classes, children, options) {
    this.classes = classes || [];
    this.children = children || [];
    this.height = 0;
    this.depth = 0;
    this.maxFontSize = 0;
    this.style = {};
    this.attributes = {};
    if (options) {
        if (options.style.isTight()) {
            this.classes.push("mtight");
        }
        if (options.getColor()) {
            this.style.color = options.getColor();
        }
    }
}

/**
 * Sets an arbitrary attribute on the span. Warning: use this wisely. Not all
 * browsers support attributes the same, and having too many custom attributes
 * is probably bad.
 */
span.prototype.setAttribute = function(attribute, value) {
    this.attributes[attribute] = value;
};

span.prototype.tryCombine = function(sibling) {
    return false;
};

/**
 * Convert the span into an HTML node
 */
span.prototype.toNode = function() {
    var span = document.createElement("span");

    // Apply the class
    span.className = createClass(this.classes);

    // Apply inline styles
    for (var style in this.style) {
        if (Object.prototype.hasOwnProperty.call(this.style, style)) {
            span.style[style] = this.style[style];
        }
    }

    // Apply attributes
    for (var attr in this.attributes) {
        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            span.setAttribute(attr, this.attributes[attr]);
        }
    }

    // Append the children, also as HTML nodes
    for (var i = 0; i < this.children.length; i++) {
        span.appendChild(this.children[i].toNode());
    }

    return span;
};

/**
 * Convert the span into an HTML markup string
 */
span.prototype.toMarkup = function() {
    var markup = "<span";

    // Add the class
    if (this.classes.length) {
        markup += " class=\"";
        markup += utils.escape(createClass(this.classes));
        markup += "\"";
    }

    var styles = "";

    // Add the styles, after hyphenation
    for (var style in this.style) {
        if (this.style.hasOwnProperty(style)) {
            styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
        }
    }

    if (styles) {
        markup += " style=\"" + utils.escape(styles) + "\"";
    }

    // Add the attributes
    for (var attr in this.attributes) {
        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            markup += " " + attr + "=\"";
            markup += utils.escape(this.attributes[attr]);
            markup += "\"";
        }
    }

    markup += ">";

    // Add the markup of the children, also as markup
    for (var i = 0; i < this.children.length; i++) {
        markup += this.children[i].toMarkup();
    }

    markup += "</span>";

    return markup;
};

/**
 * This node represents a document fragment, which contains elements, but when
 * placed into the DOM doesn't have any representation itself. Thus, it only
 * contains children and doesn't have any HTML properties. It also keeps track
 * of a height, depth, and maxFontSize.
 */
function documentFragment(children) {
    this.children = children || [];
    this.height = 0;
    this.depth = 0;
    this.maxFontSize = 0;
}

/**
 * Convert the fragment into a node
 */
documentFragment.prototype.toNode = function() {
    // Create a fragment
    var frag = document.createDocumentFragment();

    // Append the children
    for (var i = 0; i < this.children.length; i++) {
        frag.appendChild(this.children[i].toNode());
    }

    return frag;
};

/**
 * Convert the fragment into HTML markup
 */
documentFragment.prototype.toMarkup = function() {
    var markup = "";

    // Simply concatenate the markup for the children together
    for (var i = 0; i < this.children.length; i++) {
        markup += this.children[i].toMarkup();
    }

    return markup;
};

var iCombinations = {
    'î': '\u0131\u0302',
    'ï': '\u0131\u0308',
    'í': '\u0131\u0301',
    // 'ī': '\u0131\u0304', // enable when we add Extended Latin
    'ì': '\u0131\u0300'
};

/**
 * A symbol node contains information about a single symbol. It either renders
 * to a single text node, or a span with a single text node in it, depending on
 * whether it has CSS classes, styles, or needs italic correction.
 */
function symbolNode(value, height, depth, italic, skew, classes, style) {
    this.value = value || "";
    this.height = height || 0;
    this.depth = depth || 0;
    this.italic = italic || 0;
    this.skew = skew || 0;
    this.classes = classes || [];
    this.style = style || {};
    this.maxFontSize = 0;

    // Mark CJK characters with specific classes so that we can specify which
    // fonts to use.  This allows us to render these characters with a serif
    // font in situations where the browser would either default to a sans serif
    // or render a placeholder character.
    if (unicodeRegexes.cjkRegex.test(value)) {
        // I couldn't find any fonts that contained Hangul as well as all of
        // the other characters we wanted to test there for it gets its own
        // CSS class.
        if (unicodeRegexes.hangulRegex.test(value)) {
            this.classes.push('hangul_fallback');
        } else {
            this.classes.push('cjk_fallback');
        }
    }

    if (/[îïíì]/.test(this.value)) {    // add ī when we add Extended Latin
        this.value = iCombinations[this.value];
    }
}

symbolNode.prototype.tryCombine = function(sibling) {
    if (!sibling
        || !(sibling instanceof symbolNode)
        || this.italic > 0
        || createClass(this.classes) !== createClass(sibling.classes)
        || this.skew !== sibling.skew
        || this.maxFontSize !== sibling.maxFontSize) {
        return false;
    }
    for (var style in this.style) {
        if (this.style.hasOwnProperty(style)
            && this.style[style] !== sibling.style[style]) {
            return false;
        }
    }
    for (style in sibling.style) {
        if (sibling.style.hasOwnProperty(style)
            && this.style[style] !== sibling.style[style]) {
            return false;
        }
    }
    this.value += sibling.value;
    this.height = Math.max(this.height, sibling.height);
    this.depth = Math.max(this.depth, sibling.depth);
    this.italic = sibling.italic;
    return true;
};

/**
 * Creates a text node or span from a symbol node. Note that a span is only
 * created if it is needed.
 */
symbolNode.prototype.toNode = function() {
    var node = document.createTextNode(this.value);
    var span = null;

    if (this.italic > 0) {
        span = document.createElement("span");
        span.style.marginRight = this.italic + "em";
    }

    if (this.classes.length > 0) {
        span = span || document.createElement("span");
        span.className = createClass(this.classes);
    }

    for (var style in this.style) {
        if (this.style.hasOwnProperty(style)) {
            span = span || document.createElement("span");
            span.style[style] = this.style[style];
        }
    }

    if (span) {
        span.appendChild(node);
        return span;
    } else {
        return node;
    }
};

/**
 * Creates markup for a symbol node.
 */
symbolNode.prototype.toMarkup = function() {
    // TODO(alpert): More duplication than I'd like from
    // span.prototype.toMarkup and symbolNode.prototype.toNode...
    var needsSpan = false;

    var markup = "<span";

    if (this.classes.length) {
        needsSpan = true;
        markup += " class=\"";
        markup += utils.escape(createClass(this.classes));
        markup += "\"";
    }

    var styles = "";

    if (this.italic > 0) {
        styles += "margin-right:" + this.italic + "em;";
    }
    for (var style in this.style) {
        if (this.style.hasOwnProperty(style)) {
            styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
        }
    }

    if (styles) {
        needsSpan = true;
        markup += " style=\"" + utils.escape(styles) + "\"";
    }

    var escaped = utils.escape(this.value);
    if (needsSpan) {
        markup += ">";
        markup += escaped;
        markup += "</span>";
        return markup;
    } else {
        return escaped;
    }
};

module.exports = {
    span: span,
    documentFragment: documentFragment,
    symbolNode: symbolNode
};

},{"./unicodeRegexes":112,"./utils":113}],104:[function(require,module,exports){
/* eslint no-constant-condition:0 */
var parseData = require("./parseData");
var ParseError = require("./ParseError");
var Style = require("./Style");

var ParseNode = parseData.ParseNode;

/**
 * Parse the body of the environment, with rows delimited by \\ and
 * columns delimited by &, and create a nested list in row-major order
 * with one group per cell.
 */
function parseArray(parser, result) {
    var row = [];
    var body = [row];
    var rowGaps = [];
    while (true) {
        var cell = parser.parseExpression(false, null);
        row.push(new ParseNode("ordgroup", cell, parser.mode));
        var next = parser.nextToken.text;
        if (next === "&") {
            parser.consume();
        } else if (next === "\\end") {
            break;
        } else if (next === "\\\\" || next === "\\cr") {
            var cr = parser.parseFunction();
            rowGaps.push(cr.value.size);
            row = [];
            body.push(row);
        } else {
            throw new ParseError("Expected & or \\\\ or \\end",
                                 parser.nextToken);
        }
    }
    result.body = body;
    result.rowGaps = rowGaps;
    return new ParseNode(result.type, result, parser.mode);
}

/*
 * An environment definition is very similar to a function definition:
 * it is declared with a name or a list of names, a set of properties
 * and a handler containing the actual implementation.
 *
 * The properties include:
 *  - numArgs: The number of arguments after the \begin{name} function.
 *  - argTypes: (optional) Just like for a function
 *  - allowedInText: (optional) Whether or not the environment is allowed inside
 *                   text mode (default false) (not enforced yet)
 *  - numOptionalArgs: (optional) Just like for a function
 * A bare number instead of that object indicates the numArgs value.
 *
 * The handler function will receive two arguments
 *  - context: information and references provided by the parser
 *  - args: an array of arguments passed to \begin{name}
 * The context contains the following properties:
 *  - envName: the name of the environment, one of the listed names.
 *  - parser: the parser object
 *  - lexer: the lexer object
 *  - positions: the positions associated with these arguments from args.
 * The handler must return a ParseResult.
 */

function defineEnvironment(names, props, handler) {
    if (typeof names === "string") {
        names = [names];
    }
    if (typeof props === "number") {
        props = { numArgs: props };
    }
    // Set default values of environments
    var data = {
        numArgs: props.numArgs || 0,
        argTypes: props.argTypes,
        greediness: 1,
        allowedInText: !!props.allowedInText,
        numOptionalArgs: props.numOptionalArgs || 0,
        handler: handler
    };
    for (var i = 0; i < names.length; ++i) {
        module.exports[names[i]] = data;
    }
}

// Arrays are part of LaTeX, defined in lttab.dtx so its documentation
// is part of the source2e.pdf file of LaTeX2e source documentation.
defineEnvironment("array", {
    numArgs: 1
}, function(context, args) {
    var colalign = args[0];
    colalign = colalign.value.map ? colalign.value : [colalign];
    var cols = colalign.map(function(node) {
        var ca = node.value;
        if ("lcr".indexOf(ca) !== -1) {
            return {
                type: "align",
                align: ca
            };
        } else if (ca === "|") {
            return {
                type: "separator",
                separator: "|"
            };
        }
        throw new ParseError(
            "Unknown column alignment: " + node.value,
            node);
    });
    var res = {
        type: "array",
        cols: cols,
        hskipBeforeAndAfter: true // \@preamble in lttab.dtx
    };
    res = parseArray(context.parser, res);
    return res;
});

// The matrix environments of amsmath builds on the array environment
// of LaTeX, which is discussed above.
defineEnvironment([
    "matrix",
    "pmatrix",
    "bmatrix",
    "Bmatrix",
    "vmatrix",
    "Vmatrix"
], {
}, function(context) {
    var delimiters = {
        "matrix": null,
        "pmatrix": ["(", ")"],
        "bmatrix": ["[", "]"],
        "Bmatrix": ["\\{", "\\}"],
        "vmatrix": ["|", "|"],
        "Vmatrix": ["\\Vert", "\\Vert"]
    }[context.envName];
    var res = {
        type: "array",
        hskipBeforeAndAfter: false // \hskip -\arraycolsep in amsmath
    };
    res = parseArray(context.parser, res);
    if (delimiters) {
        res = new ParseNode("leftright", {
            body: [res],
            left: delimiters[0],
            right: delimiters[1]
        }, context.mode);
    }
    return res;
});

// A cases environment (in amsmath.sty) is almost equivalent to
// \def\arraystretch{1.2}%
// \left\{\begin{array}{@{}l@{\quad}l@{}} … \end{array}\right.
defineEnvironment("cases", {
}, function(context) {
    var res = {
        type: "array",
        arraystretch: 1.2,
        cols: [{
            type: "align",
            align: "l",
            pregap: 0,
            // TODO(kevinb) get the current style.
            // For now we use the metrics for TEXT style which is what we were
            // doing before.  Before attempting to get the current style we
            // should look at TeX's behavior especially for \over and matrices.
            postgap: Style.TEXT.metrics.quad
        }, {
            type: "align",
            align: "l",
            pregap: 0,
            postgap: 0
        }]
    };
    res = parseArray(context.parser, res);
    res = new ParseNode("leftright", {
        body: [res],
        left: "\\{",
        right: "."
    }, context.mode);
    return res;
});

// An aligned environment is like the align* environment
// except it operates within math mode.
// Note that we assume \nomallineskiplimit to be zero,
// so that \strut@ is the same as \strut.
defineEnvironment("aligned", {
}, function(context) {
    var res = {
        type: "array",
        cols: []
    };
    res = parseArray(context.parser, res);
    var emptyGroup = new ParseNode("ordgroup", [], context.mode);
    var numCols = 0;
    res.value.body.forEach(function(row) {
        var i;
        for (i = 1; i < row.length; i += 2) {
            row[i].value.unshift(emptyGroup);
        }
        if (numCols < row.length) {
            numCols = row.length;
        }
    });
    for (var i = 0; i < numCols; ++i) {
        var align = "r";
        var pregap = 0;
        if (i % 2 === 1) {
            align = "l";
        } else if (i > 0) {
            pregap = 2; // one \qquad between columns
        }
        res.value.cols[i] = {
            type: "align",
            align: align,
            pregap: pregap,
            postgap: 0
        };
    }
    return res;
});

},{"./ParseError":94,"./Style":97,"./parseData":109}],105:[function(require,module,exports){
/* eslint no-unused-vars:0 */

var Style = require("./Style");
var cjkRegex = require("./unicodeRegexes").cjkRegex;

/**
 * This file contains metrics regarding fonts and individual symbols. The sigma
 * and xi variables, as well as the metricMap map contain data extracted from
 * TeX, TeX font metrics, and the TTF files. These data are then exposed via the
 * `metrics` variable and the getCharacterMetrics function.
 */

// In TeX, there are actually three sets of dimensions, one for each of
// textstyle, scriptstyle, and scriptscriptstyle.  These are provided in the
// the arrays below, in that order.
//
// The font metrics are stored in fonts cmsy10, cmsy7, and cmsy5 respsectively.
// This was determined by running the folllowing script:
//
//     latex -interaction=nonstopmode \
//     '\documentclass{article}\usepackage{amsmath}\begin{document}' \
//     '$a$ \expandafter\show\the\textfont2' \
//     '\expandafter\show\the\scriptfont2' \
//     '\expandafter\show\the\scriptscriptfont2' \
//     '\stop'
//
// The metrics themselves were retreived using the following commands:
//
//     tftopl cmsy10
//     tftopl cmsy7
//     tftopl cmsy5
//
// The output of each of these commands is quite lengthy.  The only part we
// care about is the FONTDIMEN section. Each value is measured in EMs.
var sigmas = {
    slant: [0.250, 0.250, 0.250],       // sigma1
    space: [0.000, 0.000, 0.000],       // sigma2
    stretch: [0.000, 0.000, 0.000],     // sigma3
    shrink: [0.000, 0.000, 0.000],      // sigma4
    xHeight: [0.431, 0.431, 0.431],     // sigma5
    quad: [1.000, 1.171, 1.472],        // sigma6
    extraSpace: [0.000, 0.000, 0.000],  // sigma7
    num1: [0.677, 0.732, 0.925],        // sigma8
    num2: [0.394, 0.384, 0.387],        // sigma9
    num3: [0.444, 0.471, 0.504],        // sigma10
    denom1: [0.686, 0.752, 1.025],      // sigma11
    denom2: [0.345, 0.344, 0.532],      // sigma12
    sup1: [0.413, 0.503, 0.504],        // sigma13
    sup2: [0.363, 0.431, 0.404],        // sigma14
    sup3: [0.289, 0.286, 0.294],        // sigma15
    sub1: [0.150, 0.143, 0.200],        // sigma16
    sub2: [0.247, 0.286, 0.400],        // sigma17
    supDrop: [0.386, 0.353, 0.494],     // sigma18
    subDrop: [0.050, 0.071, 0.100],     // sigma19
    delim1: [2.390, 1.700, 1.980],      // sigma20
    delim2: [1.010, 1.157, 1.420],      // sigma21
    axisHeight: [0.250, 0.250, 0.250]  // sigma22
};

// These font metrics are extracted from TeX by using
// \font\a=cmex10
// \showthe\fontdimenX\a
// where X is the corresponding variable number. These correspond to the font
// parameters of the extension fonts (family 3). See the TeXbook, page 441.
var xi1 = 0;
var xi2 = 0;
var xi3 = 0;
var xi4 = 0;
var xi5 = 0.431;
var xi6 = 1;
var xi7 = 0;
var xi8 = 0.04;
var xi9 = 0.111;
var xi10 = 0.166;
var xi11 = 0.2;
var xi12 = 0.6;
var xi13 = 0.1;

// This value determines how large a pt is, for metrics which are defined in
// terms of pts.
// This value is also used in katex.less; if you change it make sure the values
// match.
var ptPerEm = 10.0;

// The space between adjacent `|` columns in an array definition. From
// `\showthe\doublerulesep` in LaTeX.
var doubleRuleSep = 2.0 / ptPerEm;

/**
 * This is just a mapping from common names to real metrics
 */
var metrics = {
    defaultRuleThickness: xi8,
    bigOpSpacing1: xi9,
    bigOpSpacing2: xi10,
    bigOpSpacing3: xi11,
    bigOpSpacing4: xi12,
    bigOpSpacing5: xi13,
    ptPerEm: ptPerEm,
    doubleRuleSep: doubleRuleSep
};

// This map contains a mapping from font name and character code to character
// metrics, including height, depth, italic correction, and skew (kern from the
// character to the corresponding \skewchar)
// This map is generated via `make metrics`. It should not be changed manually.
var metricMap = require("./fontMetricsData");

// These are very rough approximations.  We default to Times New Roman which
// should have Latin-1 and Cyrillic characters, but may not depending on the
// operating system.  The metrics do not account for extra height from the
// accents.  In the case of Cyrillic characters which have both ascenders and
// descenders we prefer approximations with ascenders, primarily to prevent
// the fraction bar or root line from intersecting the glyph.
// TODO(kevinb) allow union of multiple glyph metrics for better accuracy.
var extraCharacterMap = {
    // Latin-1
    'À': 'A',
    'Á': 'A',
    'Â': 'A',
    'Ã': 'A',
    'Ä': 'A',
    'Å': 'A',
    'Æ': 'A',
    'Ç': 'C',
    'È': 'E',
    'É': 'E',
    'Ê': 'E',
    'Ë': 'E',
    'Ì': 'I',
    'Í': 'I',
    'Î': 'I',
    'Ï': 'I',
    'Ð': 'D',
    'Ñ': 'N',
    'Ò': 'O',
    'Ó': 'O',
    'Ô': 'O',
    'Õ': 'O',
    'Ö': 'O',
    'Ø': 'O',
    'Ù': 'U',
    'Ú': 'U',
    'Û': 'U',
    'Ü': 'U',
    'Ý': 'Y',
    'Þ': 'o',
    'ß': 'B',
    'à': 'a',
    'á': 'a',
    'â': 'a',
    'ã': 'a',
    'ä': 'a',
    'å': 'a',
    'æ': 'a',
    'ç': 'c',
    'è': 'e',
    'é': 'e',
    'ê': 'e',
    'ë': 'e',
    'ì': 'i',
    'í': 'i',
    'î': 'i',
    'ï': 'i',
    'ð': 'd',
    'ñ': 'n',
    'ò': 'o',
    'ó': 'o',
    'ô': 'o',
    'õ': 'o',
    'ö': 'o',
    'ø': 'o',
    'ù': 'u',
    'ú': 'u',
    'û': 'u',
    'ü': 'u',
    'ý': 'y',
    'þ': 'o',
    'ÿ': 'y',

    // Cyrillic
    'А': 'A',
    'Б': 'B',
    'В': 'B',
    'Г': 'F',
    'Д': 'A',
    'Е': 'E',
    'Ж': 'K',
    'З': '3',
    'И': 'N',
    'Й': 'N',
    'К': 'K',
    'Л': 'N',
    'М': 'M',
    'Н': 'H',
    'О': 'O',
    'П': 'N',
    'Р': 'P',
    'С': 'C',
    'Т': 'T',
    'У': 'y',
    'Ф': 'O',
    'Х': 'X',
    'Ц': 'U',
    'Ч': 'h',
    'Ш': 'W',
    'Щ': 'W',
    'Ъ': 'B',
    'Ы': 'X',
    'Ь': 'B',
    'Э': '3',
    'Ю': 'X',
    'Я': 'R',
    'а': 'a',
    'б': 'b',
    'в': 'a',
    'г': 'r',
    'д': 'y',
    'е': 'e',
    'ж': 'm',
    'з': 'e',
    'и': 'n',
    'й': 'n',
    'к': 'n',
    'л': 'n',
    'м': 'm',
    'н': 'n',
    'о': 'o',
    'п': 'n',
    'р': 'p',
    'с': 'c',
    'т': 'o',
    'у': 'y',
    'ф': 'b',
    'х': 'x',
    'ц': 'n',
    'ч': 'n',
    'ш': 'w',
    'щ': 'w',
    'ъ': 'a',
    'ы': 'm',
    'ь': 'a',
    'э': 'e',
    'ю': 'm',
    'я': 'r'
};

/**
 * This function is a convenience function for looking up information in the
 * metricMap table. It takes a character as a string, and a style.
 *
 * Note: the `width` property may be undefined if fontMetricsData.js wasn't
 * built using `Make extended_metrics`.
 */
var getCharacterMetrics = function(character, style) {
    var ch = character.charCodeAt(0);
    if (character[0] in extraCharacterMap) {
        ch = extraCharacterMap[character[0]].charCodeAt(0);
    } else if (cjkRegex.test(character[0])) {
        ch = 'M'.charCodeAt(0);
    }
    var metrics = metricMap[style][ch];
    if (metrics) {
        return {
            depth: metrics[0],
            height: metrics[1],
            italic: metrics[2],
            skew: metrics[3],
            width: metrics[4]
        };
    }
};

module.exports = {
    metrics: metrics,
    sigmas: sigmas,
    getCharacterMetrics: getCharacterMetrics
};

},{"./Style":97,"./fontMetricsData":106,"./unicodeRegexes":112}],106:[function(require,module,exports){
module.exports = {
    "AMS-Regular": {
        "65": [0, 0.68889, 0, 0],
        "66": [0, 0.68889, 0, 0],
        "67": [0, 0.68889, 0, 0],
        "68": [0, 0.68889, 0, 0],
        "69": [0, 0.68889, 0, 0],
        "70": [0, 0.68889, 0, 0],
        "71": [0, 0.68889, 0, 0],
        "72": [0, 0.68889, 0, 0],
        "73": [0, 0.68889, 0, 0],
        "74": [0.16667, 0.68889, 0, 0],
        "75": [0, 0.68889, 0, 0],
        "76": [0, 0.68889, 0, 0],
        "77": [0, 0.68889, 0, 0],
        "78": [0, 0.68889, 0, 0],
        "79": [0.16667, 0.68889, 0, 0],
        "80": [0, 0.68889, 0, 0],
        "81": [0.16667, 0.68889, 0, 0],
        "82": [0, 0.68889, 0, 0],
        "83": [0, 0.68889, 0, 0],
        "84": [0, 0.68889, 0, 0],
        "85": [0, 0.68889, 0, 0],
        "86": [0, 0.68889, 0, 0],
        "87": [0, 0.68889, 0, 0],
        "88": [0, 0.68889, 0, 0],
        "89": [0, 0.68889, 0, 0],
        "90": [0, 0.68889, 0, 0],
        "107": [0, 0.68889, 0, 0],
        "165": [0, 0.675, 0.025, 0],
        "174": [0.15559, 0.69224, 0, 0],
        "240": [0, 0.68889, 0, 0],
        "295": [0, 0.68889, 0, 0],
        "710": [0, 0.825, 0, 0],
        "732": [0, 0.9, 0, 0],
        "770": [0, 0.825, 0, 0],
        "771": [0, 0.9, 0, 0],
        "989": [0.08167, 0.58167, 0, 0],
        "1008": [0, 0.43056, 0.04028, 0],
        "8245": [0, 0.54986, 0, 0],
        "8463": [0, 0.68889, 0, 0],
        "8487": [0, 0.68889, 0, 0],
        "8498": [0, 0.68889, 0, 0],
        "8502": [0, 0.68889, 0, 0],
        "8503": [0, 0.68889, 0, 0],
        "8504": [0, 0.68889, 0, 0],
        "8513": [0, 0.68889, 0, 0],
        "8592": [-0.03598, 0.46402, 0, 0],
        "8594": [-0.03598, 0.46402, 0, 0],
        "8602": [-0.13313, 0.36687, 0, 0],
        "8603": [-0.13313, 0.36687, 0, 0],
        "8606": [0.01354, 0.52239, 0, 0],
        "8608": [0.01354, 0.52239, 0, 0],
        "8610": [0.01354, 0.52239, 0, 0],
        "8611": [0.01354, 0.52239, 0, 0],
        "8619": [0, 0.54986, 0, 0],
        "8620": [0, 0.54986, 0, 0],
        "8621": [-0.13313, 0.37788, 0, 0],
        "8622": [-0.13313, 0.36687, 0, 0],
        "8624": [0, 0.69224, 0, 0],
        "8625": [0, 0.69224, 0, 0],
        "8630": [0, 0.43056, 0, 0],
        "8631": [0, 0.43056, 0, 0],
        "8634": [0.08198, 0.58198, 0, 0],
        "8635": [0.08198, 0.58198, 0, 0],
        "8638": [0.19444, 0.69224, 0, 0],
        "8639": [0.19444, 0.69224, 0, 0],
        "8642": [0.19444, 0.69224, 0, 0],
        "8643": [0.19444, 0.69224, 0, 0],
        "8644": [0.1808, 0.675, 0, 0],
        "8646": [0.1808, 0.675, 0, 0],
        "8647": [0.1808, 0.675, 0, 0],
        "8648": [0.19444, 0.69224, 0, 0],
        "8649": [0.1808, 0.675, 0, 0],
        "8650": [0.19444, 0.69224, 0, 0],
        "8651": [0.01354, 0.52239, 0, 0],
        "8652": [0.01354, 0.52239, 0, 0],
        "8653": [-0.13313, 0.36687, 0, 0],
        "8654": [-0.13313, 0.36687, 0, 0],
        "8655": [-0.13313, 0.36687, 0, 0],
        "8666": [0.13667, 0.63667, 0, 0],
        "8667": [0.13667, 0.63667, 0, 0],
        "8669": [-0.13313, 0.37788, 0, 0],
        "8672": [-0.064, 0.437, 0, 0],
        "8674": [-0.064, 0.437, 0, 0],
        "8705": [0, 0.825, 0, 0],
        "8708": [0, 0.68889, 0, 0],
        "8709": [0.08167, 0.58167, 0, 0],
        "8717": [0, 0.43056, 0, 0],
        "8722": [-0.03598, 0.46402, 0, 0],
        "8724": [0.08198, 0.69224, 0, 0],
        "8726": [0.08167, 0.58167, 0, 0],
        "8733": [0, 0.69224, 0, 0],
        "8736": [0, 0.69224, 0, 0],
        "8737": [0, 0.69224, 0, 0],
        "8738": [0.03517, 0.52239, 0, 0],
        "8739": [0.08167, 0.58167, 0, 0],
        "8740": [0.25142, 0.74111, 0, 0],
        "8741": [0.08167, 0.58167, 0, 0],
        "8742": [0.25142, 0.74111, 0, 0],
        "8756": [0, 0.69224, 0, 0],
        "8757": [0, 0.69224, 0, 0],
        "8764": [-0.13313, 0.36687, 0, 0],
        "8765": [-0.13313, 0.37788, 0, 0],
        "8769": [-0.13313, 0.36687, 0, 0],
        "8770": [-0.03625, 0.46375, 0, 0],
        "8774": [0.30274, 0.79383, 0, 0],
        "8776": [-0.01688, 0.48312, 0, 0],
        "8778": [0.08167, 0.58167, 0, 0],
        "8782": [0.06062, 0.54986, 0, 0],
        "8783": [0.06062, 0.54986, 0, 0],
        "8785": [0.08198, 0.58198, 0, 0],
        "8786": [0.08198, 0.58198, 0, 0],
        "8787": [0.08198, 0.58198, 0, 0],
        "8790": [0, 0.69224, 0, 0],
        "8791": [0.22958, 0.72958, 0, 0],
        "8796": [0.08198, 0.91667, 0, 0],
        "8806": [0.25583, 0.75583, 0, 0],
        "8807": [0.25583, 0.75583, 0, 0],
        "8808": [0.25142, 0.75726, 0, 0],
        "8809": [0.25142, 0.75726, 0, 0],
        "8812": [0.25583, 0.75583, 0, 0],
        "8814": [0.20576, 0.70576, 0, 0],
        "8815": [0.20576, 0.70576, 0, 0],
        "8816": [0.30274, 0.79383, 0, 0],
        "8817": [0.30274, 0.79383, 0, 0],
        "8818": [0.22958, 0.72958, 0, 0],
        "8819": [0.22958, 0.72958, 0, 0],
        "8822": [0.1808, 0.675, 0, 0],
        "8823": [0.1808, 0.675, 0, 0],
        "8828": [0.13667, 0.63667, 0, 0],
        "8829": [0.13667, 0.63667, 0, 0],
        "8830": [0.22958, 0.72958, 0, 0],
        "8831": [0.22958, 0.72958, 0, 0],
        "8832": [0.20576, 0.70576, 0, 0],
        "8833": [0.20576, 0.70576, 0, 0],
        "8840": [0.30274, 0.79383, 0, 0],
        "8841": [0.30274, 0.79383, 0, 0],
        "8842": [0.13597, 0.63597, 0, 0],
        "8843": [0.13597, 0.63597, 0, 0],
        "8847": [0.03517, 0.54986, 0, 0],
        "8848": [0.03517, 0.54986, 0, 0],
        "8858": [0.08198, 0.58198, 0, 0],
        "8859": [0.08198, 0.58198, 0, 0],
        "8861": [0.08198, 0.58198, 0, 0],
        "8862": [0, 0.675, 0, 0],
        "8863": [0, 0.675, 0, 0],
        "8864": [0, 0.675, 0, 0],
        "8865": [0, 0.675, 0, 0],
        "8872": [0, 0.69224, 0, 0],
        "8873": [0, 0.69224, 0, 0],
        "8874": [0, 0.69224, 0, 0],
        "8876": [0, 0.68889, 0, 0],
        "8877": [0, 0.68889, 0, 0],
        "8878": [0, 0.68889, 0, 0],
        "8879": [0, 0.68889, 0, 0],
        "8882": [0.03517, 0.54986, 0, 0],
        "8883": [0.03517, 0.54986, 0, 0],
        "8884": [0.13667, 0.63667, 0, 0],
        "8885": [0.13667, 0.63667, 0, 0],
        "8888": [0, 0.54986, 0, 0],
        "8890": [0.19444, 0.43056, 0, 0],
        "8891": [0.19444, 0.69224, 0, 0],
        "8892": [0.19444, 0.69224, 0, 0],
        "8901": [0, 0.54986, 0, 0],
        "8903": [0.08167, 0.58167, 0, 0],
        "8905": [0.08167, 0.58167, 0, 0],
        "8906": [0.08167, 0.58167, 0, 0],
        "8907": [0, 0.69224, 0, 0],
        "8908": [0, 0.69224, 0, 0],
        "8909": [-0.03598, 0.46402, 0, 0],
        "8910": [0, 0.54986, 0, 0],
        "8911": [0, 0.54986, 0, 0],
        "8912": [0.03517, 0.54986, 0, 0],
        "8913": [0.03517, 0.54986, 0, 0],
        "8914": [0, 0.54986, 0, 0],
        "8915": [0, 0.54986, 0, 0],
        "8916": [0, 0.69224, 0, 0],
        "8918": [0.0391, 0.5391, 0, 0],
        "8919": [0.0391, 0.5391, 0, 0],
        "8920": [0.03517, 0.54986, 0, 0],
        "8921": [0.03517, 0.54986, 0, 0],
        "8922": [0.38569, 0.88569, 0, 0],
        "8923": [0.38569, 0.88569, 0, 0],
        "8926": [0.13667, 0.63667, 0, 0],
        "8927": [0.13667, 0.63667, 0, 0],
        "8928": [0.30274, 0.79383, 0, 0],
        "8929": [0.30274, 0.79383, 0, 0],
        "8934": [0.23222, 0.74111, 0, 0],
        "8935": [0.23222, 0.74111, 0, 0],
        "8936": [0.23222, 0.74111, 0, 0],
        "8937": [0.23222, 0.74111, 0, 0],
        "8938": [0.20576, 0.70576, 0, 0],
        "8939": [0.20576, 0.70576, 0, 0],
        "8940": [0.30274, 0.79383, 0, 0],
        "8941": [0.30274, 0.79383, 0, 0],
        "8994": [0.19444, 0.69224, 0, 0],
        "8995": [0.19444, 0.69224, 0, 0],
        "9416": [0.15559, 0.69224, 0, 0],
        "9484": [0, 0.69224, 0, 0],
        "9488": [0, 0.69224, 0, 0],
        "9492": [0, 0.37788, 0, 0],
        "9496": [0, 0.37788, 0, 0],
        "9585": [0.19444, 0.68889, 0, 0],
        "9586": [0.19444, 0.74111, 0, 0],
        "9632": [0, 0.675, 0, 0],
        "9633": [0, 0.675, 0, 0],
        "9650": [0, 0.54986, 0, 0],
        "9651": [0, 0.54986, 0, 0],
        "9654": [0.03517, 0.54986, 0, 0],
        "9660": [0, 0.54986, 0, 0],
        "9661": [0, 0.54986, 0, 0],
        "9664": [0.03517, 0.54986, 0, 0],
        "9674": [0.11111, 0.69224, 0, 0],
        "9733": [0.19444, 0.69224, 0, 0],
        "10003": [0, 0.69224, 0, 0],
        "10016": [0, 0.69224, 0, 0],
        "10731": [0.11111, 0.69224, 0, 0],
        "10846": [0.19444, 0.75583, 0, 0],
        "10877": [0.13667, 0.63667, 0, 0],
        "10878": [0.13667, 0.63667, 0, 0],
        "10885": [0.25583, 0.75583, 0, 0],
        "10886": [0.25583, 0.75583, 0, 0],
        "10887": [0.13597, 0.63597, 0, 0],
        "10888": [0.13597, 0.63597, 0, 0],
        "10889": [0.26167, 0.75726, 0, 0],
        "10890": [0.26167, 0.75726, 0, 0],
        "10891": [0.48256, 0.98256, 0, 0],
        "10892": [0.48256, 0.98256, 0, 0],
        "10901": [0.13667, 0.63667, 0, 0],
        "10902": [0.13667, 0.63667, 0, 0],
        "10933": [0.25142, 0.75726, 0, 0],
        "10934": [0.25142, 0.75726, 0, 0],
        "10935": [0.26167, 0.75726, 0, 0],
        "10936": [0.26167, 0.75726, 0, 0],
        "10937": [0.26167, 0.75726, 0, 0],
        "10938": [0.26167, 0.75726, 0, 0],
        "10949": [0.25583, 0.75583, 0, 0],
        "10950": [0.25583, 0.75583, 0, 0],
        "10955": [0.28481, 0.79383, 0, 0],
        "10956": [0.28481, 0.79383, 0, 0],
        "57350": [0.08167, 0.58167, 0, 0],
        "57351": [0.08167, 0.58167, 0, 0],
        "57352": [0.08167, 0.58167, 0, 0],
        "57353": [0, 0.43056, 0.04028, 0],
        "57356": [0.25142, 0.75726, 0, 0],
        "57357": [0.25142, 0.75726, 0, 0],
        "57358": [0.41951, 0.91951, 0, 0],
        "57359": [0.30274, 0.79383, 0, 0],
        "57360": [0.30274, 0.79383, 0, 0],
        "57361": [0.41951, 0.91951, 0, 0],
        "57366": [0.25142, 0.75726, 0, 0],
        "57367": [0.25142, 0.75726, 0, 0],
        "57368": [0.25142, 0.75726, 0, 0],
        "57369": [0.25142, 0.75726, 0, 0],
        "57370": [0.13597, 0.63597, 0, 0],
        "57371": [0.13597, 0.63597, 0, 0]
    },
    "Caligraphic-Regular": {
        "48": [0, 0.43056, 0, 0],
        "49": [0, 0.43056, 0, 0],
        "50": [0, 0.43056, 0, 0],
        "51": [0.19444, 0.43056, 0, 0],
        "52": [0.19444, 0.43056, 0, 0],
        "53": [0.19444, 0.43056, 0, 0],
        "54": [0, 0.64444, 0, 0],
        "55": [0.19444, 0.43056, 0, 0],
        "56": [0, 0.64444, 0, 0],
        "57": [0.19444, 0.43056, 0, 0],
        "65": [0, 0.68333, 0, 0.19445],
        "66": [0, 0.68333, 0.03041, 0.13889],
        "67": [0, 0.68333, 0.05834, 0.13889],
        "68": [0, 0.68333, 0.02778, 0.08334],
        "69": [0, 0.68333, 0.08944, 0.11111],
        "70": [0, 0.68333, 0.09931, 0.11111],
        "71": [0.09722, 0.68333, 0.0593, 0.11111],
        "72": [0, 0.68333, 0.00965, 0.11111],
        "73": [0, 0.68333, 0.07382, 0],
        "74": [0.09722, 0.68333, 0.18472, 0.16667],
        "75": [0, 0.68333, 0.01445, 0.05556],
        "76": [0, 0.68333, 0, 0.13889],
        "77": [0, 0.68333, 0, 0.13889],
        "78": [0, 0.68333, 0.14736, 0.08334],
        "79": [0, 0.68333, 0.02778, 0.11111],
        "80": [0, 0.68333, 0.08222, 0.08334],
        "81": [0.09722, 0.68333, 0, 0.11111],
        "82": [0, 0.68333, 0, 0.08334],
        "83": [0, 0.68333, 0.075, 0.13889],
        "84": [0, 0.68333, 0.25417, 0],
        "85": [0, 0.68333, 0.09931, 0.08334],
        "86": [0, 0.68333, 0.08222, 0],
        "87": [0, 0.68333, 0.08222, 0.08334],
        "88": [0, 0.68333, 0.14643, 0.13889],
        "89": [0.09722, 0.68333, 0.08222, 0.08334],
        "90": [0, 0.68333, 0.07944, 0.13889]
    },
    "Fraktur-Regular": {
        "33": [0, 0.69141, 0, 0],
        "34": [0, 0.69141, 0, 0],
        "38": [0, 0.69141, 0, 0],
        "39": [0, 0.69141, 0, 0],
        "40": [0.24982, 0.74947, 0, 0],
        "41": [0.24982, 0.74947, 0, 0],
        "42": [0, 0.62119, 0, 0],
        "43": [0.08319, 0.58283, 0, 0],
        "44": [0, 0.10803, 0, 0],
        "45": [0.08319, 0.58283, 0, 0],
        "46": [0, 0.10803, 0, 0],
        "47": [0.24982, 0.74947, 0, 0],
        "48": [0, 0.47534, 0, 0],
        "49": [0, 0.47534, 0, 0],
        "50": [0, 0.47534, 0, 0],
        "51": [0.18906, 0.47534, 0, 0],
        "52": [0.18906, 0.47534, 0, 0],
        "53": [0.18906, 0.47534, 0, 0],
        "54": [0, 0.69141, 0, 0],
        "55": [0.18906, 0.47534, 0, 0],
        "56": [0, 0.69141, 0, 0],
        "57": [0.18906, 0.47534, 0, 0],
        "58": [0, 0.47534, 0, 0],
        "59": [0.12604, 0.47534, 0, 0],
        "61": [-0.13099, 0.36866, 0, 0],
        "63": [0, 0.69141, 0, 0],
        "65": [0, 0.69141, 0, 0],
        "66": [0, 0.69141, 0, 0],
        "67": [0, 0.69141, 0, 0],
        "68": [0, 0.69141, 0, 0],
        "69": [0, 0.69141, 0, 0],
        "70": [0.12604, 0.69141, 0, 0],
        "71": [0, 0.69141, 0, 0],
        "72": [0.06302, 0.69141, 0, 0],
        "73": [0, 0.69141, 0, 0],
        "74": [0.12604, 0.69141, 0, 0],
        "75": [0, 0.69141, 0, 0],
        "76": [0, 0.69141, 0, 0],
        "77": [0, 0.69141, 0, 0],
        "78": [0, 0.69141, 0, 0],
        "79": [0, 0.69141, 0, 0],
        "80": [0.18906, 0.69141, 0, 0],
        "81": [0.03781, 0.69141, 0, 0],
        "82": [0, 0.69141, 0, 0],
        "83": [0, 0.69141, 0, 0],
        "84": [0, 0.69141, 0, 0],
        "85": [0, 0.69141, 0, 0],
        "86": [0, 0.69141, 0, 0],
        "87": [0, 0.69141, 0, 0],
        "88": [0, 0.69141, 0, 0],
        "89": [0.18906, 0.69141, 0, 0],
        "90": [0.12604, 0.69141, 0, 0],
        "91": [0.24982, 0.74947, 0, 0],
        "93": [0.24982, 0.74947, 0, 0],
        "94": [0, 0.69141, 0, 0],
        "97": [0, 0.47534, 0, 0],
        "98": [0, 0.69141, 0, 0],
        "99": [0, 0.47534, 0, 0],
        "100": [0, 0.62119, 0, 0],
        "101": [0, 0.47534, 0, 0],
        "102": [0.18906, 0.69141, 0, 0],
        "103": [0.18906, 0.47534, 0, 0],
        "104": [0.18906, 0.69141, 0, 0],
        "105": [0, 0.69141, 0, 0],
        "106": [0, 0.69141, 0, 0],
        "107": [0, 0.69141, 0, 0],
        "108": [0, 0.69141, 0, 0],
        "109": [0, 0.47534, 0, 0],
        "110": [0, 0.47534, 0, 0],
        "111": [0, 0.47534, 0, 0],
        "112": [0.18906, 0.52396, 0, 0],
        "113": [0.18906, 0.47534, 0, 0],
        "114": [0, 0.47534, 0, 0],
        "115": [0, 0.47534, 0, 0],
        "116": [0, 0.62119, 0, 0],
        "117": [0, 0.47534, 0, 0],
        "118": [0, 0.52396, 0, 0],
        "119": [0, 0.52396, 0, 0],
        "120": [0.18906, 0.47534, 0, 0],
        "121": [0.18906, 0.47534, 0, 0],
        "122": [0.18906, 0.47534, 0, 0],
        "8216": [0, 0.69141, 0, 0],
        "8217": [0, 0.69141, 0, 0],
        "58112": [0, 0.62119, 0, 0],
        "58113": [0, 0.62119, 0, 0],
        "58114": [0.18906, 0.69141, 0, 0],
        "58115": [0.18906, 0.69141, 0, 0],
        "58116": [0.18906, 0.47534, 0, 0],
        "58117": [0, 0.69141, 0, 0],
        "58118": [0, 0.62119, 0, 0],
        "58119": [0, 0.47534, 0, 0]
    },
    "Main-Bold": {
        "33": [0, 0.69444, 0, 0],
        "34": [0, 0.69444, 0, 0],
        "35": [0.19444, 0.69444, 0, 0],
        "36": [0.05556, 0.75, 0, 0],
        "37": [0.05556, 0.75, 0, 0],
        "38": [0, 0.69444, 0, 0],
        "39": [0, 0.69444, 0, 0],
        "40": [0.25, 0.75, 0, 0],
        "41": [0.25, 0.75, 0, 0],
        "42": [0, 0.75, 0, 0],
        "43": [0.13333, 0.63333, 0, 0],
        "44": [0.19444, 0.15556, 0, 0],
        "45": [0, 0.44444, 0, 0],
        "46": [0, 0.15556, 0, 0],
        "47": [0.25, 0.75, 0, 0],
        "48": [0, 0.64444, 0, 0],
        "49": [0, 0.64444, 0, 0],
        "50": [0, 0.64444, 0, 0],
        "51": [0, 0.64444, 0, 0],
        "52": [0, 0.64444, 0, 0],
        "53": [0, 0.64444, 0, 0],
        "54": [0, 0.64444, 0, 0],
        "55": [0, 0.64444, 0, 0],
        "56": [0, 0.64444, 0, 0],
        "57": [0, 0.64444, 0, 0],
        "58": [0, 0.44444, 0, 0],
        "59": [0.19444, 0.44444, 0, 0],
        "60": [0.08556, 0.58556, 0, 0],
        "61": [-0.10889, 0.39111, 0, 0],
        "62": [0.08556, 0.58556, 0, 0],
        "63": [0, 0.69444, 0, 0],
        "64": [0, 0.69444, 0, 0],
        "65": [0, 0.68611, 0, 0],
        "66": [0, 0.68611, 0, 0],
        "67": [0, 0.68611, 0, 0],
        "68": [0, 0.68611, 0, 0],
        "69": [0, 0.68611, 0, 0],
        "70": [0, 0.68611, 0, 0],
        "71": [0, 0.68611, 0, 0],
        "72": [0, 0.68611, 0, 0],
        "73": [0, 0.68611, 0, 0],
        "74": [0, 0.68611, 0, 0],
        "75": [0, 0.68611, 0, 0],
        "76": [0, 0.68611, 0, 0],
        "77": [0, 0.68611, 0, 0],
        "78": [0, 0.68611, 0, 0],
        "79": [0, 0.68611, 0, 0],
        "80": [0, 0.68611, 0, 0],
        "81": [0.19444, 0.68611, 0, 0],
        "82": [0, 0.68611, 0, 0],
        "83": [0, 0.68611, 0, 0],
        "84": [0, 0.68611, 0, 0],
        "85": [0, 0.68611, 0, 0],
        "86": [0, 0.68611, 0.01597, 0],
        "87": [0, 0.68611, 0.01597, 0],
        "88": [0, 0.68611, 0, 0],
        "89": [0, 0.68611, 0.02875, 0],
        "90": [0, 0.68611, 0, 0],
        "91": [0.25, 0.75, 0, 0],
        "92": [0.25, 0.75, 0, 0],
        "93": [0.25, 0.75, 0, 0],
        "94": [0, 0.69444, 0, 0],
        "95": [0.31, 0.13444, 0.03194, 0],
        "96": [0, 0.69444, 0, 0],
        "97": [0, 0.44444, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.44444, 0, 0],
        "100": [0, 0.69444, 0, 0],
        "101": [0, 0.44444, 0, 0],
        "102": [0, 0.69444, 0.10903, 0],
        "103": [0.19444, 0.44444, 0.01597, 0],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.69444, 0, 0],
        "106": [0.19444, 0.69444, 0, 0],
        "107": [0, 0.69444, 0, 0],
        "108": [0, 0.69444, 0, 0],
        "109": [0, 0.44444, 0, 0],
        "110": [0, 0.44444, 0, 0],
        "111": [0, 0.44444, 0, 0],
        "112": [0.19444, 0.44444, 0, 0],
        "113": [0.19444, 0.44444, 0, 0],
        "114": [0, 0.44444, 0, 0],
        "115": [0, 0.44444, 0, 0],
        "116": [0, 0.63492, 0, 0],
        "117": [0, 0.44444, 0, 0],
        "118": [0, 0.44444, 0.01597, 0],
        "119": [0, 0.44444, 0.01597, 0],
        "120": [0, 0.44444, 0, 0],
        "121": [0.19444, 0.44444, 0.01597, 0],
        "122": [0, 0.44444, 0, 0],
        "123": [0.25, 0.75, 0, 0],
        "124": [0.25, 0.75, 0, 0],
        "125": [0.25, 0.75, 0, 0],
        "126": [0.35, 0.34444, 0, 0],
        "168": [0, 0.69444, 0, 0],
        "172": [0, 0.44444, 0, 0],
        "175": [0, 0.59611, 0, 0],
        "176": [0, 0.69444, 0, 0],
        "177": [0.13333, 0.63333, 0, 0],
        "180": [0, 0.69444, 0, 0],
        "215": [0.13333, 0.63333, 0, 0],
        "247": [0.13333, 0.63333, 0, 0],
        "305": [0, 0.44444, 0, 0],
        "567": [0.19444, 0.44444, 0, 0],
        "710": [0, 0.69444, 0, 0],
        "711": [0, 0.63194, 0, 0],
        "713": [0, 0.59611, 0, 0],
        "714": [0, 0.69444, 0, 0],
        "715": [0, 0.69444, 0, 0],
        "728": [0, 0.69444, 0, 0],
        "729": [0, 0.69444, 0, 0],
        "730": [0, 0.69444, 0, 0],
        "732": [0, 0.69444, 0, 0],
        "768": [0, 0.69444, 0, 0],
        "769": [0, 0.69444, 0, 0],
        "770": [0, 0.69444, 0, 0],
        "771": [0, 0.69444, 0, 0],
        "772": [0, 0.59611, 0, 0],
        "774": [0, 0.69444, 0, 0],
        "775": [0, 0.69444, 0, 0],
        "776": [0, 0.69444, 0, 0],
        "778": [0, 0.69444, 0, 0],
        "779": [0, 0.69444, 0, 0],
        "780": [0, 0.63194, 0, 0],
        "824": [0.19444, 0.69444, 0, 0],
        "915": [0, 0.68611, 0, 0],
        "916": [0, 0.68611, 0, 0],
        "920": [0, 0.68611, 0, 0],
        "923": [0, 0.68611, 0, 0],
        "926": [0, 0.68611, 0, 0],
        "928": [0, 0.68611, 0, 0],
        "931": [0, 0.68611, 0, 0],
        "933": [0, 0.68611, 0, 0],
        "934": [0, 0.68611, 0, 0],
        "936": [0, 0.68611, 0, 0],
        "937": [0, 0.68611, 0, 0],
        "8211": [0, 0.44444, 0.03194, 0],
        "8212": [0, 0.44444, 0.03194, 0],
        "8216": [0, 0.69444, 0, 0],
        "8217": [0, 0.69444, 0, 0],
        "8220": [0, 0.69444, 0, 0],
        "8221": [0, 0.69444, 0, 0],
        "8224": [0.19444, 0.69444, 0, 0],
        "8225": [0.19444, 0.69444, 0, 0],
        "8242": [0, 0.55556, 0, 0],
        "8407": [0, 0.72444, 0.15486, 0],
        "8463": [0, 0.69444, 0, 0],
        "8465": [0, 0.69444, 0, 0],
        "8467": [0, 0.69444, 0, 0],
        "8472": [0.19444, 0.44444, 0, 0],
        "8476": [0, 0.69444, 0, 0],
        "8501": [0, 0.69444, 0, 0],
        "8592": [-0.10889, 0.39111, 0, 0],
        "8593": [0.19444, 0.69444, 0, 0],
        "8594": [-0.10889, 0.39111, 0, 0],
        "8595": [0.19444, 0.69444, 0, 0],
        "8596": [-0.10889, 0.39111, 0, 0],
        "8597": [0.25, 0.75, 0, 0],
        "8598": [0.19444, 0.69444, 0, 0],
        "8599": [0.19444, 0.69444, 0, 0],
        "8600": [0.19444, 0.69444, 0, 0],
        "8601": [0.19444, 0.69444, 0, 0],
        "8636": [-0.10889, 0.39111, 0, 0],
        "8637": [-0.10889, 0.39111, 0, 0],
        "8640": [-0.10889, 0.39111, 0, 0],
        "8641": [-0.10889, 0.39111, 0, 0],
        "8656": [-0.10889, 0.39111, 0, 0],
        "8657": [0.19444, 0.69444, 0, 0],
        "8658": [-0.10889, 0.39111, 0, 0],
        "8659": [0.19444, 0.69444, 0, 0],
        "8660": [-0.10889, 0.39111, 0, 0],
        "8661": [0.25, 0.75, 0, 0],
        "8704": [0, 0.69444, 0, 0],
        "8706": [0, 0.69444, 0.06389, 0],
        "8707": [0, 0.69444, 0, 0],
        "8709": [0.05556, 0.75, 0, 0],
        "8711": [0, 0.68611, 0, 0],
        "8712": [0.08556, 0.58556, 0, 0],
        "8715": [0.08556, 0.58556, 0, 0],
        "8722": [0.13333, 0.63333, 0, 0],
        "8723": [0.13333, 0.63333, 0, 0],
        "8725": [0.25, 0.75, 0, 0],
        "8726": [0.25, 0.75, 0, 0],
        "8727": [-0.02778, 0.47222, 0, 0],
        "8728": [-0.02639, 0.47361, 0, 0],
        "8729": [-0.02639, 0.47361, 0, 0],
        "8730": [0.18, 0.82, 0, 0],
        "8733": [0, 0.44444, 0, 0],
        "8734": [0, 0.44444, 0, 0],
        "8736": [0, 0.69224, 0, 0],
        "8739": [0.25, 0.75, 0, 0],
        "8741": [0.25, 0.75, 0, 0],
        "8743": [0, 0.55556, 0, 0],
        "8744": [0, 0.55556, 0, 0],
        "8745": [0, 0.55556, 0, 0],
        "8746": [0, 0.55556, 0, 0],
        "8747": [0.19444, 0.69444, 0.12778, 0],
        "8764": [-0.10889, 0.39111, 0, 0],
        "8768": [0.19444, 0.69444, 0, 0],
        "8771": [0.00222, 0.50222, 0, 0],
        "8776": [0.02444, 0.52444, 0, 0],
        "8781": [0.00222, 0.50222, 0, 0],
        "8801": [0.00222, 0.50222, 0, 0],
        "8804": [0.19667, 0.69667, 0, 0],
        "8805": [0.19667, 0.69667, 0, 0],
        "8810": [0.08556, 0.58556, 0, 0],
        "8811": [0.08556, 0.58556, 0, 0],
        "8826": [0.08556, 0.58556, 0, 0],
        "8827": [0.08556, 0.58556, 0, 0],
        "8834": [0.08556, 0.58556, 0, 0],
        "8835": [0.08556, 0.58556, 0, 0],
        "8838": [0.19667, 0.69667, 0, 0],
        "8839": [0.19667, 0.69667, 0, 0],
        "8846": [0, 0.55556, 0, 0],
        "8849": [0.19667, 0.69667, 0, 0],
        "8850": [0.19667, 0.69667, 0, 0],
        "8851": [0, 0.55556, 0, 0],
        "8852": [0, 0.55556, 0, 0],
        "8853": [0.13333, 0.63333, 0, 0],
        "8854": [0.13333, 0.63333, 0, 0],
        "8855": [0.13333, 0.63333, 0, 0],
        "8856": [0.13333, 0.63333, 0, 0],
        "8857": [0.13333, 0.63333, 0, 0],
        "8866": [0, 0.69444, 0, 0],
        "8867": [0, 0.69444, 0, 0],
        "8868": [0, 0.69444, 0, 0],
        "8869": [0, 0.69444, 0, 0],
        "8900": [-0.02639, 0.47361, 0, 0],
        "8901": [-0.02639, 0.47361, 0, 0],
        "8902": [-0.02778, 0.47222, 0, 0],
        "8968": [0.25, 0.75, 0, 0],
        "8969": [0.25, 0.75, 0, 0],
        "8970": [0.25, 0.75, 0, 0],
        "8971": [0.25, 0.75, 0, 0],
        "8994": [-0.13889, 0.36111, 0, 0],
        "8995": [-0.13889, 0.36111, 0, 0],
        "9651": [0.19444, 0.69444, 0, 0],
        "9657": [-0.02778, 0.47222, 0, 0],
        "9661": [0.19444, 0.69444, 0, 0],
        "9667": [-0.02778, 0.47222, 0, 0],
        "9711": [0.19444, 0.69444, 0, 0],
        "9824": [0.12963, 0.69444, 0, 0],
        "9825": [0.12963, 0.69444, 0, 0],
        "9826": [0.12963, 0.69444, 0, 0],
        "9827": [0.12963, 0.69444, 0, 0],
        "9837": [0, 0.75, 0, 0],
        "9838": [0.19444, 0.69444, 0, 0],
        "9839": [0.19444, 0.69444, 0, 0],
        "10216": [0.25, 0.75, 0, 0],
        "10217": [0.25, 0.75, 0, 0],
        "10815": [0, 0.68611, 0, 0],
        "10927": [0.19667, 0.69667, 0, 0],
        "10928": [0.19667, 0.69667, 0, 0]
    },
    "Main-Italic": {
        "33": [0, 0.69444, 0.12417, 0],
        "34": [0, 0.69444, 0.06961, 0],
        "35": [0.19444, 0.69444, 0.06616, 0],
        "37": [0.05556, 0.75, 0.13639, 0],
        "38": [0, 0.69444, 0.09694, 0],
        "39": [0, 0.69444, 0.12417, 0],
        "40": [0.25, 0.75, 0.16194, 0],
        "41": [0.25, 0.75, 0.03694, 0],
        "42": [0, 0.75, 0.14917, 0],
        "43": [0.05667, 0.56167, 0.03694, 0],
        "44": [0.19444, 0.10556, 0, 0],
        "45": [0, 0.43056, 0.02826, 0],
        "46": [0, 0.10556, 0, 0],
        "47": [0.25, 0.75, 0.16194, 0],
        "48": [0, 0.64444, 0.13556, 0],
        "49": [0, 0.64444, 0.13556, 0],
        "50": [0, 0.64444, 0.13556, 0],
        "51": [0, 0.64444, 0.13556, 0],
        "52": [0.19444, 0.64444, 0.13556, 0],
        "53": [0, 0.64444, 0.13556, 0],
        "54": [0, 0.64444, 0.13556, 0],
        "55": [0.19444, 0.64444, 0.13556, 0],
        "56": [0, 0.64444, 0.13556, 0],
        "57": [0, 0.64444, 0.13556, 0],
        "58": [0, 0.43056, 0.0582, 0],
        "59": [0.19444, 0.43056, 0.0582, 0],
        "61": [-0.13313, 0.36687, 0.06616, 0],
        "63": [0, 0.69444, 0.1225, 0],
        "64": [0, 0.69444, 0.09597, 0],
        "65": [0, 0.68333, 0, 0],
        "66": [0, 0.68333, 0.10257, 0],
        "67": [0, 0.68333, 0.14528, 0],
        "68": [0, 0.68333, 0.09403, 0],
        "69": [0, 0.68333, 0.12028, 0],
        "70": [0, 0.68333, 0.13305, 0],
        "71": [0, 0.68333, 0.08722, 0],
        "72": [0, 0.68333, 0.16389, 0],
        "73": [0, 0.68333, 0.15806, 0],
        "74": [0, 0.68333, 0.14028, 0],
        "75": [0, 0.68333, 0.14528, 0],
        "76": [0, 0.68333, 0, 0],
        "77": [0, 0.68333, 0.16389, 0],
        "78": [0, 0.68333, 0.16389, 0],
        "79": [0, 0.68333, 0.09403, 0],
        "80": [0, 0.68333, 0.10257, 0],
        "81": [0.19444, 0.68333, 0.09403, 0],
        "82": [0, 0.68333, 0.03868, 0],
        "83": [0, 0.68333, 0.11972, 0],
        "84": [0, 0.68333, 0.13305, 0],
        "85": [0, 0.68333, 0.16389, 0],
        "86": [0, 0.68333, 0.18361, 0],
        "87": [0, 0.68333, 0.18361, 0],
        "88": [0, 0.68333, 0.15806, 0],
        "89": [0, 0.68333, 0.19383, 0],
        "90": [0, 0.68333, 0.14528, 0],
        "91": [0.25, 0.75, 0.1875, 0],
        "93": [0.25, 0.75, 0.10528, 0],
        "94": [0, 0.69444, 0.06646, 0],
        "95": [0.31, 0.12056, 0.09208, 0],
        "97": [0, 0.43056, 0.07671, 0],
        "98": [0, 0.69444, 0.06312, 0],
        "99": [0, 0.43056, 0.05653, 0],
        "100": [0, 0.69444, 0.10333, 0],
        "101": [0, 0.43056, 0.07514, 0],
        "102": [0.19444, 0.69444, 0.21194, 0],
        "103": [0.19444, 0.43056, 0.08847, 0],
        "104": [0, 0.69444, 0.07671, 0],
        "105": [0, 0.65536, 0.1019, 0],
        "106": [0.19444, 0.65536, 0.14467, 0],
        "107": [0, 0.69444, 0.10764, 0],
        "108": [0, 0.69444, 0.10333, 0],
        "109": [0, 0.43056, 0.07671, 0],
        "110": [0, 0.43056, 0.07671, 0],
        "111": [0, 0.43056, 0.06312, 0],
        "112": [0.19444, 0.43056, 0.06312, 0],
        "113": [0.19444, 0.43056, 0.08847, 0],
        "114": [0, 0.43056, 0.10764, 0],
        "115": [0, 0.43056, 0.08208, 0],
        "116": [0, 0.61508, 0.09486, 0],
        "117": [0, 0.43056, 0.07671, 0],
        "118": [0, 0.43056, 0.10764, 0],
        "119": [0, 0.43056, 0.10764, 0],
        "120": [0, 0.43056, 0.12042, 0],
        "121": [0.19444, 0.43056, 0.08847, 0],
        "122": [0, 0.43056, 0.12292, 0],
        "126": [0.35, 0.31786, 0.11585, 0],
        "163": [0, 0.69444, 0, 0],
        "305": [0, 0.43056, 0, 0.02778],
        "567": [0.19444, 0.43056, 0, 0.08334],
        "768": [0, 0.69444, 0, 0],
        "769": [0, 0.69444, 0.09694, 0],
        "770": [0, 0.69444, 0.06646, 0],
        "771": [0, 0.66786, 0.11585, 0],
        "772": [0, 0.56167, 0.10333, 0],
        "774": [0, 0.69444, 0.10806, 0],
        "775": [0, 0.66786, 0.11752, 0],
        "776": [0, 0.66786, 0.10474, 0],
        "778": [0, 0.69444, 0, 0],
        "779": [0, 0.69444, 0.1225, 0],
        "780": [0, 0.62847, 0.08295, 0],
        "915": [0, 0.68333, 0.13305, 0],
        "916": [0, 0.68333, 0, 0],
        "920": [0, 0.68333, 0.09403, 0],
        "923": [0, 0.68333, 0, 0],
        "926": [0, 0.68333, 0.15294, 0],
        "928": [0, 0.68333, 0.16389, 0],
        "931": [0, 0.68333, 0.12028, 0],
        "933": [0, 0.68333, 0.11111, 0],
        "934": [0, 0.68333, 0.05986, 0],
        "936": [0, 0.68333, 0.11111, 0],
        "937": [0, 0.68333, 0.10257, 0],
        "8211": [0, 0.43056, 0.09208, 0],
        "8212": [0, 0.43056, 0.09208, 0],
        "8216": [0, 0.69444, 0.12417, 0],
        "8217": [0, 0.69444, 0.12417, 0],
        "8220": [0, 0.69444, 0.1685, 0],
        "8221": [0, 0.69444, 0.06961, 0],
        "8463": [0, 0.68889, 0, 0]
    },
    "Main-Regular": {
        "32": [0, 0, 0, 0],
        "33": [0, 0.69444, 0, 0],
        "34": [0, 0.69444, 0, 0],
        "35": [0.19444, 0.69444, 0, 0],
        "36": [0.05556, 0.75, 0, 0],
        "37": [0.05556, 0.75, 0, 0],
        "38": [0, 0.69444, 0, 0],
        "39": [0, 0.69444, 0, 0],
        "40": [0.25, 0.75, 0, 0],
        "41": [0.25, 0.75, 0, 0],
        "42": [0, 0.75, 0, 0],
        "43": [0.08333, 0.58333, 0, 0],
        "44": [0.19444, 0.10556, 0, 0],
        "45": [0, 0.43056, 0, 0],
        "46": [0, 0.10556, 0, 0],
        "47": [0.25, 0.75, 0, 0],
        "48": [0, 0.64444, 0, 0],
        "49": [0, 0.64444, 0, 0],
        "50": [0, 0.64444, 0, 0],
        "51": [0, 0.64444, 0, 0],
        "52": [0, 0.64444, 0, 0],
        "53": [0, 0.64444, 0, 0],
        "54": [0, 0.64444, 0, 0],
        "55": [0, 0.64444, 0, 0],
        "56": [0, 0.64444, 0, 0],
        "57": [0, 0.64444, 0, 0],
        "58": [0, 0.43056, 0, 0],
        "59": [0.19444, 0.43056, 0, 0],
        "60": [0.0391, 0.5391, 0, 0],
        "61": [-0.13313, 0.36687, 0, 0],
        "62": [0.0391, 0.5391, 0, 0],
        "63": [0, 0.69444, 0, 0],
        "64": [0, 0.69444, 0, 0],
        "65": [0, 0.68333, 0, 0],
        "66": [0, 0.68333, 0, 0],
        "67": [0, 0.68333, 0, 0],
        "68": [0, 0.68333, 0, 0],
        "69": [0, 0.68333, 0, 0],
        "70": [0, 0.68333, 0, 0],
        "71": [0, 0.68333, 0, 0],
        "72": [0, 0.68333, 0, 0],
        "73": [0, 0.68333, 0, 0],
        "74": [0, 0.68333, 0, 0],
        "75": [0, 0.68333, 0, 0],
        "76": [0, 0.68333, 0, 0],
        "77": [0, 0.68333, 0, 0],
        "78": [0, 0.68333, 0, 0],
        "79": [0, 0.68333, 0, 0],
        "80": [0, 0.68333, 0, 0],
        "81": [0.19444, 0.68333, 0, 0],
        "82": [0, 0.68333, 0, 0],
        "83": [0, 0.68333, 0, 0],
        "84": [0, 0.68333, 0, 0],
        "85": [0, 0.68333, 0, 0],
        "86": [0, 0.68333, 0.01389, 0],
        "87": [0, 0.68333, 0.01389, 0],
        "88": [0, 0.68333, 0, 0],
        "89": [0, 0.68333, 0.025, 0],
        "90": [0, 0.68333, 0, 0],
        "91": [0.25, 0.75, 0, 0],
        "92": [0.25, 0.75, 0, 0],
        "93": [0.25, 0.75, 0, 0],
        "94": [0, 0.69444, 0, 0],
        "95": [0.31, 0.12056, 0.02778, 0],
        "96": [0, 0.69444, 0, 0],
        "97": [0, 0.43056, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.43056, 0, 0],
        "100": [0, 0.69444, 0, 0],
        "101": [0, 0.43056, 0, 0],
        "102": [0, 0.69444, 0.07778, 0],
        "103": [0.19444, 0.43056, 0.01389, 0],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.66786, 0, 0],
        "106": [0.19444, 0.66786, 0, 0],
        "107": [0, 0.69444, 0, 0],
        "108": [0, 0.69444, 0, 0],
        "109": [0, 0.43056, 0, 0],
        "110": [0, 0.43056, 0, 0],
        "111": [0, 0.43056, 0, 0],
        "112": [0.19444, 0.43056, 0, 0],
        "113": [0.19444, 0.43056, 0, 0],
        "114": [0, 0.43056, 0, 0],
        "115": [0, 0.43056, 0, 0],
        "116": [0, 0.61508, 0, 0],
        "117": [0, 0.43056, 0, 0],
        "118": [0, 0.43056, 0.01389, 0],
        "119": [0, 0.43056, 0.01389, 0],
        "120": [0, 0.43056, 0, 0],
        "121": [0.19444, 0.43056, 0.01389, 0],
        "122": [0, 0.43056, 0, 0],
        "123": [0.25, 0.75, 0, 0],
        "124": [0.25, 0.75, 0, 0],
        "125": [0.25, 0.75, 0, 0],
        "126": [0.35, 0.31786, 0, 0],
        "160": [0, 0, 0, 0],
        "168": [0, 0.66786, 0, 0],
        "172": [0, 0.43056, 0, 0],
        "175": [0, 0.56778, 0, 0],
        "176": [0, 0.69444, 0, 0],
        "177": [0.08333, 0.58333, 0, 0],
        "180": [0, 0.69444, 0, 0],
        "215": [0.08333, 0.58333, 0, 0],
        "247": [0.08333, 0.58333, 0, 0],
        "305": [0, 0.43056, 0, 0],
        "567": [0.19444, 0.43056, 0, 0],
        "710": [0, 0.69444, 0, 0],
        "711": [0, 0.62847, 0, 0],
        "713": [0, 0.56778, 0, 0],
        "714": [0, 0.69444, 0, 0],
        "715": [0, 0.69444, 0, 0],
        "728": [0, 0.69444, 0, 0],
        "729": [0, 0.66786, 0, 0],
        "730": [0, 0.69444, 0, 0],
        "732": [0, 0.66786, 0, 0],
        "768": [0, 0.69444, 0, 0],
        "769": [0, 0.69444, 0, 0],
        "770": [0, 0.69444, 0, 0],
        "771": [0, 0.66786, 0, 0],
        "772": [0, 0.56778, 0, 0],
        "774": [0, 0.69444, 0, 0],
        "775": [0, 0.66786, 0, 0],
        "776": [0, 0.66786, 0, 0],
        "778": [0, 0.69444, 0, 0],
        "779": [0, 0.69444, 0, 0],
        "780": [0, 0.62847, 0, 0],
        "824": [0.19444, 0.69444, 0, 0],
        "915": [0, 0.68333, 0, 0],
        "916": [0, 0.68333, 0, 0],
        "920": [0, 0.68333, 0, 0],
        "923": [0, 0.68333, 0, 0],
        "926": [0, 0.68333, 0, 0],
        "928": [0, 0.68333, 0, 0],
        "931": [0, 0.68333, 0, 0],
        "933": [0, 0.68333, 0, 0],
        "934": [0, 0.68333, 0, 0],
        "936": [0, 0.68333, 0, 0],
        "937": [0, 0.68333, 0, 0],
        "8211": [0, 0.43056, 0.02778, 0],
        "8212": [0, 0.43056, 0.02778, 0],
        "8216": [0, 0.69444, 0, 0],
        "8217": [0, 0.69444, 0, 0],
        "8220": [0, 0.69444, 0, 0],
        "8221": [0, 0.69444, 0, 0],
        "8224": [0.19444, 0.69444, 0, 0],
        "8225": [0.19444, 0.69444, 0, 0],
        "8230": [0, 0.12, 0, 0],
        "8242": [0, 0.55556, 0, 0],
        "8407": [0, 0.71444, 0.15382, 0],
        "8463": [0, 0.68889, 0, 0],
        "8465": [0, 0.69444, 0, 0],
        "8467": [0, 0.69444, 0, 0.11111],
        "8472": [0.19444, 0.43056, 0, 0.11111],
        "8476": [0, 0.69444, 0, 0],
        "8501": [0, 0.69444, 0, 0],
        "8592": [-0.13313, 0.36687, 0, 0],
        "8593": [0.19444, 0.69444, 0, 0],
        "8594": [-0.13313, 0.36687, 0, 0],
        "8595": [0.19444, 0.69444, 0, 0],
        "8596": [-0.13313, 0.36687, 0, 0],
        "8597": [0.25, 0.75, 0, 0],
        "8598": [0.19444, 0.69444, 0, 0],
        "8599": [0.19444, 0.69444, 0, 0],
        "8600": [0.19444, 0.69444, 0, 0],
        "8601": [0.19444, 0.69444, 0, 0],
        "8614": [0.011, 0.511, 0, 0],
        "8617": [0.011, 0.511, 0, 0],
        "8618": [0.011, 0.511, 0, 0],
        "8636": [-0.13313, 0.36687, 0, 0],
        "8637": [-0.13313, 0.36687, 0, 0],
        "8640": [-0.13313, 0.36687, 0, 0],
        "8641": [-0.13313, 0.36687, 0, 0],
        "8652": [0.011, 0.671, 0, 0],
        "8656": [-0.13313, 0.36687, 0, 0],
        "8657": [0.19444, 0.69444, 0, 0],
        "8658": [-0.13313, 0.36687, 0, 0],
        "8659": [0.19444, 0.69444, 0, 0],
        "8660": [-0.13313, 0.36687, 0, 0],
        "8661": [0.25, 0.75, 0, 0],
        "8704": [0, 0.69444, 0, 0],
        "8706": [0, 0.69444, 0.05556, 0.08334],
        "8707": [0, 0.69444, 0, 0],
        "8709": [0.05556, 0.75, 0, 0],
        "8711": [0, 0.68333, 0, 0],
        "8712": [0.0391, 0.5391, 0, 0],
        "8715": [0.0391, 0.5391, 0, 0],
        "8722": [0.08333, 0.58333, 0, 0],
        "8723": [0.08333, 0.58333, 0, 0],
        "8725": [0.25, 0.75, 0, 0],
        "8726": [0.25, 0.75, 0, 0],
        "8727": [-0.03472, 0.46528, 0, 0],
        "8728": [-0.05555, 0.44445, 0, 0],
        "8729": [-0.05555, 0.44445, 0, 0],
        "8730": [0.2, 0.8, 0, 0],
        "8733": [0, 0.43056, 0, 0],
        "8734": [0, 0.43056, 0, 0],
        "8736": [0, 0.69224, 0, 0],
        "8739": [0.25, 0.75, 0, 0],
        "8741": [0.25, 0.75, 0, 0],
        "8743": [0, 0.55556, 0, 0],
        "8744": [0, 0.55556, 0, 0],
        "8745": [0, 0.55556, 0, 0],
        "8746": [0, 0.55556, 0, 0],
        "8747": [0.19444, 0.69444, 0.11111, 0],
        "8764": [-0.13313, 0.36687, 0, 0],
        "8768": [0.19444, 0.69444, 0, 0],
        "8771": [-0.03625, 0.46375, 0, 0],
        "8773": [-0.022, 0.589, 0, 0],
        "8776": [-0.01688, 0.48312, 0, 0],
        "8781": [-0.03625, 0.46375, 0, 0],
        "8784": [-0.133, 0.67, 0, 0],
        "8800": [0.215, 0.716, 0, 0],
        "8801": [-0.03625, 0.46375, 0, 0],
        "8804": [0.13597, 0.63597, 0, 0],
        "8805": [0.13597, 0.63597, 0, 0],
        "8810": [0.0391, 0.5391, 0, 0],
        "8811": [0.0391, 0.5391, 0, 0],
        "8826": [0.0391, 0.5391, 0, 0],
        "8827": [0.0391, 0.5391, 0, 0],
        "8834": [0.0391, 0.5391, 0, 0],
        "8835": [0.0391, 0.5391, 0, 0],
        "8838": [0.13597, 0.63597, 0, 0],
        "8839": [0.13597, 0.63597, 0, 0],
        "8846": [0, 0.55556, 0, 0],
        "8849": [0.13597, 0.63597, 0, 0],
        "8850": [0.13597, 0.63597, 0, 0],
        "8851": [0, 0.55556, 0, 0],
        "8852": [0, 0.55556, 0, 0],
        "8853": [0.08333, 0.58333, 0, 0],
        "8854": [0.08333, 0.58333, 0, 0],
        "8855": [0.08333, 0.58333, 0, 0],
        "8856": [0.08333, 0.58333, 0, 0],
        "8857": [0.08333, 0.58333, 0, 0],
        "8866": [0, 0.69444, 0, 0],
        "8867": [0, 0.69444, 0, 0],
        "8868": [0, 0.69444, 0, 0],
        "8869": [0, 0.69444, 0, 0],
        "8872": [0.249, 0.75, 0, 0],
        "8900": [-0.05555, 0.44445, 0, 0],
        "8901": [-0.05555, 0.44445, 0, 0],
        "8902": [-0.03472, 0.46528, 0, 0],
        "8904": [0.005, 0.505, 0, 0],
        "8942": [0.03, 0.9, 0, 0],
        "8943": [-0.19, 0.31, 0, 0],
        "8945": [-0.1, 0.82, 0, 0],
        "8968": [0.25, 0.75, 0, 0],
        "8969": [0.25, 0.75, 0, 0],
        "8970": [0.25, 0.75, 0, 0],
        "8971": [0.25, 0.75, 0, 0],
        "8994": [-0.14236, 0.35764, 0, 0],
        "8995": [-0.14236, 0.35764, 0, 0],
        "9136": [0.244, 0.744, 0, 0],
        "9137": [0.244, 0.744, 0, 0],
        "9651": [0.19444, 0.69444, 0, 0],
        "9657": [-0.03472, 0.46528, 0, 0],
        "9661": [0.19444, 0.69444, 0, 0],
        "9667": [-0.03472, 0.46528, 0, 0],
        "9711": [0.19444, 0.69444, 0, 0],
        "9824": [0.12963, 0.69444, 0, 0],
        "9825": [0.12963, 0.69444, 0, 0],
        "9826": [0.12963, 0.69444, 0, 0],
        "9827": [0.12963, 0.69444, 0, 0],
        "9837": [0, 0.75, 0, 0],
        "9838": [0.19444, 0.69444, 0, 0],
        "9839": [0.19444, 0.69444, 0, 0],
        "10216": [0.25, 0.75, 0, 0],
        "10217": [0.25, 0.75, 0, 0],
        "10222": [0.244, 0.744, 0, 0],
        "10223": [0.244, 0.744, 0, 0],
        "10229": [0.011, 0.511, 0, 0],
        "10230": [0.011, 0.511, 0, 0],
        "10231": [0.011, 0.511, 0, 0],
        "10232": [0.024, 0.525, 0, 0],
        "10233": [0.024, 0.525, 0, 0],
        "10234": [0.024, 0.525, 0, 0],
        "10236": [0.011, 0.511, 0, 0],
        "10815": [0, 0.68333, 0, 0],
        "10927": [0.13597, 0.63597, 0, 0],
        "10928": [0.13597, 0.63597, 0, 0]
    },
    "Math-BoldItalic": {
        "47": [0.19444, 0.69444, 0, 0],
        "65": [0, 0.68611, 0, 0],
        "66": [0, 0.68611, 0.04835, 0],
        "67": [0, 0.68611, 0.06979, 0],
        "68": [0, 0.68611, 0.03194, 0],
        "69": [0, 0.68611, 0.05451, 0],
        "70": [0, 0.68611, 0.15972, 0],
        "71": [0, 0.68611, 0, 0],
        "72": [0, 0.68611, 0.08229, 0],
        "73": [0, 0.68611, 0.07778, 0],
        "74": [0, 0.68611, 0.10069, 0],
        "75": [0, 0.68611, 0.06979, 0],
        "76": [0, 0.68611, 0, 0],
        "77": [0, 0.68611, 0.11424, 0],
        "78": [0, 0.68611, 0.11424, 0],
        "79": [0, 0.68611, 0.03194, 0],
        "80": [0, 0.68611, 0.15972, 0],
        "81": [0.19444, 0.68611, 0, 0],
        "82": [0, 0.68611, 0.00421, 0],
        "83": [0, 0.68611, 0.05382, 0],
        "84": [0, 0.68611, 0.15972, 0],
        "85": [0, 0.68611, 0.11424, 0],
        "86": [0, 0.68611, 0.25555, 0],
        "87": [0, 0.68611, 0.15972, 0],
        "88": [0, 0.68611, 0.07778, 0],
        "89": [0, 0.68611, 0.25555, 0],
        "90": [0, 0.68611, 0.06979, 0],
        "97": [0, 0.44444, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.44444, 0, 0],
        "100": [0, 0.69444, 0, 0],
        "101": [0, 0.44444, 0, 0],
        "102": [0.19444, 0.69444, 0.11042, 0],
        "103": [0.19444, 0.44444, 0.03704, 0],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.69326, 0, 0],
        "106": [0.19444, 0.69326, 0.0622, 0],
        "107": [0, 0.69444, 0.01852, 0],
        "108": [0, 0.69444, 0.0088, 0],
        "109": [0, 0.44444, 0, 0],
        "110": [0, 0.44444, 0, 0],
        "111": [0, 0.44444, 0, 0],
        "112": [0.19444, 0.44444, 0, 0],
        "113": [0.19444, 0.44444, 0.03704, 0],
        "114": [0, 0.44444, 0.03194, 0],
        "115": [0, 0.44444, 0, 0],
        "116": [0, 0.63492, 0, 0],
        "117": [0, 0.44444, 0, 0],
        "118": [0, 0.44444, 0.03704, 0],
        "119": [0, 0.44444, 0.02778, 0],
        "120": [0, 0.44444, 0, 0],
        "121": [0.19444, 0.44444, 0.03704, 0],
        "122": [0, 0.44444, 0.04213, 0],
        "915": [0, 0.68611, 0.15972, 0],
        "916": [0, 0.68611, 0, 0],
        "920": [0, 0.68611, 0.03194, 0],
        "923": [0, 0.68611, 0, 0],
        "926": [0, 0.68611, 0.07458, 0],
        "928": [0, 0.68611, 0.08229, 0],
        "931": [0, 0.68611, 0.05451, 0],
        "933": [0, 0.68611, 0.15972, 0],
        "934": [0, 0.68611, 0, 0],
        "936": [0, 0.68611, 0.11653, 0],
        "937": [0, 0.68611, 0.04835, 0],
        "945": [0, 0.44444, 0, 0],
        "946": [0.19444, 0.69444, 0.03403, 0],
        "947": [0.19444, 0.44444, 0.06389, 0],
        "948": [0, 0.69444, 0.03819, 0],
        "949": [0, 0.44444, 0, 0],
        "950": [0.19444, 0.69444, 0.06215, 0],
        "951": [0.19444, 0.44444, 0.03704, 0],
        "952": [0, 0.69444, 0.03194, 0],
        "953": [0, 0.44444, 0, 0],
        "954": [0, 0.44444, 0, 0],
        "955": [0, 0.69444, 0, 0],
        "956": [0.19444, 0.44444, 0, 0],
        "957": [0, 0.44444, 0.06898, 0],
        "958": [0.19444, 0.69444, 0.03021, 0],
        "959": [0, 0.44444, 0, 0],
        "960": [0, 0.44444, 0.03704, 0],
        "961": [0.19444, 0.44444, 0, 0],
        "962": [0.09722, 0.44444, 0.07917, 0],
        "963": [0, 0.44444, 0.03704, 0],
        "964": [0, 0.44444, 0.13472, 0],
        "965": [0, 0.44444, 0.03704, 0],
        "966": [0.19444, 0.44444, 0, 0],
        "967": [0.19444, 0.44444, 0, 0],
        "968": [0.19444, 0.69444, 0.03704, 0],
        "969": [0, 0.44444, 0.03704, 0],
        "977": [0, 0.69444, 0, 0],
        "981": [0.19444, 0.69444, 0, 0],
        "982": [0, 0.44444, 0.03194, 0],
        "1009": [0.19444, 0.44444, 0, 0],
        "1013": [0, 0.44444, 0, 0]
    },
    "Math-Italic": {
        "47": [0.19444, 0.69444, 0, 0],
        "65": [0, 0.68333, 0, 0.13889],
        "66": [0, 0.68333, 0.05017, 0.08334],
        "67": [0, 0.68333, 0.07153, 0.08334],
        "68": [0, 0.68333, 0.02778, 0.05556],
        "69": [0, 0.68333, 0.05764, 0.08334],
        "70": [0, 0.68333, 0.13889, 0.08334],
        "71": [0, 0.68333, 0, 0.08334],
        "72": [0, 0.68333, 0.08125, 0.05556],
        "73": [0, 0.68333, 0.07847, 0.11111],
        "74": [0, 0.68333, 0.09618, 0.16667],
        "75": [0, 0.68333, 0.07153, 0.05556],
        "76": [0, 0.68333, 0, 0.02778],
        "77": [0, 0.68333, 0.10903, 0.08334],
        "78": [0, 0.68333, 0.10903, 0.08334],
        "79": [0, 0.68333, 0.02778, 0.08334],
        "80": [0, 0.68333, 0.13889, 0.08334],
        "81": [0.19444, 0.68333, 0, 0.08334],
        "82": [0, 0.68333, 0.00773, 0.08334],
        "83": [0, 0.68333, 0.05764, 0.08334],
        "84": [0, 0.68333, 0.13889, 0.08334],
        "85": [0, 0.68333, 0.10903, 0.02778],
        "86": [0, 0.68333, 0.22222, 0],
        "87": [0, 0.68333, 0.13889, 0],
        "88": [0, 0.68333, 0.07847, 0.08334],
        "89": [0, 0.68333, 0.22222, 0],
        "90": [0, 0.68333, 0.07153, 0.08334],
        "97": [0, 0.43056, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.43056, 0, 0.05556],
        "100": [0, 0.69444, 0, 0.16667],
        "101": [0, 0.43056, 0, 0.05556],
        "102": [0.19444, 0.69444, 0.10764, 0.16667],
        "103": [0.19444, 0.43056, 0.03588, 0.02778],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.65952, 0, 0],
        "106": [0.19444, 0.65952, 0.05724, 0],
        "107": [0, 0.69444, 0.03148, 0],
        "108": [0, 0.69444, 0.01968, 0.08334],
        "109": [0, 0.43056, 0, 0],
        "110": [0, 0.43056, 0, 0],
        "111": [0, 0.43056, 0, 0.05556],
        "112": [0.19444, 0.43056, 0, 0.08334],
        "113": [0.19444, 0.43056, 0.03588, 0.08334],
        "114": [0, 0.43056, 0.02778, 0.05556],
        "115": [0, 0.43056, 0, 0.05556],
        "116": [0, 0.61508, 0, 0.08334],
        "117": [0, 0.43056, 0, 0.02778],
        "118": [0, 0.43056, 0.03588, 0.02778],
        "119": [0, 0.43056, 0.02691, 0.08334],
        "120": [0, 0.43056, 0, 0.02778],
        "121": [0.19444, 0.43056, 0.03588, 0.05556],
        "122": [0, 0.43056, 0.04398, 0.05556],
        "915": [0, 0.68333, 0.13889, 0.08334],
        "916": [0, 0.68333, 0, 0.16667],
        "920": [0, 0.68333, 0.02778, 0.08334],
        "923": [0, 0.68333, 0, 0.16667],
        "926": [0, 0.68333, 0.07569, 0.08334],
        "928": [0, 0.68333, 0.08125, 0.05556],
        "931": [0, 0.68333, 0.05764, 0.08334],
        "933": [0, 0.68333, 0.13889, 0.05556],
        "934": [0, 0.68333, 0, 0.08334],
        "936": [0, 0.68333, 0.11, 0.05556],
        "937": [0, 0.68333, 0.05017, 0.08334],
        "945": [0, 0.43056, 0.0037, 0.02778],
        "946": [0.19444, 0.69444, 0.05278, 0.08334],
        "947": [0.19444, 0.43056, 0.05556, 0],
        "948": [0, 0.69444, 0.03785, 0.05556],
        "949": [0, 0.43056, 0, 0.08334],
        "950": [0.19444, 0.69444, 0.07378, 0.08334],
        "951": [0.19444, 0.43056, 0.03588, 0.05556],
        "952": [0, 0.69444, 0.02778, 0.08334],
        "953": [0, 0.43056, 0, 0.05556],
        "954": [0, 0.43056, 0, 0],
        "955": [0, 0.69444, 0, 0],
        "956": [0.19444, 0.43056, 0, 0.02778],
        "957": [0, 0.43056, 0.06366, 0.02778],
        "958": [0.19444, 0.69444, 0.04601, 0.11111],
        "959": [0, 0.43056, 0, 0.05556],
        "960": [0, 0.43056, 0.03588, 0],
        "961": [0.19444, 0.43056, 0, 0.08334],
        "962": [0.09722, 0.43056, 0.07986, 0.08334],
        "963": [0, 0.43056, 0.03588, 0],
        "964": [0, 0.43056, 0.1132, 0.02778],
        "965": [0, 0.43056, 0.03588, 0.02778],
        "966": [0.19444, 0.43056, 0, 0.08334],
        "967": [0.19444, 0.43056, 0, 0.05556],
        "968": [0.19444, 0.69444, 0.03588, 0.11111],
        "969": [0, 0.43056, 0.03588, 0],
        "977": [0, 0.69444, 0, 0.08334],
        "981": [0.19444, 0.69444, 0, 0.08334],
        "982": [0, 0.43056, 0.02778, 0],
        "1009": [0.19444, 0.43056, 0, 0.08334],
        "1013": [0, 0.43056, 0, 0.05556]
    },
    "Math-Regular": {
        "65": [0, 0.68333, 0, 0.13889],
        "66": [0, 0.68333, 0.05017, 0.08334],
        "67": [0, 0.68333, 0.07153, 0.08334],
        "68": [0, 0.68333, 0.02778, 0.05556],
        "69": [0, 0.68333, 0.05764, 0.08334],
        "70": [0, 0.68333, 0.13889, 0.08334],
        "71": [0, 0.68333, 0, 0.08334],
        "72": [0, 0.68333, 0.08125, 0.05556],
        "73": [0, 0.68333, 0.07847, 0.11111],
        "74": [0, 0.68333, 0.09618, 0.16667],
        "75": [0, 0.68333, 0.07153, 0.05556],
        "76": [0, 0.68333, 0, 0.02778],
        "77": [0, 0.68333, 0.10903, 0.08334],
        "78": [0, 0.68333, 0.10903, 0.08334],
        "79": [0, 0.68333, 0.02778, 0.08334],
        "80": [0, 0.68333, 0.13889, 0.08334],
        "81": [0.19444, 0.68333, 0, 0.08334],
        "82": [0, 0.68333, 0.00773, 0.08334],
        "83": [0, 0.68333, 0.05764, 0.08334],
        "84": [0, 0.68333, 0.13889, 0.08334],
        "85": [0, 0.68333, 0.10903, 0.02778],
        "86": [0, 0.68333, 0.22222, 0],
        "87": [0, 0.68333, 0.13889, 0],
        "88": [0, 0.68333, 0.07847, 0.08334],
        "89": [0, 0.68333, 0.22222, 0],
        "90": [0, 0.68333, 0.07153, 0.08334],
        "97": [0, 0.43056, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.43056, 0, 0.05556],
        "100": [0, 0.69444, 0, 0.16667],
        "101": [0, 0.43056, 0, 0.05556],
        "102": [0.19444, 0.69444, 0.10764, 0.16667],
        "103": [0.19444, 0.43056, 0.03588, 0.02778],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.65952, 0, 0],
        "106": [0.19444, 0.65952, 0.05724, 0],
        "107": [0, 0.69444, 0.03148, 0],
        "108": [0, 0.69444, 0.01968, 0.08334],
        "109": [0, 0.43056, 0, 0],
        "110": [0, 0.43056, 0, 0],
        "111": [0, 0.43056, 0, 0.05556],
        "112": [0.19444, 0.43056, 0, 0.08334],
        "113": [0.19444, 0.43056, 0.03588, 0.08334],
        "114": [0, 0.43056, 0.02778, 0.05556],
        "115": [0, 0.43056, 0, 0.05556],
        "116": [0, 0.61508, 0, 0.08334],
        "117": [0, 0.43056, 0, 0.02778],
        "118": [0, 0.43056, 0.03588, 0.02778],
        "119": [0, 0.43056, 0.02691, 0.08334],
        "120": [0, 0.43056, 0, 0.02778],
        "121": [0.19444, 0.43056, 0.03588, 0.05556],
        "122": [0, 0.43056, 0.04398, 0.05556],
        "915": [0, 0.68333, 0.13889, 0.08334],
        "916": [0, 0.68333, 0, 0.16667],
        "920": [0, 0.68333, 0.02778, 0.08334],
        "923": [0, 0.68333, 0, 0.16667],
        "926": [0, 0.68333, 0.07569, 0.08334],
        "928": [0, 0.68333, 0.08125, 0.05556],
        "931": [0, 0.68333, 0.05764, 0.08334],
        "933": [0, 0.68333, 0.13889, 0.05556],
        "934": [0, 0.68333, 0, 0.08334],
        "936": [0, 0.68333, 0.11, 0.05556],
        "937": [0, 0.68333, 0.05017, 0.08334],
        "945": [0, 0.43056, 0.0037, 0.02778],
        "946": [0.19444, 0.69444, 0.05278, 0.08334],
        "947": [0.19444, 0.43056, 0.05556, 0],
        "948": [0, 0.69444, 0.03785, 0.05556],
        "949": [0, 0.43056, 0, 0.08334],
        "950": [0.19444, 0.69444, 0.07378, 0.08334],
        "951": [0.19444, 0.43056, 0.03588, 0.05556],
        "952": [0, 0.69444, 0.02778, 0.08334],
        "953": [0, 0.43056, 0, 0.05556],
        "954": [0, 0.43056, 0, 0],
        "955": [0, 0.69444, 0, 0],
        "956": [0.19444, 0.43056, 0, 0.02778],
        "957": [0, 0.43056, 0.06366, 0.02778],
        "958": [0.19444, 0.69444, 0.04601, 0.11111],
        "959": [0, 0.43056, 0, 0.05556],
        "960": [0, 0.43056, 0.03588, 0],
        "961": [0.19444, 0.43056, 0, 0.08334],
        "962": [0.09722, 0.43056, 0.07986, 0.08334],
        "963": [0, 0.43056, 0.03588, 0],
        "964": [0, 0.43056, 0.1132, 0.02778],
        "965": [0, 0.43056, 0.03588, 0.02778],
        "966": [0.19444, 0.43056, 0, 0.08334],
        "967": [0.19444, 0.43056, 0, 0.05556],
        "968": [0.19444, 0.69444, 0.03588, 0.11111],
        "969": [0, 0.43056, 0.03588, 0],
        "977": [0, 0.69444, 0, 0.08334],
        "981": [0.19444, 0.69444, 0, 0.08334],
        "982": [0, 0.43056, 0.02778, 0],
        "1009": [0.19444, 0.43056, 0, 0.08334],
        "1013": [0, 0.43056, 0, 0.05556]
    },
    "SansSerif-Regular": {
        "33": [0, 0.69444, 0, 0],
        "34": [0, 0.69444, 0, 0],
        "35": [0.19444, 0.69444, 0, 0],
        "36": [0.05556, 0.75, 0, 0],
        "37": [0.05556, 0.75, 0, 0],
        "38": [0, 0.69444, 0, 0],
        "39": [0, 0.69444, 0, 0],
        "40": [0.25, 0.75, 0, 0],
        "41": [0.25, 0.75, 0, 0],
        "42": [0, 0.75, 0, 0],
        "43": [0.08333, 0.58333, 0, 0],
        "44": [0.125, 0.08333, 0, 0],
        "45": [0, 0.44444, 0, 0],
        "46": [0, 0.08333, 0, 0],
        "47": [0.25, 0.75, 0, 0],
        "48": [0, 0.65556, 0, 0],
        "49": [0, 0.65556, 0, 0],
        "50": [0, 0.65556, 0, 0],
        "51": [0, 0.65556, 0, 0],
        "52": [0, 0.65556, 0, 0],
        "53": [0, 0.65556, 0, 0],
        "54": [0, 0.65556, 0, 0],
        "55": [0, 0.65556, 0, 0],
        "56": [0, 0.65556, 0, 0],
        "57": [0, 0.65556, 0, 0],
        "58": [0, 0.44444, 0, 0],
        "59": [0.125, 0.44444, 0, 0],
        "61": [-0.13, 0.37, 0, 0],
        "63": [0, 0.69444, 0, 0],
        "64": [0, 0.69444, 0, 0],
        "65": [0, 0.69444, 0, 0],
        "66": [0, 0.69444, 0, 0],
        "67": [0, 0.69444, 0, 0],
        "68": [0, 0.69444, 0, 0],
        "69": [0, 0.69444, 0, 0],
        "70": [0, 0.69444, 0, 0],
        "71": [0, 0.69444, 0, 0],
        "72": [0, 0.69444, 0, 0],
        "73": [0, 0.69444, 0, 0],
        "74": [0, 0.69444, 0, 0],
        "75": [0, 0.69444, 0, 0],
        "76": [0, 0.69444, 0, 0],
        "77": [0, 0.69444, 0, 0],
        "78": [0, 0.69444, 0, 0],
        "79": [0, 0.69444, 0, 0],
        "80": [0, 0.69444, 0, 0],
        "81": [0.125, 0.69444, 0, 0],
        "82": [0, 0.69444, 0, 0],
        "83": [0, 0.69444, 0, 0],
        "84": [0, 0.69444, 0, 0],
        "85": [0, 0.69444, 0, 0],
        "86": [0, 0.69444, 0.01389, 0],
        "87": [0, 0.69444, 0.01389, 0],
        "88": [0, 0.69444, 0, 0],
        "89": [0, 0.69444, 0.025, 0],
        "90": [0, 0.69444, 0, 0],
        "91": [0.25, 0.75, 0, 0],
        "93": [0.25, 0.75, 0, 0],
        "94": [0, 0.69444, 0, 0],
        "95": [0.35, 0.09444, 0.02778, 0],
        "97": [0, 0.44444, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.44444, 0, 0],
        "100": [0, 0.69444, 0, 0],
        "101": [0, 0.44444, 0, 0],
        "102": [0, 0.69444, 0.06944, 0],
        "103": [0.19444, 0.44444, 0.01389, 0],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.67937, 0, 0],
        "106": [0.19444, 0.67937, 0, 0],
        "107": [0, 0.69444, 0, 0],
        "108": [0, 0.69444, 0, 0],
        "109": [0, 0.44444, 0, 0],
        "110": [0, 0.44444, 0, 0],
        "111": [0, 0.44444, 0, 0],
        "112": [0.19444, 0.44444, 0, 0],
        "113": [0.19444, 0.44444, 0, 0],
        "114": [0, 0.44444, 0.01389, 0],
        "115": [0, 0.44444, 0, 0],
        "116": [0, 0.57143, 0, 0],
        "117": [0, 0.44444, 0, 0],
        "118": [0, 0.44444, 0.01389, 0],
        "119": [0, 0.44444, 0.01389, 0],
        "120": [0, 0.44444, 0, 0],
        "121": [0.19444, 0.44444, 0.01389, 0],
        "122": [0, 0.44444, 0, 0],
        "126": [0.35, 0.32659, 0, 0],
        "305": [0, 0.44444, 0, 0],
        "567": [0.19444, 0.44444, 0, 0],
        "768": [0, 0.69444, 0, 0],
        "769": [0, 0.69444, 0, 0],
        "770": [0, 0.69444, 0, 0],
        "771": [0, 0.67659, 0, 0],
        "772": [0, 0.60889, 0, 0],
        "774": [0, 0.69444, 0, 0],
        "775": [0, 0.67937, 0, 0],
        "776": [0, 0.67937, 0, 0],
        "778": [0, 0.69444, 0, 0],
        "779": [0, 0.69444, 0, 0],
        "780": [0, 0.63194, 0, 0],
        "915": [0, 0.69444, 0, 0],
        "916": [0, 0.69444, 0, 0],
        "920": [0, 0.69444, 0, 0],
        "923": [0, 0.69444, 0, 0],
        "926": [0, 0.69444, 0, 0],
        "928": [0, 0.69444, 0, 0],
        "931": [0, 0.69444, 0, 0],
        "933": [0, 0.69444, 0, 0],
        "934": [0, 0.69444, 0, 0],
        "936": [0, 0.69444, 0, 0],
        "937": [0, 0.69444, 0, 0],
        "8211": [0, 0.44444, 0.02778, 0],
        "8212": [0, 0.44444, 0.02778, 0],
        "8216": [0, 0.69444, 0, 0],
        "8217": [0, 0.69444, 0, 0],
        "8220": [0, 0.69444, 0, 0],
        "8221": [0, 0.69444, 0, 0]
    },
    "Script-Regular": {
        "65": [0, 0.7, 0.22925, 0],
        "66": [0, 0.7, 0.04087, 0],
        "67": [0, 0.7, 0.1689, 0],
        "68": [0, 0.7, 0.09371, 0],
        "69": [0, 0.7, 0.18583, 0],
        "70": [0, 0.7, 0.13634, 0],
        "71": [0, 0.7, 0.17322, 0],
        "72": [0, 0.7, 0.29694, 0],
        "73": [0, 0.7, 0.19189, 0],
        "74": [0.27778, 0.7, 0.19189, 0],
        "75": [0, 0.7, 0.31259, 0],
        "76": [0, 0.7, 0.19189, 0],
        "77": [0, 0.7, 0.15981, 0],
        "78": [0, 0.7, 0.3525, 0],
        "79": [0, 0.7, 0.08078, 0],
        "80": [0, 0.7, 0.08078, 0],
        "81": [0, 0.7, 0.03305, 0],
        "82": [0, 0.7, 0.06259, 0],
        "83": [0, 0.7, 0.19189, 0],
        "84": [0, 0.7, 0.29087, 0],
        "85": [0, 0.7, 0.25815, 0],
        "86": [0, 0.7, 0.27523, 0],
        "87": [0, 0.7, 0.27523, 0],
        "88": [0, 0.7, 0.26006, 0],
        "89": [0, 0.7, 0.2939, 0],
        "90": [0, 0.7, 0.24037, 0]
    },
    "Size1-Regular": {
        "40": [0.35001, 0.85, 0, 0],
        "41": [0.35001, 0.85, 0, 0],
        "47": [0.35001, 0.85, 0, 0],
        "91": [0.35001, 0.85, 0, 0],
        "92": [0.35001, 0.85, 0, 0],
        "93": [0.35001, 0.85, 0, 0],
        "123": [0.35001, 0.85, 0, 0],
        "125": [0.35001, 0.85, 0, 0],
        "710": [0, 0.72222, 0, 0],
        "732": [0, 0.72222, 0, 0],
        "770": [0, 0.72222, 0, 0],
        "771": [0, 0.72222, 0, 0],
        "8214": [-0.00099, 0.601, 0, 0],
        "8593": [1e-05, 0.6, 0, 0],
        "8595": [1e-05, 0.6, 0, 0],
        "8657": [1e-05, 0.6, 0, 0],
        "8659": [1e-05, 0.6, 0, 0],
        "8719": [0.25001, 0.75, 0, 0],
        "8720": [0.25001, 0.75, 0, 0],
        "8721": [0.25001, 0.75, 0, 0],
        "8730": [0.35001, 0.85, 0, 0],
        "8739": [-0.00599, 0.606, 0, 0],
        "8741": [-0.00599, 0.606, 0, 0],
        "8747": [0.30612, 0.805, 0.19445, 0],
        "8748": [0.306, 0.805, 0.19445, 0],
        "8749": [0.306, 0.805, 0.19445, 0],
        "8750": [0.30612, 0.805, 0.19445, 0],
        "8896": [0.25001, 0.75, 0, 0],
        "8897": [0.25001, 0.75, 0, 0],
        "8898": [0.25001, 0.75, 0, 0],
        "8899": [0.25001, 0.75, 0, 0],
        "8968": [0.35001, 0.85, 0, 0],
        "8969": [0.35001, 0.85, 0, 0],
        "8970": [0.35001, 0.85, 0, 0],
        "8971": [0.35001, 0.85, 0, 0],
        "9168": [-0.00099, 0.601, 0, 0],
        "10216": [0.35001, 0.85, 0, 0],
        "10217": [0.35001, 0.85, 0, 0],
        "10752": [0.25001, 0.75, 0, 0],
        "10753": [0.25001, 0.75, 0, 0],
        "10754": [0.25001, 0.75, 0, 0],
        "10756": [0.25001, 0.75, 0, 0],
        "10758": [0.25001, 0.75, 0, 0]
    },
    "Size2-Regular": {
        "40": [0.65002, 1.15, 0, 0],
        "41": [0.65002, 1.15, 0, 0],
        "47": [0.65002, 1.15, 0, 0],
        "91": [0.65002, 1.15, 0, 0],
        "92": [0.65002, 1.15, 0, 0],
        "93": [0.65002, 1.15, 0, 0],
        "123": [0.65002, 1.15, 0, 0],
        "125": [0.65002, 1.15, 0, 0],
        "710": [0, 0.75, 0, 0],
        "732": [0, 0.75, 0, 0],
        "770": [0, 0.75, 0, 0],
        "771": [0, 0.75, 0, 0],
        "8719": [0.55001, 1.05, 0, 0],
        "8720": [0.55001, 1.05, 0, 0],
        "8721": [0.55001, 1.05, 0, 0],
        "8730": [0.65002, 1.15, 0, 0],
        "8747": [0.86225, 1.36, 0.44445, 0],
        "8748": [0.862, 1.36, 0.44445, 0],
        "8749": [0.862, 1.36, 0.44445, 0],
        "8750": [0.86225, 1.36, 0.44445, 0],
        "8896": [0.55001, 1.05, 0, 0],
        "8897": [0.55001, 1.05, 0, 0],
        "8898": [0.55001, 1.05, 0, 0],
        "8899": [0.55001, 1.05, 0, 0],
        "8968": [0.65002, 1.15, 0, 0],
        "8969": [0.65002, 1.15, 0, 0],
        "8970": [0.65002, 1.15, 0, 0],
        "8971": [0.65002, 1.15, 0, 0],
        "10216": [0.65002, 1.15, 0, 0],
        "10217": [0.65002, 1.15, 0, 0],
        "10752": [0.55001, 1.05, 0, 0],
        "10753": [0.55001, 1.05, 0, 0],
        "10754": [0.55001, 1.05, 0, 0],
        "10756": [0.55001, 1.05, 0, 0],
        "10758": [0.55001, 1.05, 0, 0]
    },
    "Size3-Regular": {
        "40": [0.95003, 1.45, 0, 0],
        "41": [0.95003, 1.45, 0, 0],
        "47": [0.95003, 1.45, 0, 0],
        "91": [0.95003, 1.45, 0, 0],
        "92": [0.95003, 1.45, 0, 0],
        "93": [0.95003, 1.45, 0, 0],
        "123": [0.95003, 1.45, 0, 0],
        "125": [0.95003, 1.45, 0, 0],
        "710": [0, 0.75, 0, 0],
        "732": [0, 0.75, 0, 0],
        "770": [0, 0.75, 0, 0],
        "771": [0, 0.75, 0, 0],
        "8730": [0.95003, 1.45, 0, 0],
        "8968": [0.95003, 1.45, 0, 0],
        "8969": [0.95003, 1.45, 0, 0],
        "8970": [0.95003, 1.45, 0, 0],
        "8971": [0.95003, 1.45, 0, 0],
        "10216": [0.95003, 1.45, 0, 0],
        "10217": [0.95003, 1.45, 0, 0]
    },
    "Size4-Regular": {
        "40": [1.25003, 1.75, 0, 0],
        "41": [1.25003, 1.75, 0, 0],
        "47": [1.25003, 1.75, 0, 0],
        "91": [1.25003, 1.75, 0, 0],
        "92": [1.25003, 1.75, 0, 0],
        "93": [1.25003, 1.75, 0, 0],
        "123": [1.25003, 1.75, 0, 0],
        "125": [1.25003, 1.75, 0, 0],
        "710": [0, 0.825, 0, 0],
        "732": [0, 0.825, 0, 0],
        "770": [0, 0.825, 0, 0],
        "771": [0, 0.825, 0, 0],
        "8730": [1.25003, 1.75, 0, 0],
        "8968": [1.25003, 1.75, 0, 0],
        "8969": [1.25003, 1.75, 0, 0],
        "8970": [1.25003, 1.75, 0, 0],
        "8971": [1.25003, 1.75, 0, 0],
        "9115": [0.64502, 1.155, 0, 0],
        "9116": [1e-05, 0.6, 0, 0],
        "9117": [0.64502, 1.155, 0, 0],
        "9118": [0.64502, 1.155, 0, 0],
        "9119": [1e-05, 0.6, 0, 0],
        "9120": [0.64502, 1.155, 0, 0],
        "9121": [0.64502, 1.155, 0, 0],
        "9122": [-0.00099, 0.601, 0, 0],
        "9123": [0.64502, 1.155, 0, 0],
        "9124": [0.64502, 1.155, 0, 0],
        "9125": [-0.00099, 0.601, 0, 0],
        "9126": [0.64502, 1.155, 0, 0],
        "9127": [1e-05, 0.9, 0, 0],
        "9128": [0.65002, 1.15, 0, 0],
        "9129": [0.90001, 0, 0, 0],
        "9130": [0, 0.3, 0, 0],
        "9131": [1e-05, 0.9, 0, 0],
        "9132": [0.65002, 1.15, 0, 0],
        "9133": [0.90001, 0, 0, 0],
        "9143": [0.88502, 0.915, 0, 0],
        "10216": [1.25003, 1.75, 0, 0],
        "10217": [1.25003, 1.75, 0, 0],
        "57344": [-0.00499, 0.605, 0, 0],
        "57345": [-0.00499, 0.605, 0, 0],
        "57680": [0, 0.12, 0, 0],
        "57681": [0, 0.12, 0, 0],
        "57682": [0, 0.12, 0, 0],
        "57683": [0, 0.12, 0, 0]
    },
    "Typewriter-Regular": {
        "33": [0, 0.61111, 0, 0],
        "34": [0, 0.61111, 0, 0],
        "35": [0, 0.61111, 0, 0],
        "36": [0.08333, 0.69444, 0, 0],
        "37": [0.08333, 0.69444, 0, 0],
        "38": [0, 0.61111, 0, 0],
        "39": [0, 0.61111, 0, 0],
        "40": [0.08333, 0.69444, 0, 0],
        "41": [0.08333, 0.69444, 0, 0],
        "42": [0, 0.52083, 0, 0],
        "43": [-0.08056, 0.53055, 0, 0],
        "44": [0.13889, 0.125, 0, 0],
        "45": [-0.08056, 0.53055, 0, 0],
        "46": [0, 0.125, 0, 0],
        "47": [0.08333, 0.69444, 0, 0],
        "48": [0, 0.61111, 0, 0],
        "49": [0, 0.61111, 0, 0],
        "50": [0, 0.61111, 0, 0],
        "51": [0, 0.61111, 0, 0],
        "52": [0, 0.61111, 0, 0],
        "53": [0, 0.61111, 0, 0],
        "54": [0, 0.61111, 0, 0],
        "55": [0, 0.61111, 0, 0],
        "56": [0, 0.61111, 0, 0],
        "57": [0, 0.61111, 0, 0],
        "58": [0, 0.43056, 0, 0],
        "59": [0.13889, 0.43056, 0, 0],
        "60": [-0.05556, 0.55556, 0, 0],
        "61": [-0.19549, 0.41562, 0, 0],
        "62": [-0.05556, 0.55556, 0, 0],
        "63": [0, 0.61111, 0, 0],
        "64": [0, 0.61111, 0, 0],
        "65": [0, 0.61111, 0, 0],
        "66": [0, 0.61111, 0, 0],
        "67": [0, 0.61111, 0, 0],
        "68": [0, 0.61111, 0, 0],
        "69": [0, 0.61111, 0, 0],
        "70": [0, 0.61111, 0, 0],
        "71": [0, 0.61111, 0, 0],
        "72": [0, 0.61111, 0, 0],
        "73": [0, 0.61111, 0, 0],
        "74": [0, 0.61111, 0, 0],
        "75": [0, 0.61111, 0, 0],
        "76": [0, 0.61111, 0, 0],
        "77": [0, 0.61111, 0, 0],
        "78": [0, 0.61111, 0, 0],
        "79": [0, 0.61111, 0, 0],
        "80": [0, 0.61111, 0, 0],
        "81": [0.13889, 0.61111, 0, 0],
        "82": [0, 0.61111, 0, 0],
        "83": [0, 0.61111, 0, 0],
        "84": [0, 0.61111, 0, 0],
        "85": [0, 0.61111, 0, 0],
        "86": [0, 0.61111, 0, 0],
        "87": [0, 0.61111, 0, 0],
        "88": [0, 0.61111, 0, 0],
        "89": [0, 0.61111, 0, 0],
        "90": [0, 0.61111, 0, 0],
        "91": [0.08333, 0.69444, 0, 0],
        "92": [0.08333, 0.69444, 0, 0],
        "93": [0.08333, 0.69444, 0, 0],
        "94": [0, 0.61111, 0, 0],
        "95": [0.09514, 0, 0, 0],
        "96": [0, 0.61111, 0, 0],
        "97": [0, 0.43056, 0, 0],
        "98": [0, 0.61111, 0, 0],
        "99": [0, 0.43056, 0, 0],
        "100": [0, 0.61111, 0, 0],
        "101": [0, 0.43056, 0, 0],
        "102": [0, 0.61111, 0, 0],
        "103": [0.22222, 0.43056, 0, 0],
        "104": [0, 0.61111, 0, 0],
        "105": [0, 0.61111, 0, 0],
        "106": [0.22222, 0.61111, 0, 0],
        "107": [0, 0.61111, 0, 0],
        "108": [0, 0.61111, 0, 0],
        "109": [0, 0.43056, 0, 0],
        "110": [0, 0.43056, 0, 0],
        "111": [0, 0.43056, 0, 0],
        "112": [0.22222, 0.43056, 0, 0],
        "113": [0.22222, 0.43056, 0, 0],
        "114": [0, 0.43056, 0, 0],
        "115": [0, 0.43056, 0, 0],
        "116": [0, 0.55358, 0, 0],
        "117": [0, 0.43056, 0, 0],
        "118": [0, 0.43056, 0, 0],
        "119": [0, 0.43056, 0, 0],
        "120": [0, 0.43056, 0, 0],
        "121": [0.22222, 0.43056, 0, 0],
        "122": [0, 0.43056, 0, 0],
        "123": [0.08333, 0.69444, 0, 0],
        "124": [0.08333, 0.69444, 0, 0],
        "125": [0.08333, 0.69444, 0, 0],
        "126": [0, 0.61111, 0, 0],
        "127": [0, 0.61111, 0, 0],
        "305": [0, 0.43056, 0, 0],
        "567": [0.22222, 0.43056, 0, 0],
        "768": [0, 0.61111, 0, 0],
        "769": [0, 0.61111, 0, 0],
        "770": [0, 0.61111, 0, 0],
        "771": [0, 0.61111, 0, 0],
        "772": [0, 0.56555, 0, 0],
        "774": [0, 0.61111, 0, 0],
        "776": [0, 0.61111, 0, 0],
        "778": [0, 0.61111, 0, 0],
        "780": [0, 0.56597, 0, 0],
        "915": [0, 0.61111, 0, 0],
        "916": [0, 0.61111, 0, 0],
        "920": [0, 0.61111, 0, 0],
        "923": [0, 0.61111, 0, 0],
        "926": [0, 0.61111, 0, 0],
        "928": [0, 0.61111, 0, 0],
        "931": [0, 0.61111, 0, 0],
        "933": [0, 0.61111, 0, 0],
        "934": [0, 0.61111, 0, 0],
        "936": [0, 0.61111, 0, 0],
        "937": [0, 0.61111, 0, 0],
        "2018": [0, 0.61111, 0, 0],
        "2019": [0, 0.61111, 0, 0],
        "8242": [0, 0.61111, 0, 0]
    }
};

},{}],107:[function(require,module,exports){
var utils = require("./utils");
var ParseError = require("./ParseError");
var parseData = require("./parseData");
var ParseNode = parseData.ParseNode;

/* This file contains a list of functions that we parse, identified by
 * the calls to defineFunction.
 *
 * The first argument to defineFunction is a single name or a list of names.
 * All functions named in such a list will share a single implementation.
 *
 * Each declared function can have associated properties, which
 * include the following:
 *
 *  - numArgs: The number of arguments the function takes.
 *             If this is the only property, it can be passed as a number
 *             instead of an element of a properties object.
 *  - argTypes: (optional) An array corresponding to each argument of the
 *              function, giving the type of argument that should be parsed. Its
 *              length should be equal to `numArgs + numOptionalArgs`. Valid
 *              types:
 *               - "size": A size-like thing, such as "1em" or "5ex"
 *               - "color": An html color, like "#abc" or "blue"
 *               - "original": The same type as the environment that the
 *                             function being parsed is in (e.g. used for the
 *                             bodies of functions like \color where the first
 *                             argument is special and the second argument is
 *                             parsed normally)
 *              Other possible types (probably shouldn't be used)
 *               - "text": Text-like (e.g. \text)
 *               - "math": Normal math
 *              If undefined, this will be treated as an appropriate length
 *              array of "original" strings
 *  - greediness: (optional) The greediness of the function to use ungrouped
 *                arguments.
 *
 *                E.g. if you have an expression
 *                  \sqrt \frac 1 2
 *                since \frac has greediness=2 vs \sqrt's greediness=1, \frac
 *                will use the two arguments '1' and '2' as its two arguments,
 *                then that whole function will be used as the argument to
 *                \sqrt. On the other hand, the expressions
 *                  \frac \frac 1 2 3
 *                and
 *                  \frac \sqrt 1 2
 *                will fail because \frac and \frac have equal greediness
 *                and \sqrt has a lower greediness than \frac respectively. To
 *                make these parse, we would have to change them to:
 *                  \frac {\frac 1 2} 3
 *                and
 *                  \frac {\sqrt 1} 2
 *
 *                The default value is `1`
 *  - allowedInText: (optional) Whether or not the function is allowed inside
 *                   text mode (default false)
 *  - numOptionalArgs: (optional) The number of optional arguments the function
 *                     should parse. If the optional arguments aren't found,
 *                     `null` will be passed to the handler in their place.
 *                     (default 0)
 *  - infix: (optional) Must be true if the function is an infix operator.
 *
 * The last argument is that implementation, the handler for the function(s).
 * It is called to handle these functions and their arguments.
 * It receives two arguments:
 *  - context contains information and references provided by the parser
 *  - args is an array of arguments obtained from TeX input
 * The context contains the following properties:
 *  - funcName: the text (i.e. name) of the function, including \
 *  - parser: the parser object
 *  - lexer: the lexer object
 *  - positions: the positions in the overall string of the function
 *               and the arguments.
 * The latter three should only be used to produce error messages.
 *
 * The function should return an object with the following keys:
 *  - type: The type of element that this is. This is then used in
 *          buildHTML/buildMathML to determine which function
 *          should be called to build this node into a DOM node
 * Any other data can be added to the object, which will be passed
 * in to the function in buildHTML/buildMathML as `group.value`.
 */

function defineFunction(names, props, handler) {
    if (typeof names === "string") {
        names = [names];
    }
    if (typeof props === "number") {
        props = { numArgs: props };
    }
    // Set default values of functions
    var data = {
        numArgs: props.numArgs,
        argTypes: props.argTypes,
        greediness: (props.greediness === undefined) ? 1 : props.greediness,
        allowedInText: !!props.allowedInText,
        numOptionalArgs: props.numOptionalArgs || 0,
        infix: !!props.infix,
        handler: handler
    };
    for (var i = 0; i < names.length; ++i) {
        module.exports[names[i]] = data;
    }
}

// Since the corresponding buildHTML/buildMathML function expects a
// list of elements, we normalize for different kinds of arguments
var ordargument = function(arg) {
    if (arg.type === "ordgroup") {
        return arg.value;
    } else {
        return [arg];
    }
};

// A normal square root
defineFunction("\\sqrt", {
    numArgs: 1,
    numOptionalArgs: 1
}, function(context, args) {
    var index = args[0];
    var body = args[1];
    return {
        type: "sqrt",
        body: body,
        index: index
    };
});

// Non-mathy text, possibly in a font
var textFunctionStyles = {
    "\\text": undefined, "\\textrm": "mathrm", "\\textsf": "mathsf",
    "\\texttt": "mathtt", "\\textnormal": "mathrm", "\\textbf": "mathbf",
    "\\textit": "textit"
};

defineFunction([
    "\\text", "\\textrm", "\\textsf", "\\texttt", "\\textnormal",
    "\\textbf", "\\textit"
], {
    numArgs: 1,
    argTypes: ["text"],
    greediness: 2,
    allowedInText: true
}, function(context, args) {
    var body = args[0];
    return {
        type: "text",
        body: ordargument(body),
        style: textFunctionStyles[context.funcName]
    };
});

// A two-argument custom color
defineFunction("\\color", {
    numArgs: 2,
    allowedInText: true,
    greediness: 3,
    argTypes: ["color", "original"]
}, function(context, args) {
    var color = args[0];
    var body = args[1];
    return {
        type: "color",
        color: color.value,
        value: ordargument(body)
    };
});

// An overline
defineFunction("\\overline", {
    numArgs: 1
}, function(context, args) {
    var body = args[0];
    return {
        type: "overline",
        body: body
    };
});

// An underline
defineFunction("\\underline", {
    numArgs: 1
}, function(context, args) {
    var body = args[0];
    return {
        type: "underline",
        body: body
    };
});

// A box of the width and height
defineFunction("\\rule", {
    numArgs: 2,
    numOptionalArgs: 1,
    argTypes: ["size", "size", "size"]
}, function(context, args) {
    var shift = args[0];
    var width = args[1];
    var height = args[2];
    return {
        type: "rule",
        shift: shift && shift.value,
        width: width.value,
        height: height.value
    };
});

// TODO: In TeX, \mkern only accepts mu-units, and \kern does not accept
// mu-units. In current KaTeX we relax this; both commands accept any unit.
defineFunction(["\\kern", "\\mkern"], {
    numArgs: 1,
    argTypes: ["size"]
}, function(context, args) {
    return {
        type: "kern",
        dimension: args[0].value
    };
});

// A KaTeX logo
defineFunction("\\KaTeX", {
    numArgs: 0
}, function(context) {
    return {
        type: "katex"
    };
});

defineFunction("\\phantom", {
    numArgs: 1
}, function(context, args) {
    var body = args[0];
    return {
        type: "phantom",
        value: ordargument(body)
    };
});

// Math class commands except \mathop
defineFunction([
    "\\mathord", "\\mathbin", "\\mathrel", "\\mathopen",
    "\\mathclose", "\\mathpunct", "\\mathinner"
], {
    numArgs: 1
}, function(context, args) {
    var body = args[0];
    return {
        type: "mclass",
        mclass: "m" + context.funcName.substr(5),
        value: ordargument(body)
    };
});

// Build a relation by placing one symbol on top of another
defineFunction("\\stackrel", {
    numArgs: 2
}, function(context, args) {
    var top = args[0];
    var bottom = args[1];

    var bottomop = new ParseNode("op", {
        type: "op",
        limits: true,
        alwaysHandleSupSub: true,
        symbol: false,
        value: ordargument(bottom)
    }, bottom.mode);

    var supsub = new ParseNode("supsub", {
        base: bottomop,
        sup: top,
        sub: null
    }, top.mode);

    return {
        type: "mclass",
        mclass: "mrel",
        value: [supsub]
    };
});

// \mod-type functions
defineFunction("\\bmod", {
    numArgs: 0
}, function(context, args) {
    return {
        type: "mod",
        modType: "bmod",
        value: null
    };
});

defineFunction(["\\pod", "\\pmod", "\\mod"], {
    numArgs: 1
}, function(context, args) {
    var body = args[0];
    return {
        type: "mod",
        modType: context.funcName.substr(1),
        value: ordargument(body)
    };
});

// Extra data needed for the delimiter handler down below
var delimiterSizes = {
    "\\bigl" : {mclass: "mopen",    size: 1},
    "\\Bigl" : {mclass: "mopen",    size: 2},
    "\\biggl": {mclass: "mopen",    size: 3},
    "\\Biggl": {mclass: "mopen",    size: 4},
    "\\bigr" : {mclass: "mclose",   size: 1},
    "\\Bigr" : {mclass: "mclose",   size: 2},
    "\\biggr": {mclass: "mclose",   size: 3},
    "\\Biggr": {mclass: "mclose",   size: 4},
    "\\bigm" : {mclass: "mrel",     size: 1},
    "\\Bigm" : {mclass: "mrel",     size: 2},
    "\\biggm": {mclass: "mrel",     size: 3},
    "\\Biggm": {mclass: "mrel",     size: 4},
    "\\big"  : {mclass: "mord",     size: 1},
    "\\Big"  : {mclass: "mord",     size: 2},
    "\\bigg" : {mclass: "mord",     size: 3},
    "\\Bigg" : {mclass: "mord",     size: 4}
};

var delimiters = [
    "(", ")", "[", "\\lbrack", "]", "\\rbrack",
    "\\{", "\\lbrace", "\\}", "\\rbrace",
    "\\lfloor", "\\rfloor", "\\lceil", "\\rceil",
    "<", ">", "\\langle", "\\rangle", "\\lt", "\\gt",
    "\\lvert", "\\rvert", "\\lVert", "\\rVert",
    "\\lgroup", "\\rgroup", "\\lmoustache", "\\rmoustache",
    "/", "\\backslash",
    "|", "\\vert", "\\|", "\\Vert",
    "\\uparrow", "\\Uparrow",
    "\\downarrow", "\\Downarrow",
    "\\updownarrow", "\\Updownarrow",
    "."
];

var fontAliases = {
    "\\Bbb": "\\mathbb",
    "\\bold": "\\mathbf",
    "\\frak": "\\mathfrak"
};

// Single-argument color functions
defineFunction([
    "\\blue", "\\orange", "\\pink", "\\red",
    "\\green", "\\gray", "\\purple",
    "\\blueA", "\\blueB", "\\blueC", "\\blueD", "\\blueE",
    "\\tealA", "\\tealB", "\\tealC", "\\tealD", "\\tealE",
    "\\greenA", "\\greenB", "\\greenC", "\\greenD", "\\greenE",
    "\\goldA", "\\goldB", "\\goldC", "\\goldD", "\\goldE",
    "\\redA", "\\redB", "\\redC", "\\redD", "\\redE",
    "\\maroonA", "\\maroonB", "\\maroonC", "\\maroonD", "\\maroonE",
    "\\purpleA", "\\purpleB", "\\purpleC", "\\purpleD", "\\purpleE",
    "\\mintA", "\\mintB", "\\mintC",
    "\\grayA", "\\grayB", "\\grayC", "\\grayD", "\\grayE",
    "\\grayF", "\\grayG", "\\grayH", "\\grayI",
    "\\kaBlue", "\\kaGreen"
], {
    numArgs: 1,
    allowedInText: true,
    greediness: 3
}, function(context, args) {
    var body = args[0];
    return {
        type: "color",
        color: "katex-" + context.funcName.slice(1),
        value: ordargument(body)
    };
});

// There are 2 flags for operators; whether they produce limits in
// displaystyle, and whether they are symbols and should grow in
// displaystyle. These four groups cover the four possible choices.

// No limits, not symbols
defineFunction([
    "\\arcsin", "\\arccos", "\\arctan", "\\arg", "\\cos", "\\cosh",
    "\\cot", "\\coth", "\\csc", "\\deg", "\\dim", "\\exp", "\\hom",
    "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh",
    "\\tan", "\\tanh"
], {
    numArgs: 0
}, function(context) {
    return {
        type: "op",
        limits: false,
        symbol: false,
        body: context.funcName
    };
});

// Limits, not symbols
defineFunction([
    "\\det", "\\gcd", "\\inf", "\\lim", "\\liminf", "\\limsup", "\\max",
    "\\min", "\\Pr", "\\sup"
], {
    numArgs: 0
}, function(context) {
    return {
        type: "op",
        limits: true,
        symbol: false,
        body: context.funcName
    };
});

// No limits, symbols
defineFunction([
    "\\int", "\\iint", "\\iiint", "\\oint"
], {
    numArgs: 0
}, function(context) {
    return {
        type: "op",
        limits: false,
        symbol: true,
        body: context.funcName
    };
});

// Limits, symbols
defineFunction([
    "\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap",
    "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes",
    "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint"
], {
    numArgs: 0
}, function(context) {
    return {
        type: "op",
        limits: true,
        symbol: true,
        body: context.funcName
    };
});

// \mathop class command
defineFunction("\\mathop", {
    numArgs: 1
}, function(context, args) {
    var body = args[0];
    return {
        type: "op",
        limits: false,
        symbol: false,
        value: ordargument(body)
    };
});

// Fractions
defineFunction([
    "\\dfrac", "\\frac", "\\tfrac",
    "\\dbinom", "\\binom", "\\tbinom",
    "\\\\atopfrac" // can’t be entered directly
], {
    numArgs: 2,
    greediness: 2
}, function(context, args) {
    var numer = args[0];
    var denom = args[1];
    var hasBarLine;
    var leftDelim = null;
    var rightDelim = null;
    var size = "auto";

    switch (context.funcName) {
        case "\\dfrac":
        case "\\frac":
        case "\\tfrac":
            hasBarLine = true;
            break;
        case "\\\\atopfrac":
            hasBarLine = false;
            break;
        case "\\dbinom":
        case "\\binom":
        case "\\tbinom":
            hasBarLine = false;
            leftDelim = "(";
            rightDelim = ")";
            break;
        default:
            throw new Error("Unrecognized genfrac command");
    }

    switch (context.funcName) {
        case "\\dfrac":
        case "\\dbinom":
            size = "display";
            break;
        case "\\tfrac":
        case "\\tbinom":
            size = "text";
            break;
    }

    return {
        type: "genfrac",
        numer: numer,
        denom: denom,
        hasBarLine: hasBarLine,
        leftDelim: leftDelim,
        rightDelim: rightDelim,
        size: size
    };
});

// Left and right overlap functions
defineFunction(["\\llap", "\\rlap"], {
    numArgs: 1,
    allowedInText: true
}, function(context, args) {
    var body = args[0];
    return {
        type: context.funcName.slice(1),
        body: body
    };
});

// Delimiter functions
var checkDelimiter = function(delim, context) {
    if (utils.contains(delimiters, delim.value)) {
        return delim;
    } else {
        throw new ParseError(
            "Invalid delimiter: '" + delim.value + "' after '" +
            context.funcName + "'", delim);
    }
};

defineFunction([
    "\\bigl", "\\Bigl", "\\biggl", "\\Biggl",
    "\\bigr", "\\Bigr", "\\biggr", "\\Biggr",
    "\\bigm", "\\Bigm", "\\biggm", "\\Biggm",
    "\\big",  "\\Big",  "\\bigg",  "\\Bigg"
], {
    numArgs: 1
}, function(context, args) {
    var delim = checkDelimiter(args[0], context);

    return {
        type: "delimsizing",
        size: delimiterSizes[context.funcName].size,
        mclass: delimiterSizes[context.funcName].mclass,
        value: delim.value
    };
});

defineFunction([
    "\\left", "\\right"
], {
    numArgs: 1
}, function(context, args) {
    var delim = checkDelimiter(args[0], context);

    // \left and \right are caught somewhere in Parser.js, which is
    // why this data doesn't match what is in buildHTML.
    return {
        type: "leftright",
        value: delim.value
    };
});

defineFunction("\\middle", {
    numArgs: 1
}, function(context, args) {
    var delim = checkDelimiter(args[0], context);
    if (!context.parser.leftrightDepth) {
        throw new ParseError("\\middle without preceding \\left", delim);
    }

    return {
        type: "middle",
        value: delim.value
    };
});

// Sizing functions (handled in Parser.js explicitly, hence no handler)
defineFunction([
    "\\tiny", "\\scriptsize", "\\footnotesize", "\\small",
    "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"
], 0, null);

// Style changing functions (handled in Parser.js explicitly, hence no
// handler)
defineFunction([
    "\\displaystyle", "\\textstyle", "\\scriptstyle",
    "\\scriptscriptstyle"
], 0, null);

defineFunction([
    // styles
    "\\mathrm", "\\mathit", "\\mathbf",

    // families
    "\\mathbb", "\\mathcal", "\\mathfrak", "\\mathscr", "\\mathsf",
    "\\mathtt",

    // aliases
    "\\Bbb", "\\bold", "\\frak"
], {
    numArgs: 1,
    greediness: 2
}, function(context, args) {
    var body = args[0];
    var func = context.funcName;
    if (func in fontAliases) {
        func = fontAliases[func];
    }
    return {
        type: "font",
        font: func.slice(1),
        body: body
    };
});

// Accents
defineFunction([
    "\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve",
    "\\check", "\\hat", "\\vec", "\\dot"
    // We don't support expanding accents yet
    // "\\widetilde", "\\widehat"
], {
    numArgs: 1
}, function(context, args) {
    var base = args[0];
    return {
        type: "accent",
        accent: context.funcName,
        base: base
    };
});

// Infix generalized fractions
defineFunction(["\\over", "\\choose", "\\atop"], {
    numArgs: 0,
    infix: true
}, function(context) {
    var replaceWith;
    switch (context.funcName) {
        case "\\over":
            replaceWith = "\\frac";
            break;
        case "\\choose":
            replaceWith = "\\binom";
            break;
        case "\\atop":
            replaceWith = "\\\\atopfrac";
            break;
        default:
            throw new Error("Unrecognized infix genfrac command");
    }
    return {
        type: "infix",
        replaceWith: replaceWith,
        token: context.token
    };
});

// Row breaks for aligned data
defineFunction(["\\\\", "\\cr"], {
    numArgs: 0,
    numOptionalArgs: 1,
    argTypes: ["size"]
}, function(context, args) {
    var size = args[0];
    return {
        type: "cr",
        size: size
    };
});

// Environment delimiters
defineFunction(["\\begin", "\\end"], {
    numArgs: 1,
    argTypes: ["text"]
}, function(context, args) {
    var nameGroup = args[0];
    if (nameGroup.type !== "ordgroup") {
        throw new ParseError("Invalid environment name", nameGroup);
    }
    var name = "";
    for (var i = 0; i < nameGroup.value.length; ++i) {
        name += nameGroup.value[i].value;
    }
    return {
        type: "environment",
        name: name,
        nameGroup: nameGroup
    };
});

},{"./ParseError":94,"./parseData":109,"./utils":113}],108:[function(require,module,exports){
/**
 * These objects store data about MathML nodes. This is the MathML equivalent
 * of the types in domTree.js. Since MathML handles its own rendering, and
 * since we're mainly using MathML to improve accessibility, we don't manage
 * any of the styling state that the plain DOM nodes do.
 *
 * The `toNode` and `toMarkup` functions work simlarly to how they do in
 * domTree.js, creating namespaced DOM nodes and HTML text markup respectively.
 */

var utils = require("./utils");

/**
 * This node represents a general purpose MathML node of any type. The
 * constructor requires the type of node to create (for example, `"mo"` or
 * `"mspace"`, corresponding to `<mo>` and `<mspace>` tags).
 */
function MathNode(type, children) {
    this.type = type;
    this.attributes = {};
    this.children = children || [];
}

/**
 * Sets an attribute on a MathML node. MathML depends on attributes to convey a
 * semantic content, so this is used heavily.
 */
MathNode.prototype.setAttribute = function(name, value) {
    this.attributes[name] = value;
};

/**
 * Converts the math node into a MathML-namespaced DOM element.
 */
MathNode.prototype.toNode = function() {
    var node = document.createElementNS(
        "http://www.w3.org/1998/Math/MathML", this.type);

    for (var attr in this.attributes) {
        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            node.setAttribute(attr, this.attributes[attr]);
        }
    }

    for (var i = 0; i < this.children.length; i++) {
        node.appendChild(this.children[i].toNode());
    }

    return node;
};

/**
 * Converts the math node into an HTML markup string.
 */
MathNode.prototype.toMarkup = function() {
    var markup = "<" + this.type;

    // Add the attributes
    for (var attr in this.attributes) {
        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            markup += " " + attr + "=\"";
            markup += utils.escape(this.attributes[attr]);
            markup += "\"";
        }
    }

    markup += ">";

    for (var i = 0; i < this.children.length; i++) {
        markup += this.children[i].toMarkup();
    }

    markup += "</" + this.type + ">";

    return markup;
};

/**
 * This node represents a piece of text.
 */
function TextNode(text) {
    this.text = text;
}

/**
 * Converts the text node into a DOM text node.
 */
TextNode.prototype.toNode = function() {
    return document.createTextNode(this.text);
};

/**
 * Converts the text node into HTML markup (which is just the text itself).
 */
TextNode.prototype.toMarkup = function() {
    return utils.escape(this.text);
};

module.exports = {
    MathNode: MathNode,
    TextNode: TextNode
};

},{"./utils":113}],109:[function(require,module,exports){
/**
 * The resulting parse tree nodes of the parse tree.
 *
 * It is possible to provide position information, so that a ParseNode can
 * fulfil a role similar to a Token in error reporting.
 * For details on the corresponding properties see Token constructor.
 * Providing such information can lead to better error reporting.
 *
 * @param {string}  type       type of node, like e.g. "ordgroup"
 * @param {?object} value      type-specific representation of the node
 * @param {string}  mode       parse mode in action for this node,
 *                             "math" or "text"
 * @param {Token=} firstToken  first token of the input for this node,
 *                             will omit position information if unset
 * @param {Token=} lastToken   last token of the input for this node,
 *                             will default to firstToken if unset
 */
function ParseNode(type, value, mode, firstToken, lastToken) {
    this.type = type;
    this.value = value;
    this.mode = mode;
    if (firstToken && (!lastToken || lastToken.lexer === firstToken.lexer)) {
        this.lexer = firstToken.lexer;
        this.start = firstToken.start;
        this.end = (lastToken || firstToken).end;
    }
}

module.exports = {
    ParseNode: ParseNode
};


},{}],110:[function(require,module,exports){
/**
 * Provides a single function for parsing an expression using a Parser
 * TODO(emily): Remove this
 */

var Parser = require("./Parser");

/**
 * Parses an expression using a Parser, then returns the parsed result.
 */
var parseTree = function(toParse, settings) {
    if (!(typeof toParse === 'string' || toParse instanceof String)) {
        throw new TypeError('KaTeX can only parse string typed expression');
    }
    var parser = new Parser(toParse, settings);

    return parser.parse();
};

module.exports = parseTree;

},{"./Parser":95}],111:[function(require,module,exports){
/**
 * This file holds a list of all no-argument functions and single-character
 * symbols (like 'a' or ';').
 *
 * For each of the symbols, there are three properties they can have:
 * - font (required): the font to be used for this symbol. Either "main" (the
     normal font), or "ams" (the ams fonts).
 * - group (required): the ParseNode group type the symbol should have (i.e.
     "textord", "mathord", etc).
     See https://github.com/Khan/KaTeX/wiki/Examining-TeX#group-types
 * - replace: the character that this symbol or function should be
 *   replaced with (i.e. "\phi" has a replace value of "\u03d5", the phi
 *   character in the main font).
 *
 * The outermost map in the table indicates what mode the symbols should be
 * accepted in (e.g. "math" or "text").
 */

module.exports = {
    math: {},
    text: {}
};

function defineSymbol(mode, font, group, replace, name) {
    module.exports[mode][name] = {
        font: font,
        group: group,
        replace: replace
    };
}

// Some abbreviations for commonly used strings.
// This helps minify the code, and also spotting typos using jshint.

// modes:
var math = "math";
var text = "text";

// fonts:
var main = "main";
var ams = "ams";

// groups:
var accent = "accent";
var bin = "bin";
var close = "close";
var inner = "inner";
var mathord = "mathord";
var op = "op";
var open = "open";
var punct = "punct";
var rel = "rel";
var spacing = "spacing";
var textord = "textord";

// Now comes the symbol table

// Relation Symbols
defineSymbol(math, main, rel, "\u2261", "\\equiv");
defineSymbol(math, main, rel, "\u227a", "\\prec");
defineSymbol(math, main, rel, "\u227b", "\\succ");
defineSymbol(math, main, rel, "\u223c", "\\sim");
defineSymbol(math, main, rel, "\u22a5", "\\perp");
defineSymbol(math, main, rel, "\u2aaf", "\\preceq");
defineSymbol(math, main, rel, "\u2ab0", "\\succeq");
defineSymbol(math, main, rel, "\u2243", "\\simeq");
defineSymbol(math, main, rel, "\u2223", "\\mid");
defineSymbol(math, main, rel, "\u226a", "\\ll");
defineSymbol(math, main, rel, "\u226b", "\\gg");
defineSymbol(math, main, rel, "\u224d", "\\asymp");
defineSymbol(math, main, rel, "\u2225", "\\parallel");
defineSymbol(math, main, rel, "\u22c8", "\\bowtie");
defineSymbol(math, main, rel, "\u2323", "\\smile");
defineSymbol(math, main, rel, "\u2291", "\\sqsubseteq");
defineSymbol(math, main, rel, "\u2292", "\\sqsupseteq");
defineSymbol(math, main, rel, "\u2250", "\\doteq");
defineSymbol(math, main, rel, "\u2322", "\\frown");
defineSymbol(math, main, rel, "\u220b", "\\ni");
defineSymbol(math, main, rel, "\u221d", "\\propto");
defineSymbol(math, main, rel, "\u22a2", "\\vdash");
defineSymbol(math, main, rel, "\u22a3", "\\dashv");
defineSymbol(math, main, rel, "\u220b", "\\owns");

// Punctuation
defineSymbol(math, main, punct, "\u002e", "\\ldotp");
defineSymbol(math, main, punct, "\u22c5", "\\cdotp");

// Misc Symbols
defineSymbol(math, main, textord, "\u0023", "\\#");
defineSymbol(text, main, textord, "\u0023", "\\#");
defineSymbol(math, main, textord, "\u0026", "\\&");
defineSymbol(text, main, textord, "\u0026", "\\&");
defineSymbol(math, main, textord, "\u2135", "\\aleph");
defineSymbol(math, main, textord, "\u2200", "\\forall");
defineSymbol(math, main, textord, "\u210f", "\\hbar");
defineSymbol(math, main, textord, "\u2203", "\\exists");
defineSymbol(math, main, textord, "\u2207", "\\nabla");
defineSymbol(math, main, textord, "\u266d", "\\flat");
defineSymbol(math, main, textord, "\u2113", "\\ell");
defineSymbol(math, main, textord, "\u266e", "\\natural");
defineSymbol(math, main, textord, "\u2663", "\\clubsuit");
defineSymbol(math, main, textord, "\u2118", "\\wp");
defineSymbol(math, main, textord, "\u266f", "\\sharp");
defineSymbol(math, main, textord, "\u2662", "\\diamondsuit");
defineSymbol(math, main, textord, "\u211c", "\\Re");
defineSymbol(math, main, textord, "\u2661", "\\heartsuit");
defineSymbol(math, main, textord, "\u2111", "\\Im");
defineSymbol(math, main, textord, "\u2660", "\\spadesuit");

// Math and Text
defineSymbol(math, main, textord, "\u2020", "\\dag");
defineSymbol(math, main, textord, "\u2021", "\\ddag");

// Large Delimiters
defineSymbol(math, main, close, "\u23b1", "\\rmoustache");
defineSymbol(math, main, open, "\u23b0", "\\lmoustache");
defineSymbol(math, main, close, "\u27ef", "\\rgroup");
defineSymbol(math, main, open, "\u27ee", "\\lgroup");

// Binary Operators
defineSymbol(math, main, bin, "\u2213", "\\mp");
defineSymbol(math, main, bin, "\u2296", "\\ominus");
defineSymbol(math, main, bin, "\u228e", "\\uplus");
defineSymbol(math, main, bin, "\u2293", "\\sqcap");
defineSymbol(math, main, bin, "\u2217", "\\ast");
defineSymbol(math, main, bin, "\u2294", "\\sqcup");
defineSymbol(math, main, bin, "\u25ef", "\\bigcirc");
defineSymbol(math, main, bin, "\u2219", "\\bullet");
defineSymbol(math, main, bin, "\u2021", "\\ddagger");
defineSymbol(math, main, bin, "\u2240", "\\wr");
defineSymbol(math, main, bin, "\u2a3f", "\\amalg");

// Arrow Symbols
defineSymbol(math, main, rel, "\u27f5", "\\longleftarrow");
defineSymbol(math, main, rel, "\u21d0", "\\Leftarrow");
defineSymbol(math, main, rel, "\u27f8", "\\Longleftarrow");
defineSymbol(math, main, rel, "\u27f6", "\\longrightarrow");
defineSymbol(math, main, rel, "\u21d2", "\\Rightarrow");
defineSymbol(math, main, rel, "\u27f9", "\\Longrightarrow");
defineSymbol(math, main, rel, "\u2194", "\\leftrightarrow");
defineSymbol(math, main, rel, "\u27f7", "\\longleftrightarrow");
defineSymbol(math, main, rel, "\u21d4", "\\Leftrightarrow");
defineSymbol(math, main, rel, "\u27fa", "\\Longleftrightarrow");
defineSymbol(math, main, rel, "\u21a6", "\\mapsto");
defineSymbol(math, main, rel, "\u27fc", "\\longmapsto");
defineSymbol(math, main, rel, "\u2197", "\\nearrow");
defineSymbol(math, main, rel, "\u21a9", "\\hookleftarrow");
defineSymbol(math, main, rel, "\u21aa", "\\hookrightarrow");
defineSymbol(math, main, rel, "\u2198", "\\searrow");
defineSymbol(math, main, rel, "\u21bc", "\\leftharpoonup");
defineSymbol(math, main, rel, "\u21c0", "\\rightharpoonup");
defineSymbol(math, main, rel, "\u2199", "\\swarrow");
defineSymbol(math, main, rel, "\u21bd", "\\leftharpoondown");
defineSymbol(math, main, rel, "\u21c1", "\\rightharpoondown");
defineSymbol(math, main, rel, "\u2196", "\\nwarrow");
defineSymbol(math, main, rel, "\u21cc", "\\rightleftharpoons");

// AMS Negated Binary Relations
defineSymbol(math, ams, rel, "\u226e", "\\nless");
defineSymbol(math, ams, rel, "\ue010", "\\nleqslant");
defineSymbol(math, ams, rel, "\ue011", "\\nleqq");
defineSymbol(math, ams, rel, "\u2a87", "\\lneq");
defineSymbol(math, ams, rel, "\u2268", "\\lneqq");
defineSymbol(math, ams, rel, "\ue00c", "\\lvertneqq");
defineSymbol(math, ams, rel, "\u22e6", "\\lnsim");
defineSymbol(math, ams, rel, "\u2a89", "\\lnapprox");
defineSymbol(math, ams, rel, "\u2280", "\\nprec");
defineSymbol(math, ams, rel, "\u22e0", "\\npreceq");
defineSymbol(math, ams, rel, "\u22e8", "\\precnsim");
defineSymbol(math, ams, rel, "\u2ab9", "\\precnapprox");
defineSymbol(math, ams, rel, "\u2241", "\\nsim");
defineSymbol(math, ams, rel, "\ue006", "\\nshortmid");
defineSymbol(math, ams, rel, "\u2224", "\\nmid");
defineSymbol(math, ams, rel, "\u22ac", "\\nvdash");
defineSymbol(math, ams, rel, "\u22ad", "\\nvDash");
defineSymbol(math, ams, rel, "\u22ea", "\\ntriangleleft");
defineSymbol(math, ams, rel, "\u22ec", "\\ntrianglelefteq");
defineSymbol(math, ams, rel, "\u228a", "\\subsetneq");
defineSymbol(math, ams, rel, "\ue01a", "\\varsubsetneq");
defineSymbol(math, ams, rel, "\u2acb", "\\subsetneqq");
defineSymbol(math, ams, rel, "\ue017", "\\varsubsetneqq");
defineSymbol(math, ams, rel, "\u226f", "\\ngtr");
defineSymbol(math, ams, rel, "\ue00f", "\\ngeqslant");
defineSymbol(math, ams, rel, "\ue00e", "\\ngeqq");
defineSymbol(math, ams, rel, "\u2a88", "\\gneq");
defineSymbol(math, ams, rel, "\u2269", "\\gneqq");
defineSymbol(math, ams, rel, "\ue00d", "\\gvertneqq");
defineSymbol(math, ams, rel, "\u22e7", "\\gnsim");
defineSymbol(math, ams, rel, "\u2a8a", "\\gnapprox");
defineSymbol(math, ams, rel, "\u2281", "\\nsucc");
defineSymbol(math, ams, rel, "\u22e1", "\\nsucceq");
defineSymbol(math, ams, rel, "\u22e9", "\\succnsim");
defineSymbol(math, ams, rel, "\u2aba", "\\succnapprox");
defineSymbol(math, ams, rel, "\u2246", "\\ncong");
defineSymbol(math, ams, rel, "\ue007", "\\nshortparallel");
defineSymbol(math, ams, rel, "\u2226", "\\nparallel");
defineSymbol(math, ams, rel, "\u22af", "\\nVDash");
defineSymbol(math, ams, rel, "\u22eb", "\\ntriangleright");
defineSymbol(math, ams, rel, "\u22ed", "\\ntrianglerighteq");
defineSymbol(math, ams, rel, "\ue018", "\\nsupseteqq");
defineSymbol(math, ams, rel, "\u228b", "\\supsetneq");
defineSymbol(math, ams, rel, "\ue01b", "\\varsupsetneq");
defineSymbol(math, ams, rel, "\u2acc", "\\supsetneqq");
defineSymbol(math, ams, rel, "\ue019", "\\varsupsetneqq");
defineSymbol(math, ams, rel, "\u22ae", "\\nVdash");
defineSymbol(math, ams, rel, "\u2ab5", "\\precneqq");
defineSymbol(math, ams, rel, "\u2ab6", "\\succneqq");
defineSymbol(math, ams, rel, "\ue016", "\\nsubseteqq");
defineSymbol(math, ams, bin, "\u22b4", "\\unlhd");
defineSymbol(math, ams, bin, "\u22b5", "\\unrhd");

// AMS Negated Arrows
defineSymbol(math, ams, rel, "\u219a", "\\nleftarrow");
defineSymbol(math, ams, rel, "\u219b", "\\nrightarrow");
defineSymbol(math, ams, rel, "\u21cd", "\\nLeftarrow");
defineSymbol(math, ams, rel, "\u21cf", "\\nRightarrow");
defineSymbol(math, ams, rel, "\u21ae", "\\nleftrightarrow");
defineSymbol(math, ams, rel, "\u21ce", "\\nLeftrightarrow");

// AMS Misc
defineSymbol(math, ams, rel, "\u25b3", "\\vartriangle");
defineSymbol(math, ams, textord, "\u210f", "\\hslash");
defineSymbol(math, ams, textord, "\u25bd", "\\triangledown");
defineSymbol(math, ams, textord, "\u25ca", "\\lozenge");
defineSymbol(math, ams, textord, "\u24c8", "\\circledS");
defineSymbol(math, ams, textord, "\u00ae", "\\circledR");
defineSymbol(math, ams, textord, "\u2221", "\\measuredangle");
defineSymbol(math, ams, textord, "\u2204", "\\nexists");
defineSymbol(math, ams, textord, "\u2127", "\\mho");
defineSymbol(math, ams, textord, "\u2132", "\\Finv");
defineSymbol(math, ams, textord, "\u2141", "\\Game");
defineSymbol(math, ams, textord, "\u006b", "\\Bbbk");
defineSymbol(math, ams, textord, "\u2035", "\\backprime");
defineSymbol(math, ams, textord, "\u25b2", "\\blacktriangle");
defineSymbol(math, ams, textord, "\u25bc", "\\blacktriangledown");
defineSymbol(math, ams, textord, "\u25a0", "\\blacksquare");
defineSymbol(math, ams, textord, "\u29eb", "\\blacklozenge");
defineSymbol(math, ams, textord, "\u2605", "\\bigstar");
defineSymbol(math, ams, textord, "\u2222", "\\sphericalangle");
defineSymbol(math, ams, textord, "\u2201", "\\complement");
defineSymbol(math, ams, textord, "\u00f0", "\\eth");
defineSymbol(math, ams, textord, "\u2571", "\\diagup");
defineSymbol(math, ams, textord, "\u2572", "\\diagdown");
defineSymbol(math, ams, textord, "\u25a1", "\\square");
defineSymbol(math, ams, textord, "\u25a1", "\\Box");
defineSymbol(math, ams, textord, "\u25ca", "\\Diamond");
defineSymbol(math, ams, textord, "\u00a5", "\\yen");
defineSymbol(math, ams, textord, "\u2713", "\\checkmark");

// AMS Hebrew
defineSymbol(math, ams, textord, "\u2136", "\\beth");
defineSymbol(math, ams, textord, "\u2138", "\\daleth");
defineSymbol(math, ams, textord, "\u2137", "\\gimel");

// AMS Greek
defineSymbol(math, ams, textord, "\u03dd", "\\digamma");
defineSymbol(math, ams, textord, "\u03f0", "\\varkappa");

// AMS Delimiters
defineSymbol(math, ams, open, "\u250c", "\\ulcorner");
defineSymbol(math, ams, close, "\u2510", "\\urcorner");
defineSymbol(math, ams, open, "\u2514", "\\llcorner");
defineSymbol(math, ams, close, "\u2518", "\\lrcorner");

// AMS Binary Relations
defineSymbol(math, ams, rel, "\u2266", "\\leqq");
defineSymbol(math, ams, rel, "\u2a7d", "\\leqslant");
defineSymbol(math, ams, rel, "\u2a95", "\\eqslantless");
defineSymbol(math, ams, rel, "\u2272", "\\lesssim");
defineSymbol(math, ams, rel, "\u2a85", "\\lessapprox");
defineSymbol(math, ams, rel, "\u224a", "\\approxeq");
defineSymbol(math, ams, bin, "\u22d6", "\\lessdot");
defineSymbol(math, ams, rel, "\u22d8", "\\lll");
defineSymbol(math, ams, rel, "\u2276", "\\lessgtr");
defineSymbol(math, ams, rel, "\u22da", "\\lesseqgtr");
defineSymbol(math, ams, rel, "\u2a8b", "\\lesseqqgtr");
defineSymbol(math, ams, rel, "\u2251", "\\doteqdot");
defineSymbol(math, ams, rel, "\u2253", "\\risingdotseq");
defineSymbol(math, ams, rel, "\u2252", "\\fallingdotseq");
defineSymbol(math, ams, rel, "\u223d", "\\backsim");
defineSymbol(math, ams, rel, "\u22cd", "\\backsimeq");
defineSymbol(math, ams, rel, "\u2ac5", "\\subseteqq");
defineSymbol(math, ams, rel, "\u22d0", "\\Subset");
defineSymbol(math, ams, rel, "\u228f", "\\sqsubset");
defineSymbol(math, ams, rel, "\u227c", "\\preccurlyeq");
defineSymbol(math, ams, rel, "\u22de", "\\curlyeqprec");
defineSymbol(math, ams, rel, "\u227e", "\\precsim");
defineSymbol(math, ams, rel, "\u2ab7", "\\precapprox");
defineSymbol(math, ams, rel, "\u22b2", "\\vartriangleleft");
defineSymbol(math, ams, rel, "\u22b4", "\\trianglelefteq");
defineSymbol(math, ams, rel, "\u22a8", "\\vDash");
defineSymbol(math, ams, rel, "\u22aa", "\\Vvdash");
defineSymbol(math, ams, rel, "\u2323", "\\smallsmile");
defineSymbol(math, ams, rel, "\u2322", "\\smallfrown");
defineSymbol(math, ams, rel, "\u224f", "\\bumpeq");
defineSymbol(math, ams, rel, "\u224e", "\\Bumpeq");
defineSymbol(math, ams, rel, "\u2267", "\\geqq");
defineSymbol(math, ams, rel, "\u2a7e", "\\geqslant");
defineSymbol(math, ams, rel, "\u2a96", "\\eqslantgtr");
defineSymbol(math, ams, rel, "\u2273", "\\gtrsim");
defineSymbol(math, ams, rel, "\u2a86", "\\gtrapprox");
defineSymbol(math, ams, bin, "\u22d7", "\\gtrdot");
defineSymbol(math, ams, rel, "\u22d9", "\\ggg");
defineSymbol(math, ams, rel, "\u2277", "\\gtrless");
defineSymbol(math, ams, rel, "\u22db", "\\gtreqless");
defineSymbol(math, ams, rel, "\u2a8c", "\\gtreqqless");
defineSymbol(math, ams, rel, "\u2256", "\\eqcirc");
defineSymbol(math, ams, rel, "\u2257", "\\circeq");
defineSymbol(math, ams, rel, "\u225c", "\\triangleq");
defineSymbol(math, ams, rel, "\u223c", "\\thicksim");
defineSymbol(math, ams, rel, "\u2248", "\\thickapprox");
defineSymbol(math, ams, rel, "\u2ac6", "\\supseteqq");
defineSymbol(math, ams, rel, "\u22d1", "\\Supset");
defineSymbol(math, ams, rel, "\u2290", "\\sqsupset");
defineSymbol(math, ams, rel, "\u227d", "\\succcurlyeq");
defineSymbol(math, ams, rel, "\u22df", "\\curlyeqsucc");
defineSymbol(math, ams, rel, "\u227f", "\\succsim");
defineSymbol(math, ams, rel, "\u2ab8", "\\succapprox");
defineSymbol(math, ams, rel, "\u22b3", "\\vartriangleright");
defineSymbol(math, ams, rel, "\u22b5", "\\trianglerighteq");
defineSymbol(math, ams, rel, "\u22a9", "\\Vdash");
defineSymbol(math, ams, rel, "\u2223", "\\shortmid");
defineSymbol(math, ams, rel, "\u2225", "\\shortparallel");
defineSymbol(math, ams, rel, "\u226c", "\\between");
defineSymbol(math, ams, rel, "\u22d4", "\\pitchfork");
defineSymbol(math, ams, rel, "\u221d", "\\varpropto");
defineSymbol(math, ams, rel, "\u25c0", "\\blacktriangleleft");
defineSymbol(math, ams, rel, "\u2234", "\\therefore");
defineSymbol(math, ams, rel, "\u220d", "\\backepsilon");
defineSymbol(math, ams, rel, "\u25b6", "\\blacktriangleright");
defineSymbol(math, ams, rel, "\u2235", "\\because");
defineSymbol(math, ams, rel, "\u22d8", "\\llless");
defineSymbol(math, ams, rel, "\u22d9", "\\gggtr");
defineSymbol(math, ams, bin, "\u22b2", "\\lhd");
defineSymbol(math, ams, bin, "\u22b3", "\\rhd");
defineSymbol(math, ams, rel, "\u2242", "\\eqsim");
defineSymbol(math, main, rel, "\u22c8", "\\Join");
defineSymbol(math, ams, rel, "\u2251", "\\Doteq");

// AMS Binary Operators
defineSymbol(math, ams, bin, "\u2214", "\\dotplus");
defineSymbol(math, ams, bin, "\u2216", "\\smallsetminus");
defineSymbol(math, ams, bin, "\u22d2", "\\Cap");
defineSymbol(math, ams, bin, "\u22d3", "\\Cup");
defineSymbol(math, ams, bin, "\u2a5e", "\\doublebarwedge");
defineSymbol(math, ams, bin, "\u229f", "\\boxminus");
defineSymbol(math, ams, bin, "\u229e", "\\boxplus");
defineSymbol(math, ams, bin, "\u22c7", "\\divideontimes");
defineSymbol(math, ams, bin, "\u22c9", "\\ltimes");
defineSymbol(math, ams, bin, "\u22ca", "\\rtimes");
defineSymbol(math, ams, bin, "\u22cb", "\\leftthreetimes");
defineSymbol(math, ams, bin, "\u22cc", "\\rightthreetimes");
defineSymbol(math, ams, bin, "\u22cf", "\\curlywedge");
defineSymbol(math, ams, bin, "\u22ce", "\\curlyvee");
defineSymbol(math, ams, bin, "\u229d", "\\circleddash");
defineSymbol(math, ams, bin, "\u229b", "\\circledast");
defineSymbol(math, ams, bin, "\u22c5", "\\centerdot");
defineSymbol(math, ams, bin, "\u22ba", "\\intercal");
defineSymbol(math, ams, bin, "\u22d2", "\\doublecap");
defineSymbol(math, ams, bin, "\u22d3", "\\doublecup");
defineSymbol(math, ams, bin, "\u22a0", "\\boxtimes");

// AMS Arrows
defineSymbol(math, ams, rel, "\u21e2", "\\dashrightarrow");
defineSymbol(math, ams, rel, "\u21e0", "\\dashleftarrow");
defineSymbol(math, ams, rel, "\u21c7", "\\leftleftarrows");
defineSymbol(math, ams, rel, "\u21c6", "\\leftrightarrows");
defineSymbol(math, ams, rel, "\u21da", "\\Lleftarrow");
defineSymbol(math, ams, rel, "\u219e", "\\twoheadleftarrow");
defineSymbol(math, ams, rel, "\u21a2", "\\leftarrowtail");
defineSymbol(math, ams, rel, "\u21ab", "\\looparrowleft");
defineSymbol(math, ams, rel, "\u21cb", "\\leftrightharpoons");
defineSymbol(math, ams, rel, "\u21b6", "\\curvearrowleft");
defineSymbol(math, ams, rel, "\u21ba", "\\circlearrowleft");
defineSymbol(math, ams, rel, "\u21b0", "\\Lsh");
defineSymbol(math, ams, rel, "\u21c8", "\\upuparrows");
defineSymbol(math, ams, rel, "\u21bf", "\\upharpoonleft");
defineSymbol(math, ams, rel, "\u21c3", "\\downharpoonleft");
defineSymbol(math, ams, rel, "\u22b8", "\\multimap");
defineSymbol(math, ams, rel, "\u21ad", "\\leftrightsquigarrow");
defineSymbol(math, ams, rel, "\u21c9", "\\rightrightarrows");
defineSymbol(math, ams, rel, "\u21c4", "\\rightleftarrows");
defineSymbol(math, ams, rel, "\u21a0", "\\twoheadrightarrow");
defineSymbol(math, ams, rel, "\u21a3", "\\rightarrowtail");
defineSymbol(math, ams, rel, "\u21ac", "\\looparrowright");
defineSymbol(math, ams, rel, "\u21b7", "\\curvearrowright");
defineSymbol(math, ams, rel, "\u21bb", "\\circlearrowright");
defineSymbol(math, ams, rel, "\u21b1", "\\Rsh");
defineSymbol(math, ams, rel, "\u21ca", "\\downdownarrows");
defineSymbol(math, ams, rel, "\u21be", "\\upharpoonright");
defineSymbol(math, ams, rel, "\u21c2", "\\downharpoonright");
defineSymbol(math, ams, rel, "\u21dd", "\\rightsquigarrow");
defineSymbol(math, ams, rel, "\u21dd", "\\leadsto");
defineSymbol(math, ams, rel, "\u21db", "\\Rrightarrow");
defineSymbol(math, ams, rel, "\u21be", "\\restriction");

defineSymbol(math, main, textord, "\u2018", "`");
defineSymbol(math, main, textord, "$", "\\$");
defineSymbol(text, main, textord, "$", "\\$");
defineSymbol(math, main, textord, "%", "\\%");
defineSymbol(text, main, textord, "%", "\\%");
defineSymbol(math, main, textord, "_", "\\_");
defineSymbol(text, main, textord, "_", "\\_");
defineSymbol(math, main, textord, "\u2220", "\\angle");
defineSymbol(math, main, textord, "\u221e", "\\infty");
defineSymbol(math, main, textord, "\u2032", "\\prime");
defineSymbol(math, main, textord, "\u25b3", "\\triangle");
defineSymbol(math, main, textord, "\u0393", "\\Gamma");
defineSymbol(math, main, textord, "\u0394", "\\Delta");
defineSymbol(math, main, textord, "\u0398", "\\Theta");
defineSymbol(math, main, textord, "\u039b", "\\Lambda");
defineSymbol(math, main, textord, "\u039e", "\\Xi");
defineSymbol(math, main, textord, "\u03a0", "\\Pi");
defineSymbol(math, main, textord, "\u03a3", "\\Sigma");
defineSymbol(math, main, textord, "\u03a5", "\\Upsilon");
defineSymbol(math, main, textord, "\u03a6", "\\Phi");
defineSymbol(math, main, textord, "\u03a8", "\\Psi");
defineSymbol(math, main, textord, "\u03a9", "\\Omega");
defineSymbol(math, main, textord, "\u00ac", "\\neg");
defineSymbol(math, main, textord, "\u00ac", "\\lnot");
defineSymbol(math, main, textord, "\u22a4", "\\top");
defineSymbol(math, main, textord, "\u22a5", "\\bot");
defineSymbol(math, main, textord, "\u2205", "\\emptyset");
defineSymbol(math, ams, textord, "\u2205", "\\varnothing");
defineSymbol(math, main, mathord, "\u03b1", "\\alpha");
defineSymbol(math, main, mathord, "\u03b2", "\\beta");
defineSymbol(math, main, mathord, "\u03b3", "\\gamma");
defineSymbol(math, main, mathord, "\u03b4", "\\delta");
defineSymbol(math, main, mathord, "\u03f5", "\\epsilon");
defineSymbol(math, main, mathord, "\u03b6", "\\zeta");
defineSymbol(math, main, mathord, "\u03b7", "\\eta");
defineSymbol(math, main, mathord, "\u03b8", "\\theta");
defineSymbol(math, main, mathord, "\u03b9", "\\iota");
defineSymbol(math, main, mathord, "\u03ba", "\\kappa");
defineSymbol(math, main, mathord, "\u03bb", "\\lambda");
defineSymbol(math, main, mathord, "\u03bc", "\\mu");
defineSymbol(math, main, mathord, "\u03bd", "\\nu");
defineSymbol(math, main, mathord, "\u03be", "\\xi");
defineSymbol(math, main, mathord, "o", "\\omicron");
defineSymbol(math, main, mathord, "\u03c0", "\\pi");
defineSymbol(math, main, mathord, "\u03c1", "\\rho");
defineSymbol(math, main, mathord, "\u03c3", "\\sigma");
defineSymbol(math, main, mathord, "\u03c4", "\\tau");
defineSymbol(math, main, mathord, "\u03c5", "\\upsilon");
defineSymbol(math, main, mathord, "\u03d5", "\\phi");
defineSymbol(math, main, mathord, "\u03c7", "\\chi");
defineSymbol(math, main, mathord, "\u03c8", "\\psi");
defineSymbol(math, main, mathord, "\u03c9", "\\omega");
defineSymbol(math, main, mathord, "\u03b5", "\\varepsilon");
defineSymbol(math, main, mathord, "\u03d1", "\\vartheta");
defineSymbol(math, main, mathord, "\u03d6", "\\varpi");
defineSymbol(math, main, mathord, "\u03f1", "\\varrho");
defineSymbol(math, main, mathord, "\u03c2", "\\varsigma");
defineSymbol(math, main, mathord, "\u03c6", "\\varphi");
defineSymbol(math, main, bin, "\u2217", "*");
defineSymbol(math, main, bin, "+", "+");
defineSymbol(math, main, bin, "\u2212", "-");
defineSymbol(math, main, bin, "\u22c5", "\\cdot");
defineSymbol(math, main, bin, "\u2218", "\\circ");
defineSymbol(math, main, bin, "\u00f7", "\\div");
defineSymbol(math, main, bin, "\u00b1", "\\pm");
defineSymbol(math, main, bin, "\u00d7", "\\times");
defineSymbol(math, main, bin, "\u2229", "\\cap");
defineSymbol(math, main, bin, "\u222a", "\\cup");
defineSymbol(math, main, bin, "\u2216", "\\setminus");
defineSymbol(math, main, bin, "\u2227", "\\land");
defineSymbol(math, main, bin, "\u2228", "\\lor");
defineSymbol(math, main, bin, "\u2227", "\\wedge");
defineSymbol(math, main, bin, "\u2228", "\\vee");
defineSymbol(math, main, textord, "\u221a", "\\surd");
defineSymbol(math, main, open, "(", "(");
defineSymbol(math, main, open, "[", "[");
defineSymbol(math, main, open, "\u27e8", "\\langle");
defineSymbol(math, main, open, "\u2223", "\\lvert");
defineSymbol(math, main, open, "\u2225", "\\lVert");
defineSymbol(math, main, close, ")", ")");
defineSymbol(math, main, close, "]", "]");
defineSymbol(math, main, close, "?", "?");
defineSymbol(math, main, close, "!", "!");
defineSymbol(math, main, close, "\u27e9", "\\rangle");
defineSymbol(math, main, close, "\u2223", "\\rvert");
defineSymbol(math, main, close, "\u2225", "\\rVert");
defineSymbol(math, main, rel, "=", "=");
defineSymbol(math, main, rel, "<", "<");
defineSymbol(math, main, rel, ">", ">");
defineSymbol(math, main, rel, ":", ":");
defineSymbol(math, main, rel, "\u2248", "\\approx");
defineSymbol(math, main, rel, "\u2245", "\\cong");
defineSymbol(math, main, rel, "\u2265", "\\ge");
defineSymbol(math, main, rel, "\u2265", "\\geq");
defineSymbol(math, main, rel, "\u2190", "\\gets");
defineSymbol(math, main, rel, ">", "\\gt");
defineSymbol(math, main, rel, "\u2208", "\\in");
defineSymbol(math, main, rel, "\u2209", "\\notin");
defineSymbol(math, main, rel, "\u2282", "\\subset");
defineSymbol(math, main, rel, "\u2283", "\\supset");
defineSymbol(math, main, rel, "\u2286", "\\subseteq");
defineSymbol(math, main, rel, "\u2287", "\\supseteq");
defineSymbol(math, ams, rel, "\u2288", "\\nsubseteq");
defineSymbol(math, ams, rel, "\u2289", "\\nsupseteq");
defineSymbol(math, main, rel, "\u22a8", "\\models");
defineSymbol(math, main, rel, "\u2190", "\\leftarrow");
defineSymbol(math, main, rel, "\u2264", "\\le");
defineSymbol(math, main, rel, "\u2264", "\\leq");
defineSymbol(math, main, rel, "<", "\\lt");
defineSymbol(math, main, rel, "\u2260", "\\ne");
defineSymbol(math, main, rel, "\u2260", "\\neq");
defineSymbol(math, main, rel, "\u2192", "\\rightarrow");
defineSymbol(math, main, rel, "\u2192", "\\to");
defineSymbol(math, ams, rel, "\u2271", "\\ngeq");
defineSymbol(math, ams, rel, "\u2270", "\\nleq");
defineSymbol(math, main, spacing, null, "\\!");
defineSymbol(math, main, spacing, "\u00a0", "\\ ");
defineSymbol(math, main, spacing, "\u00a0", "~");
defineSymbol(math, main, spacing, null, "\\,");
defineSymbol(math, main, spacing, null, "\\:");
defineSymbol(math, main, spacing, null, "\\;");
defineSymbol(math, main, spacing, null, "\\enspace");
defineSymbol(math, main, spacing, null, "\\qquad");
defineSymbol(math, main, spacing, null, "\\quad");
defineSymbol(math, main, spacing, "\u00a0", "\\space");
defineSymbol(math, main, punct, ",", ",");
defineSymbol(math, main, punct, ";", ";");
defineSymbol(math, main, punct, ":", "\\colon");
defineSymbol(math, ams, bin, "\u22bc", "\\barwedge");
defineSymbol(math, ams, bin, "\u22bb", "\\veebar");
defineSymbol(math, main, bin, "\u2299", "\\odot");
defineSymbol(math, main, bin, "\u2295", "\\oplus");
defineSymbol(math, main, bin, "\u2297", "\\otimes");
defineSymbol(math, main, textord, "\u2202", "\\partial");
defineSymbol(math, main, bin, "\u2298", "\\oslash");
defineSymbol(math, ams, bin, "\u229a", "\\circledcirc");
defineSymbol(math, ams, bin, "\u22a1", "\\boxdot");
defineSymbol(math, main, bin, "\u25b3", "\\bigtriangleup");
defineSymbol(math, main, bin, "\u25bd", "\\bigtriangledown");
defineSymbol(math, main, bin, "\u2020", "\\dagger");
defineSymbol(math, main, bin, "\u22c4", "\\diamond");
defineSymbol(math, main, bin, "\u22c6", "\\star");
defineSymbol(math, main, bin, "\u25c3", "\\triangleleft");
defineSymbol(math, main, bin, "\u25b9", "\\triangleright");
defineSymbol(math, main, open, "{", "\\{");
defineSymbol(text, main, textord, "{", "\\{");
defineSymbol(math, main, close, "}", "\\}");
defineSymbol(text, main, textord, "}", "\\}");
defineSymbol(math, main, open, "{", "\\lbrace");
defineSymbol(math, main, close, "}", "\\rbrace");
defineSymbol(math, main, open, "[", "\\lbrack");
defineSymbol(math, main, close, "]", "\\rbrack");
defineSymbol(math, main, open, "\u230a", "\\lfloor");
defineSymbol(math, main, close, "\u230b", "\\rfloor");
defineSymbol(math, main, open, "\u2308", "\\lceil");
defineSymbol(math, main, close, "\u2309", "\\rceil");
defineSymbol(math, main, textord, "\\", "\\backslash");
defineSymbol(math, main, textord, "\u2223", "|");
defineSymbol(math, main, textord, "\u2223", "\\vert");
defineSymbol(math, main, textord, "\u2225", "\\|");
defineSymbol(math, main, textord, "\u2225", "\\Vert");
defineSymbol(math, main, rel, "\u2191", "\\uparrow");
defineSymbol(math, main, rel, "\u21d1", "\\Uparrow");
defineSymbol(math, main, rel, "\u2193", "\\downarrow");
defineSymbol(math, main, rel, "\u21d3", "\\Downarrow");
defineSymbol(math, main, rel, "\u2195", "\\updownarrow");
defineSymbol(math, main, rel, "\u21d5", "\\Updownarrow");
defineSymbol(math, math, op, "\u2210", "\\coprod");
defineSymbol(math, math, op, "\u22c1", "\\bigvee");
defineSymbol(math, math, op, "\u22c0", "\\bigwedge");
defineSymbol(math, math, op, "\u2a04", "\\biguplus");
defineSymbol(math, math, op, "\u22c2", "\\bigcap");
defineSymbol(math, math, op, "\u22c3", "\\bigcup");
defineSymbol(math, math, op, "\u222b", "\\int");
defineSymbol(math, math, op, "\u222b", "\\intop");
defineSymbol(math, math, op, "\u222c", "\\iint");
defineSymbol(math, math, op, "\u222d", "\\iiint");
defineSymbol(math, math, op, "\u220f", "\\prod");
defineSymbol(math, math, op, "\u2211", "\\sum");
defineSymbol(math, math, op, "\u2a02", "\\bigotimes");
defineSymbol(math, math, op, "\u2a01", "\\bigoplus");
defineSymbol(math, math, op, "\u2a00", "\\bigodot");
defineSymbol(math, math, op, "\u222e", "\\oint");
defineSymbol(math, math, op, "\u2a06", "\\bigsqcup");
defineSymbol(math, math, op, "\u222b", "\\smallint");
defineSymbol(text, main, inner, "\u2026", "\\textellipsis");
defineSymbol(math, main, inner, "\u2026", "\\mathellipsis");
defineSymbol(text, main, inner, "\u2026", "\\ldots");
defineSymbol(math, main, inner, "\u2026", "\\ldots");
defineSymbol(math, main, inner, "\u22ef", "\\cdots");
defineSymbol(math, main, inner, "\u22f1", "\\ddots");
defineSymbol(math, main, textord, "\u22ee", "\\vdots");
defineSymbol(math, main, accent, "\u00b4", "\\acute");
defineSymbol(math, main, accent, "\u0060", "\\grave");
defineSymbol(math, main, accent, "\u00a8", "\\ddot");
defineSymbol(math, main, accent, "\u007e", "\\tilde");
defineSymbol(math, main, accent, "\u00af", "\\bar");
defineSymbol(math, main, accent, "\u02d8", "\\breve");
defineSymbol(math, main, accent, "\u02c7", "\\check");
defineSymbol(math, main, accent, "\u005e", "\\hat");
defineSymbol(math, main, accent, "\u20d7", "\\vec");
defineSymbol(math, main, accent, "\u02d9", "\\dot");
defineSymbol(math, main, mathord, "\u0131", "\\imath");
defineSymbol(math, main, mathord, "\u0237", "\\jmath");

defineSymbol(text, main, textord, "\u2013", "--");
defineSymbol(text, main, textord, "\u2014", "---");
defineSymbol(text, main, textord, "\u2018", "`");
defineSymbol(text, main, textord, "\u2019", "'");
defineSymbol(text, main, textord, "\u201c", "``");
defineSymbol(text, main, textord, "\u201d", "''");
defineSymbol(math, main, textord, "\u00b0", "\\degree");
defineSymbol(text, main, textord, "\u00b0", "\\degree");
defineSymbol(math, main, mathord, "\u00a3", "\\pounds");
defineSymbol(math, ams, textord, "\u2720", "\\maltese");
defineSymbol(text, ams, textord, "\u2720", "\\maltese");

defineSymbol(text, main, spacing, "\u00a0", "\\ ");
defineSymbol(text, main, spacing, "\u00a0", " ");
defineSymbol(text, main, spacing, "\u00a0", "~");

// There are lots of symbols which are the same, so we add them in afterwards.
var i;
var ch;

// All of these are textords in math mode
var mathTextSymbols = "0123456789/@.\"";
for (i = 0; i < mathTextSymbols.length; i++) {
    ch = mathTextSymbols.charAt(i);
    defineSymbol(math, main, textord, ch, ch);
}

// All of these are textords in text mode
var textSymbols = "0123456789!@*()-=+[]\";:?/.,";
for (i = 0; i < textSymbols.length; i++) {
    ch = textSymbols.charAt(i);
    defineSymbol(text, main, textord, ch, ch);
}

// All of these are textords in text mode, and mathords in math mode
var letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
for (i = 0; i < letters.length; i++) {
    ch = letters.charAt(i);
    defineSymbol(math, main, mathord, ch, ch);
    defineSymbol(text, main, textord, ch, ch);
}

// Latin-1 letters
for (i = 0x00C0; i <= 0x00D6; i++) {
    ch = String.fromCharCode(i);
    defineSymbol(text, main, textord, ch, ch);
}

for (i = 0x00D8; i <= 0x00F6; i++) {
    ch = String.fromCharCode(i);
    defineSymbol(text, main, textord, ch, ch);
}

for (i = 0x00F8; i <= 0x00FF; i++) {
    ch = String.fromCharCode(i);
    defineSymbol(text, main, textord, ch, ch);
}

// Cyrillic
for (i = 0x0410; i <= 0x044F; i++) {
    ch = String.fromCharCode(i);
    defineSymbol(text, main, textord, ch, ch);
}

// Unicode versions of existing characters
defineSymbol(text, main, textord, "\u2013", "–");
defineSymbol(text, main, textord, "\u2014", "—");
defineSymbol(text, main, textord, "\u2018", "‘");
defineSymbol(text, main, textord, "\u2019", "’");
defineSymbol(text, main, textord, "\u201c", "“");
defineSymbol(text, main, textord, "\u201d", "”");

},{}],112:[function(require,module,exports){
var hangulRegex = /[\uAC00-\uD7AF]/;

// This regex combines
// - Hiragana: [\u3040-\u309F]
// - Katakana: [\u30A0-\u30FF]
// - CJK ideograms: [\u4E00-\u9FAF]
// - Hangul syllables: [\uAC00-\uD7AF]
// Notably missing are halfwidth Katakana and Romanji glyphs.
var cjkRegex =
    /[\u3040-\u309F]|[\u30A0-\u30FF]|[\u4E00-\u9FAF]|[\uAC00-\uD7AF]/;

module.exports = {
    cjkRegex: cjkRegex,
    hangulRegex: hangulRegex
};

},{}],113:[function(require,module,exports){
/**
 * This file contains a list of utility functions which are useful in other
 * files.
 */

/**
 * Provide an `indexOf` function which works in IE8, but defers to native if
 * possible.
 */
var nativeIndexOf = Array.prototype.indexOf;
var indexOf = function(list, elem) {
    if (list == null) {
        return -1;
    }
    if (nativeIndexOf && list.indexOf === nativeIndexOf) {
        return list.indexOf(elem);
    }
    var i = 0;
    var l = list.length;
    for (; i < l; i++) {
        if (list[i] === elem) {
            return i;
        }
    }
    return -1;
};

/**
 * Return whether an element is contained in a list
 */
var contains = function(list, elem) {
    return indexOf(list, elem) !== -1;
};

/**
 * Provide a default value if a setting is undefined
 */
var deflt = function(setting, defaultIfUndefined) {
    return setting === undefined ? defaultIfUndefined : setting;
};

// hyphenate and escape adapted from Facebook's React under Apache 2 license

var uppercase = /([A-Z])/g;
var hyphenate = function(str) {
    return str.replace(uppercase, "-$1").toLowerCase();
};

var ESCAPE_LOOKUP = {
    "&": "&amp;",
    ">": "&gt;",
    "<": "&lt;",
    "\"": "&quot;",
    "'": "&#x27;"
};

var ESCAPE_REGEX = /[&><"']/g;

function escaper(match) {
    return ESCAPE_LOOKUP[match];
}

/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */
function escape(text) {
    return ("" + text).replace(ESCAPE_REGEX, escaper);
}

/**
 * A function to set the text content of a DOM element in all supported
 * browsers. Note that we don't define this if there is no document.
 */
var setTextContent;
if (typeof document !== "undefined") {
    var testNode = document.createElement("span");
    if ("textContent" in testNode) {
        setTextContent = function(node, text) {
            node.textContent = text;
        };
    } else {
        setTextContent = function(node, text) {
            node.innerText = text;
        };
    }
}

/**
 * A function to clear a node.
 */
function clearNode(node) {
    setTextContent(node, "");
}

module.exports = {
    contains: contains,
    deflt: deflt,
    escape: escape,
    hyphenate: hyphenate,
    indexOf: indexOf,
    setTextContent: setTextContent,
    clearNode: clearNode
};

},{}],114:[function(require,module,exports){
/** @flow */

"use strict";

function getRelocatable(re) {
  // In the future, this could use a WeakMap instead of an expando.
  if (!re.__matchAtRelocatable) {
    // Disjunctions are the lowest-precedence operator, so we can make any
    // pattern match the empty string by appending `|()` to it:
    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-patterns
    var source = re.source + "|()";

    // We always make the new regex global.
    var flags = "g" + (re.ignoreCase ? "i" : "") + (re.multiline ? "m" : "") + (re.unicode ? "u" : "")
    // sticky (/.../y) doesn't make sense in conjunction with our relocation
    // logic, so we ignore it here.
    ;

    re.__matchAtRelocatable = new RegExp(source, flags);
  }
  return re.__matchAtRelocatable;
}

function matchAt(re, str, pos) {
  if (re.global || re.sticky) {
    throw new Error("matchAt(...): Only non-global regexes are supported");
  }
  var reloc = getRelocatable(re);
  reloc.lastIndex = pos;
  var match = reloc.exec(str);
  // Last capturing group is our sentinel that indicates whether the regex
  // matched at the given location.
  if (match[match.length - 1] == null) {
    // Original regex matched.
    match.length = match.length - 1;
    return match;
  } else {
    return null;
  }
}

module.exports = matchAt;
},{}],115:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('./Subscriber');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerSubscriber = function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        _super.call(this);
        this.parent = parent;
        this.outerValue = outerValue;
        this.outerIndex = outerIndex;
        this.index = 0;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber);
exports.InnerSubscriber = InnerSubscriber;


},{"./Subscriber":122}],116:[function(require,module,exports){
"use strict";

var root_1 = require('./util/root');
var toSubscriber_1 = require('./util/toSubscriber');
var observable_1 = require('./symbol/observable');
/**
 * A representation of any set of values over any amount of time. This the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
var Observable = function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is  called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    /**
     * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.
     *
     * <span class="informal">Use it when you have all these Observables, but still nothing is happening.</span>
     *
     * `subscribe` is not a regular operator, but a method that calls Observables internal `subscribe` function. It
     * might be for example a function that you passed to a {@link create} static factory, but most of the time it is
     * a library implementation, which defines what and when will be emitted by an Observable. This means that calling
     * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often
     * thought.
     *
     * Apart from starting the execution of an Observable, this method allows you to listen for values
     * that an Observable emits, as well as for when it completes or errors. You can achieve this in two
     * following ways.
     *
     * The first way is creating an object that implements {@link Observer} interface. It should have methods
     * defined by that interface, but note that it should be just a regular JavaScript object, which you can create
     * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do
     * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also
     * that your object does not have to implement all methods. If you find yourself creating a method that doesn't
     * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will
     * be left uncaught.
     *
     * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.
     * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent
     * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,
     * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,
     * since `subscribe` recognizes these functions by where they were placed in function call. When it comes
     * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.
     *
     * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.
     * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean
     * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback
     * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.
     *
     * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.
     * It is an Observable itself that decides when these functions will be called. For example {@link of}
     * by default emits all its values synchronously. Always check documentation for how given Observable
     * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.
     *
     * @example <caption>Subscribe with an Observer</caption>
     * const sumObserver = {
     *   sum: 0,
     *   next(value) {
     *     console.log('Adding: ' + value);
     *     this.sum = this.sum + value;
     *   },
     *   error() { // We actually could just remote this method,
     *   },        // since we do not really care about errors right now.
     *   complete() {
     *     console.log('Sum equals: ' + this.sum);
     *   }
     * };
     *
     * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.
     * .subscribe(sumObserver);
     *
     * // Logs:
     * // "Adding: 1"
     * // "Adding: 2"
     * // "Adding: 3"
     * // "Sum equals: 6"
     *
     *
     * @example <caption>Subscribe with functions</caption>
     * let sum = 0;
     *
     * Rx.Observable.of(1, 2, 3)
     * .subscribe(
     *   function(value) {
     *     console.log('Adding: ' + value);
     *     sum = sum + value;
     *   },
     *   undefined,
     *   function() {
     *     console.log('Sum equals: ' + sum);
     *   }
     * );
     *
     * // Logs:
     * // "Adding: 1"
     * // "Adding: 2"
     * // "Adding: 3"
     * // "Sum equals: 6"
     *
     *
     * @example <caption>Cancel a subscription</caption>
     * const subscription = Rx.Observable.interval(1000).subscribe(
     *   num => console.log(num),
     *   undefined,
     *   () => console.log('completed!') // Will not be called, even
     * );                                // when cancelling subscription
     *
     *
     * setTimeout(() => {
     *   subscription.unsubscribe();
     *   console.log('unsubscribed!');
     * }, 2500);
     *
     * // Logs:
     * // 0 after 1s
     * // 1 after 2s
     * // "unsubscribed!" after 2,5s
     *
     *
     * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,
     *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed
     *  Observable.
     * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,
     *  the error will be thrown as unhandled.
     * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.
     * @return {ISubscription} a subscription reference to the registered handlers
     * @method subscribe
     */
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this.source);
        } else {
            sink.add(this.source ? this._subscribe(sink) : this._trySubscribe(sink));
        }
        if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
                throw sink.syncErrorValue;
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        } catch (err) {
            sink.syncErrorThrown = true;
            sink.syncErrorValue = err;
            sink.error(err);
        }
    };
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    Observable.prototype.forEach = function (next, PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
                PromiseCtor = root_1.root.Rx.config.Promise;
            } else if (root_1.root.Promise) {
                PromiseCtor = root_1.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            // Must be declared in a separate statement to avoid a RefernceError when
            // accessing subscription below in the closure due to Temporal Dead Zone.
            var subscription;
            subscription = _this.subscribe(function (value) {
                if (subscription) {
                    // if there is a subscription, then we can surmise
                    // the next handling is asynchronous. Any errors thrown
                    // need to be rejected explicitly and unsubscribe must be
                    // called manually
                    try {
                        next(value);
                    } catch (err) {
                        reject(err);
                        subscription.unsubscribe();
                    }
                } else {
                    // if there is NO subscription, then we're getting a nexted
                    // value synchronously during subscription. We can just call it.
                    // If it errors, Observable's `subscribe` will ensure the
                    // unsubscription logic is called, then synchronously rethrow the error.
                    // After that, Promise will trap the error and send it
                    // down the rejection path.
                    next(value);
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        return this.source.subscribe(subscriber);
    };
    /**
     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     * @method Symbol.observable
     * @return {Observable} this instance of the observable
     */
    Observable.prototype[observable_1.observable] = function () {
        return this;
    };
    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     */
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}();
exports.Observable = Observable;


},{"./symbol/observable":155,"./util/root":168,"./util/toSubscriber":170}],117:[function(require,module,exports){
"use strict";

exports.empty = {
    closed: true,
    next: function (value) {},
    error: function (err) {
        throw err;
    },
    complete: function () {}
};


},{}],118:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('./Subscriber');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var OuterSubscriber = function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        _super.apply(this, arguments);
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber_1.Subscriber);
exports.OuterSubscriber = OuterSubscriber;


},{"./Subscriber":122}],119:[function(require,module,exports){
"use strict";
/**
 * An execution context and a data structure to order tasks and schedule their
 * execution. Provides a notion of (potentially virtual) time, through the
 * `now()` getter method.
 *
 * Each unit of work in a Scheduler is called an {@link Action}.
 *
 * ```ts
 * class Scheduler {
 *   now(): number;
 *   schedule(work, delay?, state?): Subscription;
 * }
 * ```
 *
 * @class Scheduler
 */

var Scheduler = function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) {
            now = Scheduler.now;
        }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    /**
     * Schedules a function, `work`, for execution. May happen at some point in
     * the future, according to the `delay` parameter, if specified. May be passed
     * some context object, `state`, which will be passed to the `work` function.
     *
     * The given arguments will be processed an stored as an Action object in a
     * queue of actions.
     *
     * @param {function(state: ?T): ?Subscription} work A function representing a
     * task, or some unit of work to be executed by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler itself.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @return {Subscription} A subscription in order to be able to unsubscribe
     * the scheduled work.
     */
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = Date.now ? Date.now : function () {
        return +new Date();
    };
    return Scheduler;
}();
exports.Scheduler = Scheduler;


},{}],120:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('./Observable');
var Subscriber_1 = require('./Subscriber');
var Subscription_1 = require('./Subscription');
var ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');
var SubjectSubscription_1 = require('./SubjectSubscription');
var rxSubscriber_1 = require('./symbol/rxSubscriber');
/**
 * @class SubjectSubscriber<T>
 */
var SubjectSubscriber = function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        _super.call(this, destination);
        this.destination = destination;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber);
exports.SubjectSubscriber = SubjectSubscriber;
/**
 * @class Subject<T>
 */
var Subject = function (_super) {
    __extends(Subject, _super);
    function Subject() {
        _super.call(this);
        this.observers = [];
        this.closed = false;
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
    }
    Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        } else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        } else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable);
exports.Subject = Subject;
/**
 * @class AnonymousSubject<T>
 */
var AnonymousSubject = function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        _super.call(this);
        this.destination = destination;
        this.source = source;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        } else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject);
exports.AnonymousSubject = AnonymousSubject;


},{"./Observable":116,"./SubjectSubscription":121,"./Subscriber":122,"./Subscription":123,"./symbol/rxSubscriber":156,"./util/ObjectUnsubscribedError":157}],121:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = require('./Subscription');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubjectSubscription = function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        _super.call(this);
        this.subject = subject;
        this.subscriber = subscriber;
        this.closed = false;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription);
exports.SubjectSubscription = SubjectSubscription;


},{"./Subscription":123}],122:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isFunction_1 = require('./util/isFunction');
var Subscription_1 = require('./Subscription');
var Observer_1 = require('./Observer');
var rxSubscriber_1 = require('./symbol/rxSubscriber');
/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
var Subscriber = function (_super) {
    __extends(Subscriber, _super);
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    function Subscriber(destinationOrNext, error, complete) {
        _super.call(this);
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;
        switch (arguments.length) {
            case 0:
                this.destination = Observer_1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    this.destination = Observer_1.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        this.destination = destinationOrNext;
                        this.destination.add(this);
                    } else {
                        this.syncErrorThrowable = true;
                        this.destination = new SafeSubscriber(this, destinationOrNext);
                    }
                    break;
                }
            default:
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                break;
        }
    }
    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () {
        return this;
    };
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     */
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents;
        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription);
exports.Subscriber = Subscriber;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SafeSubscriber = function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        _super.call(this);
        this._parentSubscriber = _parentSubscriber;
        var next;
        var context = this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        } else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== Observer_1.empty) {
                context = Object.create(observerOrNext);
                if (isFunction_1.isFunction(context.unsubscribe)) {
                    this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = this.unsubscribe.bind(this);
            }
        }
        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._error) {
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                } else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            } else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                throw err;
            } else {
                _parentSubscriber.syncErrorValue = err;
                _parentSubscriber.syncErrorThrown = true;
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () {
                    return _this._complete.call(_this._context);
                };
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                } else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            } else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        } catch (err) {
            this.unsubscribe();
            throw err;
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        try {
            fn.call(this._context, value);
        } catch (err) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber);


},{"./Observer":117,"./Subscription":123,"./symbol/rxSubscriber":156,"./util/isFunction":163}],123:[function(require,module,exports){
"use strict";

var isArray_1 = require('./util/isArray');
var isObject_1 = require('./util/isObject');
var isFunction_1 = require('./util/isFunction');
var tryCatch_1 = require('./util/tryCatch');
var errorObject_1 = require('./util/errorObject');
var UnsubscriptionError_1 = require('./util/UnsubscriptionError');
/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
var Subscription = function () {
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    function Subscription(unsubscribe) {
        /**
         * A flag to indicate whether this Subscription has already been unsubscribed.
         * @type {boolean}
         */
        this.closed = false;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents,
            _unsubscribe = _a._unsubscribe,
            _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        // null out _subscriptions first so any child subscriptions that attempt
        // to remove themselves from this subscription will noop
        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0;
        // if this._parent is null, then so is this._parents, and we
        // don't have to remove ourselves from any parent subscriptions.
        while (_parent) {
            _parent.remove(this);
            // if this._parents is null or index >= len,
            // then _parent is set to null, and the loop exits
            _parent = ++index < len && _parents[index] || null;
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject_1.errorObject) {
                hasErrors = true;
                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ? flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            index = -1;
            len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject_1.errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject_1.errorObject.e;
                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                        } else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    Subscription.prototype.add = function (teardown) {
        if (!teardown || teardown === Subscription.EMPTY) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var subscription = teardown;
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                } else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                } else if (typeof subscription._addParent !== 'function' /* quack quack */) {
                        var tmp = subscription;
                        subscription = new Subscription();
                        subscription._subscriptions = [tmp];
                    }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        var subscriptions = this._subscriptions || (this._subscriptions = []);
        subscriptions.push(subscription);
        subscription._addParent(this);
        return subscription;
    };
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.prototype._addParent = function (parent) {
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents;
        if (!_parent || _parent === parent) {
            // If we don't have a parent, or the new parent is the same as the
            // current parent, then set this._parent to the new parent.
            this._parent = parent;
        } else if (!_parents) {
            // If there's already one parent, but not multiple, allocate an Array to
            // store the rest of the parent Subscriptions.
            this._parents = [parent];
        } else if (_parents.indexOf(parent) === -1) {
            // Only add the new parent to the _parents list if it's not already there.
            _parents.push(parent);
        }
    };
    Subscription.EMPTY = function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription());
    return Subscription;
}();
exports.Subscription = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) {
        return errs.concat(err instanceof UnsubscriptionError_1.UnsubscriptionError ? err.errors : err);
    }, []);
}


},{"./util/UnsubscriptionError":158,"./util/errorObject":159,"./util/isArray":160,"./util/isFunction":163,"./util/isObject":165,"./util/tryCatch":171}],124:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
var ScalarObservable_1 = require('./ScalarObservable');
var EmptyObservable_1 = require('./EmptyObservable');
var isScheduler_1 = require('../util/isScheduler');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayObservable = function (_super) {
    __extends(ArrayObservable, _super);
    function ArrayObservable(array, scheduler) {
        _super.call(this);
        this.array = array;
        this.scheduler = scheduler;
        if (!scheduler && array.length === 1) {
            this._isScalar = true;
            this.value = array[0];
        }
    }
    ArrayObservable.create = function (array, scheduler) {
        return new ArrayObservable(array, scheduler);
    };
    /**
     * Creates an Observable that emits some values you specify as arguments,
     * immediately one after the other, and then emits a complete notification.
     *
     * <span class="informal">Emits the arguments you provide, then completes.
     * </span>
     *
     * <img src="./img/of.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the arguments given, and the complete notification thereafter. It can
     * be used for composing with other Observables, such as with {@link concat}.
     * By default, it uses a `null` IScheduler, which means the `next`
     * notifications are sent synchronously, although with a different IScheduler
     * it is possible to determine when those notifications will be delivered.
     *
     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
     * var numbers = Rx.Observable.of(10, 20, 30);
     * var letters = Rx.Observable.of('a', 'b', 'c');
     * var interval = Rx.Observable.interval(1000);
     * var result = numbers.concat(letters).concat(interval);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link throw}
     *
     * @param {...T} values Arguments that represent `next` values to be emitted.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emissions of the `next` notifications.
     * @return {Observable<T>} An Observable that emits each given input value.
     * @static true
     * @name of
     * @owner Observable
     */
    ArrayObservable.of = function () {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            array[_i - 0] = arguments[_i];
        }
        var scheduler = array[array.length - 1];
        if (isScheduler_1.isScheduler(scheduler)) {
            array.pop();
        } else {
            scheduler = null;
        }
        var len = array.length;
        if (len > 1) {
            return new ArrayObservable(array, scheduler);
        } else if (len === 1) {
            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
        } else {
            return new EmptyObservable_1.EmptyObservable(scheduler);
        }
    };
    ArrayObservable.dispatch = function (state) {
        var array = state.array,
            index = state.index,
            count = state.count,
            subscriber = state.subscriber;
        if (index >= count) {
            subscriber.complete();
            return;
        }
        subscriber.next(array[index]);
        if (subscriber.closed) {
            return;
        }
        state.index = index + 1;
        this.schedule(state);
    };
    ArrayObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var array = this.array;
        var count = array.length;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ArrayObservable.dispatch, 0, {
                array: array, index: index, count: count, subscriber: subscriber
            });
        } else {
            for (var i = 0; i < count && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayObservable;
}(Observable_1.Observable);
exports.ArrayObservable = ArrayObservable;


},{"../Observable":116,"../util/isScheduler":167,"./EmptyObservable":126,"./ScalarObservable":128}],125:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = require('../Subject');
var Observable_1 = require('../Observable');
var Subscriber_1 = require('../Subscriber');
var Subscription_1 = require('../Subscription');
/**
 * @class ConnectableObservable<T>
 */
var ConnectableObservable = function (_super) {
    __extends(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        _super.call(this);
        this.source = source;
        this.subjectFactory = subjectFactory;
        this._refCount = 0;
        this._isComplete = false;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            this._isComplete = false;
            connection = this._connection = new Subscription_1.Subscription();
            connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription_1.Subscription.EMPTY;
            } else {
                this._connection = connection;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return this.lift(new RefCountOperator(this));
    };
    return ConnectableObservable;
}(Observable_1.Observable);
exports.ConnectableObservable = ConnectableObservable;
var connectableProto = ConnectableObservable.prototype;
exports.connectableObservableDescriptor = {
    operator: { value: null },
    _refCount: { value: 0, writable: true },
    _subject: { value: null, writable: true },
    _connection: { value: null, writable: true },
    _subscribe: { value: connectableProto._subscribe },
    _isComplete: { value: connectableProto._isComplete, writable: true },
    getSubject: { value: connectableProto.getSubject },
    connect: { value: connectableProto.connect },
    refCount: { value: connectableProto.refCount }
};
var ConnectableSubscriber = function (_super) {
    __extends(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(Subject_1.SubjectSubscriber);
var RefCountOperator = function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}();
var RefCountSubscriber = function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        ///
        // Compare the local RefCountSubscriber's connection Subscription to the
        // connection Subscription on the shared ConnectableObservable. In cases
        // where the ConnectableObservable source synchronously emits values, and
        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
        // execution continues to here before the RefCountOperator has a chance to
        // supply the RefCountSubscriber with the shared connection Subscription.
        // For example:
        // ```
        // Observable.range(0, 10)
        //   .publish()
        //   .refCount()
        //   .take(5)
        //   .subscribe();
        // ```
        // In order to account for this case, RefCountSubscriber should only dispose
        // the ConnectableObservable's shared connection Subscription if the
        // connection Subscription exists, *and* either:
        //   a. RefCountSubscriber doesn't have a reference to the shared connection
        //      Subscription yet, or,
        //   b. RefCountSubscriber's connection Subscription reference is identical
        //      to the shared connection Subscription
        ///
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber);


},{"../Observable":116,"../Subject":120,"../Subscriber":122,"../Subscription":123}],126:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var EmptyObservable = function (_super) {
    __extends(EmptyObservable, _super);
    function EmptyObservable(scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits a complete notification.
     *
     * <span class="informal">Just emits 'complete', and nothing else.
     * </span>
     *
     * <img src="./img/empty.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the complete notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then complete.</caption>
     * var result = Rx.Observable.empty().startWith(7);
     * result.subscribe(x => console.log(x));
     *
     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
     * );
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following to the console:
     * // x is equal to the count on the interval eg(0,1,2,3,...)
     * // x will occur every 1000ms
     * // if x % 2 is equal to 1 print abc
     * // if x % 2 is not equal to 1 nothing will be output
     *
     * @see {@link create}
     * @see {@link never}
     * @see {@link of}
     * @see {@link throw}
     *
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the complete notification.
     * @return {Observable} An "empty" Observable: emits only the complete
     * notification.
     * @static true
     * @name empty
     * @owner Observable
     */
    EmptyObservable.create = function (scheduler) {
        return new EmptyObservable(scheduler);
    };
    EmptyObservable.dispatch = function (arg) {
        var subscriber = arg.subscriber;
        subscriber.complete();
    };
    EmptyObservable.prototype._subscribe = function (subscriber) {
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
        } else {
            subscriber.complete();
        }
    };
    return EmptyObservable;
}(Observable_1.Observable);
exports.EmptyObservable = EmptyObservable;


},{"../Observable":116}],127:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
var tryCatch_1 = require('../util/tryCatch');
var isFunction_1 = require('../util/isFunction');
var errorObject_1 = require('../util/errorObject');
var Subscription_1 = require('../Subscription');
var toString = Object.prototype.toString;
function isNodeStyleEventEmitter(sourceObj) {
    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isNodeList(sourceObj) {
    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';
}
function isHTMLCollection(sourceObj) {
    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';
}
function isEventTarget(sourceObj) {
    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var FromEventObservable = function (_super) {
    __extends(FromEventObservable, _super);
    function FromEventObservable(sourceObj, eventName, selector, options) {
        _super.call(this);
        this.sourceObj = sourceObj;
        this.eventName = eventName;
        this.selector = selector;
        this.options = options;
    }
    /* tslint:enable:max-line-length */
    /**
     * Creates an Observable that emits events of a specific type coming from the
     * given event target.
     *
     * <span class="informal">Creates an Observable from DOM events, or Node
     * EventEmitter events or others.</span>
     *
     * <img src="./img/fromEvent.png" width="100%">
     *
     * Creates an Observable by attaching an event listener to an "event target",
     * which may be an object with `addEventListener` and `removeEventListener`,
     * a Node.js EventEmitter, a jQuery style EventEmitter, a NodeList from the
     * DOM, or an HTMLCollection from the DOM. The event handler is attached when
     * the output Observable is subscribed, and removed when the Subscription is
     * unsubscribed.
     *
     * @example <caption>Emits clicks happening on the DOM document</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * clicks.subscribe(x => console.log(x));
     *
     * // Results in:
     * // MouseEvent object logged to console everytime a click
     * // occurs on the document.
     *
     * @see {@link from}
     * @see {@link fromEventPattern}
     *
     * @param {EventTargetLike} target The DOMElement, event target, Node.js
     * EventEmitter, NodeList or HTMLCollection to attach the event handler to.
     * @param {string} eventName The event name of interest, being emitted by the
     * `target`.
     * @param {EventListenerOptions} [options] Options to pass through to addEventListener
     * @param {SelectorMethodSignature<T>} [selector] An optional function to
     * post-process results. It takes the arguments from the event handler and
     * should return a single value.
     * @return {Observable<T>}
     * @static true
     * @name fromEvent
     * @owner Observable
     */
    FromEventObservable.create = function (target, eventName, options, selector) {
        if (isFunction_1.isFunction(options)) {
            selector = options;
            options = undefined;
        }
        return new FromEventObservable(target, eventName, selector, options);
    };
    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {
        var unsubscribe;
        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {
            for (var i = 0, len = sourceObj.length; i < len; i++) {
                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
            }
        } else if (isEventTarget(sourceObj)) {
            var source_1 = sourceObj;
            sourceObj.addEventListener(eventName, handler, options);
            unsubscribe = function () {
                return source_1.removeEventListener(eventName, handler);
            };
        } else if (isJQueryStyleEventEmitter(sourceObj)) {
            var source_2 = sourceObj;
            sourceObj.on(eventName, handler);
            unsubscribe = function () {
                return source_2.off(eventName, handler);
            };
        } else if (isNodeStyleEventEmitter(sourceObj)) {
            var source_3 = sourceObj;
            sourceObj.addListener(eventName, handler);
            unsubscribe = function () {
                return source_3.removeListener(eventName, handler);
            };
        } else {
            throw new TypeError('Invalid event target');
        }
        subscriber.add(new Subscription_1.Subscription(unsubscribe));
    };
    FromEventObservable.prototype._subscribe = function (subscriber) {
        var sourceObj = this.sourceObj;
        var eventName = this.eventName;
        var options = this.options;
        var selector = this.selector;
        var handler = selector ? function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);
            if (result === errorObject_1.errorObject) {
                subscriber.error(errorObject_1.errorObject.e);
            } else {
                subscriber.next(result);
            }
        } : function (e) {
            return subscriber.next(e);
        };
        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);
    };
    return FromEventObservable;
}(Observable_1.Observable);
exports.FromEventObservable = FromEventObservable;


},{"../Observable":116,"../Subscription":123,"../util/errorObject":159,"../util/isFunction":163,"../util/tryCatch":171}],128:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ScalarObservable = function (_super) {
    __extends(ScalarObservable, _super);
    function ScalarObservable(value, scheduler) {
        _super.call(this);
        this.value = value;
        this.scheduler = scheduler;
        this._isScalar = true;
        if (scheduler) {
            this._isScalar = false;
        }
    }
    ScalarObservable.create = function (value, scheduler) {
        return new ScalarObservable(value, scheduler);
    };
    ScalarObservable.dispatch = function (state) {
        var done = state.done,
            value = state.value,
            subscriber = state.subscriber;
        if (done) {
            subscriber.complete();
            return;
        }
        subscriber.next(value);
        if (subscriber.closed) {
            return;
        }
        state.done = true;
        this.schedule(state);
    };
    ScalarObservable.prototype._subscribe = function (subscriber) {
        var value = this.value;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ScalarObservable.dispatch, 0, {
                done: false, value: value, subscriber: subscriber
            });
        } else {
            subscriber.next(value);
            if (!subscriber.closed) {
                subscriber.complete();
            }
        }
    };
    return ScalarObservable;
}(Observable_1.Observable);
exports.ScalarObservable = ScalarObservable;


},{"../Observable":116}],129:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isNumeric_1 = require('../util/isNumeric');
var Observable_1 = require('../Observable');
var async_1 = require('../scheduler/async');
var isScheduler_1 = require('../util/isScheduler');
var isDate_1 = require('../util/isDate');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var TimerObservable = function (_super) {
    __extends(TimerObservable, _super);
    function TimerObservable(dueTime, period, scheduler) {
        if (dueTime === void 0) {
            dueTime = 0;
        }
        _super.call(this);
        this.period = -1;
        this.dueTime = 0;
        if (isNumeric_1.isNumeric(period)) {
            this.period = Number(period) < 1 && 1 || Number(period);
        } else if (isScheduler_1.isScheduler(period)) {
            scheduler = period;
        }
        if (!isScheduler_1.isScheduler(scheduler)) {
            scheduler = async_1.async;
        }
        this.scheduler = scheduler;
        this.dueTime = isDate_1.isDate(dueTime) ? +dueTime - this.scheduler.now() : dueTime;
    }
    /**
     * Creates an Observable that starts emitting after an `initialDelay` and
     * emits ever increasing numbers after each `period` of time thereafter.
     *
     * <span class="informal">Its like {@link interval}, but you can specify when
     * should the emissions start.</span>
     *
     * <img src="./img/timer.png" width="100%">
     *
     * `timer` returns an Observable that emits an infinite sequence of ascending
     * integers, with a constant interval of time, `period` of your choosing
     * between those emissions. The first emission happens after the specified
     * `initialDelay`. The initial delay may be a {@link Date}. By default, this
     * operator uses the `async` IScheduler to provide a notion of time, but you
     * may pass any IScheduler to it. If `period` is not specified, the output
     * Observable emits only one value, `0`. Otherwise, it emits an infinite
     * sequence.
     *
     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>
     * var numbers = Rx.Observable.timer(3000, 1000);
     * numbers.subscribe(x => console.log(x));
     *
     * @example <caption>Emits one number after five seconds</caption>
     * var numbers = Rx.Observable.timer(5000);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link interval}
     * @see {@link delay}
     *
     * @param {number|Date} initialDelay The initial delay time to wait before
     * emitting the first value of `0`.
     * @param {number} [period] The period of time between emissions of the
     * subsequent numbers.
     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a `0` after the
     * `initialDelay` and ever increasing numbers after each `period` of time
     * thereafter.
     * @static true
     * @name timer
     * @owner Observable
     */
    TimerObservable.create = function (initialDelay, period, scheduler) {
        if (initialDelay === void 0) {
            initialDelay = 0;
        }
        return new TimerObservable(initialDelay, period, scheduler);
    };
    TimerObservable.dispatch = function (state) {
        var index = state.index,
            period = state.period,
            subscriber = state.subscriber;
        var action = this;
        subscriber.next(index);
        if (subscriber.closed) {
            return;
        } else if (period === -1) {
            return subscriber.complete();
        }
        state.index = index + 1;
        action.schedule(state, period);
    };
    TimerObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this,
            period = _a.period,
            dueTime = _a.dueTime,
            scheduler = _a.scheduler;
        return scheduler.schedule(TimerObservable.dispatch, dueTime, {
            index: index, period: period, subscriber: subscriber
        });
    };
    return TimerObservable;
}(Observable_1.Observable);
exports.TimerObservable = TimerObservable;


},{"../Observable":116,"../scheduler/async":153,"../util/isDate":162,"../util/isNumeric":164,"../util/isScheduler":167}],130:[function(require,module,exports){
"use strict";

var EmptyObservable_1 = require('./EmptyObservable');
exports.empty = EmptyObservable_1.EmptyObservable.create;


},{"./EmptyObservable":126}],131:[function(require,module,exports){
"use strict";

var FromEventObservable_1 = require('./FromEventObservable');
exports.fromEvent = FromEventObservable_1.FromEventObservable.create;


},{"./FromEventObservable":127}],132:[function(require,module,exports){
"use strict";

var TimerObservable_1 = require('./TimerObservable');
exports.timer = TimerObservable_1.TimerObservable.create;


},{"./TimerObservable":129}],133:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
 *
 * <img src="./img/catch.png" width="100%">
 *
 * @example <caption>Continues with a different Observable when there's an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n == 4) {
 * 	     throw 'four!';
 *     }
 *	   return n;
 *   })
 *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, I, II, III, IV, V
 *
 * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n === 4) {
 * 	     throw 'four!';
 *     }
 * 	   return n;
 *   })
 *   .catch((err, caught) => caught)
 *   .take(30)
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, 1, 2, 3, ...
 *
 * @example <caption>Throws a new error when the source Observable throws an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 *     if (n == 4) {
 *       throw 'four!';
 *     }
 *     return n;
 *   })
 *   .catch(err => {
 *     throw 'error in source. Details: ' + err;
 *   })
 *   .subscribe(
 *     x => console.log(x),
 *     err => console.log(err)
 *   );
 *   // 1, 2, 3, error in source. Details: four!
 *
 * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
 *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
 *  is returned by the `selector` will be used to continue the observable chain.
 * @return {Observable} An observable that originates from either the source or the observable returned by the
 *  catch `selector` function.
 * @method catch
 * @name catch
 * @owner Observable
 */
function _catch(selector) {
    var operator = new CatchOperator(selector);
    var caught = this.lift(operator);
    return operator.caught = caught;
}
exports._catch = _catch;
var CatchOperator = function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CatchSubscriber = function (_super) {
    __extends(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        _super.call(this, destination);
        this.selector = selector;
        this.caught = caught;
    }
    // NOTE: overriding `error` instead of `_error` because we don't want
    // to have this flag this subscriber as `isStopped`. We can mimic the
    // behavior of the RetrySubscriber (from the `retry` operator), where
    // we unsubscribe from our source chain, reset our Subscriber flags,
    // then subscribe to the selector result.
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            } catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            this.add(subscribeToResult_1.subscribeToResult(this, result));
        }
    };
    return CatchSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":118,"../util/subscribeToResult":169}],134:[function(require,module,exports){
"use strict";

var Observable_1 = require('../Observable');
var isScheduler_1 = require('../util/isScheduler');
var ArrayObservable_1 = require('../observable/ArrayObservable');
var mergeAll_1 = require('./mergeAll');
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from every
 * given input Observable after the current Observable.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * Joins this Observable with multiple other Observables by subscribing to them
 * one at a time, starting with the source, and merging their results into the
 * output Observable. Will wait for each Observable to complete before moving
 * on to the next.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = timer.concat(sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 * @example <caption>Concatenate 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = timer1.concat(timer2, timer3);
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {ObservableInput} other An input Observable to concatenate after the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @method concat
 * @owner Observable
 */
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return this.lift.call(concatStatic.apply(void 0, [this].concat(observables)));
}
exports.concat = concat;
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from given
 * Observable and then moves on to the next.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * `concat` joins multiple Observables together, by subscribing to them one at a time and
 * merging their results into the output Observable. You can pass either an array of
 * Observables, or put them directly as arguments. Passing an empty array will result
 * in Observable that completes immediately.
 *
 * `concat` will subscribe to first input Observable and emit all its values, without
 * changing or affecting them in any way. When that Observable completes, it will
 * subscribe to then next Observable passed and, again, emit its values. This will be
 * repeated, until the operator runs out of Observables. When last input Observable completes,
 * `concat` will complete as well. At any given moment only one Observable passed to operator
 * emits values. If you would like to emit values from passed Observables concurrently, check out
 * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,
 * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.
 *
 * Note that if some input Observable never completes, `concat` will also never complete
 * and Observables following the one that did not complete will never be subscribed. On the other
 * hand, if some Observable simply completes immediately after it is subscribed, it will be
 * invisible for `concat`, which will just move on to the next Observable.
 *
 * If any Observable in chain errors, instead of passing control to the next Observable,
 * `concat` will error immediately as well. Observables that would be subscribed after
 * the one that emitted error, never will.
 *
 * If you pass to `concat` the same Observable many times, its stream of values
 * will be "replayed" on every subscription, which means you can repeat given Observable
 * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,
 * you can always use {@link repeat}.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = Rx.Observable.concat(timer, sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 *
 * @example <caption>Concatenate an array of 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 *
 * @example <caption>Concatenate the same Observable to repeat it</caption>
 * const timer = Rx.Observable.interval(1000).take(2);
 *
 * Rx.Observable.concat(timer, timer) // concating the same Observable!
 * .subscribe(
 *   value => console.log(value),
 *   err => {},
 *   () => console.log('...and it is done!')
 * );
 *
 * // Logs:
 * // 0 after 1s
 * // 1 after 2s
 * // 0 after 3s
 * // 1 after 4s
 * // "...and it is done!" also after 4s
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {ObservableInput} input1 An input Observable to concatenate with others.
 * @param {ObservableInput} input2 An input Observable to concatenate with others.
 * More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @static true
 * @name concat
 * @owner Observable
 */
function concatStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var scheduler = null;
    var args = observables;
    if (isScheduler_1.isScheduler(args[observables.length - 1])) {
        scheduler = args.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(1));
}
exports.concatStatic = concatStatic;


},{"../Observable":116,"../observable/ArrayObservable":124,"../util/isScheduler":167,"./mergeAll":141}],135:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var async_1 = require('../scheduler/async');
/**
 * Emits a value from the source Observable only after a particular time span
 * has passed without another source emission.
 *
 * <span class="informal">It's like {@link delay}, but passes only the most
 * recent value from each burst of emissions.</span>
 *
 * <img src="./img/debounceTime.png" width="100%">
 *
 * `debounceTime` delays values emitted by the source Observable, but drops
 * previous pending delayed emissions if a new value arrives on the source
 * Observable. This operator keeps track of the most recent value from the
 * source Observable, and emits that only when `dueTime` enough time has passed
 * without any other value appearing on the source Observable. If a new value
 * appears before `dueTime` silence occurs, the previous value will be dropped
 * and will not be emitted on the output Observable.
 *
 * This is a rate-limiting operator, because it is impossible for more than one
 * value to be emitted in any time window of duration `dueTime`, but it is also
 * a delay-like operator since output emissions do not occur at the same time as
 * they did on the source Observable. Optionally takes a {@link IScheduler} for
 * managing timers.
 *
 * @example <caption>Emit the most recent click after a burst of clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.debounceTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} dueTime The timeout duration in milliseconds (or the time
 * unit determined internally by the optional `scheduler`) for the window of
 * time required to wait for emission silence before emitting the most recent
 * source value.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the timeout for each value.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified `dueTime`, and may drop some values if they occur
 * too frequently.
 * @method debounceTime
 * @owner Observable
 */
function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) {
        scheduler = async_1.async;
    }
    return this.lift(new DebounceTimeOperator(dueTime, scheduler));
}
exports.debounceTime = debounceTime;
var DebounceTimeOperator = function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DebounceTimeSubscriber = function (_super) {
    __extends(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        _super.call(this, destination);
        this.dueTime = dueTime;
        this.scheduler = scheduler;
        this.debouncedSubscription = null;
        this.lastValue = null;
        this.hasValue = false;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            this.destination.next(this.lastValue);
            this.lastValue = null;
            this.hasValue = false;
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(Subscriber_1.Subscriber);
function dispatchNext(subscriber) {
    subscriber.debouncedNext();
}


},{"../Subscriber":122,"../scheduler/async":153}],136:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/* tslint:enable:max-line-length */
/**
 * Perform a side effect for every emission on the source Observable, but return
 * an Observable that is identical to the source.
 *
 * <span class="informal">Intercepts each emission on the source and runs a
 * function, but returns an output which is identical to the source as long as errors don't occur.</span>
 *
 * <img src="./img/do.png" width="100%">
 *
 * Returns a mirrored Observable of the source Observable, but modified so that
 * the provided Observer is called to perform a side effect for every value,
 * error, and completion emitted by the source. Any errors that are thrown in
 * the aforementioned Observer or handlers are safely sent down the error path
 * of the output Observable.
 *
 * This operator is useful for debugging your Observables for the correct values
 * or performing other side effects.
 *
 * Note: this is different to a `subscribe` on the Observable. If the Observable
 * returned by `do` is not subscribed, the side effects specified by the
 * Observer will never happen. `do` therefore simply spies on existing
 * execution, it does not trigger an execution to happen like `subscribe` does.
 *
 * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks
 *   .do(ev => console.log(ev))
 *   .map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link map}
 * @see {@link subscribe}
 *
 * @param {Observer|function} [nextOrObserver] A normal Observer object or a
 * callback for `next`.
 * @param {function} [error] Callback for errors in the source.
 * @param {function} [complete] Callback for the completion of the source.
 * @return {Observable} An Observable identical to the source, but runs the
 * specified Observer or callback(s) for each item.
 * @method do
 * @name do
 * @owner Observable
 */
function _do(nextOrObserver, error, complete) {
    return this.lift(new DoOperator(nextOrObserver, error, complete));
}
exports._do = _do;
var DoOperator = function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DoSubscriber = function (_super) {
    __extends(DoSubscriber, _super);
    function DoSubscriber(destination, nextOrObserver, error, complete) {
        _super.call(this, destination);
        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);
        safeSubscriber.syncErrorThrowable = true;
        this.add(safeSubscriber);
        this.safeSubscriber = safeSubscriber;
    }
    DoSubscriber.prototype._next = function (value) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.next(value);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        } else {
            this.destination.next(value);
        }
    };
    DoSubscriber.prototype._error = function (err) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.error(err);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        } else {
            this.destination.error(err);
        }
    };
    DoSubscriber.prototype._complete = function () {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.complete();
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        } else {
            this.destination.complete();
        }
    };
    return DoSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":122}],137:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable only if the previous projected Observable has completed.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link exhaust}.</span>
 *
 * <img src="./img/exhaustMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. When it projects a source value to
 * an Observable, the output Observable begins emitting the items emitted by
 * that projected Observable. However, `exhaustMap` ignores every new projected
 * Observable if the previous projected Observable has not yet completed. Once
 * that one completes, it will accept and flatten the next projected Observable
 * and repeat this process.
 *
 * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaust}
 * @see {@link mergeMap}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable containing projected Observables
 * of each item of the source, ignoring projected Observables that start before
 * their preceding Observable has completed.
 * @method exhaustMap
 * @owner Observable
 */
function exhaustMap(project, resultSelector) {
    return this.lift(new SwitchFirstMapOperator(project, resultSelector));
}
exports.exhaustMap = exhaustMap;
var SwitchFirstMapOperator = function () {
    function SwitchFirstMapOperator(project, resultSelector) {
        this.project = project;
        this.resultSelector = resultSelector;
    }
    SwitchFirstMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));
    };
    return SwitchFirstMapOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchFirstMapSubscriber = function (_super) {
    __extends(SwitchFirstMapSubscriber, _super);
    function SwitchFirstMapSubscriber(destination, project, resultSelector) {
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.hasSubscription = false;
        this.hasCompleted = false;
        this.index = 0;
    }
    SwitchFirstMapSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.tryNext(value);
        }
    };
    SwitchFirstMapSubscriber.prototype.tryNext = function (value) {
        var index = this.index++;
        var destination = this.destination;
        try {
            var result = this.project(value, index);
            this.hasSubscription = true;
            this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));
        } catch (err) {
            destination.error(err);
        }
    };
    SwitchFirstMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this,
            resultSelector = _a.resultSelector,
            destination = _a.destination;
        if (resultSelector) {
            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
        } else {
            destination.next(innerValue);
        }
    };
    SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {
        var _a = this,
            resultSelector = _a.resultSelector,
            destination = _a.destination;
        try {
            var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
            destination.next(result);
        } catch (err) {
            destination.error(err);
        }
    };
    SwitchFirstMapSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":118,"../util/subscribeToResult":169}],138:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/* tslint:enable:max-line-length */
/**
 * Filter items emitted by the source Observable by only emitting those that
 * satisfy a specified predicate.
 *
 * <span class="informal">Like
 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
 * it only emits a value from the source if it passes a criterion function.</span>
 *
 * <img src="./img/filter.png" width="100%">
 *
 * Similar to the well-known `Array.prototype.filter` method, this operator
 * takes values from the source Observable, passes them through a `predicate`
 * function and only emits those values that yielded `true`.
 *
 * @example <caption>Emit only click events whose target was a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
 * clicksOnDivs.subscribe(x => console.log(x));
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 * @see {@link ignoreElements}
 * @see {@link partition}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted, if `false` the value is not passed to the output
 * Observable. The `index` parameter is the number `i` for the i-th source
 * emission that has happened since the subscription, starting from the number
 * `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of values from the source that were
 * allowed by the `predicate` function.
 * @method filter
 * @owner Observable
 */
function filter(predicate, thisArg) {
    return this.lift(new FilterOperator(predicate, thisArg));
}
exports.filter = filter;
var FilterOperator = function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FilterSubscriber = function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.count = 0;
        this.predicate = predicate;
    }
    // the try catch block below is left specifically for
    // optimization and perf reasons. a tryCatcher is not necessary here.
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":122}],139:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var Subscription_1 = require('../Subscription');
/**
 * Returns an Observable that mirrors the source Observable, but will call a specified function when
 * the source terminates on complete or error.
 * @param {function} callback Function to be called when source terminates.
 * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.
 * @method finally
 * @owner Observable
 */
function _finally(callback) {
    return this.lift(new FinallyOperator(callback));
}
exports._finally = _finally;
var FinallyOperator = function () {
    function FinallyOperator(callback) {
        this.callback = callback;
    }
    FinallyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
    };
    return FinallyOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FinallySubscriber = function (_super) {
    __extends(FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        _super.call(this, destination);
        this.add(new Subscription_1.Subscription(callback));
    }
    return FinallySubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":122,"../Subscription":123}],140:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * <img src="./img/map.png" width="100%">
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * @example <caption>Map every click to the clientX position of that click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks.map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link mapTo}
 * @see {@link pluck}
 *
 * @param {function(value: T, index: number): R} project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return {Observable<R>} An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
function map(project, thisArg) {
    if (typeof project !== 'function') {
        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
    }
    return this.lift(new MapOperator(project, thisArg));
}
exports.map = map;
var MapOperator = function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}();
exports.MapOperator = MapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapSubscriber = function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        _super.call(this, destination);
        this.project = project;
        this.count = 0;
        this.thisArg = thisArg || this;
    }
    // NOTE: This looks unoptimized, but it's actually purposefully NOT
    // using try/catch optimizations.
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":122}],141:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Converts a higher-order Observable into a first-order Observable which
 * concurrently delivers all values that are emitted on the inner Observables.
 *
 * <span class="informal">Flattens an Observable-of-Observables.</span>
 *
 * <img src="./img/mergeAll.png" width="100%">
 *
 * `mergeAll` subscribes to an Observable that emits Observables, also known as
 * a higher-order Observable. Each time it observes one of these emitted inner
 * Observables, it subscribes to that and delivers all the values from the
 * inner Observable on the output Observable. The output Observable only
 * completes once all inner Observables have completed. Any error delivered by
 * a inner Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var firstOrder = higherOrder.mergeAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
 * var firstOrder = higherOrder.mergeAll(2);
 * firstOrder.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link exhaust}
 * @see {@link merge}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits values coming from all the
 * inner Observables emitted by the source Observable.
 * @method mergeAll
 * @owner Observable
 */
function mergeAll(concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    return this.lift(new MergeAllOperator(concurrent));
}
exports.mergeAll = mergeAll;
var MergeAllOperator = function () {
    function MergeAllOperator(concurrent) {
        this.concurrent = concurrent;
    }
    MergeAllOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeAllSubscriber(observer, this.concurrent));
    };
    return MergeAllOperator;
}();
exports.MergeAllOperator = MergeAllOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeAllSubscriber = function (_super) {
    __extends(MergeAllSubscriber, _super);
    function MergeAllSubscriber(destination, concurrent) {
        _super.call(this, destination);
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
    }
    MergeAllSubscriber.prototype._next = function (observable) {
        if (this.active < this.concurrent) {
            this.active++;
            this.add(subscribeToResult_1.subscribeToResult(this, observable));
        } else {
            this.buffer.push(observable);
        }
    };
    MergeAllSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        } else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeAllSubscriber;
}(OuterSubscriber_1.OuterSubscriber);
exports.MergeAllSubscriber = MergeAllSubscriber;


},{"../OuterSubscriber":118,"../util/subscribeToResult":169}],142:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var subscribeToResult_1 = require('../util/subscribeToResult');
var OuterSubscriber_1 = require('../OuterSubscriber');
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link mergeAll}.</span>
 *
 * <img src="./img/mergeMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an Observable, and then merging those resulting Observables and
 * emitting the results of this merger.
 *
 * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
 * var letters = Rx.Observable.of('a', 'b', 'c');
 * var result = letters.mergeMap(x =>
 *   Rx.Observable.interval(1000).map(i => x+i)
 * );
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // a0
 * // b0
 * // c0
 * // a1
 * // b1
 * // c1
 * // continues to list a,b,c with respective ascending integers
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and merging the results of the Observables obtained
 * from this transformation.
 * @method mergeMap
 * @owner Observable
 */
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
        resultSelector = null;
    }
    return this.lift(new MergeMapOperator(project, resultSelector, concurrent));
}
exports.mergeMap = mergeMap;
var MergeMapOperator = function () {
    function MergeMapOperator(project, resultSelector, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));
    };
    return MergeMapOperator;
}();
exports.MergeMapOperator = MergeMapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeMapSubscriber = function (_super) {
    __extends(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        } else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result, value, index);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } else {
            this.destination.next(innerValue);
        }
    };
    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        } else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber);
exports.MergeMapSubscriber = MergeMapSubscriber;


},{"../OuterSubscriber":118,"../util/subscribeToResult":169}],143:[function(require,module,exports){
"use strict";

var ConnectableObservable_1 = require('../observable/ConnectableObservable');
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits the results of invoking a specified selector on items
 * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.
 *
 * <img src="./img/multicast.png" width="100%">
 *
 * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through
 * which the source sequence's elements will be multicast to the selector function
 * or Subject to push source elements into.
 * @param {Function} [selector] - Optional selector function that can use the multicasted source stream
 * as many times as needed, without causing multiple subscriptions to the source stream.
 * Subscribers to the given source will receive all notifications of the source from the
 * time of the subscription forward.
 * @return {Observable} An Observable that emits the results of invoking the selector
 * on the items emitted by a `ConnectableObservable` that shares a single subscription to
 * the underlying stream.
 * @method multicast
 * @owner Observable
 */
function multicast(subjectOrSubjectFactory, selector) {
    var subjectFactory;
    if (typeof subjectOrSubjectFactory === 'function') {
        subjectFactory = subjectOrSubjectFactory;
    } else {
        subjectFactory = function subjectFactory() {
            return subjectOrSubjectFactory;
        };
    }
    if (typeof selector === 'function') {
        return this.lift(new MulticastOperator(subjectFactory, selector));
    }
    var connectable = Object.create(this, ConnectableObservable_1.connectableObservableDescriptor);
    connectable.source = this;
    connectable.subjectFactory = subjectFactory;
    return connectable;
}
exports.multicast = multicast;
var MulticastOperator = function () {
    function MulticastOperator(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
    }
    MulticastOperator.prototype.call = function (subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
    };
    return MulticastOperator;
}();
exports.MulticastOperator = MulticastOperator;


},{"../observable/ConnectableObservable":125}],144:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/**
 * Groups pairs of consecutive emissions together and emits them as an array of
 * two values.
 *
 * <span class="informal">Puts the current value and previous value together as
 * an array, and emits that.</span>
 *
 * <img src="./img/pairwise.png" width="100%">
 *
 * The Nth emission from the source Observable will cause the output Observable
 * to emit an array [(N-1)th, Nth] of the previous and the current value, as a
 * pair. For this reason, `pairwise` emits on the second and subsequent
 * emissions from the source Observable, but not on the first emission, because
 * there is no previous value in that case.
 *
 * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var pairs = clicks.pairwise();
 * var distance = pairs.map(pair => {
 *   var x0 = pair[0].clientX;
 *   var y0 = pair[0].clientY;
 *   var x1 = pair[1].clientX;
 *   var y1 = pair[1].clientY;
 *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
 * });
 * distance.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 *
 * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of
 * consecutive values from the source Observable.
 * @method pairwise
 * @owner Observable
 */
function pairwise() {
    return this.lift(new PairwiseOperator());
}
exports.pairwise = pairwise;
var PairwiseOperator = function () {
    function PairwiseOperator() {}
    PairwiseOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
    };
    return PairwiseOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var PairwiseSubscriber = function (_super) {
    __extends(PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        _super.call(this, destination);
        this.hasPrev = false;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        if (this.hasPrev) {
            this.destination.next([this.prev, value]);
        } else {
            this.hasPrev = true;
        }
        this.prev = value;
    };
    return PairwiseSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":122}],145:[function(require,module,exports){
"use strict";

var multicast_1 = require('./multicast');
var Subject_1 = require('../Subject');
function shareSubjectFactory() {
    return new Subject_1.Subject();
}
/**
 * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one
 * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will
 * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.
 * This is an alias for .publish().refCount().
 *
 * <img src="./img/share.png" width="100%">
 *
 * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.
 * @method share
 * @owner Observable
 */
function share() {
    return multicast_1.multicast.call(this, shareSubjectFactory).refCount();
}
exports.share = share;
;


},{"../Subject":120,"./multicast":143}],146:[function(require,module,exports){
"use strict";

var ArrayObservable_1 = require('../observable/ArrayObservable');
var ScalarObservable_1 = require('../observable/ScalarObservable');
var EmptyObservable_1 = require('../observable/EmptyObservable');
var concat_1 = require('./concat');
var isScheduler_1 = require('../util/isScheduler');
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits the items you specify as arguments before it begins to emit
 * items emitted by the source Observable.
 *
 * <img src="./img/startWith.png" width="100%">
 *
 * @param {...T} values - Items you want the modified Observable to emit first.
 * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling
 * the emissions of the `next` notifications.
 * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items
 * emitted by the source Observable.
 * @method startWith
 * @owner Observable
 */
function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i - 0] = arguments[_i];
    }
    var scheduler = array[array.length - 1];
    if (isScheduler_1.isScheduler(scheduler)) {
        array.pop();
    } else {
        scheduler = null;
    }
    var len = array.length;
    if (len === 1) {
        return concat_1.concatStatic(new ScalarObservable_1.ScalarObservable(array[0], scheduler), this);
    } else if (len > 1) {
        return concat_1.concatStatic(new ArrayObservable_1.ArrayObservable(array, scheduler), this);
    } else {
        return concat_1.concatStatic(new EmptyObservable_1.EmptyObservable(scheduler), this);
    }
}
exports.startWith = startWith;


},{"../observable/ArrayObservable":124,"../observable/EmptyObservable":126,"../observable/ScalarObservable":128,"../util/isScheduler":167,"./concat":134}],147:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, emitting values only from the most recently projected Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link switch}.</span>
 *
 * <img src="./img/switchMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each time it observes one of these
 * inner Observables, the output Observable begins emitting the items emitted by
 * that inner Observable. When a new inner Observable is emitted, `switchMap`
 * stops emitting items from the earlier-emitted inner Observable and begins
 * emitting items from the new one. It continues to behave like this for
 * subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switch}
 * @see {@link switchMapTo}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking only the values from the most recently
 * projected inner Observable.
 * @method switchMap
 * @owner Observable
 */
function switchMap(project, resultSelector) {
    return this.lift(new SwitchMapOperator(project, resultSelector));
}
exports.switchMap = switchMap;
var SwitchMapOperator = function () {
    function SwitchMapOperator(project, resultSelector) {
        this.project = project;
        this.resultSelector = resultSelector;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));
    };
    return SwitchMapOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchMapSubscriber = function (_super) {
    __extends(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project, resultSelector) {
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.index = 0;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        } catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result, value, index);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);
        } else {
            this.destination.next(innerValue);
        }
    };
    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return SwitchMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":118,"../util/subscribeToResult":169}],148:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Emits the values emitted by the source Observable until a `notifier`
 * Observable emits a value.
 *
 * <span class="informal">Lets values pass until a second Observable,
 * `notifier`, emits something. Then, it completes.</span>
 *
 * <img src="./img/takeUntil.png" width="100%">
 *
 * `takeUntil` subscribes and begins mirroring the source Observable. It also
 * monitors a second Observable, `notifier` that you provide. If the `notifier`
 * emits a value or a complete notification, the output Observable stops
 * mirroring the source Observable and completes.
 *
 * @example <caption>Tick every second until the first click happens</caption>
 * var interval = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = interval.takeUntil(clicks);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeLast}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @param {Observable} notifier The Observable whose first emitted value will
 * cause the output Observable of `takeUntil` to stop emitting values from the
 * source Observable.
 * @return {Observable<T>} An Observable that emits the values from the source
 * Observable until such time as `notifier` emits its first value.
 * @method takeUntil
 * @owner Observable
 */
function takeUntil(notifier) {
    return this.lift(new TakeUntilOperator(notifier));
}
exports.takeUntil = takeUntil;
var TakeUntilOperator = function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeUntilSubscriber(subscriber, this.notifier));
    };
    return TakeUntilOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeUntilSubscriber = function (_super) {
    __extends(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination, notifier) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
    }
    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    return TakeUntilSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":118,"../util/subscribeToResult":169}],149:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ArrayObservable_1 = require('../observable/ArrayObservable');
var isArray_1 = require('../util/isArray');
var Subscriber_1 = require('../Subscriber');
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
var iterator_1 = require('../symbol/iterator');
/* tslint:enable:max-line-length */
/**
 * @param observables
 * @return {Observable<R>}
 * @method zip
 * @owner Observable
 */
function zipProto() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return this.lift.call(zipStatic.apply(void 0, [this].concat(observables)));
}
exports.zipProto = zipProto;
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each
 * of its input Observables.
 *
 * If the latest parameter is a function, this function is used to compute the created value from the input values.
 * Otherwise, an array of the input values is returned.
 *
 * @example <caption>Combine age and name from different sources</caption>
 *
 * let age$ = Observable.of<number>(27, 25, 29);
 * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');
 * let isDev$ = Observable.of<boolean>(true, true, false);
 *
 * Observable
 *     .zip(age$,
 *          name$,
 *          isDev$,
 *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))
 *     .subscribe(x => console.log(x));
 *
 * // outputs
 * // { age: 27, name: 'Foo', isDev: true }
 * // { age: 25, name: 'Bar', isDev: true }
 * // { age: 29, name: 'Beer', isDev: false }
 *
 * @param observables
 * @return {Observable<R>}
 * @static true
 * @name zip
 * @owner Observable
 */
function zipStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = observables[observables.length - 1];
    if (typeof project === 'function') {
        observables.pop();
    }
    return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));
}
exports.zipStatic = zipStatic;
var ZipOperator = function () {
    function ZipOperator(project) {
        this.project = project;
    }
    ZipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.project));
    };
    return ZipOperator;
}();
exports.ZipOperator = ZipOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipSubscriber = function (_super) {
    __extends(ZipSubscriber, _super);
    function ZipSubscriber(destination, project, values) {
        if (values === void 0) {
            values = Object.create(null);
        }
        _super.call(this, destination);
        this.iterators = [];
        this.active = 0;
        this.project = typeof project === 'function' ? project : null;
        this.values = values;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (isArray_1.isArray(value)) {
            iterators.push(new StaticArrayIterator(value));
        } else if (typeof value[iterator_1.iterator] === 'function') {
            iterators.push(new StaticIterator(value[iterator_1.iterator]()));
        } else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        if (len === 0) {
            this.destination.complete();
            return;
        }
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (iterator.stillUnsubscribed) {
                this.add(iterator.subscribe(iterator, i));
            } else {
                this.active--; // not an observable
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        // abort if not all of them have values
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            var result = iterator.next();
            // check to see if it's completed now that you've gotten
            // the next value.
            if (iterator.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.project) {
            this._tryProject(args);
        } else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(Subscriber_1.Subscriber);
exports.ZipSubscriber = ZipSubscriber;
var StaticIterator = function () {
    function StaticIterator(iterator) {
        this.iterator = iterator;
        this.nextResult = iterator.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return nextResult && nextResult.done;
    };
    return StaticIterator;
}();
var StaticArrayIterator = function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[iterator_1.iterator] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipBufferIterator = function (_super) {
    __extends(ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        _super.call(this, destination);
        this.parent = parent;
        this.observable = observable;
        this.stillUnsubscribed = true;
        this.buffer = [];
        this.isComplete = false;
    }
    ZipBufferIterator.prototype[iterator_1.iterator] = function () {
        return this;
    };
    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next
    //    this is legit because `next()` will never be called by a subscription in this case.
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        } else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        } else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function (value, index) {
        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);
    };
    return ZipBufferIterator;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":118,"../Subscriber":122,"../observable/ArrayObservable":124,"../symbol/iterator":154,"../util/isArray":160,"../util/subscribeToResult":169}],150:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = require('../Subscription');
/**
 * A unit of work to be executed in a {@link Scheduler}. An action is typically
 * created from within a Scheduler and an RxJS user does not need to concern
 * themselves about creating and manipulating an Action.
 *
 * ```ts
 * class Action<T> extends Subscription {
 *   new (scheduler: Scheduler, work: (state?: T) => void);
 *   schedule(state?: T, delay: number = 0): Subscription;
 * }
 * ```
 *
 * @class Action<T>
 */
var Action = function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        _super.call(this);
    }
    /**
     * Schedules this action on its parent Scheduler for execution. May be passed
     * some context object, `state`. May happen at some point in the future,
     * according to the `delay` parameter, if specified.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler.
     * @return {void}
     */
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return this;
    };
    return Action;
}(Subscription_1.Subscription);
exports.Action = Action;


},{"../Subscription":123}],151:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = require('../util/root');
var Action_1 = require('./Action');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AsyncAction = function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
        this.pending = false;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (this.closed) {
            return this;
        }
        // Always replace the current state with the new state.
        this.state = state;
        // Set the pending flag indicating that this action has been scheduled, or
        // has recursively rescheduled itself.
        this.pending = true;
        var id = this.id;
        var scheduler = this.scheduler;
        //
        // Important implementation note:
        //
        // Actions only execute once by default, unless rescheduled from within the
        // scheduled callback. This allows us to implement single and repeat
        // actions via the same code path, without adding API surface area, as well
        // as mimic traditional recursion but across asynchronous boundaries.
        //
        // However, JS runtimes and timers distinguish between intervals achieved by
        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
        // serial `setTimeout` calls can be individually delayed, which delays
        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
        // guarantee the interval callback will be invoked more precisely to the
        // interval period, regardless of load.
        //
        // Therefore, we use `setInterval` to schedule single and repeat actions.
        // If the action reschedules itself with the same delay, the interval is not
        // canceled. If the action doesn't reschedule, or reschedules with a
        // different delay, the interval will be canceled after scheduled callback
        // execution.
        //
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.delay = delay;
        // If this action has already an async Id, don't request a new one.
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        // If this action is rescheduled with the same delay time, don't clear the interval id.
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        // Otherwise, if the action's delay time is different from the current delay,
        // or the action has been rescheduled before it's executed, clear the interval id
        return root_1.root.clearInterval(id) && undefined || undefined;
    };
    /**
     * Immediately executes this action and the `work` it contains.
     * @return {any}
     */
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        } else if (this.pending === false && this.id != null) {
            // Dequeue if the action didn't reschedule itself. Don't call
            // unsubscribe(), because the action could reschedule later.
            // For example:
            // ```
            // scheduler.schedule(function doWork(counter) {
            //   /* ... I'm a busy worker bee ... */
            //   var originalAction = this;
            //   /* wait 100ms before rescheduling the action */
            //   setTimeout(function () {
            //     originalAction.schedule(counter + 1);
            //   }, 100);
            // }, 1000);
            // ```
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        } catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(Action_1.Action);
exports.AsyncAction = AsyncAction;


},{"../util/root":168,"./Action":150}],152:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Scheduler_1 = require('../Scheduler');
var AsyncScheduler = function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler() {
        _super.apply(this, arguments);
        this.actions = [];
        /**
         * A flag to indicate whether the Scheduler is currently executing a batch of
         * queued actions.
         * @type {boolean}
         */
        this.active = false;
        /**
         * An internal ID used to track the latest asynchronous task such as those
         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
         * others.
         * @type {any}
         */
        this.scheduled = undefined;
    }
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift()); // exhaust the scheduler queue
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler_1.Scheduler);
exports.AsyncScheduler = AsyncScheduler;


},{"../Scheduler":119}],153:[function(require,module,exports){
"use strict";

var AsyncAction_1 = require('./AsyncAction');
var AsyncScheduler_1 = require('./AsyncScheduler');
/**
 *
 * Async Scheduler
 *
 * <span class="informal">Schedule task as if you used setTimeout(task, duration)</span>
 *
 * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript
 * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating
 * in intervals.
 *
 * If you just want to "defer" task, that is to perform it right after currently
 * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),
 * better choice will be the {@link asap} scheduler.
 *
 * @example <caption>Use async scheduler to delay task</caption>
 * const task = () => console.log('it works!');
 *
 * Rx.Scheduler.async.schedule(task, 2000);
 *
 * // After 2 seconds logs:
 * // "it works!"
 *
 *
 * @example <caption>Use async scheduler to repeat task in intervals</caption>
 * function task(state) {
 *   console.log(state);
 *   this.schedule(state + 1, 1000); // `this` references currently executing Action,
 *                                   // which we reschedule with new state and delay
 * }
 *
 * Rx.Scheduler.async.schedule(task, 3000, 0);
 *
 * // Logs:
 * // 0 after 3s
 * // 1 after 4s
 * // 2 after 5s
 * // 3 after 6s
 *
 * @static true
 * @name async
 * @owner Scheduler
 */
exports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);


},{"./AsyncAction":151,"./AsyncScheduler":152}],154:[function(require,module,exports){
"use strict";

var root_1 = require('../util/root');
function symbolIteratorPonyfill(root) {
    var Symbol = root.Symbol;
    if (typeof Symbol === 'function') {
        if (!Symbol.iterator) {
            Symbol.iterator = Symbol('iterator polyfill');
        }
        return Symbol.iterator;
    } else {
        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
        var Set_1 = root.Set;
        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {
            return '@@iterator';
        }
        var Map_1 = root.Map;
        // required for compatability with es6-shim
        if (Map_1) {
            var keys = Object.getOwnPropertyNames(Map_1.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {
                    return key;
                }
            }
        }
        return '@@iterator';
    }
}
exports.symbolIteratorPonyfill = symbolIteratorPonyfill;
exports.iterator = symbolIteratorPonyfill(root_1.root);
/**
 * @deprecated use iterator instead
 */
exports.$$iterator = exports.iterator;


},{"../util/root":168}],155:[function(require,module,exports){
"use strict";

var root_1 = require('../util/root');
function getSymbolObservable(context) {
    var $$observable;
    var Symbol = context.Symbol;
    if (typeof Symbol === 'function') {
        if (Symbol.observable) {
            $$observable = Symbol.observable;
        } else {
            $$observable = Symbol('observable');
            Symbol.observable = $$observable;
        }
    } else {
        $$observable = '@@observable';
    }
    return $$observable;
}
exports.getSymbolObservable = getSymbolObservable;
exports.observable = getSymbolObservable(root_1.root);
/**
 * @deprecated use observable instead
 */
exports.$$observable = exports.observable;


},{"../util/root":168}],156:[function(require,module,exports){
"use strict";

var root_1 = require('../util/root');
var Symbol = root_1.root.Symbol;
exports.rxSubscriber = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? Symbol.for('rxSubscriber') : '@@rxSubscriber';
/**
 * @deprecated use rxSubscriber instead
 */
exports.$$rxSubscriber = exports.rxSubscriber;


},{"../util/root":168}],157:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an action is invalid because the object has been
 * unsubscribed.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 *
 * @class ObjectUnsubscribedError
 */
var ObjectUnsubscribedError = function (_super) {
    __extends(ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
        var err = _super.call(this, 'object unsubscribed');
        this.name = err.name = 'ObjectUnsubscribedError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ObjectUnsubscribedError;
}(Error);
exports.ObjectUnsubscribedError = ObjectUnsubscribedError;


},{}],158:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
var UnsubscriptionError = function (_super) {
    __extends(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        _super.call(this);
        this.errors = errors;
        var err = Error.call(this, errors ? errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) {
            return i + 1 + ") " + err.toString();
        }).join('\n  ') : '');
        this.name = err.name = 'UnsubscriptionError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return UnsubscriptionError;
}(Error);
exports.UnsubscriptionError = UnsubscriptionError;


},{}],159:[function(require,module,exports){
"use strict";
// typeof any so that it we don't have to cast when comparing a result to the error object

exports.errorObject = { e: {} };


},{}],160:[function(require,module,exports){
"use strict";

exports.isArray = Array.isArray || function (x) {
  return x && typeof x.length === 'number';
};


},{}],161:[function(require,module,exports){
"use strict";

exports.isArrayLike = function (x) {
  return x && typeof x.length === 'number';
};


},{}],162:[function(require,module,exports){
"use strict";

function isDate(value) {
    return value instanceof Date && !isNaN(+value);
}
exports.isDate = isDate;


},{}],163:[function(require,module,exports){
"use strict";

function isFunction(x) {
    return typeof x === 'function';
}
exports.isFunction = isFunction;


},{}],164:[function(require,module,exports){
"use strict";

var isArray_1 = require('../util/isArray');
function isNumeric(val) {
    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    // adding 1 corrects loss of precision from parseFloat (#15100)
    return !isArray_1.isArray(val) && val - parseFloat(val) + 1 >= 0;
}
exports.isNumeric = isNumeric;
;


},{"../util/isArray":160}],165:[function(require,module,exports){
"use strict";

function isObject(x) {
    return x != null && typeof x === 'object';
}
exports.isObject = isObject;


},{}],166:[function(require,module,exports){
"use strict";

function isPromise(value) {
    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
exports.isPromise = isPromise;


},{}],167:[function(require,module,exports){
"use strict";

function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}
exports.isScheduler = isScheduler;


},{}],168:[function(require,module,exports){
(function (global){
"use strict";
// CommonJS / Node have global context exposed as "global" variable.
// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake
// the global "global" var for now.

var __window = typeof window !== 'undefined' && window;
var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && self;
var __global = typeof global !== 'undefined' && global;
var _root = __window || __global || __self;
exports.root = _root;
// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.
// This is needed when used with angular/tsickle which inserts a goog.module statement.
// Wrap in IIFE
(function () {
    if (!_root) {
        throw new Error('RxJS could not find any global context (window, self, global)');
    }
})();


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],169:[function(require,module,exports){
"use strict";

var root_1 = require('./root');
var isArrayLike_1 = require('./isArrayLike');
var isPromise_1 = require('./isPromise');
var isObject_1 = require('./isObject');
var Observable_1 = require('../Observable');
var iterator_1 = require('../symbol/iterator');
var InnerSubscriber_1 = require('../InnerSubscriber');
var observable_1 = require('../symbol/observable');
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    if (destination.closed) {
        return null;
    }
    if (result instanceof Observable_1.Observable) {
        if (result._isScalar) {
            destination.next(result.value);
            destination.complete();
            return null;
        } else {
            return result.subscribe(destination);
        }
    } else if (isArrayLike_1.isArrayLike(result)) {
        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {
            destination.next(result[i]);
        }
        if (!destination.closed) {
            destination.complete();
        }
    } else if (isPromise_1.isPromise(result)) {
        result.then(function (value) {
            if (!destination.closed) {
                destination.next(value);
                destination.complete();
            }
        }, function (err) {
            return destination.error(err);
        }).then(null, function (err) {
            // Escaping the Promise trap: globally throw unhandled errors
            root_1.root.setTimeout(function () {
                throw err;
            });
        });
        return destination;
    } else if (result && typeof result[iterator_1.iterator] === 'function') {
        var iterator = result[iterator_1.iterator]();
        do {
            var item = iterator.next();
            if (item.done) {
                destination.complete();
                break;
            }
            destination.next(item.value);
            if (destination.closed) {
                break;
            }
        } while (true);
    } else if (result && typeof result[observable_1.observable] === 'function') {
        var obs = result[observable_1.observable]();
        if (typeof obs.subscribe !== 'function') {
            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));
        } else {
            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
        }
    } else {
        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected." + ' You can provide an Observable, Promise, Array, or Iterable.';
        destination.error(new TypeError(msg));
    }
    return null;
}
exports.subscribeToResult = subscribeToResult;


},{"../InnerSubscriber":115,"../Observable":116,"../symbol/iterator":154,"../symbol/observable":155,"./isArrayLike":161,"./isObject":165,"./isPromise":166,"./root":168}],170:[function(require,module,exports){
"use strict";

var Subscriber_1 = require('../Subscriber');
var rxSubscriber_1 = require('../symbol/rxSubscriber');
var Observer_1 = require('../Observer');
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
            return nextOrObserver[rxSubscriber_1.rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer_1.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;


},{"../Observer":117,"../Subscriber":122,"../symbol/rxSubscriber":156}],171:[function(require,module,exports){
"use strict";

var errorObject_1 = require('./errorObject');
var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    } catch (e) {
        errorObject_1.errorObject.e = e;
        return errorObject_1.errorObject;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}
exports.tryCatch = tryCatch;
;


},{"./errorObject":159}],172:[function(require,module,exports){
'use strict';

var isArrayish = require('is-arrayish');

var concat = Array.prototype.concat;
var slice = Array.prototype.slice;

var swizzle = module.exports = function swizzle(args) {
	var results = [];

	for (var i = 0, len = args.length; i < len; i++) {
		var arg = args[i];

		if (isArrayish(arg)) {
			// http://jsperf.com/javascript-array-concat-vs-push/98
			results = concat.call(results, slice.call(arg));
		} else {
			results.push(arg);
		}
	}

	return results;
};

swizzle.wrap = function (fn) {
	return function () {
		return fn(swizzle(arguments));
	};
};

},{"is-arrayish":89}],173:[function(require,module,exports){
// Copyright 2014 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
//     You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//     See the License for the specific language governing permissions and
// limitations under the License.

!function(a,b){var c={},d={},e={},f=null;!function(a,b){function c(a){if("number"==typeof a)return a;var b={};for(var c in a)b[c]=a[c];return b}function d(){this._delay=0,this._endDelay=0,this._fill="none",this._iterationStart=0,this._iterations=1,this._duration=0,this._playbackRate=1,this._direction="normal",this._easing="linear",this._easingFunction=x}function e(){return a.isDeprecated("Invalid timing inputs","2016-03-02","TypeError exceptions will be thrown instead.",!0)}function f(b,c,e){var f=new d;return c&&(f.fill="both",f.duration="auto"),"number"!=typeof b||isNaN(b)?void 0!==b&&Object.getOwnPropertyNames(b).forEach(function(c){if("auto"!=b[c]){if(("number"==typeof f[c]||"duration"==c)&&("number"!=typeof b[c]||isNaN(b[c])))return;if("fill"==c&&-1==v.indexOf(b[c]))return;if("direction"==c&&-1==w.indexOf(b[c]))return;if("playbackRate"==c&&1!==b[c]&&a.isDeprecated("AnimationEffectTiming.playbackRate","2014-11-28","Use Animation.playbackRate instead."))return;f[c]=b[c]}}):f.duration=b,f}function g(a){return"number"==typeof a&&(a=isNaN(a)?{duration:0}:{duration:a}),a}function h(b,c){return b=a.numericTimingToObject(b),f(b,c)}function i(a,b,c,d){return a<0||a>1||c<0||c>1?x:function(e){function f(a,b,c){return 3*a*(1-c)*(1-c)*c+3*b*(1-c)*c*c+c*c*c}if(e<=0){var g=0;return a>0?g=b/a:!b&&c>0&&(g=d/c),g*e}if(e>=1){var h=0;return c<1?h=(d-1)/(c-1):1==c&&a<1&&(h=(b-1)/(a-1)),1+h*(e-1)}for(var i=0,j=1;i<j;){var k=(i+j)/2,l=f(a,c,k);if(Math.abs(e-l)<1e-5)return f(b,d,k);l<e?i=k:j=k}return f(b,d,k)}}function j(a,b){return function(c){if(c>=1)return 1;var d=1/a;return(c+=b*d)-c%d}}function k(a){C||(C=document.createElement("div").style),C.animationTimingFunction="",C.animationTimingFunction=a;var b=C.animationTimingFunction;if(""==b&&e())throw new TypeError(a+" is not a valid value for easing");return b}function l(a){if("linear"==a)return x;var b=E.exec(a);if(b)return i.apply(this,b.slice(1).map(Number));var c=F.exec(a);return c?j(Number(c[1]),{start:y,middle:z,end:A}[c[2]]):B[a]||x}function m(a){return Math.abs(n(a)/a.playbackRate)}function n(a){return 0===a.duration||0===a.iterations?0:a.duration*a.iterations}function o(a,b,c){if(null==b)return G;var d=c.delay+a+c.endDelay;return b<Math.min(c.delay,d)?H:b>=Math.min(c.delay+a,d)?I:J}function p(a,b,c,d,e){switch(d){case H:return"backwards"==b||"both"==b?0:null;case J:return c-e;case I:return"forwards"==b||"both"==b?a:null;case G:return null}}function q(a,b,c,d,e){var f=e;return 0===a?b!==H&&(f+=c):f+=d/a,f}function r(a,b,c,d,e,f){var g=a===1/0?b%1:a%1;return 0!==g||c!==I||0===d||0===e&&0!==f||(g=1),g}function s(a,b,c,d){return a===I&&b===1/0?1/0:1===c?Math.floor(d)-1:Math.floor(d)}function t(a,b,c){var d=a;if("normal"!==a&&"reverse"!==a){var e=b;"alternate-reverse"===a&&(e+=1),d="normal",e!==1/0&&e%2!=0&&(d="reverse")}return"normal"===d?c:1-c}function u(a,b,c){var d=o(a,b,c),e=p(a,c.fill,b,d,c.delay);if(null===e)return null;var f=q(c.duration,d,c.iterations,e,c.iterationStart),g=r(f,c.iterationStart,d,c.iterations,e,c.duration),h=s(d,c.iterations,g,f),i=t(c.direction,h,g);return c._easingFunction(i)}var v="backwards|forwards|both|none".split("|"),w="reverse|alternate|alternate-reverse".split("|"),x=function(a){return a};d.prototype={_setMember:function(b,c){this["_"+b]=c,this._effect&&(this._effect._timingInput[b]=c,this._effect._timing=a.normalizeTimingInput(this._effect._timingInput),this._effect.activeDuration=a.calculateActiveDuration(this._effect._timing),this._effect._animation&&this._effect._animation._rebuildUnderlyingAnimation())},get playbackRate(){return this._playbackRate},set delay(a){this._setMember("delay",a)},get delay(){return this._delay},set endDelay(a){this._setMember("endDelay",a)},get endDelay(){return this._endDelay},set fill(a){this._setMember("fill",a)},get fill(){return this._fill},set iterationStart(a){if((isNaN(a)||a<0)&&e())throw new TypeError("iterationStart must be a non-negative number, received: "+timing.iterationStart);this._setMember("iterationStart",a)},get iterationStart(){return this._iterationStart},set duration(a){if("auto"!=a&&(isNaN(a)||a<0)&&e())throw new TypeError("duration must be non-negative or auto, received: "+a);this._setMember("duration",a)},get duration(){return this._duration},set direction(a){this._setMember("direction",a)},get direction(){return this._direction},set easing(a){this._easingFunction=l(k(a)),this._setMember("easing",a)},get easing(){return this._easing},set iterations(a){if((isNaN(a)||a<0)&&e())throw new TypeError("iterations must be non-negative, received: "+a);this._setMember("iterations",a)},get iterations(){return this._iterations}};var y=1,z=.5,A=0,B={ease:i(.25,.1,.25,1),"ease-in":i(.42,0,1,1),"ease-out":i(0,0,.58,1),"ease-in-out":i(.42,0,.58,1),"step-start":j(1,y),"step-middle":j(1,z),"step-end":j(1,A)},C=null,D="\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*",E=new RegExp("cubic-bezier\\("+D+","+D+","+D+","+D+"\\)"),F=/steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/,G=0,H=1,I=2,J=3;a.cloneTimingInput=c,a.makeTiming=f,a.numericTimingToObject=g,a.normalizeTimingInput=h,a.calculateActiveDuration=m,a.calculateIterationProgress=u,a.calculatePhase=o,a.normalizeEasing=k,a.parseEasingFunction=l}(c),function(a,b){function c(a,b){return a in k?k[a][b]||b:b}function d(a){return"display"===a||0===a.lastIndexOf("animation",0)||0===a.lastIndexOf("transition",0)}function e(a,b,e){if(!d(a)){var f=h[a];if(f){i.style[a]=b;for(var g in f){var j=f[g],k=i.style[j];e[j]=c(j,k)}}else e[a]=c(a,b)}}function f(a){var b=[];for(var c in a)if(!(c in["easing","offset","composite"])){var d=a[c];Array.isArray(d)||(d=[d]);for(var e,f=d.length,g=0;g<f;g++)e={},e.offset="offset"in a?a.offset:1==f?1:g/(f-1),"easing"in a&&(e.easing=a.easing),"composite"in a&&(e.composite=a.composite),e[c]=d[g],b.push(e)}return b.sort(function(a,b){return a.offset-b.offset}),b}function g(b){function c(){var a=d.length;null==d[a-1].offset&&(d[a-1].offset=1),a>1&&null==d[0].offset&&(d[0].offset=0);for(var b=0,c=d[0].offset,e=1;e<a;e++){var f=d[e].offset;if(null!=f){for(var g=1;g<e-b;g++)d[b+g].offset=c+(f-c)*g/(e-b);b=e,c=f}}}if(null==b)return[];window.Symbol&&Symbol.iterator&&Array.prototype.from&&b[Symbol.iterator]&&(b=Array.from(b)),Array.isArray(b)||(b=f(b));for(var d=b.map(function(b){var c={};for(var d in b){var f=b[d];if("offset"==d){if(null!=f){if(f=Number(f),!isFinite(f))throw new TypeError("Keyframe offsets must be numbers.");if(f<0||f>1)throw new TypeError("Keyframe offsets must be between 0 and 1.")}}else if("composite"==d){if("add"==f||"accumulate"==f)throw{type:DOMException.NOT_SUPPORTED_ERR,name:"NotSupportedError",message:"add compositing is not supported"};if("replace"!=f)throw new TypeError("Invalid composite mode "+f+".")}else f="easing"==d?a.normalizeEasing(f):""+f;e(d,f,c)}return void 0==c.offset&&(c.offset=null),void 0==c.easing&&(c.easing="linear"),c}),g=!0,h=-1/0,i=0;i<d.length;i++){var j=d[i].offset;if(null!=j){if(j<h)throw new TypeError("Keyframes are not loosely sorted by offset. Sort or specify offsets.");h=j}else g=!1}return d=d.filter(function(a){return a.offset>=0&&a.offset<=1}),g||c(),d}var h={background:["backgroundImage","backgroundPosition","backgroundSize","backgroundRepeat","backgroundAttachment","backgroundOrigin","backgroundClip","backgroundColor"],border:["borderTopColor","borderTopStyle","borderTopWidth","borderRightColor","borderRightStyle","borderRightWidth","borderBottomColor","borderBottomStyle","borderBottomWidth","borderLeftColor","borderLeftStyle","borderLeftWidth"],borderBottom:["borderBottomWidth","borderBottomStyle","borderBottomColor"],borderColor:["borderTopColor","borderRightColor","borderBottomColor","borderLeftColor"],borderLeft:["borderLeftWidth","borderLeftStyle","borderLeftColor"],borderRadius:["borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius"],borderRight:["borderRightWidth","borderRightStyle","borderRightColor"],borderTop:["borderTopWidth","borderTopStyle","borderTopColor"],borderWidth:["borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth"],flex:["flexGrow","flexShrink","flexBasis"],font:["fontFamily","fontSize","fontStyle","fontVariant","fontWeight","lineHeight"],margin:["marginTop","marginRight","marginBottom","marginLeft"],outline:["outlineColor","outlineStyle","outlineWidth"],padding:["paddingTop","paddingRight","paddingBottom","paddingLeft"]},i=document.createElementNS("http://www.w3.org/1999/xhtml","div"),j={thin:"1px",medium:"3px",thick:"5px"},k={borderBottomWidth:j,borderLeftWidth:j,borderRightWidth:j,borderTopWidth:j,fontSize:{"xx-small":"60%","x-small":"75%",small:"89%",medium:"100%",large:"120%","x-large":"150%","xx-large":"200%"},fontWeight:{normal:"400",bold:"700"},outlineWidth:j,textShadow:{none:"0px 0px 0px transparent"},boxShadow:{none:"0px 0px 0px 0px transparent"}};a.convertToArrayForm=f,a.normalizeKeyframes=g}(c),function(a){var b={};a.isDeprecated=function(a,c,d,e){var f=e?"are":"is",g=new Date,h=new Date(c);return h.setMonth(h.getMonth()+3),!(g<h&&(a in b||console.warn("Web Animations: "+a+" "+f+" deprecated and will stop working on "+h.toDateString()+". "+d),b[a]=!0,1))},a.deprecated=function(b,c,d,e){var f=e?"are":"is";if(a.isDeprecated(b,c,d,e))throw new Error(b+" "+f+" no longer supported. "+d)}}(c),function(){if(document.documentElement.animate){var a=document.documentElement.animate([],0),b=!0;if(a&&(b=!1,"play|currentTime|pause|reverse|playbackRate|cancel|finish|startTime|playState".split("|").forEach(function(c){void 0===a[c]&&(b=!0)})),!b)return}!function(a,b,c){function d(a){for(var b={},c=0;c<a.length;c++)for(var d in a[c])if("offset"!=d&&"easing"!=d&&"composite"!=d){var e={offset:a[c].offset,easing:a[c].easing,value:a[c][d]};b[d]=b[d]||[],b[d].push(e)}for(var f in b){var g=b[f];if(0!=g[0].offset||1!=g[g.length-1].offset)throw{type:DOMException.NOT_SUPPORTED_ERR,name:"NotSupportedError",message:"Partial keyframes are not supported"}}return b}function e(c){var d=[];for(var e in c)for(var f=c[e],g=0;g<f.length-1;g++){var h=g,i=g+1,j=f[h].offset,k=f[i].offset,l=j,m=k;0==g&&(l=-1/0,0==k&&(i=h)),g==f.length-2&&(m=1/0,1==j&&(h=i)),d.push({applyFrom:l,applyTo:m,startOffset:f[h].offset,endOffset:f[i].offset,easingFunction:a.parseEasingFunction(f[h].easing),property:e,interpolation:b.propertyInterpolation(e,f[h].value,f[i].value)})}return d.sort(function(a,b){return a.startOffset-b.startOffset}),d}b.convertEffectInput=function(c){var f=a.normalizeKeyframes(c),g=d(f),h=e(g);return function(a,c){if(null!=c)h.filter(function(a){return c>=a.applyFrom&&c<a.applyTo}).forEach(function(d){var e=c-d.startOffset,f=d.endOffset-d.startOffset,g=0==f?0:d.easingFunction(e/f);b.apply(a,d.property,d.interpolation(g))});else for(var d in g)"offset"!=d&&"easing"!=d&&"composite"!=d&&b.clear(a,d)}}}(c,d),function(a,b,c){function d(a){return a.replace(/-(.)/g,function(a,b){return b.toUpperCase()})}function e(a,b,c){h[c]=h[c]||[],h[c].push([a,b])}function f(a,b,c){for(var f=0;f<c.length;f++){e(a,b,d(c[f]))}}function g(c,e,f){var g=c;/-/.test(c)&&!a.isDeprecated("Hyphenated property names","2016-03-22","Use camelCase instead.",!0)&&(g=d(c)),"initial"!=e&&"initial"!=f||("initial"==e&&(e=i[g]),"initial"==f&&(f=i[g]));for(var j=e==f?[]:h[g],k=0;j&&k<j.length;k++){var l=j[k][0](e),m=j[k][0](f);if(void 0!==l&&void 0!==m){var n=j[k][1](l,m);if(n){var o=b.Interpolation.apply(null,n);return function(a){return 0==a?e:1==a?f:o(a)}}}}return b.Interpolation(!1,!0,function(a){return a?f:e})}var h={};b.addPropertiesHandler=f;var i={backgroundColor:"transparent",backgroundPosition:"0% 0%",borderBottomColor:"currentColor",borderBottomLeftRadius:"0px",borderBottomRightRadius:"0px",borderBottomWidth:"3px",borderLeftColor:"currentColor",borderLeftWidth:"3px",borderRightColor:"currentColor",borderRightWidth:"3px",borderSpacing:"2px",borderTopColor:"currentColor",borderTopLeftRadius:"0px",borderTopRightRadius:"0px",borderTopWidth:"3px",bottom:"auto",clip:"rect(0px, 0px, 0px, 0px)",color:"black",fontSize:"100%",fontWeight:"400",height:"auto",left:"auto",letterSpacing:"normal",lineHeight:"120%",marginBottom:"0px",marginLeft:"0px",marginRight:"0px",marginTop:"0px",maxHeight:"none",maxWidth:"none",minHeight:"0px",minWidth:"0px",opacity:"1.0",outlineColor:"invert",outlineOffset:"0px",outlineWidth:"3px",paddingBottom:"0px",paddingLeft:"0px",paddingRight:"0px",paddingTop:"0px",right:"auto",strokeDasharray:"none",strokeDashoffset:"0px",textIndent:"0px",textShadow:"0px 0px 0px transparent",top:"auto",transform:"",verticalAlign:"0px",visibility:"visible",width:"auto",wordSpacing:"normal",zIndex:"auto"};b.propertyInterpolation=g}(c,d),function(a,b,c){function d(b){var c=a.calculateActiveDuration(b),d=function(d){return a.calculateIterationProgress(c,d,b)};return d._totalDuration=b.delay+c+b.endDelay,d}b.KeyframeEffect=function(c,e,f,g){var h,i=d(a.normalizeTimingInput(f)),j=b.convertEffectInput(e),k=function(){j(c,h)};return k._update=function(a){return null!==(h=i(a))},k._clear=function(){j(c,null)},k._hasSameTarget=function(a){return c===a},k._target=c,k._totalDuration=i._totalDuration,k._id=g,k}}(c,d),function(a,b){function c(a,b,c){c.enumerable=!0,c.configurable=!0,Object.defineProperty(a,b,c)}function d(a){this._surrogateStyle=document.createElementNS("http://www.w3.org/1999/xhtml","div").style,this._style=a.style,this._length=0,this._isAnimatedProperty={};for(var b=0;b<this._style.length;b++){var c=this._style[b];this._surrogateStyle[c]=this._style[c]}this._updateIndices()}function e(a){if(!a._webAnimationsPatchedStyle){var b=new d(a);try{c(a,"style",{get:function(){return b}})}catch(b){a.style._set=function(b,c){a.style[b]=c},a.style._clear=function(b){a.style[b]=""}}a._webAnimationsPatchedStyle=a.style}}var f={cssText:1,length:1,parentRule:1},g={getPropertyCSSValue:1,getPropertyPriority:1,getPropertyValue:1,item:1,removeProperty:1,setProperty:1},h={removeProperty:1,setProperty:1};d.prototype={get cssText(){return this._surrogateStyle.cssText},set cssText(a){for(var b={},c=0;c<this._surrogateStyle.length;c++)b[this._surrogateStyle[c]]=!0;this._surrogateStyle.cssText=a,this._updateIndices();for(var c=0;c<this._surrogateStyle.length;c++)b[this._surrogateStyle[c]]=!0;for(var d in b)this._isAnimatedProperty[d]||this._style.setProperty(d,this._surrogateStyle.getPropertyValue(d))},get length(){return this._surrogateStyle.length},get parentRule(){return this._style.parentRule},_updateIndices:function(){for(;this._length<this._surrogateStyle.length;)Object.defineProperty(this,this._length,{configurable:!0,enumerable:!1,get:function(a){return function(){return this._surrogateStyle[a]}}(this._length)}),this._length++;for(;this._length>this._surrogateStyle.length;)this._length--,Object.defineProperty(this,this._length,{configurable:!0,enumerable:!1,value:void 0})},_set:function(a,b){this._style[a]=b,this._isAnimatedProperty[a]=!0},_clear:function(a){this._style[a]=this._surrogateStyle[a],delete this._isAnimatedProperty[a]}};for(var i in g)d.prototype[i]=function(a,b){return function(){var c=this._surrogateStyle[a].apply(this._surrogateStyle,arguments);return b&&(this._isAnimatedProperty[arguments[0]]||this._style[a].apply(this._style,arguments),this._updateIndices()),c}}(i,i in h);for(var j in document.documentElement.style)j in f||j in g||function(a){c(d.prototype,a,{get:function(){return this._surrogateStyle[a]},set:function(b){this._surrogateStyle[a]=b,this._updateIndices(),this._isAnimatedProperty[a]||(this._style[a]=b)}})}(j);a.apply=function(b,c,d){e(b),b.style._set(a.propertyName(c),d)},a.clear=function(b,c){b._webAnimationsPatchedStyle&&b.style._clear(a.propertyName(c))}}(d),function(a){window.Element.prototype.animate=function(b,c){var d="";return c&&c.id&&(d=c.id),a.timeline._play(a.KeyframeEffect(this,b,c,d))}}(d),function(a,b){function c(a,b,d){if("number"==typeof a&&"number"==typeof b)return a*(1-d)+b*d;if("boolean"==typeof a&&"boolean"==typeof b)return d<.5?a:b;if(a.length==b.length){for(var e=[],f=0;f<a.length;f++)e.push(c(a[f],b[f],d));return e}throw"Mismatched interpolation arguments "+a+":"+b}a.Interpolation=function(a,b,d){return function(e){return d(c(a,b,e))}}}(d),function(a,b){function c(a,b,c){return Math.max(Math.min(a,c),b)}function d(b,d,e){var f=a.dot(b,d);f=c(f,-1,1);var g=[];if(1===f)g=b;else for(var h=Math.acos(f),i=1*Math.sin(e*h)/Math.sqrt(1-f*f),j=0;j<4;j++)g.push(b[j]*(Math.cos(e*h)-f*i)+d[j]*i);return g}var e=function(){function a(a,b){for(var c=[[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]],d=0;d<4;d++)for(var e=0;e<4;e++)for(var f=0;f<4;f++)c[d][e]+=b[d][f]*a[f][e];return c}function b(a){return 0==a[0][2]&&0==a[0][3]&&0==a[1][2]&&0==a[1][3]&&0==a[2][0]&&0==a[2][1]&&1==a[2][2]&&0==a[2][3]&&0==a[3][2]&&1==a[3][3]}function c(c,d,e,f,g){for(var h=[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],i=0;i<4;i++)h[i][3]=g[i];for(var i=0;i<3;i++)for(var j=0;j<3;j++)h[3][i]+=c[j]*h[j][i];var k=f[0],l=f[1],m=f[2],n=f[3],o=[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]];o[0][0]=1-2*(l*l+m*m),o[0][1]=2*(k*l-m*n),o[0][2]=2*(k*m+l*n),o[1][0]=2*(k*l+m*n),o[1][1]=1-2*(k*k+m*m),o[1][2]=2*(l*m-k*n),o[2][0]=2*(k*m-l*n),o[2][1]=2*(l*m+k*n),o[2][2]=1-2*(k*k+l*l),h=a(h,o);var p=[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]];e[2]&&(p[2][1]=e[2],h=a(h,p)),e[1]&&(p[2][1]=0,p[2][0]=e[0],h=a(h,p)),e[0]&&(p[2][0]=0,p[1][0]=e[0],h=a(h,p));for(var i=0;i<3;i++)for(var j=0;j<3;j++)h[i][j]*=d[i];return b(h)?[h[0][0],h[0][1],h[1][0],h[1][1],h[3][0],h[3][1]]:h[0].concat(h[1],h[2],h[3])}return c}();a.composeMatrix=e,a.quat=d}(d),function(a,b,c){a.sequenceNumber=0;var d=function(a,b,c){this.target=a,this.currentTime=b,this.timelineTime=c,this.type="finish",this.bubbles=!1,this.cancelable=!1,this.currentTarget=a,this.defaultPrevented=!1,this.eventPhase=Event.AT_TARGET,this.timeStamp=Date.now()};b.Animation=function(b){this.id="",b&&b._id&&(this.id=b._id),this._sequenceNumber=a.sequenceNumber++,this._currentTime=0,this._startTime=null,this._paused=!1,this._playbackRate=1,this._inTimeline=!0,this._finishedFlag=!0,this.onfinish=null,this._finishHandlers=[],this._effect=b,this._inEffect=this._effect._update(0),this._idle=!0,this._currentTimePending=!1},b.Animation.prototype={_ensureAlive:function(){this.playbackRate<0&&0===this.currentTime?this._inEffect=this._effect._update(-1):this._inEffect=this._effect._update(this.currentTime),this._inTimeline||!this._inEffect&&this._finishedFlag||(this._inTimeline=!0,b.timeline._animations.push(this))},_tickCurrentTime:function(a,b){a!=this._currentTime&&(this._currentTime=a,this._isFinished&&!b&&(this._currentTime=this._playbackRate>0?this._totalDuration:0),this._ensureAlive())},get currentTime(){return this._idle||this._currentTimePending?null:this._currentTime},set currentTime(a){a=+a,isNaN(a)||(b.restart(),this._paused||null==this._startTime||(this._startTime=this._timeline.currentTime-a/this._playbackRate),this._currentTimePending=!1,this._currentTime!=a&&(this._idle&&(this._idle=!1,this._paused=!0),this._tickCurrentTime(a,!0),b.applyDirtiedAnimation(this)))},get startTime(){return this._startTime},set startTime(a){a=+a,isNaN(a)||this._paused||this._idle||(this._startTime=a,this._tickCurrentTime((this._timeline.currentTime-this._startTime)*this.playbackRate),b.applyDirtiedAnimation(this))},get playbackRate(){return this._playbackRate},set playbackRate(a){if(a!=this._playbackRate){var c=this.currentTime;this._playbackRate=a,this._startTime=null,"paused"!=this.playState&&"idle"!=this.playState&&(this._finishedFlag=!1,this._idle=!1,this._ensureAlive(),b.applyDirtiedAnimation(this)),null!=c&&(this.currentTime=c)}},get _isFinished(){return!this._idle&&(this._playbackRate>0&&this._currentTime>=this._totalDuration||this._playbackRate<0&&this._currentTime<=0)},get _totalDuration(){return this._effect._totalDuration},get playState(){return this._idle?"idle":null==this._startTime&&!this._paused&&0!=this.playbackRate||this._currentTimePending?"pending":this._paused?"paused":this._isFinished?"finished":"running"},_rewind:function(){if(this._playbackRate>=0)this._currentTime=0;else{if(!(this._totalDuration<1/0))throw new DOMException("Unable to rewind negative playback rate animation with infinite duration","InvalidStateError");this._currentTime=this._totalDuration}},play:function(){this._paused=!1,(this._isFinished||this._idle)&&(this._rewind(),this._startTime=null),this._finishedFlag=!1,this._idle=!1,this._ensureAlive(),b.applyDirtiedAnimation(this)},pause:function(){this._isFinished||this._paused||this._idle?this._idle&&(this._rewind(),this._idle=!1):this._currentTimePending=!0,this._startTime=null,this._paused=!0},finish:function(){this._idle||(this.currentTime=this._playbackRate>0?this._totalDuration:0,this._startTime=this._totalDuration-this.currentTime,this._currentTimePending=!1,b.applyDirtiedAnimation(this))},cancel:function(){this._inEffect&&(this._inEffect=!1,this._idle=!0,this._paused=!1,this._isFinished=!0,this._finishedFlag=!0,this._currentTime=0,this._startTime=null,this._effect._update(null),b.applyDirtiedAnimation(this))},reverse:function(){this.playbackRate*=-1,this.play()},addEventListener:function(a,b){"function"==typeof b&&"finish"==a&&this._finishHandlers.push(b)},removeEventListener:function(a,b){if("finish"==a){var c=this._finishHandlers.indexOf(b);c>=0&&this._finishHandlers.splice(c,1)}},_fireEvents:function(a){if(this._isFinished){if(!this._finishedFlag){var b=new d(this,this._currentTime,a),c=this._finishHandlers.concat(this.onfinish?[this.onfinish]:[]);setTimeout(function(){c.forEach(function(a){a.call(b.target,b)})},0),this._finishedFlag=!0}}else this._finishedFlag=!1},_tick:function(a,b){this._idle||this._paused||(null==this._startTime?b&&(this.startTime=a-this._currentTime/this.playbackRate):this._isFinished||this._tickCurrentTime((a-this._startTime)*this.playbackRate)),b&&(this._currentTimePending=!1,this._fireEvents(a))},get _needsTick(){return this.playState in{pending:1,running:1}||!this._finishedFlag},_targetAnimations:function(){var a=this._effect._target;return a._activeAnimations||(a._activeAnimations=[]),a._activeAnimations},_markTarget:function(){var a=this._targetAnimations();-1===a.indexOf(this)&&a.push(this)},_unmarkTarget:function(){var a=this._targetAnimations(),b=a.indexOf(this);-1!==b&&a.splice(b,1)}}}(c,d),function(a,b,c){function d(a){var b=j;j=[],a<q.currentTime&&(a=q.currentTime),q._animations.sort(e),q._animations=h(a,!0,q._animations)[0],b.forEach(function(b){b[1](a)}),g(),l=void 0}function e(a,b){return a._sequenceNumber-b._sequenceNumber}function f(){this._animations=[],this.currentTime=window.performance&&performance.now?performance.now():0}function g(){o.forEach(function(a){a()}),o.length=0}function h(a,c,d){p=!0,n=!1,b.timeline.currentTime=a,m=!1;var e=[],f=[],g=[],h=[];return d.forEach(function(b){b._tick(a,c),b._inEffect?(f.push(b._effect),b._markTarget()):(e.push(b._effect),b._unmarkTarget()),b._needsTick&&(m=!0);var d=b._inEffect||b._needsTick;b._inTimeline=d,d?g.push(b):h.push(b)}),o.push.apply(o,e),o.push.apply(o,f),m&&requestAnimationFrame(function(){}),p=!1,[g,h]}var i=window.requestAnimationFrame,j=[],k=0;window.requestAnimationFrame=function(a){var b=k++;return 0==j.length&&i(d),j.push([b,a]),b},window.cancelAnimationFrame=function(a){j.forEach(function(b){b[0]==a&&(b[1]=function(){})})},f.prototype={_play:function(c){c._timing=a.normalizeTimingInput(c.timing);var d=new b.Animation(c);return d._idle=!1,d._timeline=this,this._animations.push(d),b.restart(),b.applyDirtiedAnimation(d),d}};var l=void 0,m=!1,n=!1;b.restart=function(){return m||(m=!0,requestAnimationFrame(function(){}),n=!0),n},b.applyDirtiedAnimation=function(a){if(!p){a._markTarget();var c=a._targetAnimations();c.sort(e),h(b.timeline.currentTime,!1,c.slice())[1].forEach(function(a){var b=q._animations.indexOf(a);-1!==b&&q._animations.splice(b,1)}),g()}};var o=[],p=!1,q=new f;b.timeline=q}(c,d),function(a,b){function c(a,b){for(var c=0,d=0;d<a.length;d++)c+=a[d]*b[d];return c}function d(a,b){return[a[0]*b[0]+a[4]*b[1]+a[8]*b[2]+a[12]*b[3],a[1]*b[0]+a[5]*b[1]+a[9]*b[2]+a[13]*b[3],a[2]*b[0]+a[6]*b[1]+a[10]*b[2]+a[14]*b[3],a[3]*b[0]+a[7]*b[1]+a[11]*b[2]+a[15]*b[3],a[0]*b[4]+a[4]*b[5]+a[8]*b[6]+a[12]*b[7],a[1]*b[4]+a[5]*b[5]+a[9]*b[6]+a[13]*b[7],a[2]*b[4]+a[6]*b[5]+a[10]*b[6]+a[14]*b[7],a[3]*b[4]+a[7]*b[5]+a[11]*b[6]+a[15]*b[7],a[0]*b[8]+a[4]*b[9]+a[8]*b[10]+a[12]*b[11],a[1]*b[8]+a[5]*b[9]+a[9]*b[10]+a[13]*b[11],a[2]*b[8]+a[6]*b[9]+a[10]*b[10]+a[14]*b[11],a[3]*b[8]+a[7]*b[9]+a[11]*b[10]+a[15]*b[11],a[0]*b[12]+a[4]*b[13]+a[8]*b[14]+a[12]*b[15],a[1]*b[12]+a[5]*b[13]+a[9]*b[14]+a[13]*b[15],a[2]*b[12]+a[6]*b[13]+a[10]*b[14]+a[14]*b[15],a[3]*b[12]+a[7]*b[13]+a[11]*b[14]+a[15]*b[15]]}function e(a){var b=a.rad||0;return((a.deg||0)/360+(a.grad||0)/400+(a.turn||0))*(2*Math.PI)+b}function f(a){switch(a.t){case"rotatex":var b=e(a.d[0]);return[1,0,0,0,0,Math.cos(b),Math.sin(b),0,0,-Math.sin(b),Math.cos(b),0,0,0,0,1];case"rotatey":var b=e(a.d[0]);return[Math.cos(b),0,-Math.sin(b),0,0,1,0,0,Math.sin(b),0,Math.cos(b),0,0,0,0,1];case"rotate":case"rotatez":var b=e(a.d[0]);return[Math.cos(b),Math.sin(b),0,0,-Math.sin(b),Math.cos(b),0,0,0,0,1,0,0,0,0,1];case"rotate3d":var c=a.d[0],d=a.d[1],f=a.d[2],b=e(a.d[3]),g=c*c+d*d+f*f;if(0===g)c=1,d=0,f=0;else if(1!==g){var h=Math.sqrt(g);c/=h,d/=h,f/=h}var i=Math.sin(b/2),j=i*Math.cos(b/2),k=i*i;return[1-2*(d*d+f*f)*k,2*(c*d*k+f*j),2*(c*f*k-d*j),0,2*(c*d*k-f*j),1-2*(c*c+f*f)*k,2*(d*f*k+c*j),0,2*(c*f*k+d*j),2*(d*f*k-c*j),1-2*(c*c+d*d)*k,0,0,0,0,1];case"scale":return[a.d[0],0,0,0,0,a.d[1],0,0,0,0,1,0,0,0,0,1];case"scalex":return[a.d[0],0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];case"scaley":return[1,0,0,0,0,a.d[0],0,0,0,0,1,0,0,0,0,1];case"scalez":return[1,0,0,0,0,1,0,0,0,0,a.d[0],0,0,0,0,1];case"scale3d":return[a.d[0],0,0,0,0,a.d[1],0,0,0,0,a.d[2],0,0,0,0,1];case"skew":var l=e(a.d[0]),m=e(a.d[1]);return[1,Math.tan(m),0,0,Math.tan(l),1,0,0,0,0,1,0,0,0,0,1];case"skewx":var b=e(a.d[0]);return[1,0,0,0,Math.tan(b),1,0,0,0,0,1,0,0,0,0,1];case"skewy":var b=e(a.d[0]);return[1,Math.tan(b),0,0,0,1,0,0,0,0,1,0,0,0,0,1];case"translate":var c=a.d[0].px||0,d=a.d[1].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,c,d,0,1];case"translatex":var c=a.d[0].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,c,0,0,1];case"translatey":var d=a.d[0].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,0,d,0,1];case"translatez":var f=a.d[0].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,0,0,f,1];case"translate3d":var c=a.d[0].px||0,d=a.d[1].px||0,f=a.d[2].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,c,d,f,1];case"perspective":return[1,0,0,0,0,1,0,0,0,0,1,a.d[0].px?-1/a.d[0].px:0,0,0,0,1];case"matrix":return[a.d[0],a.d[1],0,0,a.d[2],a.d[3],0,0,0,0,1,0,a.d[4],a.d[5],0,1];case"matrix3d":return a.d}}function g(a){return 0===a.length?[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]:a.map(f).reduce(d)}function h(a){return[i(g(a))]}var i=function(){function a(a){return a[0][0]*a[1][1]*a[2][2]+a[1][0]*a[2][1]*a[0][2]+a[2][0]*a[0][1]*a[1][2]-a[0][2]*a[1][1]*a[2][0]-a[1][2]*a[2][1]*a[0][0]-a[2][2]*a[0][1]*a[1][0]}function b(b){for(var c=1/a(b),d=b[0][0],e=b[0][1],f=b[0][2],g=b[1][0],h=b[1][1],i=b[1][2],j=b[2][0],k=b[2][1],l=b[2][2],m=[[(h*l-i*k)*c,(f*k-e*l)*c,(e*i-f*h)*c,0],[(i*j-g*l)*c,(d*l-f*j)*c,(f*g-d*i)*c,0],[(g*k-h*j)*c,(j*e-d*k)*c,(d*h-e*g)*c,0]],n=[],o=0;o<3;o++){for(var p=0,q=0;q<3;q++)p+=b[3][q]*m[q][o];n.push(p)}return n.push(1),m.push(n),m}function d(a){return[[a[0][0],a[1][0],a[2][0],a[3][0]],[a[0][1],a[1][1],a[2][1],a[3][1]],[a[0][2],a[1][2],a[2][2],a[3][2]],[a[0][3],a[1][3],a[2][3],a[3][3]]]}function e(a,b){for(var c=[],d=0;d<4;d++){for(var e=0,f=0;f<4;f++)e+=a[f]*b[f][d];c.push(e)}return c}function f(a){var b=g(a);return[a[0]/b,a[1]/b,a[2]/b]}function g(a){return Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2])}function h(a,b,c,d){return[c*a[0]+d*b[0],c*a[1]+d*b[1],c*a[2]+d*b[2]]}function i(a,b){return[a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]]}function j(j){var k=[j.slice(0,4),j.slice(4,8),j.slice(8,12),j.slice(12,16)];if(1!==k[3][3])return null;for(var l=[],m=0;m<4;m++)l.push(k[m].slice());for(var m=0;m<3;m++)l[m][3]=0;if(0===a(l))return null;var n,o=[];k[0][3]||k[1][3]||k[2][3]?(o.push(k[0][3]),o.push(k[1][3]),o.push(k[2][3]),o.push(k[3][3]),n=e(o,d(b(l)))):n=[0,0,0,1];var p=k[3].slice(0,3),q=[];q.push(k[0].slice(0,3));var r=[];r.push(g(q[0])),q[0]=f(q[0]);var s=[];q.push(k[1].slice(0,3)),s.push(c(q[0],q[1])),q[1]=h(q[1],q[0],1,-s[0]),r.push(g(q[1])),q[1]=f(q[1]),s[0]/=r[1],q.push(k[2].slice(0,3)),s.push(c(q[0],q[2])),q[2]=h(q[2],q[0],1,-s[1]),s.push(c(q[1],q[2])),q[2]=h(q[2],q[1],1,-s[2]),r.push(g(q[2])),q[2]=f(q[2]),s[1]/=r[2],s[2]/=r[2];var t=i(q[1],q[2]);if(c(q[0],t)<0)for(var m=0;m<3;m++)r[m]*=-1,q[m][0]*=-1,q[m][1]*=-1,q[m][2]*=-1;var u,v,w=q[0][0]+q[1][1]+q[2][2]+1;return w>1e-4?(u=.5/Math.sqrt(w),v=[(q[2][1]-q[1][2])*u,(q[0][2]-q[2][0])*u,(q[1][0]-q[0][1])*u,.25/u]):q[0][0]>q[1][1]&&q[0][0]>q[2][2]?(u=2*Math.sqrt(1+q[0][0]-q[1][1]-q[2][2]),v=[.25*u,(q[0][1]+q[1][0])/u,(q[0][2]+q[2][0])/u,(q[2][1]-q[1][2])/u]):q[1][1]>q[2][2]?(u=2*Math.sqrt(1+q[1][1]-q[0][0]-q[2][2]),v=[(q[0][1]+q[1][0])/u,.25*u,(q[1][2]+q[2][1])/u,(q[0][2]-q[2][0])/u]):(u=2*Math.sqrt(1+q[2][2]-q[0][0]-q[1][1]),v=[(q[0][2]+q[2][0])/u,(q[1][2]+q[2][1])/u,.25*u,(q[1][0]-q[0][1])/u]),[p,r,s,v,n]}return j}();a.dot=c,a.makeMatrixDecomposition=h}(d),function(a){function b(a,b){var c=a.exec(b);if(c)return c=a.ignoreCase?c[0].toLowerCase():c[0],[c,b.substr(c.length)]}function c(a,b){b=b.replace(/^\s*/,"");var c=a(b);if(c)return[c[0],c[1].replace(/^\s*/,"")]}function d(a,d,e){a=c.bind(null,a);for(var f=[];;){var g=a(e);if(!g)return[f,e];if(f.push(g[0]),e=g[1],!(g=b(d,e))||""==g[1])return[f,e];e=g[1]}}function e(a,b){for(var c=0,d=0;d<b.length&&(!/\s|,/.test(b[d])||0!=c);d++)if("("==b[d])c++;else if(")"==b[d]&&(c--,0==c&&d++,c<=0))break;var e=a(b.substr(0,d));return void 0==e?void 0:[e,b.substr(d)]}function f(a,b){for(var c=a,d=b;c&&d;)c>d?c%=d:d%=c;return c=a*b/(c+d)}function g(a){return function(b){var c=a(b);return c&&(c[0]=void 0),c}}function h(a,b){return function(c){return a(c)||[b,c]}}function i(b,c){for(var d=[],e=0;e<b.length;e++){var f=a.consumeTrimmed(b[e],c);if(!f||""==f[0])return;void 0!==f[0]&&d.push(f[0]),c=f[1]}if(""==c)return d}function j(a,b,c,d,e){for(var g=[],h=[],i=[],j=f(d.length,e.length),k=0;k<j;k++){var l=b(d[k%d.length],e[k%e.length]);if(!l)return;g.push(l[0]),h.push(l[1]),i.push(l[2])}return[g,h,function(b){var d=b.map(function(a,b){return i[b](a)}).join(c);return a?a(d):d}]}function k(a,b,c){for(var d=[],e=[],f=[],g=0,h=0;h<c.length;h++)if("function"==typeof c[h]){var i=c[h](a[g],b[g++]);d.push(i[0]),e.push(i[1]),f.push(i[2])}else!function(a){d.push(!1),e.push(!1),f.push(function(){return c[a]})}(h);return[d,e,function(a){for(var b="",c=0;c<a.length;c++)b+=f[c](a[c]);return b}]}a.consumeToken=b,a.consumeTrimmed=c,a.consumeRepeated=d,a.consumeParenthesised=e,a.ignore=g,a.optional=h,a.consumeList=i,a.mergeNestedRepeated=j.bind(null,null),a.mergeWrappedNestedRepeated=j,a.mergeList=k}(d),function(a){function b(b){function c(b){var c=a.consumeToken(/^inset/i,b);if(c)return d.inset=!0,c;var c=a.consumeLengthOrPercent(b);if(c)return d.lengths.push(c[0]),c;var c=a.consumeColor(b);return c?(d.color=c[0],c):void 0}var d={inset:!1,lengths:[],color:null},e=a.consumeRepeated(c,/^/,b);if(e&&e[0].length)return[d,e[1]]}function c(c){var d=a.consumeRepeated(b,/^,/,c);if(d&&""==d[1])return d[0]}function d(b,c){for(;b.lengths.length<Math.max(b.lengths.length,c.lengths.length);)b.lengths.push({px:0});for(;c.lengths.length<Math.max(b.lengths.length,c.lengths.length);)c.lengths.push({px:0});if(b.inset==c.inset&&!!b.color==!!c.color){for(var d,e=[],f=[[],0],g=[[],0],h=0;h<b.lengths.length;h++){var i=a.mergeDimensions(b.lengths[h],c.lengths[h],2==h);f[0].push(i[0]),g[0].push(i[1]),e.push(i[2])}if(b.color&&c.color){var j=a.mergeColors(b.color,c.color);f[1]=j[0],g[1]=j[1],d=j[2]}return[f,g,function(a){for(var c=b.inset?"inset ":" ",f=0;f<e.length;f++)c+=e[f](a[0][f])+" ";return d&&(c+=d(a[1])),c}]}}function e(b,c,d,e){function f(a){return{inset:a,color:[0,0,0,0],lengths:[{px:0},{px:0},{px:0},{px:0}]}}for(var g=[],h=[],i=0;i<d.length||i<e.length;i++){var j=d[i]||f(e[i].inset),k=e[i]||f(d[i].inset);g.push(j),h.push(k)}return a.mergeNestedRepeated(b,c,g,h)}var f=e.bind(null,d,", ");a.addPropertiesHandler(c,f,["box-shadow","text-shadow"])}(d),function(a,b){function c(a){return a.toFixed(3).replace(/0+$/,"").replace(/\.$/,"")}function d(a,b,c){return Math.min(b,Math.max(a,c))}function e(a){if(/^\s*[-+]?(\d*\.)?\d+\s*$/.test(a))return Number(a)}function f(a,b){return[a,b,c]}function g(a,b){if(0!=a)return i(0,1/0)(a,b)}function h(a,b){return[a,b,function(a){return Math.round(d(1,1/0,a))}]}function i(a,b){return function(e,f){return[e,f,function(e){return c(d(a,b,e))}]}}function j(a){var b=a.trim().split(/\s*[\s,]\s*/);if(0!==b.length){for(var c=[],d=0;d<b.length;d++){var f=e(b[d]);if(void 0===f)return;c.push(f)}return c}}function k(a,b){if(a.length==b.length)return[a,b,function(a){return a.map(c).join(" ")}]}function l(a,b){return[a,b,Math.round]}a.clamp=d,a.addPropertiesHandler(j,k,["stroke-dasharray"]),a.addPropertiesHandler(e,i(0,1/0),["border-image-width","line-height"]),a.addPropertiesHandler(e,i(0,1),["opacity","shape-image-threshold"]),a.addPropertiesHandler(e,g,["flex-grow","flex-shrink"]),a.addPropertiesHandler(e,h,["orphans","widows"]),a.addPropertiesHandler(e,l,["z-index"]),a.parseNumber=e,a.parseNumberList=j,a.mergeNumbers=f,a.numberToString=c}(d),function(a,b){function c(a,b){if("visible"==a||"visible"==b)return[0,1,function(c){return c<=0?a:c>=1?b:"visible"}]}a.addPropertiesHandler(String,c,["visibility"])}(d),function(a,b){function c(a){a=a.trim(),f.fillStyle="#000",f.fillStyle=a;var b=f.fillStyle;if(f.fillStyle="#fff",f.fillStyle=a,b==f.fillStyle){f.fillRect(0,0,1,1);var c=f.getImageData(0,0,1,1).data;f.clearRect(0,0,1,1);var d=c[3]/255;return[c[0]*d,c[1]*d,c[2]*d,d]}}function d(b,c){return[b,c,function(b){function c(a){return Math.max(0,Math.min(255,a))}if(b[3])for(var d=0;d<3;d++)b[d]=Math.round(c(b[d]/b[3]));return b[3]=a.numberToString(a.clamp(0,1,b[3])),"rgba("+b.join(",")+")"}]}var e=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");e.width=e.height=1;var f=e.getContext("2d");a.addPropertiesHandler(c,d,["background-color","border-bottom-color","border-left-color","border-right-color","border-top-color","color","fill","flood-color","lighting-color","outline-color","stop-color","stroke","text-decoration-color"]),a.consumeColor=a.consumeParenthesised.bind(null,c),a.mergeColors=d}(d),function(a,b){function c(a,b){if("0"==(b=b.trim().toLowerCase())&&"px".search(a)>=0)return{px:0};if(/^[^(]*$|^calc/.test(b)){b=b.replace(/calc\(/g,"(");var c={};b=b.replace(a,function(a){return c[a]=null,"U"+a});for(var d="U("+a.source+")",e=b.replace(/[-+]?(\d*\.)?\d+/g,"N").replace(new RegExp("N"+d,"g"),"D").replace(/\s[+-]\s/g,"O").replace(/\s/g,""),f=[/N\*(D)/g,/(N|D)[*\/]N/g,/(N|D)O\1/g,/\((N|D)\)/g],g=0;g<f.length;)f[g].test(e)?(e=e.replace(f[g],"$1"),g=0):g++;if("D"==e){for(var h in c){var i=eval(b.replace(new RegExp("U"+h,"g"),"").replace(new RegExp(d,"g"),"*0"));if(!isFinite(i))return;c[h]=i}return c}}}function d(a,b){return e(a,b,!0)}function e(b,c,d){var e,f=[];for(e in b)f.push(e);for(e in c)f.indexOf(e)<0&&f.push(e);return b=f.map(function(a){return b[a]||0}),c=f.map(function(a){return c[a]||0}),[b,c,function(b){var c=b.map(function(c,e){return 1==b.length&&d&&(c=Math.max(c,0)),a.numberToString(c)+f[e]}).join(" + ");return b.length>1?"calc("+c+")":c}]}var f="px|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc",g=c.bind(null,new RegExp(f,"g")),h=c.bind(null,new RegExp(f+"|%","g")),i=c.bind(null,/deg|rad|grad|turn/g);a.parseLength=g,a.parseLengthOrPercent=h,a.consumeLengthOrPercent=a.consumeParenthesised.bind(null,h),a.parseAngle=i,a.mergeDimensions=e;var j=a.consumeParenthesised.bind(null,g),k=a.consumeRepeated.bind(void 0,j,/^/),l=a.consumeRepeated.bind(void 0,k,/^,/);a.consumeSizePairList=l;var m=function(a){var b=l(a);if(b&&""==b[1])return b[0]},n=a.mergeNestedRepeated.bind(void 0,d," "),o=a.mergeNestedRepeated.bind(void 0,n,",");a.mergeNonNegativeSizePair=n,a.addPropertiesHandler(m,o,["background-size"]),a.addPropertiesHandler(h,d,["border-bottom-width","border-image-width","border-left-width","border-right-width","border-top-width","flex-basis","font-size","height","line-height","max-height","max-width","outline-width","width"]),a.addPropertiesHandler(h,e,["border-bottom-left-radius","border-bottom-right-radius","border-top-left-radius","border-top-right-radius","bottom","left","letter-spacing","margin-bottom","margin-left","margin-right","margin-top","min-height","min-width","outline-offset","padding-bottom","padding-left","padding-right","padding-top","perspective","right","shape-margin","stroke-dashoffset","text-indent","top","vertical-align","word-spacing"])}(d,f),function(a,b){function c(b){return a.consumeLengthOrPercent(b)||a.consumeToken(/^auto/,b)}function d(b){var d=a.consumeList([a.ignore(a.consumeToken.bind(null,/^rect/)),a.ignore(a.consumeToken.bind(null,/^\(/)),a.consumeRepeated.bind(null,c,/^,/),a.ignore(a.consumeToken.bind(null,/^\)/))],b);if(d&&4==d[0].length)return d[0]}function e(b,c){return"auto"==b||"auto"==c?[!0,!1,function(d){var e=d?b:c;if("auto"==e)return"auto";var f=a.mergeDimensions(e,e);return f[2](f[0])}]:a.mergeDimensions(b,c)}function f(a){return"rect("+a+")"}var g=a.mergeWrappedNestedRepeated.bind(null,f,e,", ");a.parseBox=d,a.mergeBoxes=g,a.addPropertiesHandler(d,g,["clip"])}(d),function(a,b){function c(a){return function(b){var c=0;return a.map(function(a){return a===k?b[c++]:a})}}function d(a){return a}function e(b){if("none"==(b=b.toLowerCase().trim()))return[];for(var c,d=/\s*(\w+)\(([^)]*)\)/g,e=[],f=0;c=d.exec(b);){if(c.index!=f)return;f=c.index+c[0].length;var g=c[1],h=n[g];if(!h)return;var i=c[2].split(","),j=h[0];if(j.length<i.length)return;for(var k=[],o=0;o<j.length;o++){var p,q=i[o],r=j[o];if(void 0===(p=q?{A:function(b){return"0"==b.trim()?m:a.parseAngle(b)},N:a.parseNumber,T:a.parseLengthOrPercent,L:a.parseLength}[r.toUpperCase()](q):{a:m,n:k[0],t:l}[r]))return;k.push(p)}if(e.push({t:g,d:k}),d.lastIndex==b.length)return e}}function f(a){return a.toFixed(6).replace(".000000","")}function g(b,c){if(b.decompositionPair!==c){b.decompositionPair=c;var d=a.makeMatrixDecomposition(b)}if(c.decompositionPair!==b){c.decompositionPair=b;var e=a.makeMatrixDecomposition(c)}return null==d[0]||null==e[0]?[[!1],[!0],function(a){return a?c[0].d:b[0].d}]:(d[0].push(0),e[0].push(1),[d,e,function(b){var c=a.quat(d[0][3],e[0][3],b[5]);return a.composeMatrix(b[0],b[1],b[2],c,b[4]).map(f).join(",")}])}function h(a){return a.replace(/[xy]/,"")}function i(a){return a.replace(/(x|y|z|3d)?$/,"3d")}function j(b,c){var d=a.makeMatrixDecomposition&&!0,e=!1;if(!b.length||!c.length){b.length||(e=!0,b=c,c=[]);for(var f=0;f<b.length;f++){var j=b[f].t,k=b[f].d,l="scale"==j.substr(0,5)?1:0;c.push({t:j,d:k.map(function(a){if("number"==typeof a)return l;var b={};for(var c in a)b[c]=l;return b})})}}var m=function(a,b){return"perspective"==a&&"perspective"==b||("matrix"==a||"matrix3d"==a)&&("matrix"==b||"matrix3d"==b)},o=[],p=[],q=[];if(b.length!=c.length){if(!d)return;var r=g(b,c);o=[r[0]],p=[r[1]],q=[["matrix",[r[2]]]]}else for(var f=0;f<b.length;f++){var j,s=b[f].t,t=c[f].t,u=b[f].d,v=c[f].d,w=n[s],x=n[t];if(m(s,t)){if(!d)return;var r=g([b[f]],[c[f]]);o.push(r[0]),p.push(r[1]),q.push(["matrix",[r[2]]])}else{if(s==t)j=s;else if(w[2]&&x[2]&&h(s)==h(t))j=h(s),u=w[2](u),v=x[2](v);else{if(!w[1]||!x[1]||i(s)!=i(t)){if(!d)return;var r=g(b,c);o=[r[0]],p=[r[1]],q=[["matrix",[r[2]]]];break}j=i(s),u=w[1](u),v=x[1](v)}for(var y=[],z=[],A=[],B=0;B<u.length;B++){var C="number"==typeof u[B]?a.mergeNumbers:a.mergeDimensions,r=C(u[B],v[B]);y[B]=r[0],z[B]=r[1],A.push(r[2])}o.push(y),p.push(z),q.push([j,A])}}if(e){var D=o;o=p,p=D}return[o,p,function(a){return a.map(function(a,b){var c=a.map(function(a,c){return q[b][1][c](a)}).join(",");return"matrix"==q[b][0]&&16==c.split(",").length&&(q[b][0]="matrix3d"),q[b][0]+"("+c+")"}).join(" ")}]}var k=null,l={px:0},m={deg:0},n={matrix:["NNNNNN",[k,k,0,0,k,k,0,0,0,0,1,0,k,k,0,1],d],matrix3d:["NNNNNNNNNNNNNNNN",d],rotate:["A"],rotatex:["A"],rotatey:["A"],rotatez:["A"],rotate3d:["NNNA"],perspective:["L"],scale:["Nn",c([k,k,1]),d],scalex:["N",c([k,1,1]),c([k,1])],scaley:["N",c([1,k,1]),c([1,k])],scalez:["N",c([1,1,k])],scale3d:["NNN",d],skew:["Aa",null,d],skewx:["A",null,c([k,m])],skewy:["A",null,c([m,k])],translate:["Tt",c([k,k,l]),d],translatex:["T",c([k,l,l]),c([k,l])],translatey:["T",c([l,k,l]),c([l,k])],translatez:["L",c([l,l,k])],translate3d:["TTL",d]};a.addPropertiesHandler(e,j,["transform"])}(d),function(a){function b(a){var b=Number(a);if(!(isNaN(b)||b<100||b>900||b%100!=0))return b}function c(b){return b=100*Math.round(b/100),b=a.clamp(100,900,b),400===b?"normal":700===b?"bold":String(b)}function d(a,b){return[a,b,c]}a.addPropertiesHandler(b,d,["font-weight"])}(d),function(a){function b(a){var b={};for(var c in a)b[c]=-a[c];return b}function c(b){return a.consumeToken(/^(left|center|right|top|bottom)\b/i,b)||a.consumeLengthOrPercent(b)}function d(b,d){var e=a.consumeRepeated(c,/^/,d);if(e&&""==e[1]){var f=e[0];if(f[0]=f[0]||"center",f[1]=f[1]||"center",3==b&&(f[2]=f[2]||{px:0}),f.length==b){if(/top|bottom/.test(f[0])||/left|right/.test(f[1])){var h=f[0];f[0]=f[1],f[1]=h}if(/left|right|center|Object/.test(f[0])&&/top|bottom|center|Object/.test(f[1]))return f.map(function(a){return"object"==typeof a?a:g[a]})}}}function e(d){var e=a.consumeRepeated(c,/^/,d);if(e){for(var f=e[0],h=[{"%":50},{"%":50}],i=0,j=!1,k=0;k<f.length;k++){var l=f[k];"string"==typeof l?(j=/bottom|right/.test(l),i={left:0,right:0,center:i,top:1,bottom:1}[l],h[i]=g[l],"center"==l&&i++):(j&&(l=b(l),l["%"]=(l["%"]||0)+100),h[i]=l,i++,j=!1)}return[h,e[1]]}}function f(b){var c=a.consumeRepeated(e,/^,/,b);if(c&&""==c[1])return c[0]}var g={left:{"%":0},center:{"%":50},right:{"%":100},top:{"%":0},bottom:{"%":100}},h=a.mergeNestedRepeated.bind(null,a.mergeDimensions," ");a.addPropertiesHandler(d.bind(null,3),h,["transform-origin"]),a.addPropertiesHandler(d.bind(null,2),h,["perspective-origin"]),a.consumePosition=e,a.mergeOffsetList=h;var i=a.mergeNestedRepeated.bind(null,h,", ");a.addPropertiesHandler(f,i,["background-position","object-position"])}(d),function(a){function b(b){var c=a.consumeToken(/^circle/,b);if(c&&c[0])return["circle"].concat(a.consumeList([a.ignore(a.consumeToken.bind(void 0,/^\(/)),d,a.ignore(a.consumeToken.bind(void 0,/^at/)),a.consumePosition,a.ignore(a.consumeToken.bind(void 0,/^\)/))],c[1]));var f=a.consumeToken(/^ellipse/,b);if(f&&f[0])return["ellipse"].concat(a.consumeList([a.ignore(a.consumeToken.bind(void 0,/^\(/)),e,a.ignore(a.consumeToken.bind(void 0,/^at/)),a.consumePosition,a.ignore(a.consumeToken.bind(void 0,/^\)/))],f[1]));var g=a.consumeToken(/^polygon/,b);return g&&g[0]?["polygon"].concat(a.consumeList([a.ignore(a.consumeToken.bind(void 0,/^\(/)),a.optional(a.consumeToken.bind(void 0,/^nonzero\s*,|^evenodd\s*,/),"nonzero,"),a.consumeSizePairList,a.ignore(a.consumeToken.bind(void 0,/^\)/))],g[1])):void 0}function c(b,c){if(b[0]===c[0])return"circle"==b[0]?a.mergeList(b.slice(1),c.slice(1),["circle(",a.mergeDimensions," at ",a.mergeOffsetList,")"]):"ellipse"==b[0]?a.mergeList(b.slice(1),c.slice(1),["ellipse(",a.mergeNonNegativeSizePair," at ",a.mergeOffsetList,")"]):"polygon"==b[0]&&b[1]==c[1]?a.mergeList(b.slice(2),c.slice(2),["polygon(",b[1],g,")"]):void 0}var d=a.consumeParenthesised.bind(null,a.parseLengthOrPercent),e=a.consumeRepeated.bind(void 0,d,/^/),f=a.mergeNestedRepeated.bind(void 0,a.mergeDimensions," "),g=a.mergeNestedRepeated.bind(void 0,f,",");a.addPropertiesHandler(b,c,["shape-outside"])}(d),function(a,b){function c(a,b){b.concat([a]).forEach(function(b){b in document.documentElement.style&&(d[a]=b)})}var d={};c("transform",["webkitTransform","msTransform"]),c("transformOrigin",["webkitTransformOrigin"]),c("perspective",["webkitPerspective"]),c("perspectiveOrigin",["webkitPerspectiveOrigin"]),a.propertyName=function(a){return d[a]||a}}(d)}(),function(){if(void 0===document.createElement("div").animate([]).oncancel){var a;if(window.performance&&performance.now)var a=function(){return performance.now()};else var a=function(){return Date.now()};var b=function(a,b,c){this.target=a,this.currentTime=b,this.timelineTime=c,this.type="cancel",this.bubbles=!1,this.cancelable=!1,this.currentTarget=a,this.defaultPrevented=!1,this.eventPhase=Event.AT_TARGET,this.timeStamp=Date.now()},c=window.Element.prototype.animate;window.Element.prototype.animate=function(d,e){var f=c.call(this,d,e);f._cancelHandlers=[],f.oncancel=null;var g=f.cancel;f.cancel=function(){g.call(this);var c=new b(this,null,a()),d=this._cancelHandlers.concat(this.oncancel?[this.oncancel]:[]);setTimeout(function(){d.forEach(function(a){a.call(c.target,c)})},0)};var h=f.addEventListener;f.addEventListener=function(a,b){"function"==typeof b&&"cancel"==a?this._cancelHandlers.push(b):h.call(this,a,b)};var i=f.removeEventListener;return f.removeEventListener=function(a,b){if("cancel"==a){var c=this._cancelHandlers.indexOf(b);c>=0&&this._cancelHandlers.splice(c,1)}else i.call(this,a,b)},f}}}(),function(a){var b=document.documentElement,c=null,d=!1;try{var e=getComputedStyle(b).getPropertyValue("opacity"),f="0"==e?"1":"0";c=b.animate({opacity:[f,f]},{duration:1}),c.currentTime=0,d=getComputedStyle(b).getPropertyValue("opacity")==f}catch(a){}finally{c&&c.cancel()}if(!d){var g=window.Element.prototype.animate;window.Element.prototype.animate=function(b,c){return window.Symbol&&Symbol.iterator&&Array.prototype.from&&b[Symbol.iterator]&&(b=Array.from(b)),Array.isArray(b)||null===b||(b=a.convertToArrayForm(b)),g.call(this,b,c)}}}(c),b.true=a}({},function(){return this}());

},{}],174:[function(require,module,exports){
(function (global){
'use strict';

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof2(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

// Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

// const JS_FEATURES = [
//   'fn/array/for-each',
//   'fn/function/bind',
//   'fn/number/constructor',
//   'fn/object/assign',
//   'fn/object/define-property',
//   'fn/object/keys',
// ];

// const MODERNIZR_TESTS = [
//   'customevent',
// ];

var Mix = function Mix() {
  _classCallCheck(this, Mix);
};

var _Symbol = global.Symbol || function (x) {
  return '_' + x;
};

var def = Object.defineProperty.bind(Object);

var ROOT = _Symbol('root');
var STATE = _Symbol('state');

function createEvent(eventName) {
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  try {
    return new CustomEvent(eventName, data);
  } catch (e) {
    var event = document.createEvent('CustomEvent');
    event.initCustomEvent(eventName, true, true, data.detail);
    return event;
  }
}

function setupProperty(key, sideEffect) {
  var _this = this;

  def(this, key, {
    enumerable: true,
    get: function get() {
      return _this[STATE][key];
    },
    set: function set(value) {
      if (sideEffect != null) {
        sideEffect(value);
      } else {
        _this.setState(key, value);
      }
    }
  });
}

// TODO: study how native elements deal with attributes/properites
function setupProperties() {
  var _this2 = this;

  var sideEffects = this.sideEffects();

  Object.keys(this[STATE]).forEach(function (key) {
    if (typeof _this2[key] === 'undefined') {
      var sideEffect = sideEffects[key];
      setupProperty.call(_this2, key, sideEffect);
    }
  });
}

exports.default = function () {
  var C = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Mix;
  return function (_C) {
    _inherits(_class, _C);

    function _class() {
      _classCallCheck(this, _class);

      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    _createClass(_class, [{
      key: 'getComponentName',
      value: function getComponentName() {
        throw Error('Component needs to have a name, e.g. `my-tag`. Override `getComponentName`');
      }
    }, {
      key: 'setupComponent',
      value: function setupComponent(el, state) {
        def(this, STATE, { value: Object.assign({}, this.defaults(), state) });
        setupProperties.call(this);
        def(this, ROOT, { value: this.setupDOM(el) });
        return this;
      }
    }, {
      key: 'setupDOM',
      value: function setupDOM(el) {
        return el;
      }
    }, {
      key: 'getRoot',
      value: function getRoot() {
        return this[ROOT];
      }
    }, {
      key: 'getEl',
      value: function getEl() {
        return this[ROOT];
      }
    }, {
      key: 'fireEvent',
      value: function fireEvent(eventName, data) {
        var eventNameNS = this.componentName + '-' + eventName;
        this.el.dispatchEvent(createEvent(eventNameNS, data));
      }
    }, {
      key: 'defaults',
      value: function defaults() {
        // TODO: production builds with preprocess?
        console.warn('defaults not provided'); // eslint-disable-line no-console
        return {};
      }
    }, {
      key: 'sideEffects',
      value: function sideEffects() {
        // TODO: production builds with preprocess?
        console.warn('sideEffects not provided'); // eslint-disable-line no-console
        return {};
      }
    }, {
      key: 'setState',
      value: function setState(keyOrMap, value) {
        if (typeof keyOrMap === 'string') {
          this.setStateKV(keyOrMap, value);
        } else if ((typeof keyOrMap === 'undefined' ? 'undefined' : _typeof(keyOrMap)) === 'object') {
          this.setStateMap(keyOrMap);
        } else {
          throw Error('setState needs argument');
        }
      }
    }, {
      key: 'setStateKV',
      value: function setStateKV(key, value) {
        this[STATE][key] = value;
      }
    }, {
      key: 'setStateMap',
      value: function setStateMap(map) {
        var _this4 = this;

        Object.keys(this[STATE]).forEach(function (key) {
          _this4.setStateKV(key, map[key]);
        });
      }
    }, {
      key: 'componentName',
      get: function get() {
        return this.getComponentName();
      }
    }, {
      key: 'root',
      get: function get() {
        return this.getRoot();
      }
    }, {
      key: 'el',
      get: function get() {
        return this.getEl();
      }
    }]);

    return _class;
  }(C);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],175:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
// Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

/**
  * @param t current time
  * @param b start value
  * @param c change in value
  * @param d duration
  * @returns {number}
  */
function linearTween(t, b, c, d) {
  return c * t / d + b;
}

function pageDist(p1, p2) {
  return Math.sqrt(Math.pow(p1.pageX - p2.pageX, 2) + Math.pow(p1.pageY - p2.pageY, 2));
}

function contains(target, className) {
  var t = target;
  while (t != null) {
    if (t.classList && t.classList.contains(className)) {
      return true;
    }
    t = t.parentNode;
  }
  return false;
}

exports.linearTween = linearTween;
exports.pageDist = pageDist;
exports.contains = contains;

},{}],176:[function(require,module,exports){
(function (global){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _componentCore2 = require('y-component/src/component-core');

var _componentCore3 = _interopRequireDefault(_componentCore2);

var _common = require('../common');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} // Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

/* eslint-disable import/no-extraneous-dependencies, import/no-unresolved, import/extensions */

// const JS_FEATURES = [
//   'fn/array/for-each',
//   'fn/function/bind',
//   'fn/number/constructor',
//   'fn/object/assign',
//   'fn/object/define-property',
//   'fn/object/keys',
//   'fn/array/reduce',
// ];
//
// const MODERNIZR_TESTS = [
//   'customevent',
//   'eventlistener',
//   'queryselector',
//   'requestanimationframe',
//   'classlist',
//   'opacity',
//   'csstransforms',
//   'csspointerevents',
// ];

var _Symbol = global.Symbol || function (x) {
  return '_' + x;
};

var IDLE = _Symbol('idle');
var TOUCHING = _Symbol('touching');
var START_ANIMATING = _Symbol('startAnimating');
var ANIMATING = _Symbol('animating');

var VELOCITY_THRESHOLD = 0.2;
var VELOCITY_LINEAR_COMBINATION = 0.8;

var def = Object.defineProperty.bind(Object);

exports.default = function (C) {
  return function (_componentCore) {
    _inherits(_class, _componentCore);

    function _class() {
      _classCallCheck(this, _class);

      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    _createClass(_class, [{
      key: 'getComponentName',

      // @override
      value: function getComponentName() {
        return 'y-drawer';
      }

      // @override

    }, {
      key: 'defaults',
      value: function defaults() {
        return {
          opened: false,
          transitionDuration: 200,
          persistent: false
        };
      }

      // @override

    }, {
      key: 'sideEffects',
      value: function sideEffects() {
        var _this2 = this;

        return {
          opened: function opened(o) {
            if (o === true) _this2.open();else _this2.close();
          },
          persistent: function persistent(d) {
            if (d === true) _this2.persist();else _this2.unpersist();
          }
        };
      }

      // @override

    }, {
      key: 'setupComponent',
      value: function setupComponent(el, props) {
        _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'setupComponent', this).call(this, el, props);

        this.cacheDOMElements();
        this.defProperties();
        this.bindCallbacks();

        this.jumpTo(this.opened);
        if (!this.persistent) this.addEventListeners();
        if (this.persistent) this.scrim.style.display = 'none';

        return this;
      }
    }, {
      key: 'cacheDOMElements',
      value: function cacheDOMElements() {
        def(this, 'scrim', { value: this.root.querySelector('.y-drawer-scrim') });
        def(this, 'content', { value: this.root.querySelector('.y-drawer-content') });
      }
    }, {
      key: 'defProperties',
      value: function defProperties() {
        def(this, 'startX', { value: 0, writable: true });
        def(this, 'startY', { value: 0, writable: true });
        def(this, 'pageX', { value: 0, writable: true });
        def(this, 'pageY', { value: 0, writable: true });
        def(this, 'lastPageX', { value: 0, writable: true });
        def(this, 'lastPageY', { value: 0, writable: true });
        def(this, 'isScrolling', { writable: true });
        def(this, 'startedMoving', { value: false, writable: true });
        def(this, 'loopState', { value: IDLE, writable: true });
        def(this, 'velocity', { value: 0, writable: true });
        def(this, 'startTranslateX', { value: 0, writable: true });
        def(this, 'translateX', { value: 0, writable: true });
        def(this, 'animationFrameRequested', { value: false, writable: true });
        def(this, 'touching', { value: false, writable: true });
        def(this, 'lastTime', { writable: true });
        def(this, 'sliderWidth', { writable: true });
        def(this, 'animation', { writable: true, configurable: true });
      }
    }, {
      key: 'bindCallbacks',
      value: function bindCallbacks() {
        def(this, 'touchStartCallback', { value: this.touchStartCallback.bind(this) });
        def(this, 'touchMoveCallback', { value: this.touchMoveCallback.bind(this) });
        def(this, 'touchEndCallback', { value: this.touchEndCallback.bind(this) });
        def(this, 'scrimClickCallback', { value: this.scrimClickCallback.bind(this) });
        def(this, 'animationFrameCallback', { value: this.animationFrameCallback.bind(this) });
      }
    }, {
      key: 'addEventListeners',
      value: function addEventListeners() {
        document.addEventListener('touchstart', this.touchStartCallback, { passive: false });
        document.addEventListener('touchmove', this.touchMoveCallback, { passive: false });
        document.addEventListener('touchend', this.touchEndCallback, { passive: false });

        this.scrim.addEventListener('click', this.scrimClickCallback);
      }
    }, {
      key: 'removeEventListeners',
      value: function removeEventListeners() {
        document.removeEventListener('touchstart', this.touchStartCallback, { passive: false });
        document.removeEventListener('touchmove', this.touchMoveCallback, { passive: false });
        document.removeEventListener('touchend', this.touchEndCallback, { passive: false });

        this.scrim.removeEventListener('click', this.scrimClickCallback);
      }
    }, {
      key: 'requestAnimationLoop',
      value: function requestAnimationLoop() {
        if (!this.animationFrameRequested) {
          this.animationFrameRequested = true;
          requestAnimationFrame(this.animationFrameCallback);
        }
      }
    }, {
      key: 'getNearestTouch',
      value: function getNearestTouch(touches) {
        var _this3 = this;

        if (touches.length === 1) return touches[0];
        return Array.prototype.reduce.call(touches, function (acc, touch) {
          var dist = (0, _common.pageDist)(_this3, touch);
          return dist < acc.dist ? {
            dist: dist,
            touch: touch
          } : acc;
        }, {
          dist: Number.POSITIVE_INFINITY,
          touch: null
        }).touch;
      }
    }, {
      key: 'touchStartCallback',
      value: function touchStartCallback(e) {
        if (e.touches.length === 1) {
          this.isScrolling = undefined;

          var touch = e.touches[0];
          this.startX = touch.pageX;
          this.startY = touch.pageY;
          this.pageX = touch.pageX;
          this.pageY = touch.pageY;
          this.lastPageX = touch.pageX;
          this.lastPageY = touch.pageY;

          if (this.opened || this.pageX < window.innerWidth / 3) {
            this.prepInteraction();
            this.touching = true;
            this.loopState = TOUCHING;
          }
        }
      }
    }, {
      key: 'touchMoveCallback',
      value: function touchMoveCallback(e) {
        if (this.touching) {
          var touch = this.getNearestTouch(e.touches);
          this.pageX = touch.pageX;
          this.pageY = touch.pageY;

          if (typeof this.isScrolling === 'undefined' && this.startedMoving) {
            this.isScrolling = Math.abs(this.startY - this.pageY) > Math.abs(this.startX - this.pageX);
            if (!this.isScrolling) {
              this.loopState = TOUCHING;
              this.requestAnimationLoop();
            }
          }

          if (this.isScrolling) {
            return;
          }

          e.preventDefault();

          this.startedMoving = true;
        }
      }
    }, {
      key: 'updateMenuOpen',
      value: function updateMenuOpen() {
        if (this.velocity > VELOCITY_THRESHOLD) {
          this.setState('opened', true);
        } else if (this.velocity < -VELOCITY_THRESHOLD) {
          this.setState('opened', false);
        } else if (this.translateX >= this.sliderWidth / 2) {
          this.setState('opened', true);
        } else {
          this.setState('opened', false);
        }
      }
    }, {
      key: 'touchEndCallback',
      value: function touchEndCallback(e) {
        if (this.touching) {
          if (this.isScrolling || e.touches.length > 0) {
            return;
          }

          if (this.startedMoving) {
            this.updateMenuOpen();
          }

          if (this.opened) {
            this.scrim.style.pointerEvents = 'all';
          } else {
            this.scrim.style.pointerEvents = '';
          }

          this.loopState = START_ANIMATING;
          this.startedMoving = false;
          this.touching = false;
        }
      }
    }, {
      key: 'scrimClickCallback',
      value: function scrimClickCallback() {
        this.close();
      }
    }, {
      key: 'prepInteraction',
      value: function prepInteraction() {
        this.content.style.willChange = 'transform';
        this.scrim.style.willChange = 'opacity';
        this.content.classList.remove('y-drawer-opened');
        this.sliderWidth = this.getMovableSliderWidth();
      }
    }, {
      key: 'getMovableSliderWidth',
      value: function getMovableSliderWidth() {
        // Since part of the slider could be visible,
        // the width that is "movable" is less than the complete slider width
        // and given by
        return -this.content.offsetLeft;
      }
    }, {
      key: 'animateTo',
      value: function animateTo(opened) {
        this.prepInteraction();
        this.setState('opened', opened);
        this.loopState = START_ANIMATING;
        this.requestAnimationLoop();
      }
    }, {
      key: 'jumpTo',
      value: function jumpTo(opened) {
        this.prepInteraction();
        this.setState('opened', opened);
        this.loopState = IDLE;
        this.startTranslateX = opened * this.sliderWidth;
        this.endAnimating();
        this.updateDOM(this.startTranslateX, this.sliderWidth);
      }
    }, {
      key: 'updateTranslateX',
      value: function updateTranslateX() {
        var deltaX = this.pageX - this.startX;
        this.translateX = this.startTranslateX + deltaX;
        this.translateX = Math.max(0, Math.min(this.sliderWidth, this.translateX));
        return deltaX;
      }
    }, {
      key: 'animationFrameCallback',
      value: function animationFrameCallback(time) {
        switch (this.loopState) {
          case TOUCHING:
            {
              this.touchingFrame(time);
              break;
            }

          case START_ANIMATING:
            {
              this.startAnimatingFrame(time);
              this.loopState = ANIMATING;
              this.animationFrameCallback(time); // jump to next case block
              break;
            }

          case ANIMATING:
            {
              this.animatingFrame(time);
              break;
            }

          default:
            {
              break;
            }
        }
      }
    }, {
      key: 'touchingFrame',
      value: function touchingFrame(time) {
        var timeDiff = time - this.lastTime;

        if (timeDiff > 0) {
          var pageXDiff = this.pageX - this.lastPageX;
          this.velocity = VELOCITY_LINEAR_COMBINATION * (pageXDiff / timeDiff) + (1 - VELOCITY_LINEAR_COMBINATION) * this.velocity;
        }

        this.updateTranslateX();
        this.updateDOM(this.translateX, this.sliderWidth);

        this.lastTime = time;
        this.lastPageX = this.pageX;
        this.lastPageY = this.pageY;

        requestAnimationFrame(this.animationFrameCallback);
      }
    }, {
      key: 'startAnimatingFrame',
      value: function startAnimatingFrame(time) {
        this.updateTranslateX();

        // store all animation related data in this object,
        // delete after animation is completed
        var animation = {};
        animation.startX = this.translateX;
        animation.endX = (this.opened ? 1 : 0) * this.sliderWidth;
        animation.changeInValue = animation.endX - animation.startX;
        animation.startTime = time;
        this.animation = animation;
      }
    }, {
      key: 'animatingFrame',
      value: function animatingFrame(time) {
        var timeInAnimation = time - this.animation.startTime;

        if (timeInAnimation < this.transitionDuration) {
          this.animatingCont(timeInAnimation);
        } else {
          this.animatingEnd();
        }

        this.updateDOM(this.startTranslateX, this.sliderWidth);
      }
    }, {
      key: 'animatingCont',
      value: function animatingCont(timeInAnimation) {
        var startValue = this.animation.startX;
        var changeInValue = this.animation.changeInValue;
        this.startTranslateX = (0, _common.linearTween)(timeInAnimation, startValue, changeInValue, this.transitionDuration);
        requestAnimationFrame(this.animationFrameCallback);
      }
    }, {
      key: 'animatingEnd',
      value: function animatingEnd() {
        // end animation
        this.startTranslateX = this.animation.endX;
        delete this.animation;
        this.endAnimating();
      }
    }, {
      key: 'endAnimating',
      value: function endAnimating() {
        this.animationFrameRequested = false;
        this.loopState = IDLE;
        this.velocity = 0;

        if (this.opened) {
          // document.body.style.overflowY = 'hidden';
          this.scrim.style.pointerEvents = 'all';
          this.content.classList.add('y-drawer-opened');
        } else {
          // document.body.style.overflowY = '';
          this.scrim.style.pointerEvents = '';
        }

        this.content.style.willChange = '';
        this.scrim.style.willChange = '';

        this.fireEvent('transitioned');
      }
    }, {
      key: 'updateDOM',
      value: function updateDOM(translateX, sliderWidth) {
        this.content.style.transform = 'translateX(' + translateX + 'px)';
        this.scrim.style.opacity = translateX / sliderWidth;
      }
    }, {
      key: 'close',
      value: function close() {
        this.animateTo(false);
        return this;
      }
    }, {
      key: 'open',
      value: function open() {
        this.animateTo(true);
        return this;
      }
    }, {
      key: 'toggle',
      value: function toggle() {
        if (this.opened) {
          this.close();
        } else {
          this.open();
        }
        return this;
      }
    }, {
      key: 'persist',
      value: function persist() {
        this.scrim.style.display = 'none';
        this.removeEventListeners();
        this.setState('persistent', true);
      }
    }, {
      key: 'unpersist',
      value: function unpersist() {
        this.scrim.style.display = '';
        this.addEventListeners();
        this.setState('persistent', false);
      }
    }]);

    return _class;
  }((0, _componentCore3.default)(C));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common":175,"y-component/src/component-core":174}],177:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _core = require('../core');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} // Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

/* eslint-disable import/no-extraneous-dependencies, import/no-unresolved, import/extensions */

var style = '\n<style>\n@media screen {\n  .y-drawer-scrim {\n    display: block;\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    opacity: 0;\n    z-index: 0;\n    pointer-events: none;\n    transform: translate3d(0,0,0);\n    -webkit-tap-highlight-color: transparent;\n\n    background: rgba(0, 0, 0, 0.67);\n  }\n\n  .y-drawer-content {\n    position: fixed;\n    left: 0;\n    bottom: 0;\n    top: 0;\n    z-index: 1;\n    overflow-x: hidden;\n    overflow-y: auto;\n    transform: translate3d(0,0,0);\n    -webkit-overflow-scrolling: touch;\n    contain: strict;\n\n    left: -18rem;\n    width: 18rem;\n    background: #e8e8e8;\n  }\n\n  .y-drawer-content.y-drawer-opened {\n    left: 0!important;\n    transform: translate3d(0,0,0)!important;\n  }\n}\n\n@media print {\n  .y-drawer-scrim {\n    display: none!important;\n  }\n\n  .y-drawer-content {\n    transform: none!important;\n  }\n}\n\n</style>';

function fragmentFromString(strHTML) {
  return document.createRange().createContextualFragment(strHTML);
}

var Drawer = function (_drawerCore) {
  _inherits(Drawer, _drawerCore);

  function Drawer(el, props) {
    _classCallCheck(this, Drawer);

    var _this = _possibleConstructorReturn(this, (Drawer.__proto__ || Object.getPrototypeOf(Drawer)).call(this));

    _this.setupComponent(el, props);
    return _this;
  }

  // @override


  _createClass(Drawer, [{
    key: 'setupDOM',
    value: function setupDOM(el) {
      if (!el) throw Error('No element provided');

      var scrim = document.createElement('div');
      scrim.classList.add('y-drawer-scrim');

      var content = document.createElement('div');
      content.classList.add('y-drawer-content');
      while (el.children.length > 0) {
        content.appendChild(el.children[0]);
      }

      el.appendChild(scrim);
      el.appendChild(content);

      var ref = document.getElementsByTagName('style')[0];
      ref.parentNode.insertBefore(fragmentFromString(style), ref);

      return el;
    }
  }]);

  return Drawer;
}((0, _core2.default)());

exports.default = Drawer;

},{"../core":176}],178:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('./Subscriber');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerSubscriber = function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        _super.call(this);
        this.parent = parent;
        this.outerValue = outerValue;
        this.outerIndex = outerIndex;
        this.index = 0;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber);
exports.InnerSubscriber = InnerSubscriber;


},{"./Subscriber":186}],179:[function(require,module,exports){
"use strict";

var Observable_1 = require('./Observable');
/**
 * Represents a push-based event or value that an {@link Observable} can emit.
 * This class is particularly useful for operators that manage notifications,
 * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
 * others. Besides wrapping the actual delivered value, it also annotates it
 * with metadata of, for instance, what type of push message it is (`next`,
 * `error`, or `complete`).
 *
 * @see {@link materialize}
 * @see {@link dematerialize}
 * @see {@link observeOn}
 *
 * @class Notification<T>
 */
var Notification = function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    /**
     * Delivers to the given `observer` the value wrapped by this Notification.
     * @param {Observer} observer
     * @return
     */
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    /**
     * Given some {@link Observer} callbacks, deliver the value represented by the
     * current Notification to the correctly corresponding callback.
     * @param {function(value: T): void} next An Observer `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    /**
     * Takes an Observer or its individual callback functions, and calls `observe`
     * or `do` methods accordingly.
     * @param {Observer|function(value: T): void} nextOrObserver An Observer or
     * the `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        } else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    /**
     * Returns a simple Observable that just delivers the notification represented
     * by this Notification instance.
     * @return {any}
     */
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return Observable_1.Observable.of(this.value);
            case 'E':
                return Observable_1.Observable.throw(this.error);
            case 'C':
                return Observable_1.Observable.empty();
        }
        throw new Error('unexpected notification kind value');
    };
    /**
     * A shortcut to create a Notification instance of the type `next` from a
     * given value.
     * @param {T} value The `next` value.
     * @return {Notification<T>} The "next" Notification representing the
     * argument.
     */
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return this.undefinedValueNotification;
    };
    /**
     * A shortcut to create a Notification instance of the type `error` from a
     * given error.
     * @param {any} [err] The `error` error.
     * @return {Notification<T>} The "error" Notification representing the
     * argument.
     */
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    /**
     * A shortcut to create a Notification instance of the type `complete`.
     * @return {Notification<any>} The valueless "complete" Notification.
     */
    Notification.createComplete = function () {
        return this.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}();
exports.Notification = Notification;


},{"./Observable":180}],180:[function(require,module,exports){
"use strict";

var root_1 = require('./util/root');
var toSubscriber_1 = require('./util/toSubscriber');
var observable_1 = require('./symbol/observable');
/**
 * A representation of any set of values over any amount of time. This the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
var Observable = function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is  called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this.source);
        } else {
            sink.add(this._trySubscribe(sink));
        }
        if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
                throw sink.syncErrorValue;
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        } catch (err) {
            sink.syncErrorThrown = true;
            sink.syncErrorValue = err;
            sink.error(err);
        }
    };
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    Observable.prototype.forEach = function (next, PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
                PromiseCtor = root_1.root.Rx.config.Promise;
            } else if (root_1.root.Promise) {
                PromiseCtor = root_1.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            // Must be declared in a separate statement to avoid a RefernceError when
            // accessing subscription below in the closure due to Temporal Dead Zone.
            var subscription;
            subscription = _this.subscribe(function (value) {
                if (subscription) {
                    // if there is a subscription, then we can surmise
                    // the next handling is asynchronous. Any errors thrown
                    // need to be rejected explicitly and unsubscribe must be
                    // called manually
                    try {
                        next(value);
                    } catch (err) {
                        reject(err);
                        subscription.unsubscribe();
                    }
                } else {
                    // if there is NO subscription, then we're getting a nexted
                    // value synchronously during subscription. We can just call it.
                    // If it errors, Observable's `subscribe` will ensure the
                    // unsubscription logic is called, then synchronously rethrow the error.
                    // After that, Promise will trap the error and send it
                    // down the rejection path.
                    next(value);
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        return this.source.subscribe(subscriber);
    };
    /**
     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     * @method Symbol.observable
     * @return {Observable} this instance of the observable
     */
    Observable.prototype[observable_1.observable] = function () {
        return this;
    };
    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     */
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}();
exports.Observable = Observable;


},{"./symbol/observable":268,"./util/root":283,"./util/toSubscriber":285}],181:[function(require,module,exports){
"use strict";

exports.empty = {
    closed: true,
    next: function next(value) {},
    error: function error(err) {
        throw err;
    },
    complete: function complete() {}
};


},{}],182:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('./Subscriber');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var OuterSubscriber = function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        _super.apply(this, arguments);
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber_1.Subscriber);
exports.OuterSubscriber = OuterSubscriber;


},{"./Subscriber":186}],183:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119}],184:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('./Observable');
var Subscriber_1 = require('./Subscriber');
var Subscription_1 = require('./Subscription');
var ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');
var SubjectSubscription_1 = require('./SubjectSubscription');
var rxSubscriber_1 = require('./symbol/rxSubscriber');
/**
 * @class SubjectSubscriber<T>
 */
var SubjectSubscriber = function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        _super.call(this, destination);
        this.destination = destination;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber);
exports.SubjectSubscriber = SubjectSubscriber;
/**
 * @class Subject<T>
 */
var Subject = function (_super) {
    __extends(Subject, _super);
    function Subject() {
        _super.call(this);
        this.observers = [];
        this.closed = false;
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
    }
    Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        } else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        } else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable);
exports.Subject = Subject;
/**
 * @class AnonymousSubject<T>
 */
var AnonymousSubject = function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        _super.call(this);
        this.destination = destination;
        this.source = source;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        } else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject);
exports.AnonymousSubject = AnonymousSubject;


},{"./Observable":180,"./SubjectSubscription":185,"./Subscriber":186,"./Subscription":187,"./symbol/rxSubscriber":269,"./util/ObjectUnsubscribedError":271}],185:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = require('./Subscription');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubjectSubscription = function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        _super.call(this);
        this.subject = subject;
        this.subscriber = subscriber;
        this.closed = false;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription);
exports.SubjectSubscription = SubjectSubscription;


},{"./Subscription":187}],186:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isFunction_1 = require('./util/isFunction');
var Subscription_1 = require('./Subscription');
var Observer_1 = require('./Observer');
var rxSubscriber_1 = require('./symbol/rxSubscriber');
/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
var Subscriber = function (_super) {
    __extends(Subscriber, _super);
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    function Subscriber(destinationOrNext, error, complete) {
        _super.call(this);
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;
        switch (arguments.length) {
            case 0:
                this.destination = Observer_1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    this.destination = Observer_1.empty;
                    break;
                }
                if ((typeof destinationOrNext === 'undefined' ? 'undefined' : _typeof(destinationOrNext)) === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        this.destination = destinationOrNext;
                        this.destination.add(this);
                    } else {
                        this.syncErrorThrowable = true;
                        this.destination = new SafeSubscriber(this, destinationOrNext);
                    }
                    break;
                }
            default:
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                break;
        }
    }
    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () {
        return this;
    };
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     */
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents;
        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription);
exports.Subscriber = Subscriber;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SafeSubscriber = function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        _super.call(this);
        this._parentSubscriber = _parentSubscriber;
        var next;
        var context = this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        } else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== Observer_1.empty) {
                context = Object.create(observerOrNext);
                if (isFunction_1.isFunction(context.unsubscribe)) {
                    this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = this.unsubscribe.bind(this);
            }
        }
        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._error) {
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                } else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            } else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                throw err;
            } else {
                _parentSubscriber.syncErrorValue = err;
                _parentSubscriber.syncErrorThrown = true;
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._complete);
                    this.unsubscribe();
                } else {
                    this.__tryOrSetError(_parentSubscriber, this._complete);
                    this.unsubscribe();
                }
            } else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        } catch (err) {
            this.unsubscribe();
            throw err;
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        try {
            fn.call(this._context, value);
        } catch (err) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber);


},{"./Observer":181,"./Subscription":187,"./symbol/rxSubscriber":269,"./util/isFunction":277}],187:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isArray_1 = require('./util/isArray');
var isObject_1 = require('./util/isObject');
var isFunction_1 = require('./util/isFunction');
var tryCatch_1 = require('./util/tryCatch');
var errorObject_1 = require('./util/errorObject');
var UnsubscriptionError_1 = require('./util/UnsubscriptionError');
/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
var Subscription = function () {
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    function Subscription(unsubscribe) {
        /**
         * A flag to indicate whether this Subscription has already been unsubscribed.
         * @type {boolean}
         */
        this.closed = false;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents,
            _unsubscribe = _a._unsubscribe,
            _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        // null out _subscriptions first so any child subscriptions that attempt
        // to remove themselves from this subscription will noop
        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0;
        // if this._parent is null, then so is this._parents, and we
        // don't have to remove ourselves from any parent subscriptions.
        while (_parent) {
            _parent.remove(this);
            // if this._parents is null or index >= len,
            // then _parent is set to null, and the loop exits
            _parent = ++index < len && _parents[index] || null;
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject_1.errorObject) {
                hasErrors = true;
                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ? flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            index = -1;
            len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject_1.errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject_1.errorObject.e;
                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                        } else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    Subscription.prototype.add = function (teardown) {
        if (!teardown || teardown === Subscription.EMPTY) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var subscription = teardown;
        switch (typeof teardown === 'undefined' ? 'undefined' : _typeof(teardown)) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                } else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                } else if (typeof subscription._addParent !== 'function' /* quack quack */) {
                        var tmp = subscription;
                        subscription = new Subscription();
                        subscription._subscriptions = [tmp];
                    }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        var subscriptions = this._subscriptions || (this._subscriptions = []);
        subscriptions.push(subscription);
        subscription._addParent(this);
        return subscription;
    };
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.prototype._addParent = function (parent) {
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents;
        if (!_parent || _parent === parent) {
            // If we don't have a parent, or the new parent is the same as the
            // current parent, then set this._parent to the new parent.
            this._parent = parent;
        } else if (!_parents) {
            // If there's already one parent, but not multiple, allocate an Array to
            // store the rest of the parent Subscriptions.
            this._parents = [parent];
        } else if (_parents.indexOf(parent) === -1) {
            // Only add the new parent to the _parents list if it's not already there.
            _parents.push(parent);
        }
    };
    Subscription.EMPTY = function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription());
    return Subscription;
}();
exports.Subscription = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) {
        return errs.concat(err instanceof UnsubscriptionError_1.UnsubscriptionError ? err.errors : err);
    }, []);
}


},{"./util/UnsubscriptionError":272,"./util/errorObject":273,"./util/isArray":274,"./util/isFunction":277,"./util/isObject":279,"./util/tryCatch":286}],188:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var defer_1 = require('../../observable/defer');
Observable_1.Observable.defer = defer_1.defer;


},{"../../Observable":180,"../../observable/defer":228}],189:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../../Observable');
var ajax_1 = require('../../../observable/dom/ajax');
Observable_1.Observable.ajax = ajax_1.ajax;


},{"../../../Observable":180,"../../../observable/dom/ajax":230}],190:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var from_1 = require('../../observable/from');
Observable_1.Observable.from = from_1.from;


},{"../../Observable":180,"../../observable/from":231}],191:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var fromEvent_1 = require('../../observable/fromEvent');
Observable_1.Observable.fromEvent = fromEvent_1.fromEvent;


},{"../../Observable":180,"../../observable/fromEvent":232}],192:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var merge_1 = require('../../observable/merge');
Observable_1.Observable.merge = merge_1.merge;


},{"../../Observable":180,"../../observable/merge":233}],193:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var of_1 = require('../../observable/of');
Observable_1.Observable.of = of_1.of;


},{"../../Observable":180,"../../observable/of":234}],194:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var throw_1 = require('../../observable/throw');
Observable_1.Observable.throw = throw_1._throw;


},{"../../Observable":180,"../../observable/throw":235}],195:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var timer_1 = require('../../observable/timer');
Observable_1.Observable.timer = timer_1.timer;


},{"../../Observable":180,"../../observable/timer":236}],196:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var catch_1 = require('../../operator/catch');
Observable_1.Observable.prototype.catch = catch_1._catch;
Observable_1.Observable.prototype._catch = catch_1._catch;


},{"../../Observable":180,"../../operator/catch":237}],197:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var concatMap_1 = require('../../operator/concatMap');
Observable_1.Observable.prototype.concatMap = concatMap_1.concatMap;


},{"../../Observable":180,"../../operator/concatMap":239}],198:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var debounceTime_1 = require('../../operator/debounceTime');
Observable_1.Observable.prototype.debounceTime = debounceTime_1.debounceTime;


},{"../../Observable":180,"../../operator/debounceTime":240}],199:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var delay_1 = require('../../operator/delay');
Observable_1.Observable.prototype.delay = delay_1.delay;


},{"../../Observable":180,"../../operator/delay":241}],200:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var distinctUntilKeyChanged_1 = require('../../operator/distinctUntilKeyChanged');
Observable_1.Observable.prototype.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;


},{"../../Observable":180,"../../operator/distinctUntilKeyChanged":243}],201:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var do_1 = require('../../operator/do');
Observable_1.Observable.prototype.do = do_1._do;
Observable_1.Observable.prototype._do = do_1._do;


},{"../../Observable":180,"../../operator/do":244}],202:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var filter_1 = require('../../operator/filter');
Observable_1.Observable.prototype.filter = filter_1.filter;


},{"../../Observable":180,"../../operator/filter":245}],203:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var map_1 = require('../../operator/map');
Observable_1.Observable.prototype.map = map_1.map;


},{"../../Observable":180,"../../operator/map":246}],204:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var mergeMap_1 = require('../../operator/mergeMap');
Observable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;
Observable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;


},{"../../Observable":180,"../../operator/mergeMap":249}],205:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var partition_1 = require('../../operator/partition');
Observable_1.Observable.prototype.partition = partition_1.partition;


},{"../../Observable":180,"../../operator/partition":252}],206:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var retryWhen_1 = require('../../operator/retryWhen');
Observable_1.Observable.prototype.retryWhen = retryWhen_1.retryWhen;


},{"../../Observable":180,"../../operator/retryWhen":253}],207:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var share_1 = require('../../operator/share');
Observable_1.Observable.prototype.share = share_1.share;


},{"../../Observable":180,"../../operator/share":254}],208:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var startWith_1 = require('../../operator/startWith');
Observable_1.Observable.prototype.startWith = startWith_1.startWith;


},{"../../Observable":180,"../../operator/startWith":255}],209:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var switch_1 = require('../../operator/switch');
Observable_1.Observable.prototype.switch = switch_1._switch;
Observable_1.Observable.prototype._switch = switch_1._switch;


},{"../../Observable":180,"../../operator/switch":256}],210:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var switchMap_1 = require('../../operator/switchMap');
Observable_1.Observable.prototype.switchMap = switchMap_1.switchMap;


},{"../../Observable":180,"../../operator/switchMap":257}],211:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var take_1 = require('../../operator/take');
Observable_1.Observable.prototype.take = take_1.take;


},{"../../Observable":180,"../../operator/take":258}],212:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var takeUntil_1 = require('../../operator/takeUntil');
Observable_1.Observable.prototype.takeUntil = takeUntil_1.takeUntil;


},{"../../Observable":180,"../../operator/takeUntil":259}],213:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var throttleTime_1 = require('../../operator/throttleTime');
Observable_1.Observable.prototype.throttleTime = throttleTime_1.throttleTime;


},{"../../Observable":180,"../../operator/throttleTime":260}],214:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var withLatestFrom_1 = require('../../operator/withLatestFrom');
Observable_1.Observable.prototype.withLatestFrom = withLatestFrom_1.withLatestFrom;


},{"../../Observable":180,"../../operator/withLatestFrom":261}],215:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var zip_1 = require('../../operator/zip');
Observable_1.Observable.prototype.zip = zip_1.zipProto;


},{"../../Observable":180,"../../operator/zip":262}],216:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
var ScalarObservable_1 = require('./ScalarObservable');
var EmptyObservable_1 = require('./EmptyObservable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayLikeObservable = function (_super) {
    __extends(ArrayLikeObservable, _super);
    function ArrayLikeObservable(arrayLike, scheduler) {
        _super.call(this);
        this.arrayLike = arrayLike;
        this.scheduler = scheduler;
        if (!scheduler && arrayLike.length === 1) {
            this._isScalar = true;
            this.value = arrayLike[0];
        }
    }
    ArrayLikeObservable.create = function (arrayLike, scheduler) {
        var length = arrayLike.length;
        if (length === 0) {
            return new EmptyObservable_1.EmptyObservable();
        } else if (length === 1) {
            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);
        } else {
            return new ArrayLikeObservable(arrayLike, scheduler);
        }
    };
    ArrayLikeObservable.dispatch = function (state) {
        var arrayLike = state.arrayLike,
            index = state.index,
            length = state.length,
            subscriber = state.subscriber;
        if (subscriber.closed) {
            return;
        }
        if (index >= length) {
            subscriber.complete();
            return;
        }
        subscriber.next(arrayLike[index]);
        state.index = index + 1;
        this.schedule(state);
    };
    ArrayLikeObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this,
            arrayLike = _a.arrayLike,
            scheduler = _a.scheduler;
        var length = arrayLike.length;
        if (scheduler) {
            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {
                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber
            });
        } else {
            for (var i = 0; i < length && !subscriber.closed; i++) {
                subscriber.next(arrayLike[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayLikeObservable;
}(Observable_1.Observable);
exports.ArrayLikeObservable = ArrayLikeObservable;


},{"../Observable":180,"./EmptyObservable":220,"./ScalarObservable":226}],217:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
var ScalarObservable_1 = require('./ScalarObservable');
var EmptyObservable_1 = require('./EmptyObservable');
var isScheduler_1 = require('../util/isScheduler');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayObservable = function (_super) {
    __extends(ArrayObservable, _super);
    function ArrayObservable(array, scheduler) {
        _super.call(this);
        this.array = array;
        this.scheduler = scheduler;
        if (!scheduler && array.length === 1) {
            this._isScalar = true;
            this.value = array[0];
        }
    }
    ArrayObservable.create = function (array, scheduler) {
        return new ArrayObservable(array, scheduler);
    };
    /**
     * Creates an Observable that emits some values you specify as arguments,
     * immediately one after the other, and then emits a complete notification.
     *
     * <span class="informal">Emits the arguments you provide, then completes.
     * </span>
     *
     * <img src="./img/of.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the arguments given, and the complete notification thereafter. It can
     * be used for composing with other Observables, such as with {@link concat}.
     * By default, it uses a `null` IScheduler, which means the `next`
     * notifications are sent synchronously, although with a different IScheduler
     * it is possible to determine when those notifications will be delivered.
     *
     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
     * var numbers = Rx.Observable.of(10, 20, 30);
     * var letters = Rx.Observable.of('a', 'b', 'c');
     * var interval = Rx.Observable.interval(1000);
     * var result = numbers.concat(letters).concat(interval);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link throw}
     *
     * @param {...T} values Arguments that represent `next` values to be emitted.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emissions of the `next` notifications.
     * @return {Observable<T>} An Observable that emits each given input value.
     * @static true
     * @name of
     * @owner Observable
     */
    ArrayObservable.of = function () {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            array[_i - 0] = arguments[_i];
        }
        var scheduler = array[array.length - 1];
        if (isScheduler_1.isScheduler(scheduler)) {
            array.pop();
        } else {
            scheduler = null;
        }
        var len = array.length;
        if (len > 1) {
            return new ArrayObservable(array, scheduler);
        } else if (len === 1) {
            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
        } else {
            return new EmptyObservable_1.EmptyObservable(scheduler);
        }
    };
    ArrayObservable.dispatch = function (state) {
        var array = state.array,
            index = state.index,
            count = state.count,
            subscriber = state.subscriber;
        if (index >= count) {
            subscriber.complete();
            return;
        }
        subscriber.next(array[index]);
        if (subscriber.closed) {
            return;
        }
        state.index = index + 1;
        this.schedule(state);
    };
    ArrayObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var array = this.array;
        var count = array.length;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ArrayObservable.dispatch, 0, {
                array: array, index: index, count: count, subscriber: subscriber
            });
        } else {
            for (var i = 0; i < count && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayObservable;
}(Observable_1.Observable);
exports.ArrayObservable = ArrayObservable;


},{"../Observable":180,"../util/isScheduler":281,"./EmptyObservable":220,"./ScalarObservable":226}],218:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = require('../Subject');
var Observable_1 = require('../Observable');
var Subscriber_1 = require('../Subscriber');
var Subscription_1 = require('../Subscription');
/**
 * @class ConnectableObservable<T>
 */
var ConnectableObservable = function (_super) {
    __extends(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        _super.call(this);
        this.source = source;
        this.subjectFactory = subjectFactory;
        this._refCount = 0;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            connection = this._connection = new Subscription_1.Subscription();
            connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription_1.Subscription.EMPTY;
            } else {
                this._connection = connection;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return this.lift(new RefCountOperator(this));
    };
    return ConnectableObservable;
}(Observable_1.Observable);
exports.ConnectableObservable = ConnectableObservable;
exports.connectableObservableDescriptor = {
    operator: { value: null },
    _refCount: { value: 0, writable: true },
    _subject: { value: null, writable: true },
    _connection: { value: null, writable: true },
    _subscribe: { value: ConnectableObservable.prototype._subscribe },
    getSubject: { value: ConnectableObservable.prototype.getSubject },
    connect: { value: ConnectableObservable.prototype.connect },
    refCount: { value: ConnectableObservable.prototype.refCount }
};
var ConnectableSubscriber = function (_super) {
    __extends(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(Subject_1.SubjectSubscriber);
var RefCountOperator = function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}();
var RefCountSubscriber = function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        ///
        // Compare the local RefCountSubscriber's connection Subscription to the
        // connection Subscription on the shared ConnectableObservable. In cases
        // where the ConnectableObservable source synchronously emits values, and
        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
        // execution continues to here before the RefCountOperator has a chance to
        // supply the RefCountSubscriber with the shared connection Subscription.
        // For example:
        // ```
        // Observable.range(0, 10)
        //   .publish()
        //   .refCount()
        //   .take(5)
        //   .subscribe();
        // ```
        // In order to account for this case, RefCountSubscriber should only dispose
        // the ConnectableObservable's shared connection Subscription if the
        // connection Subscription exists, *and* either:
        //   a. RefCountSubscriber doesn't have a reference to the shared connection
        //      Subscription yet, or,
        //   b. RefCountSubscriber's connection Subscription reference is identical
        //      to the shared connection Subscription
        ///
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber);


},{"../Observable":180,"../Subject":184,"../Subscriber":186,"../Subscription":187}],219:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
var subscribeToResult_1 = require('../util/subscribeToResult');
var OuterSubscriber_1 = require('../OuterSubscriber');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var DeferObservable = function (_super) {
    __extends(DeferObservable, _super);
    function DeferObservable(observableFactory) {
        _super.call(this);
        this.observableFactory = observableFactory;
    }
    /**
     * Creates an Observable that, on subscribe, calls an Observable factory to
     * make an Observable for each new Observer.
     *
     * <span class="informal">Creates the Observable lazily, that is, only when it
     * is subscribed.
     * </span>
     *
     * <img src="./img/defer.png" width="100%">
     *
     * `defer` allows you to create the Observable only when the Observer
     * subscribes, and create a fresh Observable for each Observer. It waits until
     * an Observer subscribes to it, and then it generates an Observable,
     * typically with an Observable factory function. It does this afresh for each
     * subscriber, so although each subscriber may think it is subscribing to the
     * same Observable, in fact each subscriber gets its own individual
     * Observable.
     *
     * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>
     * var clicksOrInterval = Rx.Observable.defer(function () {
     *   if (Math.random() > 0.5) {
     *     return Rx.Observable.fromEvent(document, 'click');
     *   } else {
     *     return Rx.Observable.interval(1000);
     *   }
     * });
     * clicksOrInterval.subscribe(x => console.log(x));
     *
     * // Results in the following behavior:
     * // If the result of Math.random() is greater than 0.5 it will listen
     * // for clicks anywhere on the "document"; when document is clicked it
     * // will log a MouseEvent object to the console. If the result is less
     * // than 0.5 it will emit ascending numbers, one every second(1000ms).
     *
     * @see {@link create}
     *
     * @param {function(): SubscribableOrPromise} observableFactory The Observable
     * factory function to invoke for each Observer that subscribes to the output
     * Observable. May also return a Promise, which will be converted on the fly
     * to an Observable.
     * @return {Observable} An Observable whose Observers' subscriptions trigger
     * an invocation of the given Observable factory function.
     * @static true
     * @name defer
     * @owner Observable
     */
    DeferObservable.create = function (observableFactory) {
        return new DeferObservable(observableFactory);
    };
    DeferObservable.prototype._subscribe = function (subscriber) {
        return new DeferSubscriber(subscriber, this.observableFactory);
    };
    return DeferObservable;
}(Observable_1.Observable);
exports.DeferObservable = DeferObservable;
var DeferSubscriber = function (_super) {
    __extends(DeferSubscriber, _super);
    function DeferSubscriber(destination, factory) {
        _super.call(this, destination);
        this.factory = factory;
        this.tryDefer();
    }
    DeferSubscriber.prototype.tryDefer = function () {
        try {
            this._callFactory();
        } catch (err) {
            this._error(err);
        }
    };
    DeferSubscriber.prototype._callFactory = function () {
        var result = this.factory();
        if (result) {
            this.add(subscribeToResult_1.subscribeToResult(this, result));
        }
    };
    return DeferSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../Observable":180,"../OuterSubscriber":182,"../util/subscribeToResult":284}],220:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var EmptyObservable = function (_super) {
    __extends(EmptyObservable, _super);
    function EmptyObservable(scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits a complete notification.
     *
     * <span class="informal">Just emits 'complete', and nothing else.
     * </span>
     *
     * <img src="./img/empty.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the complete notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then complete.</caption>
     * var result = Rx.Observable.empty().startWith(7);
     * result.subscribe(x => console.log(x));
     *
     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
     * );
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following to the console:
     * // x is equal to the count on the interval eg(0,1,2,3,...)
     * // x will occur every 1000ms
     * // if x % 2 is equal to 1 print abc
     * // if x % 2 is not equal to 1 nothing will be output
     *
     * @see {@link create}
     * @see {@link never}
     * @see {@link of}
     * @see {@link throw}
     *
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the complete notification.
     * @return {Observable} An "empty" Observable: emits only the complete
     * notification.
     * @static true
     * @name empty
     * @owner Observable
     */
    EmptyObservable.create = function (scheduler) {
        return new EmptyObservable(scheduler);
    };
    EmptyObservable.dispatch = function (arg) {
        var subscriber = arg.subscriber;
        subscriber.complete();
    };
    EmptyObservable.prototype._subscribe = function (subscriber) {
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
        } else {
            subscriber.complete();
        }
    };
    return EmptyObservable;
}(Observable_1.Observable);
exports.EmptyObservable = EmptyObservable;


},{"../Observable":180}],221:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ErrorObservable = function (_super) {
    __extends(ErrorObservable, _super);
    function ErrorObservable(error, scheduler) {
        _super.call(this);
        this.error = error;
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits an error notification.
     *
     * <span class="informal">Just emits 'error', and nothing else.
     * </span>
     *
     * <img src="./img/throw.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the error notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then emit an error.</caption>
     * var result = Rx.Observable.throw(new Error('oops!')).startWith(7);
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @example <caption>Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x === 13 ?
     *     Rx.Observable.throw('Thirteens are bad') :
     *     Rx.Observable.of('a', 'b', 'c')
     * );
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link of}
     *
     * @param {any} error The particular Error to pass to the error notification.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the error notification.
     * @return {Observable} An error Observable: emits only the error notification
     * using the given error argument.
     * @static true
     * @name throw
     * @owner Observable
     */
    ErrorObservable.create = function (error, scheduler) {
        return new ErrorObservable(error, scheduler);
    };
    ErrorObservable.dispatch = function (arg) {
        var error = arg.error,
            subscriber = arg.subscriber;
        subscriber.error(error);
    };
    ErrorObservable.prototype._subscribe = function (subscriber) {
        var error = this.error;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ErrorObservable.dispatch, 0, {
                error: error, subscriber: subscriber
            });
        } else {
            subscriber.error(error);
        }
    };
    return ErrorObservable;
}(Observable_1.Observable);
exports.ErrorObservable = ErrorObservable;


},{"../Observable":180}],222:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
var tryCatch_1 = require('../util/tryCatch');
var isFunction_1 = require('../util/isFunction');
var errorObject_1 = require('../util/errorObject');
var Subscription_1 = require('../Subscription');
var toString = Object.prototype.toString;
function isNodeStyleEventEmitter(sourceObj) {
    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isNodeList(sourceObj) {
    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';
}
function isHTMLCollection(sourceObj) {
    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';
}
function isEventTarget(sourceObj) {
    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var FromEventObservable = function (_super) {
    __extends(FromEventObservable, _super);
    function FromEventObservable(sourceObj, eventName, selector, options) {
        _super.call(this);
        this.sourceObj = sourceObj;
        this.eventName = eventName;
        this.selector = selector;
        this.options = options;
    }
    /* tslint:enable:max-line-length */
    /**
     * Creates an Observable that emits events of a specific type coming from the
     * given event target.
     *
     * <span class="informal">Creates an Observable from DOM events, or Node
     * EventEmitter events or others.</span>
     *
     * <img src="./img/fromEvent.png" width="100%">
     *
     * Creates an Observable by attaching an event listener to an "event target",
     * which may be an object with `addEventListener` and `removeEventListener`,
     * a Node.js EventEmitter, a jQuery style EventEmitter, a NodeList from the
     * DOM, or an HTMLCollection from the DOM. The event handler is attached when
     * the output Observable is subscribed, and removed when the Subscription is
     * unsubscribed.
     *
     * @example <caption>Emits clicks happening on the DOM document</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * clicks.subscribe(x => console.log(x));
     *
     * // Results in:
     * // MouseEvent object logged to console everytime a click
     * // occurs on the document.
     *
     * @see {@link from}
     * @see {@link fromEventPattern}
     *
     * @param {EventTargetLike} target The DOMElement, event target, Node.js
     * EventEmitter, NodeList or HTMLCollection to attach the event handler to.
     * @param {string} eventName The event name of interest, being emitted by the
     * `target`.
     * @param {EventListenerOptions} [options] Options to pass through to addEventListener
     * @param {SelectorMethodSignature<T>} [selector] An optional function to
     * post-process results. It takes the arguments from the event handler and
     * should return a single value.
     * @return {Observable<T>}
     * @static true
     * @name fromEvent
     * @owner Observable
     */
    FromEventObservable.create = function (target, eventName, options, selector) {
        if (isFunction_1.isFunction(options)) {
            selector = options;
            options = undefined;
        }
        return new FromEventObservable(target, eventName, selector, options);
    };
    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {
        var unsubscribe;
        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {
            for (var i = 0, len = sourceObj.length; i < len; i++) {
                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
            }
        } else if (isEventTarget(sourceObj)) {
            var source_1 = sourceObj;
            sourceObj.addEventListener(eventName, handler, options);
            unsubscribe = function unsubscribe() {
                return source_1.removeEventListener(eventName, handler);
            };
        } else if (isJQueryStyleEventEmitter(sourceObj)) {
            var source_2 = sourceObj;
            sourceObj.on(eventName, handler);
            unsubscribe = function unsubscribe() {
                return source_2.off(eventName, handler);
            };
        } else if (isNodeStyleEventEmitter(sourceObj)) {
            var source_3 = sourceObj;
            sourceObj.addListener(eventName, handler);
            unsubscribe = function unsubscribe() {
                return source_3.removeListener(eventName, handler);
            };
        } else {
            throw new TypeError('Invalid event target');
        }
        subscriber.add(new Subscription_1.Subscription(unsubscribe));
    };
    FromEventObservable.prototype._subscribe = function (subscriber) {
        var sourceObj = this.sourceObj;
        var eventName = this.eventName;
        var options = this.options;
        var selector = this.selector;
        var handler = selector ? function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);
            if (result === errorObject_1.errorObject) {
                subscriber.error(errorObject_1.errorObject.e);
            } else {
                subscriber.next(result);
            }
        } : function (e) {
            return subscriber.next(e);
        };
        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);
    };
    return FromEventObservable;
}(Observable_1.Observable);
exports.FromEventObservable = FromEventObservable;


},{"../Observable":180,"../Subscription":187,"../util/errorObject":273,"../util/isFunction":277,"../util/tryCatch":286}],223:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isArray_1 = require('../util/isArray');
var isArrayLike_1 = require('../util/isArrayLike');
var isPromise_1 = require('../util/isPromise');
var PromiseObservable_1 = require('./PromiseObservable');
var IteratorObservable_1 = require('./IteratorObservable');
var ArrayObservable_1 = require('./ArrayObservable');
var ArrayLikeObservable_1 = require('./ArrayLikeObservable');
var iterator_1 = require('../symbol/iterator');
var Observable_1 = require('../Observable');
var observeOn_1 = require('../operator/observeOn');
var observable_1 = require('../symbol/observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var FromObservable = function (_super) {
    __extends(FromObservable, _super);
    function FromObservable(ish, scheduler) {
        _super.call(this, null);
        this.ish = ish;
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable from an Array, an array-like object, a Promise, an
     * iterable object, or an Observable-like object.
     *
     * <span class="informal">Converts almost anything to an Observable.</span>
     *
     * <img src="./img/from.png" width="100%">
     *
     * Convert various other objects and data types into Observables. `from`
     * converts a Promise or an array-like or an
     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)
     * object into an Observable that emits the items in that promise or array or
     * iterable. A String, in this context, is treated as an array of characters.
     * Observable-like objects (contains a function named with the ES2015 Symbol
     * for Observable) can also be converted through this operator.
     *
     * @example <caption>Converts an array to an Observable</caption>
     * var array = [10, 20, 30];
     * var result = Rx.Observable.from(array);
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // 10 20 30
     *
     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>
     * function* generateDoubles(seed) {
     *   var i = seed;
     *   while (true) {
     *     yield i;
     *     i = 2 * i; // double it
     *   }
     * }
     *
     * var iterator = generateDoubles(3);
     * var result = Rx.Observable.from(iterator).take(10);
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // 3 6 12 24 48 96 192 384 768 1536
     *
     * @see {@link create}
     * @see {@link fromEvent}
     * @see {@link fromEventPattern}
     * @see {@link fromPromise}
     *
     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an
     * Observable-like, an Array, an iterable or an array-like object to be
     * converted.
     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
     * emissions of values.
     * @return {Observable<T>} The Observable whose values are originally from the
     * input object that was converted.
     * @static true
     * @name from
     * @owner Observable
     */
    FromObservable.create = function (ish, scheduler) {
        if (ish != null) {
            if (typeof ish[observable_1.observable] === 'function') {
                if (ish instanceof Observable_1.Observable && !scheduler) {
                    return ish;
                }
                return new FromObservable(ish, scheduler);
            } else if (isArray_1.isArray(ish)) {
                return new ArrayObservable_1.ArrayObservable(ish, scheduler);
            } else if (isPromise_1.isPromise(ish)) {
                return new PromiseObservable_1.PromiseObservable(ish, scheduler);
            } else if (typeof ish[iterator_1.iterator] === 'function' || typeof ish === 'string') {
                return new IteratorObservable_1.IteratorObservable(ish, scheduler);
            } else if (isArrayLike_1.isArrayLike(ish)) {
                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);
            }
        }
        throw new TypeError((ish !== null && (typeof ish === 'undefined' ? 'undefined' : _typeof(ish)) || ish) + ' is not observable');
    };
    FromObservable.prototype._subscribe = function (subscriber) {
        var ish = this.ish;
        var scheduler = this.scheduler;
        if (scheduler == null) {
            return ish[observable_1.observable]().subscribe(subscriber);
        } else {
            return ish[observable_1.observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));
        }
    };
    return FromObservable;
}(Observable_1.Observable);
exports.FromObservable = FromObservable;


},{"../Observable":180,"../operator/observeOn":251,"../symbol/iterator":267,"../symbol/observable":268,"../util/isArray":274,"../util/isArrayLike":275,"../util/isPromise":280,"./ArrayLikeObservable":216,"./ArrayObservable":217,"./IteratorObservable":224,"./PromiseObservable":225}],224:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = require('../util/root');
var Observable_1 = require('../Observable');
var iterator_1 = require('../symbol/iterator');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var IteratorObservable = function (_super) {
    __extends(IteratorObservable, _super);
    function IteratorObservable(iterator, scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
        if (iterator == null) {
            throw new Error('iterator cannot be null.');
        }
        this.iterator = getIterator(iterator);
    }
    IteratorObservable.create = function (iterator, scheduler) {
        return new IteratorObservable(iterator, scheduler);
    };
    IteratorObservable.dispatch = function (state) {
        var index = state.index,
            hasError = state.hasError,
            iterator = state.iterator,
            subscriber = state.subscriber;
        if (hasError) {
            subscriber.error(state.error);
            return;
        }
        var result = iterator.next();
        if (result.done) {
            subscriber.complete();
            return;
        }
        subscriber.next(result.value);
        state.index = index + 1;
        if (subscriber.closed) {
            if (typeof iterator.return === 'function') {
                iterator.return();
            }
            return;
        }
        this.schedule(state);
    };
    IteratorObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this,
            iterator = _a.iterator,
            scheduler = _a.scheduler;
        if (scheduler) {
            return scheduler.schedule(IteratorObservable.dispatch, 0, {
                index: index, iterator: iterator, subscriber: subscriber
            });
        } else {
            do {
                var result = iterator.next();
                if (result.done) {
                    subscriber.complete();
                    break;
                } else {
                    subscriber.next(result.value);
                }
                if (subscriber.closed) {
                    if (typeof iterator.return === 'function') {
                        iterator.return();
                    }
                    break;
                }
            } while (true);
        }
    };
    return IteratorObservable;
}(Observable_1.Observable);
exports.IteratorObservable = IteratorObservable;
var StringIterator = function () {
    function StringIterator(str, idx, len) {
        if (idx === void 0) {
            idx = 0;
        }
        if (len === void 0) {
            len = str.length;
        }
        this.str = str;
        this.idx = idx;
        this.len = len;
    }
    StringIterator.prototype[iterator_1.iterator] = function () {
        return this;
    };
    StringIterator.prototype.next = function () {
        return this.idx < this.len ? {
            done: false,
            value: this.str.charAt(this.idx++)
        } : {
            done: true,
            value: undefined
        };
    };
    return StringIterator;
}();
var ArrayIterator = function () {
    function ArrayIterator(arr, idx, len) {
        if (idx === void 0) {
            idx = 0;
        }
        if (len === void 0) {
            len = toLength(arr);
        }
        this.arr = arr;
        this.idx = idx;
        this.len = len;
    }
    ArrayIterator.prototype[iterator_1.iterator] = function () {
        return this;
    };
    ArrayIterator.prototype.next = function () {
        return this.idx < this.len ? {
            done: false,
            value: this.arr[this.idx++]
        } : {
            done: true,
            value: undefined
        };
    };
    return ArrayIterator;
}();
function getIterator(obj) {
    var i = obj[iterator_1.iterator];
    if (!i && typeof obj === 'string') {
        return new StringIterator(obj);
    }
    if (!i && obj.length !== undefined) {
        return new ArrayIterator(obj);
    }
    if (!i) {
        throw new TypeError('object is not iterable');
    }
    return obj[iterator_1.iterator]();
}
var maxSafeInteger = Math.pow(2, 53) - 1;
function toLength(o) {
    var len = +o.length;
    if (isNaN(len)) {
        return 0;
    }
    if (len === 0 || !numberIsFinite(len)) {
        return len;
    }
    len = sign(len) * Math.floor(Math.abs(len));
    if (len <= 0) {
        return 0;
    }
    if (len > maxSafeInteger) {
        return maxSafeInteger;
    }
    return len;
}
function numberIsFinite(value) {
    return typeof value === 'number' && root_1.root.isFinite(value);
}
function sign(value) {
    var valueAsNumber = +value;
    if (valueAsNumber === 0) {
        return valueAsNumber;
    }
    if (isNaN(valueAsNumber)) {
        return valueAsNumber;
    }
    return valueAsNumber < 0 ? -1 : 1;
}


},{"../Observable":180,"../symbol/iterator":267,"../util/root":283}],225:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = require('../util/root');
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var PromiseObservable = function (_super) {
    __extends(PromiseObservable, _super);
    function PromiseObservable(promise, scheduler) {
        _super.call(this);
        this.promise = promise;
        this.scheduler = scheduler;
    }
    /**
     * Converts a Promise to an Observable.
     *
     * <span class="informal">Returns an Observable that just emits the Promise's
     * resolved value, then completes.</span>
     *
     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an
     * Observable. If the Promise resolves with a value, the output Observable
     * emits that resolved value as a `next`, and then completes. If the Promise
     * is rejected, then the output Observable emits the corresponding Error.
     *
     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>
     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link bindCallback}
     * @see {@link from}
     *
     * @param {Promise<T>} promise The promise to be converted.
     * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling
     * the delivery of the resolved value (or the rejection).
     * @return {Observable<T>} An Observable which wraps the Promise.
     * @static true
     * @name fromPromise
     * @owner Observable
     */
    PromiseObservable.create = function (promise, scheduler) {
        return new PromiseObservable(promise, scheduler);
    };
    PromiseObservable.prototype._subscribe = function (subscriber) {
        var _this = this;
        var promise = this.promise;
        var scheduler = this.scheduler;
        if (scheduler == null) {
            if (this._isScalar) {
                if (!subscriber.closed) {
                    subscriber.next(this.value);
                    subscriber.complete();
                }
            } else {
                promise.then(function (value) {
                    _this.value = value;
                    _this._isScalar = true;
                    if (!subscriber.closed) {
                        subscriber.next(value);
                        subscriber.complete();
                    }
                }, function (err) {
                    if (!subscriber.closed) {
                        subscriber.error(err);
                    }
                }).then(null, function (err) {
                    // escape the promise trap, throw unhandled errors
                    root_1.root.setTimeout(function () {
                        throw err;
                    });
                });
            }
        } else {
            if (this._isScalar) {
                if (!subscriber.closed) {
                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });
                }
            } else {
                promise.then(function (value) {
                    _this.value = value;
                    _this._isScalar = true;
                    if (!subscriber.closed) {
                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));
                    }
                }, function (err) {
                    if (!subscriber.closed) {
                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));
                    }
                }).then(null, function (err) {
                    // escape the promise trap, throw unhandled errors
                    root_1.root.setTimeout(function () {
                        throw err;
                    });
                });
            }
        }
    };
    return PromiseObservable;
}(Observable_1.Observable);
exports.PromiseObservable = PromiseObservable;
function dispatchNext(arg) {
    var value = arg.value,
        subscriber = arg.subscriber;
    if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
    }
}
function dispatchError(arg) {
    var err = arg.err,
        subscriber = arg.subscriber;
    if (!subscriber.closed) {
        subscriber.error(err);
    }
}


},{"../Observable":180,"../util/root":283}],226:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ScalarObservable = function (_super) {
    __extends(ScalarObservable, _super);
    function ScalarObservable(value, scheduler) {
        _super.call(this);
        this.value = value;
        this.scheduler = scheduler;
        this._isScalar = true;
        if (scheduler) {
            this._isScalar = false;
        }
    }
    ScalarObservable.create = function (value, scheduler) {
        return new ScalarObservable(value, scheduler);
    };
    ScalarObservable.dispatch = function (state) {
        var done = state.done,
            value = state.value,
            subscriber = state.subscriber;
        if (done) {
            subscriber.complete();
            return;
        }
        subscriber.next(value);
        if (subscriber.closed) {
            return;
        }
        state.done = true;
        this.schedule(state);
    };
    ScalarObservable.prototype._subscribe = function (subscriber) {
        var value = this.value;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ScalarObservable.dispatch, 0, {
                done: false, value: value, subscriber: subscriber
            });
        } else {
            subscriber.next(value);
            if (!subscriber.closed) {
                subscriber.complete();
            }
        }
    };
    return ScalarObservable;
}(Observable_1.Observable);
exports.ScalarObservable = ScalarObservable;


},{"../Observable":180}],227:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isNumeric_1 = require('../util/isNumeric');
var Observable_1 = require('../Observable');
var async_1 = require('../scheduler/async');
var isScheduler_1 = require('../util/isScheduler');
var isDate_1 = require('../util/isDate');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var TimerObservable = function (_super) {
    __extends(TimerObservable, _super);
    function TimerObservable(dueTime, period, scheduler) {
        if (dueTime === void 0) {
            dueTime = 0;
        }
        _super.call(this);
        this.period = -1;
        this.dueTime = 0;
        if (isNumeric_1.isNumeric(period)) {
            this.period = Number(period) < 1 && 1 || Number(period);
        } else if (isScheduler_1.isScheduler(period)) {
            scheduler = period;
        }
        if (!isScheduler_1.isScheduler(scheduler)) {
            scheduler = async_1.async;
        }
        this.scheduler = scheduler;
        this.dueTime = isDate_1.isDate(dueTime) ? +dueTime - this.scheduler.now() : dueTime;
    }
    /**
     * Creates an Observable that starts emitting after an `initialDelay` and
     * emits ever increasing numbers after each `period` of time thereafter.
     *
     * <span class="informal">Its like {@link interval}, but you can specify when
     * should the emissions start.</span>
     *
     * <img src="./img/timer.png" width="100%">
     *
     * `timer` returns an Observable that emits an infinite sequence of ascending
     * integers, with a constant interval of time, `period` of your choosing
     * between those emissions. The first emission happens after the specified
     * `initialDelay`. The initial delay may be a {@link Date}. By default, this
     * operator uses the `async` IScheduler to provide a notion of time, but you
     * may pass any IScheduler to it. If `period` is not specified, the output
     * Observable emits only one value, `0`. Otherwise, it emits an infinite
     * sequence.
     *
     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>
     * var numbers = Rx.Observable.timer(3000, 1000);
     * numbers.subscribe(x => console.log(x));
     *
     * @example <caption>Emits one number after five seconds</caption>
     * var numbers = Rx.Observable.timer(5000);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link interval}
     * @see {@link delay}
     *
     * @param {number|Date} initialDelay The initial delay time to wait before
     * emitting the first value of `0`.
     * @param {number} [period] The period of time between emissions of the
     * subsequent numbers.
     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a `0` after the
     * `initialDelay` and ever increasing numbers after each `period` of time
     * thereafter.
     * @static true
     * @name timer
     * @owner Observable
     */
    TimerObservable.create = function (initialDelay, period, scheduler) {
        if (initialDelay === void 0) {
            initialDelay = 0;
        }
        return new TimerObservable(initialDelay, period, scheduler);
    };
    TimerObservable.dispatch = function (state) {
        var index = state.index,
            period = state.period,
            subscriber = state.subscriber;
        var action = this;
        subscriber.next(index);
        if (subscriber.closed) {
            return;
        } else if (period === -1) {
            return subscriber.complete();
        }
        state.index = index + 1;
        action.schedule(state, period);
    };
    TimerObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this,
            period = _a.period,
            dueTime = _a.dueTime,
            scheduler = _a.scheduler;
        return scheduler.schedule(TimerObservable.dispatch, dueTime, {
            index: index, period: period, subscriber: subscriber
        });
    };
    return TimerObservable;
}(Observable_1.Observable);
exports.TimerObservable = TimerObservable;


},{"../Observable":180,"../scheduler/async":266,"../util/isDate":276,"../util/isNumeric":278,"../util/isScheduler":281}],228:[function(require,module,exports){
"use strict";

var DeferObservable_1 = require('./DeferObservable');
exports.defer = DeferObservable_1.DeferObservable.create;


},{"./DeferObservable":219}],229:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = require('../../util/root');
var tryCatch_1 = require('../../util/tryCatch');
var errorObject_1 = require('../../util/errorObject');
var Observable_1 = require('../../Observable');
var Subscriber_1 = require('../../Subscriber');
var map_1 = require('../../operator/map');
function getCORSRequest() {
    if (root_1.root.XMLHttpRequest) {
        return new root_1.root.XMLHttpRequest();
    } else if (!!root_1.root.XDomainRequest) {
        return new root_1.root.XDomainRequest();
    } else {
        throw new Error('CORS is not supported by your browser');
    }
}
function getXMLHttpRequest() {
    if (root_1.root.XMLHttpRequest) {
        return new root_1.root.XMLHttpRequest();
    } else {
        var progId = void 0;
        try {
            var progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];
            for (var i = 0; i < 3; i++) {
                try {
                    progId = progIds[i];
                    if (new root_1.root.ActiveXObject(progId)) {
                        break;
                    }
                } catch (e) {}
            }
            return new root_1.root.ActiveXObject(progId);
        } catch (e) {
            throw new Error('XMLHttpRequest is not supported by your browser');
        }
    }
}
function ajaxGet(url, headers) {
    if (headers === void 0) {
        headers = null;
    }
    return new AjaxObservable({ method: 'GET', url: url, headers: headers });
}
exports.ajaxGet = ajaxGet;
;
function ajaxPost(url, body, headers) {
    return new AjaxObservable({ method: 'POST', url: url, body: body, headers: headers });
}
exports.ajaxPost = ajaxPost;
;
function ajaxDelete(url, headers) {
    return new AjaxObservable({ method: 'DELETE', url: url, headers: headers });
}
exports.ajaxDelete = ajaxDelete;
;
function ajaxPut(url, body, headers) {
    return new AjaxObservable({ method: 'PUT', url: url, body: body, headers: headers });
}
exports.ajaxPut = ajaxPut;
;
function ajaxPatch(url, body, headers) {
    return new AjaxObservable({ method: 'PATCH', url: url, body: body, headers: headers });
}
exports.ajaxPatch = ajaxPatch;
;
function ajaxGetJSON(url, headers) {
    return new AjaxObservable({ method: 'GET', url: url, responseType: 'json', headers: headers }).lift(new map_1.MapOperator(function (x, index) {
        return x.response;
    }, null));
}
exports.ajaxGetJSON = ajaxGetJSON;
;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var AjaxObservable = function (_super) {
    __extends(AjaxObservable, _super);
    function AjaxObservable(urlOrRequest) {
        _super.call(this);
        var request = {
            async: true,
            createXHR: function createXHR() {
                return this.crossDomain ? getCORSRequest.call(this) : getXMLHttpRequest();
            },
            crossDomain: false,
            withCredentials: false,
            headers: {},
            method: 'GET',
            responseType: 'json',
            timeout: 0
        };
        if (typeof urlOrRequest === 'string') {
            request.url = urlOrRequest;
        } else {
            for (var prop in urlOrRequest) {
                if (urlOrRequest.hasOwnProperty(prop)) {
                    request[prop] = urlOrRequest[prop];
                }
            }
        }
        this.request = request;
    }
    AjaxObservable.prototype._subscribe = function (subscriber) {
        return new AjaxSubscriber(subscriber, this.request);
    };
    /**
     * Creates an observable for an Ajax request with either a request object with
     * url, headers, etc or a string for a URL.
     *
     * @example
     * source = Rx.Observable.ajax('/products');
     * source = Rx.Observable.ajax({ url: 'products', method: 'GET' });
     *
     * @param {string|Object} request Can be one of the following:
     *   A string of the URL to make the Ajax call.
     *   An object with the following properties
     *   - url: URL of the request
     *   - body: The body of the request
     *   - method: Method of the request, such as GET, POST, PUT, PATCH, DELETE
     *   - async: Whether the request is async
     *   - headers: Optional headers
     *   - crossDomain: true if a cross domain request, else false
     *   - createXHR: a function to override if you need to use an alternate
     *   XMLHttpRequest implementation.
     *   - resultSelector: a function to use to alter the output value type of
     *   the Observable. Gets {@link AjaxResponse} as an argument.
     * @return {Observable} An observable sequence containing the XMLHttpRequest.
     * @static true
     * @name ajax
     * @owner Observable
    */
    AjaxObservable.create = function () {
        var create = function create(urlOrRequest) {
            return new AjaxObservable(urlOrRequest);
        };
        create.get = ajaxGet;
        create.post = ajaxPost;
        create.delete = ajaxDelete;
        create.put = ajaxPut;
        create.patch = ajaxPatch;
        create.getJSON = ajaxGetJSON;
        return create;
    }();
    return AjaxObservable;
}(Observable_1.Observable);
exports.AjaxObservable = AjaxObservable;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AjaxSubscriber = function (_super) {
    __extends(AjaxSubscriber, _super);
    function AjaxSubscriber(destination, request) {
        _super.call(this, destination);
        this.request = request;
        this.done = false;
        var headers = request.headers = request.headers || {};
        // force CORS if requested
        if (!request.crossDomain && !headers['X-Requested-With']) {
            headers['X-Requested-With'] = 'XMLHttpRequest';
        }
        // ensure content type is set
        if (!('Content-Type' in headers) && !(root_1.root.FormData && request.body instanceof root_1.root.FormData) && typeof request.body !== 'undefined') {
            headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
        }
        // properly serialize body
        request.body = this.serializeBody(request.body, request.headers['Content-Type']);
        this.send();
    }
    AjaxSubscriber.prototype.next = function (e) {
        this.done = true;
        var _a = this,
            xhr = _a.xhr,
            request = _a.request,
            destination = _a.destination;
        var response = new AjaxResponse(e, xhr, request);
        destination.next(response);
    };
    AjaxSubscriber.prototype.send = function () {
        var _a = this,
            request = _a.request,
            _b = _a.request,
            user = _b.user,
            method = _b.method,
            url = _b.url,
            async = _b.async,
            password = _b.password,
            headers = _b.headers,
            body = _b.body;
        var createXHR = request.createXHR;
        var xhr = tryCatch_1.tryCatch(createXHR).call(request);
        if (xhr === errorObject_1.errorObject) {
            this.error(errorObject_1.errorObject.e);
        } else {
            this.xhr = xhr;
            // set up the events before open XHR
            // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest
            // You need to add the event listeners before calling open() on the request.
            // Otherwise the progress events will not fire.
            this.setupEvents(xhr, request);
            // open XHR
            var result = void 0;
            if (user) {
                result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async, user, password);
            } else {
                result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async);
            }
            if (result === errorObject_1.errorObject) {
                this.error(errorObject_1.errorObject.e);
                return null;
            }
            // timeout, responseType and withCredentials can be set once the XHR is open
            xhr.timeout = request.timeout;
            xhr.responseType = request.responseType;
            if ('withCredentials' in xhr) {
                xhr.withCredentials = !!request.withCredentials;
            }
            // set headers
            this.setHeaders(xhr, headers);
            // finally send the request
            result = body ? tryCatch_1.tryCatch(xhr.send).call(xhr, body) : tryCatch_1.tryCatch(xhr.send).call(xhr);
            if (result === errorObject_1.errorObject) {
                this.error(errorObject_1.errorObject.e);
                return null;
            }
        }
        return xhr;
    };
    AjaxSubscriber.prototype.serializeBody = function (body, contentType) {
        if (!body || typeof body === 'string') {
            return body;
        } else if (root_1.root.FormData && body instanceof root_1.root.FormData) {
            return body;
        }
        if (contentType) {
            var splitIndex = contentType.indexOf(';');
            if (splitIndex !== -1) {
                contentType = contentType.substring(0, splitIndex);
            }
        }
        switch (contentType) {
            case 'application/x-www-form-urlencoded':
                return Object.keys(body).map(function (key) {
                    return encodeURI(key) + "=" + encodeURI(body[key]);
                }).join('&');
            case 'application/json':
                return JSON.stringify(body);
            default:
                return body;
        }
    };
    AjaxSubscriber.prototype.setHeaders = function (xhr, headers) {
        for (var key in headers) {
            if (headers.hasOwnProperty(key)) {
                xhr.setRequestHeader(key, headers[key]);
            }
        }
    };
    AjaxSubscriber.prototype.setupEvents = function (xhr, request) {
        var progressSubscriber = request.progressSubscriber;
        function xhrTimeout(e) {
            var _a = xhrTimeout,
                subscriber = _a.subscriber,
                progressSubscriber = _a.progressSubscriber,
                request = _a.request;
            if (progressSubscriber) {
                progressSubscriber.error(e);
            }
            subscriber.error(new AjaxTimeoutError(this, request)); //TODO: Make betterer.
        }
        ;
        xhr.ontimeout = xhrTimeout;
        xhrTimeout.request = request;
        xhrTimeout.subscriber = this;
        xhrTimeout.progressSubscriber = progressSubscriber;
        if (xhr.upload && 'withCredentials' in xhr) {
            if (progressSubscriber) {
                var _xhrProgress_;
                _xhrProgress_ = function xhrProgress_1(e) {
                    var progressSubscriber = _xhrProgress_.progressSubscriber;
                    progressSubscriber.next(e);
                };
                if (root_1.root.XDomainRequest) {
                    xhr.onprogress = _xhrProgress_;
                } else {
                    xhr.upload.onprogress = _xhrProgress_;
                }
                _xhrProgress_.progressSubscriber = progressSubscriber;
            }
            var _xhrError_;
            _xhrError_ = function xhrError_1(e) {
                var _a = _xhrError_,
                    progressSubscriber = _a.progressSubscriber,
                    subscriber = _a.subscriber,
                    request = _a.request;
                if (progressSubscriber) {
                    progressSubscriber.error(e);
                }
                subscriber.error(new AjaxError('ajax error', this, request));
            };
            xhr.onerror = _xhrError_;
            _xhrError_.request = request;
            _xhrError_.subscriber = this;
            _xhrError_.progressSubscriber = progressSubscriber;
        }
        function xhrReadyStateChange(e) {
            var _a = xhrReadyStateChange,
                subscriber = _a.subscriber,
                progressSubscriber = _a.progressSubscriber,
                request = _a.request;
            if (this.readyState === 4) {
                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
                var status_1 = this.status === 1223 ? 204 : this.status;
                var response = this.responseType === 'text' ? this.response || this.responseText : this.response;
                // fix status code when it is 0 (0 status is undocumented).
                // Occurs when accessing file resources or on Android 4.1 stock browser
                // while retrieving files from application cache.
                if (status_1 === 0) {
                    status_1 = response ? 200 : 0;
                }
                if (200 <= status_1 && status_1 < 300) {
                    if (progressSubscriber) {
                        progressSubscriber.complete();
                    }
                    subscriber.next(e);
                    subscriber.complete();
                } else {
                    if (progressSubscriber) {
                        progressSubscriber.error(e);
                    }
                    subscriber.error(new AjaxError('ajax error ' + status_1, this, request));
                }
            }
        }
        ;
        xhr.onreadystatechange = xhrReadyStateChange;
        xhrReadyStateChange.subscriber = this;
        xhrReadyStateChange.progressSubscriber = progressSubscriber;
        xhrReadyStateChange.request = request;
    };
    AjaxSubscriber.prototype.unsubscribe = function () {
        var _a = this,
            done = _a.done,
            xhr = _a.xhr;
        if (!done && xhr && xhr.readyState !== 4 && typeof xhr.abort === 'function') {
            xhr.abort();
        }
        _super.prototype.unsubscribe.call(this);
    };
    return AjaxSubscriber;
}(Subscriber_1.Subscriber);
exports.AjaxSubscriber = AjaxSubscriber;
/**
 * A normalized AJAX response.
 *
 * @see {@link ajax}
 *
 * @class AjaxResponse
 */
var AjaxResponse = function () {
    function AjaxResponse(originalEvent, xhr, request) {
        this.originalEvent = originalEvent;
        this.xhr = xhr;
        this.request = request;
        this.status = xhr.status;
        this.responseType = xhr.responseType || request.responseType;
        switch (this.responseType) {
            case 'json':
                if ('response' in xhr) {
                    //IE does not support json as responseType, parse it internally
                    this.response = xhr.responseType ? xhr.response : JSON.parse(xhr.response || xhr.responseText || 'null');
                } else {
                    this.response = JSON.parse(xhr.responseText || 'null');
                }
                break;
            case 'xml':
                this.response = xhr.responseXML;
                break;
            case 'text':
            default:
                this.response = 'response' in xhr ? xhr.response : xhr.responseText;
                break;
        }
    }
    return AjaxResponse;
}();
exports.AjaxResponse = AjaxResponse;
/**
 * A normalized AJAX error.
 *
 * @see {@link ajax}
 *
 * @class AjaxError
 */
var AjaxError = function (_super) {
    __extends(AjaxError, _super);
    function AjaxError(message, xhr, request) {
        _super.call(this, message);
        this.message = message;
        this.xhr = xhr;
        this.request = request;
        this.status = xhr.status;
    }
    return AjaxError;
}(Error);
exports.AjaxError = AjaxError;
/**
 * @see {@link ajax}
 *
 * @class AjaxTimeoutError
 */
var AjaxTimeoutError = function (_super) {
    __extends(AjaxTimeoutError, _super);
    function AjaxTimeoutError(xhr, request) {
        _super.call(this, 'ajax timeout', xhr, request);
    }
    return AjaxTimeoutError;
}(AjaxError);
exports.AjaxTimeoutError = AjaxTimeoutError;


},{"../../Observable":180,"../../Subscriber":186,"../../operator/map":246,"../../util/errorObject":273,"../../util/root":283,"../../util/tryCatch":286}],230:[function(require,module,exports){
"use strict";

var AjaxObservable_1 = require('./AjaxObservable');
exports.ajax = AjaxObservable_1.AjaxObservable.create;


},{"./AjaxObservable":229}],231:[function(require,module,exports){
"use strict";

var FromObservable_1 = require('./FromObservable');
exports.from = FromObservable_1.FromObservable.create;


},{"./FromObservable":223}],232:[function(require,module,exports){
arguments[4][131][0].apply(exports,arguments)
},{"./FromEventObservable":222,"dup":131}],233:[function(require,module,exports){
"use strict";

var merge_1 = require('../operator/merge');
exports.merge = merge_1.mergeStatic;


},{"../operator/merge":247}],234:[function(require,module,exports){
"use strict";

var ArrayObservable_1 = require('./ArrayObservable');
exports.of = ArrayObservable_1.ArrayObservable.of;


},{"./ArrayObservable":217}],235:[function(require,module,exports){
"use strict";

var ErrorObservable_1 = require('./ErrorObservable');
exports._throw = ErrorObservable_1.ErrorObservable.create;


},{"./ErrorObservable":221}],236:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"./TimerObservable":227,"dup":132}],237:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
 *
 * <img src="./img/catch.png" width="100%">
 *
 * @example <caption>Continues with a different Observable when there's an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n == 4) {
 * 	     throw 'four!';
 *     }
 *	   return n;
 *   })
 *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, I, II, III, IV, V
 *
 * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n === 4) {
 * 	     throw 'four!';
 *     }
 * 	   return n;
 *   })
 *   .catch((err, caught) => caught)
 *   .take(30)
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, 1, 2, 3, ...
 *
 * @example <caption>Throws a new error when the source Observable throws an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 *     if (n == 4) {
 *       throw 'four!';
 *     }
 *     return n;
 *   })
 *   .catch(err => {
 *     throw 'error in source. Details: ' + err;
 *   })
 *   .subscribe(
 *     x => console.log(x),
 *     err => console.log(err)
 *   );
 *   // 1, 2, 3, error in source. Details: four!
 *
 * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
 *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
 *  is returned by the `selector` will be used to continue the observable chain.
 * @return {Observable} An observable that originates from either the source or the observable returned by the
 *  catch `selector` function.
 * @method catch
 * @name catch
 * @owner Observable
 */
function _catch(selector) {
    var operator = new CatchOperator(selector);
    var caught = this.lift(operator);
    return operator.caught = caught;
}
exports._catch = _catch;
var CatchOperator = function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CatchSubscriber = function (_super) {
    __extends(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        _super.call(this, destination);
        this.selector = selector;
        this.caught = caught;
    }
    // NOTE: overriding `error` instead of `_error` because we don't want
    // to have this flag this subscriber as `isStopped`. We can mimic the
    // behavior of the RetrySubscriber (from the `retry` operator), where
    // we unsubscribe from our source chain, reset our Subscriber flags,
    // then subscribe to the selector result.
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            } catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            this.add(subscribeToResult_1.subscribeToResult(this, result));
        }
    };
    return CatchSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":182,"../util/subscribeToResult":284}],238:[function(require,module,exports){
arguments[4][134][0].apply(exports,arguments)
},{"../Observable":180,"../observable/ArrayObservable":217,"../util/isScheduler":281,"./mergeAll":248,"dup":134}],239:[function(require,module,exports){
"use strict";

var mergeMap_1 = require('./mergeMap');
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, in a serialized fashion waiting for each one to complete before
 * merging the next.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link concatAll}.</span>
 *
 * <img src="./img/concatMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each new inner Observable is
 * concatenated with the previous inner Observable.
 *
 * __Warning:__ if source values arrive endlessly and faster than their
 * corresponding inner Observables can complete, it will result in memory issues
 * as inner Observables amass in an unbounded buffer waiting for their turn to
 * be subscribed to.
 *
 * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set
 * to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // (results are not concurrent)
 * // For every click on the "document" it will emit values 0 to 3 spaced
 * // on a 1000ms interval
 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
 *
 * @see {@link concat}
 * @see {@link concatAll}
 * @see {@link concatMapTo}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An observable of values merged from the projected
 * Observables as they were subscribed to, one at a time. Optionally, these
 * values may have been projected from a passed `projectResult` argument.
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking values from each projected inner
 * Observable sequentially.
 * @method concatMap
 * @owner Observable
 */
function concatMap(project, resultSelector) {
  return this.lift(new mergeMap_1.MergeMapOperator(project, resultSelector, 1));
}
exports.concatMap = concatMap;


},{"./mergeMap":249}],240:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var async_1 = require('../scheduler/async');
/**
 * Emits a value from the source Observable only after a particular time span
 * has passed without another source emission.
 *
 * <span class="informal">It's like {@link delay}, but passes only the most
 * recent value from each burst of emissions.</span>
 *
 * <img src="./img/debounceTime.png" width="100%">
 *
 * `debounceTime` delays values emitted by the source Observable, but drops
 * previous pending delayed emissions if a new value arrives on the source
 * Observable. This operator keeps track of the most recent value from the
 * source Observable, and emits that only when `dueTime` enough time has passed
 * without any other value appearing on the source Observable. If a new value
 * appears before `dueTime` silence occurs, the previous value will be dropped
 * and will not be emitted on the output Observable.
 *
 * This is a rate-limiting operator, because it is impossible for more than one
 * value to be emitted in any time window of duration `dueTime`, but it is also
 * a delay-like operator since output emissions do not occur at the same time as
 * they did on the source Observable. Optionally takes a {@link IScheduler} for
 * managing timers.
 *
 * @example <caption>Emit the most recent click after a burst of clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.debounceTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} dueTime The timeout duration in milliseconds (or the time
 * unit determined internally by the optional `scheduler`) for the window of
 * time required to wait for emission silence before emitting the most recent
 * source value.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the timeout for each value.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified `dueTime`, and may drop some values if they occur
 * too frequently.
 * @method debounceTime
 * @owner Observable
 */
function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) {
        scheduler = async_1.async;
    }
    return this.lift(new DebounceTimeOperator(dueTime, scheduler));
}
exports.debounceTime = debounceTime;
var DebounceTimeOperator = function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DebounceTimeSubscriber = function (_super) {
    __extends(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        _super.call(this, destination);
        this.dueTime = dueTime;
        this.scheduler = scheduler;
        this.debouncedSubscription = null;
        this.lastValue = null;
        this.hasValue = false;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            this.destination.next(this.lastValue);
            this.lastValue = null;
            this.hasValue = false;
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(Subscriber_1.Subscriber);
function dispatchNext(subscriber) {
    subscriber.debouncedNext();
}


},{"../Subscriber":186,"../scheduler/async":266}],241:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1 = require('../scheduler/async');
var isDate_1 = require('../util/isDate');
var Subscriber_1 = require('../Subscriber');
var Notification_1 = require('../Notification');
/**
 * Delays the emission of items from the source Observable by a given timeout or
 * until a given Date.
 *
 * <span class="informal">Time shifts each item by some specified amount of
 * milliseconds.</span>
 *
 * <img src="./img/delay.png" width="100%">
 *
 * If the delay argument is a Number, this operator time shifts the source
 * Observable by that amount of time expressed in milliseconds. The relative
 * time intervals between the values are preserved.
 *
 * If the delay argument is a Date, this operator time shifts the start of the
 * Observable execution until the given date occurs.
 *
 * @example <caption>Delay each click by one second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @example <caption>Delay all clicks until a future date happens</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var date = new Date('March 15, 2050 12:00:00'); // in the future
 * var delayedClicks = clicks.delay(date); // click emitted only after that date
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @see {@link debounceTime}
 * @see {@link delayWhen}
 *
 * @param {number|Date} delay The delay duration in milliseconds (a `number`) or
 * a `Date` until which the emission of the source items is delayed.
 * @param {Scheduler} [scheduler=async] The IScheduler to use for
 * managing the timers that handle the time-shift for each item.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified timeout or Date.
 * @method delay
 * @owner Observable
 */
function delay(delay, scheduler) {
    if (scheduler === void 0) {
        scheduler = async_1.async;
    }
    var absoluteDelay = isDate_1.isDate(delay);
    var delayFor = absoluteDelay ? +delay - scheduler.now() : Math.abs(delay);
    return this.lift(new DelayOperator(delayFor, scheduler));
}
exports.delay = delay;
var DelayOperator = function () {
    function DelayOperator(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
    }
    DelayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DelaySubscriber = function (_super) {
    __extends(DelaySubscriber, _super);
    function DelaySubscriber(destination, delay, scheduler) {
        _super.call(this, destination);
        this.delay = delay;
        this.scheduler = scheduler;
        this.queue = [];
        this.active = false;
        this.errored = false;
    }
    DelaySubscriber.dispatch = function (state) {
        var source = state.source;
        var queue = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue.length > 0 && queue[0].time - scheduler.now() <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, delay_1);
        } else {
            source.active = false;
        }
    };
    DelaySubscriber.prototype._schedule = function (scheduler) {
        this.active = true;
        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    };
    DelaySubscriber.prototype.scheduleNotification = function (notification) {
        if (this.errored === true) {
            return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };
    DelaySubscriber.prototype._next = function (value) {
        this.scheduleNotification(Notification_1.Notification.createNext(value));
    };
    DelaySubscriber.prototype._error = function (err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
    };
    DelaySubscriber.prototype._complete = function () {
        this.scheduleNotification(Notification_1.Notification.createComplete());
    };
    return DelaySubscriber;
}(Subscriber_1.Subscriber);
var DelayMessage = function () {
    function DelayMessage(time, notification) {
        this.time = time;
        this.notification = notification;
    }
    return DelayMessage;
}();


},{"../Notification":179,"../Subscriber":186,"../scheduler/async":266,"../util/isDate":276}],242:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var tryCatch_1 = require('../util/tryCatch');
var errorObject_1 = require('../util/errorObject');
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
 *
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 *
 * If a comparator function is not provided, an equality check is used by default.
 *
 * @example <caption>A simple example with numbers</caption>
 * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)
 *   .distinctUntilChanged()
 *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4
 *
 * @example <caption>An example using a compare function</caption>
 * interface Person {
 *    age: number,
 *    name: string
 * }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'})
 *     { age: 6, name: 'Foo'})
 *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo' }
 *
 * @see {@link distinct}
 * @see {@link distinctUntilKeyChanged}
 *
 * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values.
 * @method distinctUntilChanged
 * @owner Observable
 */
function distinctUntilChanged(compare, keySelector) {
    return this.lift(new DistinctUntilChangedOperator(compare, keySelector));
}
exports.distinctUntilChanged = distinctUntilChanged;
var DistinctUntilChangedOperator = function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DistinctUntilChangedSubscriber = function (_super) {
    __extends(DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.hasKey = false;
        if (typeof compare === 'function') {
            this.compare = compare;
        }
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var keySelector = this.keySelector;
        var key = value;
        if (keySelector) {
            key = tryCatch_1.tryCatch(this.keySelector)(value);
            if (key === errorObject_1.errorObject) {
                return this.destination.error(errorObject_1.errorObject.e);
            }
        }
        var result = false;
        if (this.hasKey) {
            result = tryCatch_1.tryCatch(this.compare)(this.key, key);
            if (result === errorObject_1.errorObject) {
                return this.destination.error(errorObject_1.errorObject.e);
            }
        } else {
            this.hasKey = true;
        }
        if (Boolean(result) === false) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":186,"../util/errorObject":273,"../util/tryCatch":286}],243:[function(require,module,exports){
"use strict";

var distinctUntilChanged_1 = require('./distinctUntilChanged');
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,
 * using a property accessed by using the key provided to check if the two items are distinct.
 *
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 *
 * If a comparator function is not provided, an equality check is used by default.
 *
 * @example <caption>An example comparing the name of persons</caption>
 *
 *  interface Person {
 *     age: number,
 *     name: string
 *  }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'},
 *     { age: 6, name: 'Foo'})
 *     .distinctUntilKeyChanged('name')
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo' }
 *
 * @example <caption>An example comparing the first letters of the name</caption>
 *
 * interface Person {
 *     age: number,
 *     name: string
 *  }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo1'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo2'},
 *     { age: 6, name: 'Foo3'})
 *     .distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3))
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo1' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo2' }
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 *
 * @param {string} key String key for object property lookup on each item.
 * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values based on the key specified.
 * @method distinctUntilKeyChanged
 * @owner Observable
 */
function distinctUntilKeyChanged(key, compare) {
    return distinctUntilChanged_1.distinctUntilChanged.call(this, function (x, y) {
        if (compare) {
            return compare(x[key], y[key]);
        }
        return x[key] === y[key];
    });
}
exports.distinctUntilKeyChanged = distinctUntilKeyChanged;


},{"./distinctUntilChanged":242}],244:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/* tslint:enable:max-line-length */
/**
 * Perform a side effect for every emission on the source Observable, but return
 * an Observable that is identical to the source.
 *
 * <span class="informal">Intercepts each emission on the source and runs a
 * function, but returns an output which is identical to the source as long as errors don't occur.</span>
 *
 * <img src="./img/do.png" width="100%">
 *
 * Returns a mirrored Observable of the source Observable, but modified so that
 * the provided Observer is called to perform a side effect for every value,
 * error, and completion emitted by the source. Any errors that are thrown in
 * the aforementioned Observer or handlers are safely sent down the error path
 * of the output Observable.
 *
 * This operator is useful for debugging your Observables for the correct values
 * or performing other side effects.
 *
 * Note: this is different to a `subscribe` on the Observable. If the Observable
 * returned by `do` is not subscribed, the side effects specified by the
 * Observer will never happen. `do` therefore simply spies on existing
 * execution, it does not trigger an execution to happen like `subscribe` does.
 *
 * @example <caption>Map every every click to the clientX position of that click, while also logging the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks
 *   .do(ev => console.log(ev))
 *   .map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link map}
 * @see {@link subscribe}
 *
 * @param {Observer|function} [nextOrObserver] A normal Observer object or a
 * callback for `next`.
 * @param {function} [error] Callback for errors in the source.
 * @param {function} [complete] Callback for the completion of the source.
 * @return {Observable} An Observable identical to the source, but runs the
 * specified Observer or callback(s) for each item.
 * @method do
 * @name do
 * @owner Observable
 */
function _do(nextOrObserver, error, complete) {
    return this.lift(new DoOperator(nextOrObserver, error, complete));
}
exports._do = _do;
var DoOperator = function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DoSubscriber = function (_super) {
    __extends(DoSubscriber, _super);
    function DoSubscriber(destination, nextOrObserver, error, complete) {
        _super.call(this, destination);
        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);
        safeSubscriber.syncErrorThrowable = true;
        this.add(safeSubscriber);
        this.safeSubscriber = safeSubscriber;
    }
    DoSubscriber.prototype._next = function (value) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.next(value);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        } else {
            this.destination.next(value);
        }
    };
    DoSubscriber.prototype._error = function (err) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.error(err);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        } else {
            this.destination.error(err);
        }
    };
    DoSubscriber.prototype._complete = function () {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.complete();
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        } else {
            this.destination.complete();
        }
    };
    return DoSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":186}],245:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/* tslint:enable:max-line-length */
/**
 * Filter items emitted by the source Observable by only emitting those that
 * satisfy a specified predicate.
 *
 * <span class="informal">Like
 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
 * it only emits a value from the source if it passes a criterion function.</span>
 *
 * <img src="./img/filter.png" width="100%">
 *
 * Similar to the well-known `Array.prototype.filter` method, this operator
 * takes values from the source Observable, passes them through a `predicate`
 * function and only emits those values that yielded `true`.
 *
 * @example <caption>Emit only click events whose target was a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
 * clicksOnDivs.subscribe(x => console.log(x));
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 * @see {@link ignoreElements}
 * @see {@link partition}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted, if `false` the value is not passed to the output
 * Observable. The `index` parameter is the number `i` for the i-th source
 * emission that has happened since the subscription, starting from the number
 * `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of values from the source that were
 * allowed by the `predicate` function.
 * @method filter
 * @owner Observable
 */
function filter(predicate, thisArg) {
    return this.lift(new FilterOperator(predicate, thisArg));
}
exports.filter = filter;
var FilterOperator = function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FilterSubscriber = function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.count = 0;
        this.predicate = predicate;
    }
    // the try catch block below is left specifically for
    // optimization and perf reasons. a tryCatcher is not necessary here.
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":186}],246:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * <img src="./img/map.png" width="100%">
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * @example <caption>Map every click to the clientX position of that click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks.map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link mapTo}
 * @see {@link pluck}
 *
 * @param {function(value: T, index: number): R} project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return {Observable<R>} An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
function map(project, thisArg) {
    if (typeof project !== 'function') {
        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
    }
    return this.lift(new MapOperator(project, thisArg));
}
exports.map = map;
var MapOperator = function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}();
exports.MapOperator = MapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapSubscriber = function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        _super.call(this, destination);
        this.project = project;
        this.count = 0;
        this.thisArg = thisArg || this;
    }
    // NOTE: This looks unoptimized, but it's actually purposefully NOT
    // using try/catch optimizations.
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":186}],247:[function(require,module,exports){
"use strict";

var Observable_1 = require('../Observable');
var ArrayObservable_1 = require('../observable/ArrayObservable');
var mergeAll_1 = require('./mergeAll');
var isScheduler_1 = require('../util/isScheduler');
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which concurrently emits all values from every
 * given input Observable.
 *
 * <span class="informal">Flattens multiple Observables together by blending
 * their values into one Observable.</span>
 *
 * <img src="./img/merge.png" width="100%">
 *
 * `merge` subscribes to each given input Observable (either the source or an
 * Observable given as argument), and simply forwards (without doing any
 * transformation) all the values from all the input Observables to the output
 * Observable. The output Observable only completes once all input Observables
 * have completed. Any error delivered by an input Observable will be immediately
 * emitted on the output Observable.
 *
 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var clicksOrTimer = clicks.merge(timer);
 * clicksOrTimer.subscribe(x => console.log(x));
 *
 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var concurrent = 2; // the argument
 * var merged = timer1.merge(timer2, timer3, concurrent);
 * merged.subscribe(x => console.log(x));
 *
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 *
 * @param {ObservableInput} other An input Observable to merge with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
 * concurrency of input Observables.
 * @return {Observable} An Observable that emits items that are the result of
 * every input Observable.
 * @method merge
 * @owner Observable
 */
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return this.lift.call(mergeStatic.apply(void 0, [this].concat(observables)));
}
exports.merge = merge;
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which concurrently emits all values from every
 * given input Observable.
 *
 * <span class="informal">Flattens multiple Observables together by blending
 * their values into one Observable.</span>
 *
 * <img src="./img/merge.png" width="100%">
 *
 * `merge` subscribes to each given input Observable (as arguments), and simply
 * forwards (without doing any transformation) all the values from all the input
 * Observables to the output Observable. The output Observable only completes
 * once all input Observables have completed. Any error delivered by an input
 * Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var clicksOrTimer = Rx.Observable.merge(clicks, timer);
 * clicksOrTimer.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // timer will emit ascending values, one every second(1000ms) to console
 * // clicks logs MouseEvents to console everytime the "document" is clicked
 * // Since the two streams are merged you see these happening
 * // as they occur.
 *
 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var concurrent = 2; // the argument
 * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);
 * merged.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // - First timer1 and timer2 will run concurrently
 * // - timer1 will emit a value every 1000ms for 10 iterations
 * // - timer2 will emit a value every 2000ms for 6 iterations
 * // - after timer1 hits it's max iteration, timer2 will
 * //   continue, and timer3 will start to run concurrently with timer2
 * // - when timer2 hits it's max iteration it terminates, and
 * //   timer3 will continue to emit a value every 500ms until it is complete
 *
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 *
 * @param {...ObservableInput} observables Input Observables to merge together.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
 * concurrency of input Observables.
 * @return {Observable} an Observable that emits items that are the result of
 * every input Observable.
 * @static true
 * @name merge
 * @owner Observable
 */
function mergeStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (isScheduler_1.isScheduler(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    } else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(concurrent));
}
exports.mergeStatic = mergeStatic;


},{"../Observable":180,"../observable/ArrayObservable":217,"../util/isScheduler":281,"./mergeAll":248}],248:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Converts a higher-order Observable into a first-order Observable which
 * concurrently delivers all values that are emitted on the inner Observables.
 *
 * <span class="informal">Flattens an Observable-of-Observables.</span>
 *
 * <img src="./img/mergeAll.png" width="100%">
 *
 * `mergeAll` subscribes to an Observable that emits Observables, also known as
 * a higher-order Observable. Each time it observes one of these emitted inner
 * Observables, it subscribes to that and delivers all the values from the
 * inner Observable on the output Observable. The output Observable only
 * completes once all inner Observables have completed. Any error delivered by
 * a inner Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var firstOrder = higherOrder.mergeAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
 * var firstOrder = higherOrder.mergeAll(2);
 * firstOrder.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link exhaust}
 * @see {@link merge}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits values coming from all the
 * inner Observables emitted by the source Observable.
 * @method mergeAll
 * @owner Observable
 */
function mergeAll(concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    return this.lift(new MergeAllOperator(concurrent));
}
exports.mergeAll = mergeAll;
var MergeAllOperator = function () {
    function MergeAllOperator(concurrent) {
        this.concurrent = concurrent;
    }
    MergeAllOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeAllSubscriber(observer, this.concurrent));
    };
    return MergeAllOperator;
}();
exports.MergeAllOperator = MergeAllOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeAllSubscriber = function (_super) {
    __extends(MergeAllSubscriber, _super);
    function MergeAllSubscriber(destination, concurrent) {
        _super.call(this, destination);
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
    }
    MergeAllSubscriber.prototype._next = function (observable) {
        if (this.active < this.concurrent) {
            this.active++;
            this.add(subscribeToResult_1.subscribeToResult(this, observable));
        } else {
            this.buffer.push(observable);
        }
    };
    MergeAllSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        } else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeAllSubscriber;
}(OuterSubscriber_1.OuterSubscriber);
exports.MergeAllSubscriber = MergeAllSubscriber;


},{"../OuterSubscriber":182,"../util/subscribeToResult":284}],249:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var subscribeToResult_1 = require('../util/subscribeToResult');
var OuterSubscriber_1 = require('../OuterSubscriber');
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link mergeAll}.</span>
 *
 * <img src="./img/mergeMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an Observable, and then merging those resulting Observables and
 * emitting the results of this merger.
 *
 * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
 * var letters = Rx.Observable.of('a', 'b', 'c');
 * var result = letters.mergeMap(x =>
 *   Rx.Observable.interval(1000).map(i => x+i)
 * );
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // a0
 * // b0
 * // c0
 * // a1
 * // b1
 * // c1
 * // continues to list a,b,c with respective ascending integers
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and merging the results of the Observables obtained
 * from this transformation.
 * @method mergeMap
 * @owner Observable
 */
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
        resultSelector = null;
    }
    return this.lift(new MergeMapOperator(project, resultSelector, concurrent));
}
exports.mergeMap = mergeMap;
var MergeMapOperator = function () {
    function MergeMapOperator(project, resultSelector, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));
    };
    return MergeMapOperator;
}();
exports.MergeMapOperator = MergeMapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeMapSubscriber = function (_super) {
    __extends(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        } else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result, value, index);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } else {
            this.destination.next(innerValue);
        }
    };
    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        } else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber);
exports.MergeMapSubscriber = MergeMapSubscriber;


},{"../OuterSubscriber":182,"../util/subscribeToResult":284}],250:[function(require,module,exports){
arguments[4][143][0].apply(exports,arguments)
},{"../observable/ConnectableObservable":218,"dup":143}],251:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var Notification_1 = require('../Notification');
/**
 * @see {@link Notification}
 *
 * @param scheduler
 * @param delay
 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
 * @method observeOn
 * @owner Observable
 */
function observeOn(scheduler, delay) {
    if (delay === void 0) {
        delay = 0;
    }
    return this.lift(new ObserveOnOperator(scheduler, delay));
}
exports.observeOn = observeOn;
var ObserveOnOperator = function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}();
exports.ObserveOnOperator = ObserveOnOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ObserveOnSubscriber = function (_super) {
    __extends(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        _super.call(this, destination);
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification,
            destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification_1.Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification_1.Notification.createError(err));
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification_1.Notification.createComplete());
    };
    return ObserveOnSubscriber;
}(Subscriber_1.Subscriber);
exports.ObserveOnSubscriber = ObserveOnSubscriber;
var ObserveOnMessage = function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}();
exports.ObserveOnMessage = ObserveOnMessage;


},{"../Notification":179,"../Subscriber":186}],252:[function(require,module,exports){
"use strict";

var not_1 = require('../util/not');
var filter_1 = require('./filter');
/**
 * Splits the source Observable into two, one with values that satisfy a
 * predicate, and another with values that don't satisfy the predicate.
 *
 * <span class="informal">It's like {@link filter}, but returns two Observables:
 * one like the output of {@link filter}, and the other with values that did not
 * pass the condition.</span>
 *
 * <img src="./img/partition.png" width="100%">
 *
 * `partition` outputs an array with two Observables that partition the values
 * from the source Observable through the given `predicate` function. The first
 * Observable in that array emits source values for which the predicate argument
 * returns true. The second Observable emits source values for which the
 * predicate returns false. The first behaves like {@link filter} and the second
 * behaves like {@link filter} with the predicate negated.
 *
 * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');
 * var clicksOnDivs = parts[0];
 * var clicksElsewhere = parts[1];
 * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));
 * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));
 *
 * @see {@link filter}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted on the first Observable in the returned array, if
 * `false` the value is emitted on the second Observable in the array. The
 * `index` parameter is the number `i` for the i-th source emission that has
 * happened since the subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {[Observable<T>, Observable<T>]} An array with two Observables: one
 * with values that passed the predicate, and another with values that did not
 * pass the predicate.
 * @method partition
 * @owner Observable
 */
function partition(predicate, thisArg) {
    return [filter_1.filter.call(this, predicate, thisArg), filter_1.filter.call(this, not_1.not(predicate, thisArg))];
}
exports.partition = partition;


},{"../util/not":282,"./filter":245}],253:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = require('../Subject');
var tryCatch_1 = require('../util/tryCatch');
var errorObject_1 = require('../util/errorObject');
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable
 * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.
 * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child
 * subscription. Otherwise this method will resubscribe to the source Observable.
 *
 * <img src="./img/retryWhen.png" width="100%">
 *
 * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a
 * user can `complete` or `error`, aborting the retry.
 * @return {Observable} The source Observable modified with retry logic.
 * @method retryWhen
 * @owner Observable
 */
function retryWhen(notifier) {
    return this.lift(new RetryWhenOperator(notifier, this));
}
exports.retryWhen = retryWhen;
var RetryWhenOperator = function () {
    function RetryWhenOperator(notifier, source) {
        this.notifier = notifier;
        this.source = source;
    }
    RetryWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
    };
    return RetryWhenOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RetryWhenSubscriber = function (_super) {
    __extends(RetryWhenSubscriber, _super);
    function RetryWhenSubscriber(destination, notifier, source) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.source = source;
    }
    RetryWhenSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var errors = this.errors;
            var retries = this.retries;
            var retriesSubscription = this.retriesSubscription;
            if (!retries) {
                errors = new Subject_1.Subject();
                retries = tryCatch_1.tryCatch(this.notifier)(errors);
                if (retries === errorObject_1.errorObject) {
                    return _super.prototype.error.call(this, errorObject_1.errorObject.e);
                }
                retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);
            } else {
                this.errors = null;
                this.retriesSubscription = null;
            }
            this._unsubscribeAndRecycle();
            this.errors = errors;
            this.retries = retries;
            this.retriesSubscription = retriesSubscription;
            errors.next(err);
        }
    };
    RetryWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this,
            errors = _a.errors,
            retriesSubscription = _a.retriesSubscription;
        if (errors) {
            errors.unsubscribe();
            this.errors = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this,
            errors = _a.errors,
            retries = _a.retries,
            retriesSubscription = _a.retriesSubscription;
        this.errors = null;
        this.retries = null;
        this.retriesSubscription = null;
        this._unsubscribeAndRecycle();
        this.errors = errors;
        this.retries = retries;
        this.retriesSubscription = retriesSubscription;
        this.source.subscribe(this);
    };
    return RetryWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":182,"../Subject":184,"../util/errorObject":273,"../util/subscribeToResult":284,"../util/tryCatch":286}],254:[function(require,module,exports){
arguments[4][145][0].apply(exports,arguments)
},{"../Subject":184,"./multicast":250,"dup":145}],255:[function(require,module,exports){
arguments[4][146][0].apply(exports,arguments)
},{"../observable/ArrayObservable":217,"../observable/EmptyObservable":220,"../observable/ScalarObservable":226,"../util/isScheduler":281,"./concat":238,"dup":146}],256:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Converts a higher-order Observable into a first-order Observable by
 * subscribing to only the most recently emitted of those inner Observables.
 *
 * <span class="informal">Flattens an Observable-of-Observables by dropping the
 * previous inner Observable once a new one appears.</span>
 *
 * <img src="./img/switch.png" width="100%">
 *
 * `switch` subscribes to an Observable that emits Observables, also known as a
 * higher-order Observable. Each time it observes one of these emitted inner
 * Observables, the output Observable subscribes to the inner Observable and
 * begins emitting the items emitted by that. So far, it behaves
 * like {@link mergeAll}. However, when a new inner Observable is emitted,
 * `switch` unsubscribes from the earlier-emitted inner Observable and
 * subscribes to the new inner Observable and begins emitting items from it. It
 * continues to behave like this for subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * // Each click event is mapped to an Observable that ticks every second
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var switched = higherOrder.switch();
 * // The outcome is that `switched` is essentially a timer that restarts
 * // on every click. The interval Observables from older clicks do not merge
 * // with the current interval Observable.
 * switched.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link exhaust}
 * @see {@link mergeAll}
 * @see {@link switchMap}
 * @see {@link switchMapTo}
 * @see {@link zipAll}
 *
 * @return {Observable<T>} An Observable that emits the items emitted by the
 * Observable most recently emitted by the source Observable.
 * @method switch
 * @name switch
 * @owner Observable
 */
function _switch() {
    return this.lift(new SwitchOperator());
}
exports._switch = _switch;
var SwitchOperator = function () {
    function SwitchOperator() {}
    SwitchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchSubscriber(subscriber));
    };
    return SwitchOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchSubscriber = function (_super) {
    __extends(SwitchSubscriber, _super);
    function SwitchSubscriber(destination) {
        _super.call(this, destination);
        this.active = 0;
        this.hasCompleted = false;
    }
    SwitchSubscriber.prototype._next = function (value) {
        this.unsubscribeInner();
        this.active++;
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, value));
    };
    SwitchSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    SwitchSubscriber.prototype.unsubscribeInner = function () {
        this.active = this.active > 0 ? this.active - 1 : 0;
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
            this.remove(innerSubscription);
        }
    };
    SwitchSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    SwitchSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    SwitchSubscriber.prototype.notifyComplete = function () {
        this.unsubscribeInner();
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    return SwitchSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":182,"../util/subscribeToResult":284}],257:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, emitting values only from the most recently projected Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link switch}.</span>
 *
 * <img src="./img/switchMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each time it observes one of these
 * inner Observables, the output Observable begins emitting the items emitted by
 * that inner Observable. When a new inner Observable is emitted, `switchMap`
 * stops emitting items from the earlier-emitted inner Observable and begins
 * emitting items from the new one. It continues to behave like this for
 * subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switch}
 * @see {@link switchMapTo}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking only the values from the most recently
 * projected inner Observable.
 * @method switchMap
 * @owner Observable
 */
function switchMap(project, resultSelector) {
    return this.lift(new SwitchMapOperator(project, resultSelector));
}
exports.switchMap = switchMap;
var SwitchMapOperator = function () {
    function SwitchMapOperator(project, resultSelector) {
        this.project = project;
        this.resultSelector = resultSelector;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));
    };
    return SwitchMapOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchMapSubscriber = function (_super) {
    __extends(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project, resultSelector) {
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.index = 0;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        } catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result, value, index);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);
        } else {
            this.destination.next(innerValue);
        }
    };
    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return SwitchMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":182,"../util/subscribeToResult":284}],258:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var ArgumentOutOfRangeError_1 = require('../util/ArgumentOutOfRangeError');
var EmptyObservable_1 = require('../observable/EmptyObservable');
/**
 * Emits only the first `count` values emitted by the source Observable.
 *
 * <span class="informal">Takes the first `count` values from the source, then
 * completes.</span>
 *
 * <img src="./img/take.png" width="100%">
 *
 * `take` returns an Observable that emits only the first `count` values emitted
 * by the source Observable. If the source emits fewer than `count` values then
 * all of its values are emitted. After that, it completes, regardless if the
 * source completes.
 *
 * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>
 * var interval = Rx.Observable.interval(1000);
 * var five = interval.take(5);
 * five.subscribe(x => console.log(x));
 *
 * @see {@link takeLast}
 * @see {@link takeUntil}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
 *
 * @param {number} count The maximum number of `next` values to emit.
 * @return {Observable<T>} An Observable that emits only the first `count`
 * values emitted by the source Observable, or all of the values from the source
 * if the source emits fewer than `count` values.
 * @method take
 * @owner Observable
 */
function take(count) {
    if (count === 0) {
        return new EmptyObservable_1.EmptyObservable();
    } else {
        return this.lift(new TakeOperator(count));
    }
}
exports.take = take;
var TakeOperator = function () {
    function TakeOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
        }
    }
    TakeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeSubscriber = function (_super) {
    __extends(TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.count = 0;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":186,"../observable/EmptyObservable":220,"../util/ArgumentOutOfRangeError":270}],259:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Emits the values emitted by the source Observable until a `notifier`
 * Observable emits a value.
 *
 * <span class="informal">Lets values pass until a second Observable,
 * `notifier`, emits something. Then, it completes.</span>
 *
 * <img src="./img/takeUntil.png" width="100%">
 *
 * `takeUntil` subscribes and begins mirroring the source Observable. It also
 * monitors a second Observable, `notifier` that you provide. If the `notifier`
 * emits a value or a complete notification, the output Observable stops
 * mirroring the source Observable and completes.
 *
 * @example <caption>Tick every second until the first click happens</caption>
 * var interval = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = interval.takeUntil(clicks);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeLast}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @param {Observable} notifier The Observable whose first emitted value will
 * cause the output Observable of `takeUntil` to stop emitting values from the
 * source Observable.
 * @return {Observable<T>} An Observable that emits the values from the source
 * Observable until such time as `notifier` emits its first value.
 * @method takeUntil
 * @owner Observable
 */
function takeUntil(notifier) {
    return this.lift(new TakeUntilOperator(notifier));
}
exports.takeUntil = takeUntil;
var TakeUntilOperator = function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeUntilSubscriber(subscriber, this.notifier));
    };
    return TakeUntilOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeUntilSubscriber = function (_super) {
    __extends(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination, notifier) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
    }
    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    return TakeUntilSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":182,"../util/subscribeToResult":284}],260:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var async_1 = require('../scheduler/async');
/**
 * Emits a value from the source Observable, then ignores subsequent source
 * values for `duration` milliseconds, then repeats this process.
 *
 * <span class="informal">Lets a value pass, then ignores source values for the
 * next `duration` milliseconds.</span>
 *
 * <img src="./img/throttleTime.png" width="100%">
 *
 * `throttleTime` emits the source Observable values on the output Observable
 * when its internal timer is disabled, and ignores source values when the timer
 * is enabled. Initially, the timer is disabled. As soon as the first source
 * value arrives, it is forwarded to the output Observable, and then the timer
 * is enabled. After `duration` milliseconds (or the time unit determined
 * internally by the optional `scheduler`) has passed, the timer is disabled,
 * and this process repeats for the next source value. Optionally takes a
 * {@link IScheduler} for managing timers.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.throttleTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounceTime}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttle}
 *
 * @param {number} duration Time to wait before emitting another value after
 * emitting the last value, measured in milliseconds or the time unit determined
 * internally by the optional `scheduler`.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the sampling.
 * @return {Observable<T>} An Observable that performs the throttle operation to
 * limit the rate of emissions from the source.
 * @method throttleTime
 * @owner Observable
 */
function throttleTime(duration, scheduler) {
    if (scheduler === void 0) {
        scheduler = async_1.async;
    }
    return this.lift(new ThrottleTimeOperator(duration, scheduler));
}
exports.throttleTime = throttleTime;
var ThrottleTimeOperator = function () {
    function ThrottleTimeOperator(duration, scheduler) {
        this.duration = duration;
        this.scheduler = scheduler;
    }
    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler));
    };
    return ThrottleTimeOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ThrottleTimeSubscriber = function (_super) {
    __extends(ThrottleTimeSubscriber, _super);
    function ThrottleTimeSubscriber(destination, duration, scheduler) {
        _super.call(this, destination);
        this.duration = duration;
        this.scheduler = scheduler;
    }
    ThrottleTimeSubscriber.prototype._next = function (value) {
        if (!this.throttled) {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
            this.destination.next(value);
        }
    };
    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
        var throttled = this.throttled;
        if (throttled) {
            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
        }
    };
    return ThrottleTimeSubscriber;
}(Subscriber_1.Subscriber);
function dispatchNext(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
}


},{"../Subscriber":186,"../scheduler/async":266}],261:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/* tslint:enable:max-line-length */
/**
 * Combines the source Observable with other Observables to create an Observable
 * whose values are calculated from the latest values of each, only when the
 * source emits.
 *
 * <span class="informal">Whenever the source Observable emits a value, it
 * computes a formula using that value plus the latest values from other input
 * Observables, then emits the output of that formula.</span>
 *
 * <img src="./img/withLatestFrom.png" width="100%">
 *
 * `withLatestFrom` combines each value from the source Observable (the
 * instance) with the latest values from the other input Observables only when
 * the source emits a value, optionally using a `project` function to determine
 * the value to be emitted on the output Observable. All input Observables must
 * emit at least one value before the output Observable will emit a value.
 *
 * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var result = clicks.withLatestFrom(timer);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link combineLatest}
 *
 * @param {ObservableInput} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Function} [project] Projection function for combining values
 * together. Receives all values in order of the Observables passed, where the
 * first parameter is a value from the source Observable. (e.g.
 * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not
 * passed, arrays will be emitted on the output Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @method withLatestFrom
 * @owner Observable
 */
function withLatestFrom() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
    }
    var project;
    if (typeof args[args.length - 1] === 'function') {
        project = args.pop();
    }
    var observables = args;
    return this.lift(new WithLatestFromOperator(observables, project));
}
exports.withLatestFrom = withLatestFrom;
var WithLatestFromOperator = function () {
    function WithLatestFromOperator(observables, project) {
        this.observables = observables;
        this.project = project;
    }
    WithLatestFromOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
    };
    return WithLatestFromOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WithLatestFromSubscriber = function (_super) {
    __extends(WithLatestFromSubscriber, _super);
    function WithLatestFromSubscriber(destination, observables, project) {
        _super.call(this, destination);
        this.observables = observables;
        this.project = project;
        this.toRespond = [];
        var len = observables.length;
        this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
        }
    }
    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };
    WithLatestFromSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    WithLatestFromSubscriber.prototype._next = function (value) {
        if (this.toRespond.length === 0) {
            var args = [value].concat(this.values);
            if (this.project) {
                this._tryProject(args);
            } else {
                this.destination.next(args);
            }
        }
    };
    WithLatestFromSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return WithLatestFromSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":182,"../util/subscribeToResult":284}],262:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ArrayObservable_1 = require('../observable/ArrayObservable');
var isArray_1 = require('../util/isArray');
var Subscriber_1 = require('../Subscriber');
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
var iterator_1 = require('../symbol/iterator');
/* tslint:enable:max-line-length */
/**
 * @param observables
 * @return {Observable<R>}
 * @method zip
 * @owner Observable
 */
function zipProto() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return this.lift.call(zipStatic.apply(void 0, [this].concat(observables)));
}
exports.zipProto = zipProto;
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each
 * of its input Observables.
 *
 * If the latest parameter is a function, this function is used to compute the created value from the input values.
 * Otherwise, an array of the input values is returned.
 *
 * @example <caption>Combine age and name from different sources</caption>
 *
 * let age$ = Observable.of<number>(27, 25, 29);
 * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');
 * let isDev$ = Observable.of<boolean>(true, true, false);
 *
 * Observable
 *     .zip(age$,
 *          name$,
 *          isDev$,
 *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))
 *     .subscribe(x => console.log(x));
 *
 * // outputs
 * // { age: 27, name: 'Foo', isDev: true }
 * // { age: 25, name: 'Bar', isDev: true }
 * // { age: 29, name: 'Beer', isDev: false }
 *
 * @param observables
 * @return {Observable<R>}
 * @static true
 * @name zip
 * @owner Observable
 */
function zipStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = observables[observables.length - 1];
    if (typeof project === 'function') {
        observables.pop();
    }
    return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));
}
exports.zipStatic = zipStatic;
var ZipOperator = function () {
    function ZipOperator(project) {
        this.project = project;
    }
    ZipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.project));
    };
    return ZipOperator;
}();
exports.ZipOperator = ZipOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipSubscriber = function (_super) {
    __extends(ZipSubscriber, _super);
    function ZipSubscriber(destination, project, values) {
        if (values === void 0) {
            values = Object.create(null);
        }
        _super.call(this, destination);
        this.iterators = [];
        this.active = 0;
        this.project = typeof project === 'function' ? project : null;
        this.values = values;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (isArray_1.isArray(value)) {
            iterators.push(new StaticArrayIterator(value));
        } else if (typeof value[iterator_1.iterator] === 'function') {
            iterators.push(new StaticIterator(value[iterator_1.iterator]()));
        } else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        if (len === 0) {
            this.destination.complete();
            return;
        }
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (iterator.stillUnsubscribed) {
                this.add(iterator.subscribe(iterator, i));
            } else {
                this.active--; // not an observable
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        // abort if not all of them have values
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            var result = iterator.next();
            // check to see if it's completed now that you've gotten
            // the next value.
            if (iterator.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.project) {
            this._tryProject(args);
        } else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(Subscriber_1.Subscriber);
exports.ZipSubscriber = ZipSubscriber;
var StaticIterator = function () {
    function StaticIterator(iterator) {
        this.iterator = iterator;
        this.nextResult = iterator.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return nextResult && nextResult.done;
    };
    return StaticIterator;
}();
var StaticArrayIterator = function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[iterator_1.iterator] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipBufferIterator = function (_super) {
    __extends(ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        _super.call(this, destination);
        this.parent = parent;
        this.observable = observable;
        this.stillUnsubscribed = true;
        this.buffer = [];
        this.isComplete = false;
    }
    ZipBufferIterator.prototype[iterator_1.iterator] = function () {
        return this;
    };
    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next
    //    this is legit because `next()` will never be called by a subscription in this case.
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        } else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        } else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function (value, index) {
        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);
    };
    return ZipBufferIterator;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":182,"../Subscriber":186,"../observable/ArrayObservable":217,"../symbol/iterator":267,"../util/isArray":274,"../util/subscribeToResult":284}],263:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = require('../Subscription');
/**
 * A unit of work to be executed in a {@link Scheduler}. An action is typically
 * created from within a Scheduler and an RxJS user does not need to concern
 * themselves about creating and manipulating an Action.
 *
 * ```ts
 * class Action<T> extends Subscription {
 *   new (scheduler: Scheduler, work: (state?: T) => void);
 *   schedule(state?: T, delay: number = 0): Subscription;
 * }
 * ```
 *
 * @class Action<T>
 */
var Action = function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        _super.call(this);
    }
    /**
     * Schedules this action on its parent Scheduler for execution. May be passed
     * some context object, `state`. May happen at some point in the future,
     * according to the `delay` parameter, if specified.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler.
     * @return {void}
     */
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return this;
    };
    return Action;
}(Subscription_1.Subscription);
exports.Action = Action;


},{"../Subscription":187}],264:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = require('../util/root');
var Action_1 = require('./Action');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AsyncAction = function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
        this.pending = false;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (this.closed) {
            return this;
        }
        // Always replace the current state with the new state.
        this.state = state;
        // Set the pending flag indicating that this action has been scheduled, or
        // has recursively rescheduled itself.
        this.pending = true;
        var id = this.id;
        var scheduler = this.scheduler;
        //
        // Important implementation note:
        //
        // Actions only execute once by default, unless rescheduled from within the
        // scheduled callback. This allows us to implement single and repeat
        // actions via the same code path, without adding API surface area, as well
        // as mimic traditional recursion but across asynchronous boundaries.
        //
        // However, JS runtimes and timers distinguish between intervals achieved by
        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
        // serial `setTimeout` calls can be individually delayed, which delays
        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
        // guarantee the interval callback will be invoked more precisely to the
        // interval period, regardless of load.
        //
        // Therefore, we use `setInterval` to schedule single and repeat actions.
        // If the action reschedules itself with the same delay, the interval is not
        // canceled. If the action doesn't reschedule, or reschedules with a
        // different delay, the interval will be canceled after scheduled callback
        // execution.
        //
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.delay = delay;
        // If this action has already an async Id, don't request a new one.
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        // If this action is rescheduled with the same delay time, don't clear the interval id.
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        // Otherwise, if the action's delay time is different from the current delay,
        // or the action has been rescheduled before it's executed, clear the interval id
        return root_1.root.clearInterval(id) && undefined || undefined;
    };
    /**
     * Immediately executes this action and the `work` it contains.
     * @return {any}
     */
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        } else if (this.pending === false && this.id != null) {
            // Dequeue if the action didn't reschedule itself. Don't call
            // unsubscribe(), because the action could reschedule later.
            // For example:
            // ```
            // scheduler.schedule(function doWork(counter) {
            //   /* ... I'm a busy worker bee ... */
            //   var originalAction = this;
            //   /* wait 100ms before rescheduling the action */
            //   setTimeout(function () {
            //     originalAction.schedule(counter + 1);
            //   }, 100);
            // }, 1000);
            // ```
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        } catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.delay = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
    };
    return AsyncAction;
}(Action_1.Action);
exports.AsyncAction = AsyncAction;


},{"../util/root":283,"./Action":263}],265:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Scheduler_1 = require('../Scheduler');
var AsyncScheduler = function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler() {
        _super.apply(this, arguments);
        this.actions = [];
        /**
         * A flag to indicate whether the Scheduler is currently executing a batch of
         * queued actions.
         * @type {boolean}
         */
        this.active = false;
        /**
         * An internal ID used to track the latest asynchronous task such as those
         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
         * others.
         * @type {any}
         */
        this.scheduled = undefined;
    }
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift()); // exhaust the scheduler queue
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler_1.Scheduler);
exports.AsyncScheduler = AsyncScheduler;


},{"../Scheduler":183}],266:[function(require,module,exports){
arguments[4][153][0].apply(exports,arguments)
},{"./AsyncAction":264,"./AsyncScheduler":265,"dup":153}],267:[function(require,module,exports){
"use strict";

var root_1 = require('../util/root');
function symbolIteratorPonyfill(root) {
    var _Symbol = root.Symbol;
    if (typeof _Symbol === 'function') {
        if (!_Symbol.iterator) {
            _Symbol.iterator = _Symbol('iterator polyfill');
        }
        return _Symbol.iterator;
    } else {
        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
        var Set_1 = root.Set;
        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {
            return '@@iterator';
        }
        var Map_1 = root.Map;
        // required for compatability with es6-shim
        if (Map_1) {
            var keys = Object.getOwnPropertyNames(Map_1.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {
                    return key;
                }
            }
        }
        return '@@iterator';
    }
}
exports.symbolIteratorPonyfill = symbolIteratorPonyfill;
exports.iterator = symbolIteratorPonyfill(root_1.root);
/**
 * @deprecated use iterator instead
 */
exports.$$iterator = exports.iterator;


},{"../util/root":283}],268:[function(require,module,exports){
"use strict";

var root_1 = require('../util/root');
function getSymbolObservable(context) {
    var $$observable;
    var _Symbol = context.Symbol;
    if (typeof _Symbol === 'function') {
        if (_Symbol.observable) {
            $$observable = _Symbol.observable;
        } else {
            $$observable = _Symbol('observable');
            _Symbol.observable = $$observable;
        }
    } else {
        $$observable = '@@observable';
    }
    return $$observable;
}
exports.getSymbolObservable = getSymbolObservable;
exports.observable = getSymbolObservable(root_1.root);
/**
 * @deprecated use observable instead
 */
exports.$$observable = exports.observable;


},{"../util/root":283}],269:[function(require,module,exports){
"use strict";

var root_1 = require('../util/root');
var _Symbol = root_1.root.Symbol;
exports.rxSubscriber = typeof _Symbol === 'function' && typeof _Symbol.for === 'function' ? _Symbol.for('rxSubscriber') : '@@rxSubscriber';
/**
 * @deprecated use rxSubscriber instead
 */
exports.$$rxSubscriber = exports.rxSubscriber;


},{"../util/root":283}],270:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an element was queried at a certain index of an
 * Observable, but no such index or position exists in that sequence.
 *
 * @see {@link elementAt}
 * @see {@link take}
 * @see {@link takeLast}
 *
 * @class ArgumentOutOfRangeError
 */
var ArgumentOutOfRangeError = function (_super) {
    __extends(ArgumentOutOfRangeError, _super);
    function ArgumentOutOfRangeError() {
        var err = _super.call(this, 'argument out of range');
        this.name = err.name = 'ArgumentOutOfRangeError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ArgumentOutOfRangeError;
}(Error);
exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;


},{}],271:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an action is invalid because the object has been
 * unsubscribed.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 *
 * @class ObjectUnsubscribedError
 */
var ObjectUnsubscribedError = function (_super) {
    __extends(ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
        var err = _super.call(this, 'object unsubscribed');
        this.name = err.name = 'ObjectUnsubscribedError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ObjectUnsubscribedError;
}(Error);
exports.ObjectUnsubscribedError = ObjectUnsubscribedError;


},{}],272:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
var UnsubscriptionError = function (_super) {
    __extends(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        _super.call(this);
        this.errors = errors;
        var err = Error.call(this, errors ? errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) {
            return i + 1 + ") " + err.toString();
        }).join('\n  ') : '');
        this.name = err.name = 'UnsubscriptionError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return UnsubscriptionError;
}(Error);
exports.UnsubscriptionError = UnsubscriptionError;


},{}],273:[function(require,module,exports){
arguments[4][159][0].apply(exports,arguments)
},{"dup":159}],274:[function(require,module,exports){
arguments[4][160][0].apply(exports,arguments)
},{"dup":160}],275:[function(require,module,exports){
arguments[4][161][0].apply(exports,arguments)
},{"dup":161}],276:[function(require,module,exports){
arguments[4][162][0].apply(exports,arguments)
},{"dup":162}],277:[function(require,module,exports){
arguments[4][163][0].apply(exports,arguments)
},{"dup":163}],278:[function(require,module,exports){
arguments[4][164][0].apply(exports,arguments)
},{"../util/isArray":274,"dup":164}],279:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function isObject(x) {
    return x != null && (typeof x === "undefined" ? "undefined" : _typeof(x)) === 'object';
}
exports.isObject = isObject;


},{}],280:[function(require,module,exports){
arguments[4][166][0].apply(exports,arguments)
},{"dup":166}],281:[function(require,module,exports){
arguments[4][167][0].apply(exports,arguments)
},{"dup":167}],282:[function(require,module,exports){
"use strict";

function not(pred, thisArg) {
    function notPred() {
        return !notPred.pred.apply(notPred.thisArg, arguments);
    }
    notPred.pred = pred;
    notPred.thisArg = thisArg;
    return notPred;
}
exports.not = not;


},{}],283:[function(require,module,exports){
(function (global){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) == 'object' && window.window === window) {
    exports.root = window;
} else if ((typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self.self === self) {
    exports.root = self;
} else if ((typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global.global === global) {
    exports.root = global;
} else {
    // Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.
    // This is needed when used with angular/tsickle which inserts a goog.module statement.
    // Wrap in IIFE
    (function () {
        throw new Error('RxJS could not find any global context (window, self, global)');
    })();
}


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],284:[function(require,module,exports){
arguments[4][169][0].apply(exports,arguments)
},{"../InnerSubscriber":178,"../Observable":180,"../symbol/iterator":267,"../symbol/observable":268,"./isArrayLike":275,"./isObject":279,"./isPromise":280,"./root":283,"dup":169}],285:[function(require,module,exports){
arguments[4][170][0].apply(exports,arguments)
},{"../Observer":181,"../Subscriber":186,"../symbol/rxSubscriber":269,"dup":170}],286:[function(require,module,exports){
arguments[4][171][0].apply(exports,arguments)
},{"./errorObject":273,"dup":171}],287:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isExternal = isExternal;
exports.stripHash = stripHash;
exports.isHash = isHash;
exports.matches = matches;
exports.querySelectorInv = querySelectorInv;
exports.shouldLoadAnchor = shouldLoadAnchor;
exports.getScrollHeight = getScrollHeight;
exports.getScrollLeft = getScrollLeft;
exports.getScrollTop = getScrollTop;
exports.expInterval = expInterval;
exports.fragmentFromString = fragmentFromString;

var _Observable = require('rxjs/Observable');

/**
 * Checks to see if the url is external
 *
 * @param   {string}    url - url being evaluated
 * @see     http://stackoverflow.com/questions/6238351/fastest-way-to-detect-external-urls
 */
function isExternal(url) {
  var match = url.match(/^([^:\/?#]+:)?(?:\/\/([^\/?#]*))?([^?#]+)?(\?[^#]*)?(#.*)?/); // eslint-disable-line no-useless-escape

  if (typeof match[1] === 'string' && match[1].length > 0 && match[1].toLowerCase() !== window.location.protocol) {
    return true;
  }

  var port = { http: 80, https: 443 }[window.location.protocol];

  if (typeof match[2] === 'string' && match[2].length > 0 && match[2].replace(new RegExp(':(' + port + ')?$'), '') !== window.location.host) {
    return true;
  }

  return false;
}

/**
 * Strips the hash from a url and returns the new href
 *
 * @param   {string}    href - url being evaluated
 */
// Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

function stripHash(href) {
  return href.replace(/#.*/, '');
}

/**
 * Checks to see if the url is an internal hash
 *
 * @param   {string}    href - url being evaluated
 * @param   {string}    prev - previous url (optional)
 */
function isHash(href, prev) {
  var p = prev || window.location.href;

  var hasHash = href.indexOf('#') > -1;
  var samePath = stripHash(href) === stripHash(p);

  return hasHash && samePath;
}

function matches(el, selector) {
  return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);
  // if (!matches.memo) {
  //   matches.memo =
  //     el.matches ||
  //     el.matchesSelector ||
  //     el.msMatchesSelector ||
  //     el.mozMatchesSelector ||
  //     el.webkitMatchesSelector ||
  //     el.oMatchesSelector;
  // }
  // return matches.memo.call(el, selector);
}

function querySelectorInv(el, selector) {
  var curr = el;
  while (curr !== document && curr !== document.documentElement) {
    if (matches(curr, selector)) return curr;
    curr = curr.parentNode;
  }
  return null;
}

/**
 * Checks to see if we should be loading this URL
 *
 * @param   {string}    url - url being evaluated
 * @param   {string}    blacklist - jquery selector
 */
function shouldLoadAnchor(anchor, blacklist, hrefRegex) {
  var href = anchor.href;
  // URL will only be loaded if it's not an external link, hash, or
  // blacklisted
  return !isExternal(href) && !isHash(href) && !matches(anchor, blacklist) && anchor.target === '' && (hrefRegex === null || href.search(hrefRegex) !== -1);
}

function getScrollHeight() {
  var h = document.documentElement;
  var b = document.body;
  var sh = 'scrollHeight';
  return h[sh] || b[sh];
}

function getScrollLeft() {
  return window.pageXOffset || document.body.scrollLeft;
}

function getScrollTop() {
  return window.pageYOffset || document.body.scrollTop;
}

function expInterval(init, exp) {
  return _Observable.Observable.create(function (observer) {
    var n = init;
    var id = void 0;

    function next() {
      observer.next(n);
      n *= exp;
      id = setTimeout(next, n);
    }

    id = setTimeout(next, n);

    return function () {
      clearTimeout(id);
    };
  });
}

function fragmentFromString(strHTML) {
  return document.createRange().createContextualFragment(strHTML);
}

},{"rxjs/Observable":180}],288:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;_e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }return _arr;
  }return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}(); // Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

/*
eslint-disable
import/no-extraneous-dependencies,
import/no-unresolved,
import/extensions,
no-console
*/

// const JS_FEATURES = [
//   'fn/array/for-each',
//   'fn/function/bind',
//   'fn/number/constructor',
//   'fn/object/assign',
//   'fn/object/define-property',
//   'fn/object/keys',
// ];
//
// const MODERNIZR_TESTS = [
//   'customevent',
//   'documentfragment',
//   'eventlistener',
//   'history',
//   'requestanimationframe',
//   'queryselector',
// ];

var _Observable = require('rxjs/Observable');

var _Subject = require('rxjs/Subject');

require('rxjs/add/observable/defer');

require('rxjs/add/observable/from');

require('rxjs/add/observable/fromEvent');

require('rxjs/add/observable/merge');

require('rxjs/add/observable/of');

require('rxjs/add/observable/throw');

require('rxjs/add/observable/timer');

require('rxjs/add/observable/dom/ajax');

require('rxjs/add/operator/catch');

require('rxjs/add/operator/concatMap');

require('rxjs/add/operator/debounceTime');

require('rxjs/add/operator/delay');

require('rxjs/add/operator/distinctUntilKeyChanged');

require('rxjs/add/operator/do');

require('rxjs/add/operator/filter');

require('rxjs/add/operator/map');

require('rxjs/add/operator/mergeMap');

require('rxjs/add/operator/partition');

require('rxjs/add/operator/retryWhen');

require('rxjs/add/operator/share');

require('rxjs/add/operator/startWith');

require('rxjs/add/operator/switch');

require('rxjs/add/operator/switchMap');

require('rxjs/add/operator/take');

require('rxjs/add/operator/takeUntil');

require('rxjs/add/operator/throttleTime');

require('rxjs/add/operator/withLatestFrom');

require('rxjs/add/operator/zip');

var _componentCore2 = require('y-component/src/component-core');

var _componentCore3 = _interopRequireDefault(_componentCore2);

var _common = require('../common');

var _kind = require('./kind');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

_Observable.Observable.prototype.pauseWith = function pauseWith(pauser$) {
  return this.withLatestFrom(pauser$).filter(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        paused = _ref2[1];

    return paused === false;
  }).map(function (_ref3) {
    var _ref4 = _slicedToArray(_ref3, 1),
        x = _ref4[0];

    return x;
  });
};

// ~ mixin pushStateCore with componentCore { ...

exports.default = function (C) {
  return function (_componentCore) {
    _inherits(_class, _componentCore);

    function _class() {
      _classCallCheck(this, _class);

      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    _createClass(_class, [{
      key: 'getComponentName',

      // @override
      value: function getComponentName() {
        return 'y-push-state';
      }

      // @override

    }, {
      key: 'defaults',
      value: function defaults() {
        return {
          replaceIds: [],
          linkSelector: 'a[href]',
          scrollRestoration: false,
          hrefRegex: null,
          blacklist: '.no-push-state',
          duration: 0,
          noPopDuration: true
        };
      }

      // @override

    }, {
      key: 'sideEffects',
      value: function sideEffects() {
        return {};
      }

      // @override

    }, {
      key: 'startHistory',
      value: function startHistory() {
        this.checkPreCondition();
        this.setupScrollRestoration();
        this.cacheTitleElement();
        this.setupObservables();
        return this;
      }
    }, {
      key: 'checkPreCondition',
      value: function checkPreCondition() {
        if (this.replaceIds.length === 0) {
          var id = this.el.id;
          if (id) {
            console.warn('No replace ids provided. Will replace entire content of #' + id);
          } else {
            throw Error('No replace ids provided nor does this component have and id');
          }
        }
      }
    }, {
      key: 'setupScrollRestoration',
      value: function setupScrollRestoration() {
        if ('scrollRestoration' in history) {
          history.scrollRestoration = this.scrollRestoration ? 'manual' : 'auto';
        }

        this.setScrollPosition();
        window.addEventListener('beforeunload', this.updateHistoryState.bind(this));
      }
    }, {
      key: 'cacheTitleElement',
      value: function cacheTitleElement() {
        this.titleElement = document.querySelector('title') || {};
      }
    }, {
      key: 'bindPushEvents',
      value: function bindPushEvents(link$) {
        var _this2 = this;

        return this.fromEvents(link$, 'click').map(function (event) {
          return new _kind.Push(event);
        }).filter(function (kind) {
          return _this2.isPageChangeEvent(kind);
        }).do(function (_ref5) {
          var event = _ref5.event;

          _this2.updateHistoryState();
          event.preventDefault();
        });
      }
    }, {
      key: 'bindHintEvents',
      value: function bindHintEvents(link$) {
        var _this3 = this;

        return _Observable.Observable.merge(this.fromEvents(link$, 'mouseenter'), this.fromEvents(link$, 'touchstart'), this.fromEvents(link$, 'focus')).map(function (event) {
          return new _kind.Hint(event);
        }).filter(function (kind) {
          return _this3.isPageChangeAnchor(kind);
        });
      }
    }, {
      key: 'bindPopstateEvent',
      value: function bindPopstateEvent() {
        return _Observable.Observable.fromEvent(window, 'popstate').map(function (event) {
          return new _kind.Pop(event);
        }).filter(function () {
          return window.history.state != null;
        });
      }
    }, {
      key: 'linkObservable',
      value: function linkObservable() {
        return _Observable.Observable.of(this.el.querySelectorAll(this.linkSelector));
      }
    }, {
      key: 'fromEvents',
      value: function fromEvents(link$, event) {
        return link$.mergeMap(function (link) {
          return _Observable.Observable.fromEvent(link, event);
        });
      }
    }, {
      key: 'fetchPage',
      value: function fetchPage(kind) {
        var _this4 = this;

        return _Observable.Observable.ajax(this.hrefToAjax(kind)).map(function (_ref6) {
          var response = _ref6.response;
          return Object.assign(kind, { response: response });
        }).catch(function (error) {
          return _this4.recoverIfResponse(kind, error);
        }).retryWhen(function () {
          return _Observable.Observable.merge(_Observable.Observable.fromEvent(window, 'online'), (0, _common.expInterval)(1000, 2)).do(_this4.onRetry.bind(_this4, kind));
        });
      }
    }, {
      key: 'hrefToAjax',
      value: function hrefToAjax(_ref7) {
        var href = _ref7.href;

        return {
          method: 'GET',
          url: href,
          responseType: 'text'
        };
      }
    }, {
      key: 'recoverIfResponse',
      value: function recoverIfResponse(kind, error) {
        var status = error.status,
            xhr = error.xhr;

        if (xhr && status && status > 400) {
          // Recover with error page returned from server.
          // NOTE: This assumes error page contains the same ids as the other pages...
          return _Observable.Observable.of(Object.assign(kind, { response: xhr.response }));
        }

        // else
        this.onError(Object.assign(kind, error));
        return _Observable.Observable.throw(error);
      }
    }, {
      key: 'setupObservables',
      value: function setupObservables() {
        var _this5 = this;

        // See `renewEventListeners`
        // TODO: Possible without subjects?
        this.push$$ = new _Subject.Subject();
        this.hint$$ = new _Subject.Subject();

        var push$ = this.push$$.switch
        // TODO: This prevents a whole class of concurrency bugs,
        // This is not an issue for fast animations (and prevents accidential double tapping)
        // Ideally the UI is fully repsonsive at all times though..
        // Note that spamming the back/forward button is still possible (only affects `push$`)
        ().throttleTime(this.duration + 100);

        var pop$ = this.bindPopstateEvent();

        // Definitive page change (i.e. either push or pop event)
        this.page$ = _Observable.Observable.merge(push$, pop$).share();

        // We don't want to prefetch (i.e. use bandwidth) for a _probabilistic_ page load,
        // while a _definitive_ page load is going on => `pauser$` stream.
        // Needs to be deferred b/c of "cyclical" dependency.
        var pauser$ = _Observable.Observable.defer(function () {
          return _Observable.Observable.merge(
          // A page change event means we want to pause prefetching
          _this5.page$.map(function () {
            return true;
          }),
          // A render complete event means we want to resume prefetching
          _this5.render$.map(function () {
            return false;
          }
          // Start with prefetching
          )).startWith(false);
        });

        // The stream of hint (prefetch) events, possibly paused.
        this.hint$ = this.hint$$.switch().pauseWith(pauser$);

        // The stream of (pre-)fetch events.
        // Includes definitive page change events do deal with unexpected page changes.
        this.prefetch$ = _Observable.Observable.merge(this.hint$, this.page$).distinctUntilKeyChanged('href' // Don't abort a request if the user "jiggles" over a link
        ).switchMap(function (kind) {
          return _this5.fetchPage(kind);
        }).catch(function (err, caught) {
          return caught;
        }).startWith({} // Start with some value so `withLatestFrom` below doesn't "block"
        ).share();

        this.render$ = this.page$.do(this.onStart.bind(this)).withLatestFrom(this.prefetch$).switchMap(this.getResponse.bind(this)).map(this.responseToContent.bind(this)).do(this.onReady.bind(this)).do(this.updateDOM.bind(this)).do(this.resetScrollPostion.bind(this)).do(this.onAfter.bind(this)).catch(function (error, caught) {
          _this5.onError(error);
          console.error(error);
          return caught;
        }
        // `share`ing the stream between the subscription below and `pauser$`.
        ).share();

        this.render$
        // Renewing event listeners after DOM update/layout/painting is complete
        // HACK: don't use time, use outside observable instead?
        .debounceTime(this.duration).do(this.renewEventListeners.bind(this)).subscribe();

        // Add script tags one by one (unless they are marekd `async`)
        // This simulates the behavior of a fresh page load
        this.render$.switchMap(this.reinsertScriptTags.bind(this)).do(this.onLoad.bind(this)).catch(function (error, caught) {
          _this5.onError(error);
          console.error(error);
          return caught;
        }).subscribe();

        // Fire `progress` event when fetching takes longer than `this.duration`.
        this.page$
        // HACK: add some time, jtbs
        .switchMap(function () {
          return _Observable.Observable.timer(_this5.duration + 200).do(_this5.onAnimationEnd.bind(_this5)).takeUntil(_this5.render$);
        }).do(this.onProgress.bind(this)).catch(function (error, caught) {
          _this5.onError(error);
          console.error(error);
          return caught;
        }).subscribe();

        // Start pulling values
        this.render$.subscribe();

        this.onLoad({});

        // Push streams into `push$$` and `hint$$`
        this.renewEventListeners();
      }
    }, {
      key: 'getResponse',
      value: function getResponse(_ref8) {
        var _ref9 = _slicedToArray(_ref8, 2),
            kind = _ref9[0],
            prefetch = _ref9[1];

        var res = void 0;

        // Prefetch already complete, use result
        if (kind.href === prefetch.href) {
          res = _Observable.Observable.of(Object.assign(kind, { response: prefetch.response }));

          if (kind instanceof _kind.Push || !this.noPopDuration) {
            // HACK: add some extra time to prevent 'flickering'
            // ideally, we'd like to take an animation observable as input instead
            res = res.delay(this.duration + 100);
          }
          // Prefetch in progress, use next result (this is why `prefetch$` had to be `share`d)
        } else {
          res = this.prefetch$.take(1).map(function (fetch) {
            return Object.assign(kind, { response: fetch.response });
          });

          if (kind instanceof _kind.Push || !this.noPopDuration) {
            // HACK: add some extra time to prevent 'flickering'
            // ideally, we'd like to take an animation observable as input instead
            res = res.zip(_Observable.Observable.timer(this.duration + 100), function (x) {
              return x;
            });
          }
        }

        return res;
      }
    }, {
      key: 'responseToContent',
      value: function responseToContent(sponge) {
        var response = sponge.response;

        var documentFragment = (0, _common.fragmentFromString)(response);
        var title = this.getTitleFromDocumentFragment(documentFragment);
        var content = this.getContentFromDocumentFragment(documentFragment);
        var scripts = this.tempRemoveScriptTags(content);

        return Object.assign(sponge, { title: title, content: content, scripts: scripts });
      }
    }, {
      key: 'updateDOM',
      value: function updateDOM(sponge) {
        try {
          var href = sponge.href,
              title = sponge.title,
              content = sponge.content;

          if (sponge instanceof _kind.Push) {
            window.history.replaceState({ id: this.componentName }, title, href);
          }

          this.titleElement.textContent = title;
          this.replaceContent(content);
        } catch (error) {
          throw Object.assign(sponge, { error: error });
        }
      }
    }, {
      key: 'tempRemoveScriptTags',
      value: function tempRemoveScriptTags(content) {
        var scripts = [];

        content.forEach(function (docfrag) {
          return Array.prototype.forEach.call(docfrag.querySelectorAll('script'), function (script) {
            var pair = [script, script.previousElementSibling];
            script.parentNode.removeChild(script);
            scripts.push(pair);
          });
        });

        return scripts;
      }
    }, {
      key: 'insertScript',
      value: function insertScript(_ref10) {
        var _ref11 = _slicedToArray(_ref10, 2),
            script = _ref11[0],
            ref = _ref11[1];

        return script.src !== '' ? _Observable.Observable.create(function (observer) {
          script.addEventListener('load', function (x) {
            observer.next(x);
            observer.complete();
          });

          script.addEventListener('error', function (x) {
            observer.error(x);
          });

          ref.parentNode.insertBefore(script, ref.nextElementSibling);
        }) : _Observable.Observable.of({}).do(function () {
          ref.parentNode.insertBefore(script, ref.nextElementSibling);
        });
      }
    }, {
      key: 'reinsertScriptTags',
      value: function reinsertScriptTags(_ref12) {
        var scripts = _ref12.scripts;

        if (scripts.length === 0) return _Observable.Observable.of({});
        return _Observable.Observable.from(scripts).concatMap(this.insertScript);

        // TODO: the code below does not guarantee that a script tag has loaded before a `async` one
        // const [script$, asyncScript$] = Observable.from(scripts)
        //   .partition(([script]) => script.async !== '');
        //
        // return Observable.merge(
        //     script$.concatMap(this.insertScript),
        //     asyncScript$.mergeMap(this.insertScript),
        //   );
      }
    }, {
      key: 'renewEventListeners',
      value: function renewEventListeners() {
        var link$ = this.linkObservable();
        this.push$$.next(this.bindPushEvents(link$));
        this.hint$$.next(this.bindHintEvents(link$));
      }
    }, {
      key: 'isPageChangeEvent',
      value: function isPageChangeEvent(kind) {
        var event = kind.event;

        return !event.metaKey && !event.ctrlKey && this.isPageChangeAnchor(kind);
      }
    }, {
      key: 'isPageChangeAnchor',
      value: function isPageChangeAnchor(_ref13) {
        var anchor = _ref13.event.currentTarget;

        return anchor != null && (0, _common.shouldLoadAnchor)(anchor, this.blacklist, this.hrefRegex);
      }
    }, {
      key: 'getTitleFromDocumentFragment',
      value: function getTitleFromDocumentFragment(documentFragment) {
        return (documentFragment.querySelector('title') || {}).textContent;
      }
    }, {
      key: 'getContentFromDocumentFragment',
      value: function getContentFromDocumentFragment(documentFragment) {
        if (this.replaceIds.length > 0) {
          return this.replaceIds.map(function (id) {
            return documentFragment.querySelector('#' + id);
          });
        }

        return documentFragment.querySelector('#' + this.el.id);
      }
    }, {
      key: 'replaceContent',
      value: function replaceContent(content) {
        if (this.replaceIds.length > 0) {
          this.replaceContentByIds(content);
        } else {
          this.replaceContentWholesale(content);
        }
      }
    }, {
      key: 'replaceContentByIds',
      value: function replaceContentByIds(elements) {
        var oldElements = this.replaceIds.map(function (id) {
          return document.getElementById(id);
        });

        Array.prototype.forEach.call(oldElements, function (oldElement) {
          oldElement.parentNode.replaceChild(elements.shift(), oldElement);
        });
      }
    }, {
      key: 'replaceContentWholesale',
      value: function replaceContentWholesale(content) {
        this.el.innerHTML = content.innerHTML;
      }
    }, {
      key: 'saveScrollPosition',
      value: function saveScrollPosition(state) {
        return Object.assign(state, {
          scrollTop: (0, _common.getScrollTop)(),
          scrollHeight: (0, _common.getScrollHeight)()
        });
      }
    }, {
      key: 'updateHistoryState',
      value: function updateHistoryState() {
        var state = history.state || { id: this.componentName };
        state = this.scrollRestoration ? this.saveScrollPosition(state) : state;
        history.replaceState(state, document.title, window.location.href);
      }
    }, {
      key: 'setScrollPosition',
      value: function setScrollPosition() {
        var state = history.state || {};
        document.body.style.minHeight = (state.scrollHeight || 0) + 'px';
        if (state.scrollTop != null) window.scroll(window.pageXOffset, state.scrollTop);
        document.body.style.minHeight = '';
      }
    }, {
      key: 'resetScrollPostion',
      value: function resetScrollPostion(sponge) {
        if (this.scrollRestoration) {
          if (sponge instanceof _kind.Pop) {
            this.setScrollPosition();
          }
        }
      }
    }, {
      key: 'onStart',
      value: function onStart(sponge) {
        var href = sponge.href;

        if (sponge instanceof _kind.Push) {
          window.history.pushState({ id: this.componentName }, '', href);
        }

        this.fireEvent('start', { detail: sponge });
      }
    }, {
      key: 'onReady',
      value: function onReady(sponge) {
        this.fireEvent('ready', { detail: sponge });
      }
    }, {
      key: 'onAfter',
      value: function onAfter(sponge) {
        this.fireEvent('after', { detail: sponge });
      }
    }, {
      key: 'onError',
      value: function onError(err) {
        this.fireEvent('error', { detail: err });
      }
    }, {
      key: 'onProgress',
      value: function onProgress(sponge) {
        this.fireEvent('progress', { detail: sponge });
      }
    }, {
      key: 'onRetry',
      value: function onRetry(sponge) {
        this.fireEvent('retry', { detail: sponge });
      }
    }, {
      key: 'onAnimationEnd',
      value: function onAnimationEnd(x) {
        this.fireEvent('animationend', { detail: x });
      }
    }, {
      key: 'onLoad',
      value: function onLoad(x) {
        this.fireEvent('load', { detail: x });
      }
    }]);

    return _class;
  }((0, _componentCore3.default)(C));
};

},{"../common":287,"./kind":289,"rxjs/Observable":180,"rxjs/Subject":184,"rxjs/add/observable/defer":188,"rxjs/add/observable/dom/ajax":189,"rxjs/add/observable/from":190,"rxjs/add/observable/fromEvent":191,"rxjs/add/observable/merge":192,"rxjs/add/observable/of":193,"rxjs/add/observable/throw":194,"rxjs/add/observable/timer":195,"rxjs/add/operator/catch":196,"rxjs/add/operator/concatMap":197,"rxjs/add/operator/debounceTime":198,"rxjs/add/operator/delay":199,"rxjs/add/operator/distinctUntilKeyChanged":200,"rxjs/add/operator/do":201,"rxjs/add/operator/filter":202,"rxjs/add/operator/map":203,"rxjs/add/operator/mergeMap":204,"rxjs/add/operator/partition":205,"rxjs/add/operator/retryWhen":206,"rxjs/add/operator/share":207,"rxjs/add/operator/startWith":208,"rxjs/add/operator/switch":209,"rxjs/add/operator/switchMap":210,"rxjs/add/operator/take":211,"rxjs/add/operator/takeUntil":212,"rxjs/add/operator/throttleTime":213,"rxjs/add/operator/withLatestFrom":214,"rxjs/add/operator/zip":215,"y-component/src/component-core":174}],289:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

// Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

var Kind = exports.Kind = function Kind(event) {
  _classCallCheck(this, Kind);

  this.event = event;
};

var Push = exports.Push = function (_Kind) {
  _inherits(Push, _Kind);

  function Push(event) {
    _classCallCheck(this, Push);

    var _this = _possibleConstructorReturn(this, (Push.__proto__ || Object.getPrototypeOf(Push)).call(this, event));

    _this.href = event.currentTarget.href;
    return _this;
  }

  _createClass(Push, [{
    key: 'type',
    get: function get() {
      return 'push';
    }
  }]);

  return Push;
}(Kind);

var Hint = exports.Hint = function (_Kind2) {
  _inherits(Hint, _Kind2);

  function Hint(event) {
    _classCallCheck(this, Hint);

    var _this2 = _possibleConstructorReturn(this, (Hint.__proto__ || Object.getPrototypeOf(Hint)).call(this, event));

    _this2.href = event.currentTarget.href;
    return _this2;
  }

  _createClass(Hint, [{
    key: 'type',
    get: function get() {
      return 'hint';
    }
  }]);

  return Hint;
}(Kind);

var Pop = exports.Pop = function (_Kind3) {
  _inherits(Pop, _Kind3);

  function Pop(event) {
    _classCallCheck(this, Pop);

    var _this3 = _possibleConstructorReturn(this, (Pop.__proto__ || Object.getPrototypeOf(Pop)).call(this, event));

    _this3.href = window.location.href;
    return _this3;
  }

  _createClass(Pop, [{
    key: 'type',
    get: function get() {
      return 'pop';
    }
  }]);

  return Pop;
}(Kind);

},{}],290:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _core = require('../core');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} // Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

var PushState = function (_pushStateCore) {
  _inherits(PushState, _pushStateCore);

  function PushState(el, props) {
    _classCallCheck(this, PushState);

    var _this = _possibleConstructorReturn(this, (PushState.__proto__ || Object.getPrototypeOf(PushState)).call(this));

    _this.setupComponent(el, props);
    return _this;
  }

  // @override


  _createClass(PushState, [{
    key: 'setupDOM',
    value: function setupDOM(el) {
      if (!el) throw Error('No element provided');
      return el;
    }
  }]);

  return PushState;
}((0, _core2.default)());

exports.default = PushState;

},{"../core":288}]},{},[8])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJfanNcXGxpYlxcbW9kZXJuaXpyLmpzIiwiX2pzXFxsaWJcXHZlcnNpb24uanMiLCJfanNcXHNyY1xcY29tbW9uLmpzIiwiX2pzXFxzcmNcXGNyb3NzLWZhZGVyLmpzIiwiX2pzXFxzcmNcXGRyYXdlci5qcyIsIl9qc1xcc3JjXFxmbGlwXFxmbGlwLmpzIiwiX2pzXFxzcmNcXGZsaXBcXHRpdGxlLmpzIiwiX2pzXFxzcmNcXGluZGV4LmpzIiwiX2pzXFxzcmNcXGthdGV4LmpzIiwiX2pzXFxzcmNcXHB1c2gtc3RhdGUuanMiLCJub2RlX21vZHVsZXMvY29sb3ItY29udmVydC9jb252ZXJzaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9jb2xvci1jb252ZXJ0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbG9yLWNvbnZlcnQvcm91dGUuanMiLCJub2RlX21vZHVsZXMvY29sb3ItbmFtZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb2xvci1zdHJpbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29sb3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9mbi9hcnJheS9maW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vYXJyYXkvZm9yLWVhY2guanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9mbi9hcnJheS9yZWR1Y2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9mbi9mdW5jdGlvbi9iaW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vbnVtYmVyL2NvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vb2JqZWN0L2Fzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9mbi9vYmplY3Qva2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LW1ldGhvZHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1yZWR1Y2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19iaW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2N0eC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZXhwb3J0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oYXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faHRtbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW5oZXJpdC1pZi1yZXF1aXJlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ludm9rZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lvYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXNhcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1wcm90by5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC1rZXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpY3QtbWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXRyaW0uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctd3MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZvci1lYWNoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCJub2RlX21vZHVsZXNcXGVsZW0tZGF0YXNldFxcZGlzdFxcaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtYXJyYXlpc2gvaW5kZXguanMiLCJub2RlX21vZHVsZXMva2F0ZXgva2F0ZXguanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL0xleGVyLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9NYWNyb0V4cGFuZGVyLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9PcHRpb25zLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9QYXJzZUVycm9yLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9QYXJzZXIuanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL1NldHRpbmdzLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9TdHlsZS5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9zcmMvYnVpbGRDb21tb24uanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL2J1aWxkSFRNTC5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9zcmMvYnVpbGRNYXRoTUwuanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL2J1aWxkVHJlZS5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9zcmMvZGVsaW1pdGVyLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9kb21UcmVlLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9lbnZpcm9ubWVudHMuanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL2ZvbnRNZXRyaWNzLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9mb250TWV0cmljc0RhdGEuanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL2Z1bmN0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9zcmMvbWF0aE1MVHJlZS5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9zcmMvcGFyc2VEYXRhLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9wYXJzZVRyZWUuanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL3N5bWJvbHMuanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL3VuaWNvZGVSZWdleGVzLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9tYXRjaC1hdC9saWIvbWF0Y2hBdC5qcyIsIm5vZGVfbW9kdWxlc1xccnhqc1xcSW5uZXJTdWJzY3JpYmVyLmpzIiwibm9kZV9tb2R1bGVzXFxyeGpzXFxPYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzXFxyeGpzXFxPYnNlcnZlci5qcyIsIm5vZGVfbW9kdWxlc1xccnhqc1xcT3V0ZXJTdWJzY3JpYmVyLmpzIiwibm9kZV9tb2R1bGVzXFxyeGpzXFxTY2hlZHVsZXIuanMiLCJub2RlX21vZHVsZXNcXHJ4anNcXFN1YmplY3QuanMiLCJub2RlX21vZHVsZXNcXHJ4anNcXFN1YmplY3RTdWJzY3JpcHRpb24uanMiLCJub2RlX21vZHVsZXNcXHJ4anNcXFN1YnNjcmliZXIuanMiLCJub2RlX21vZHVsZXNcXHJ4anNcXFN1YnNjcmlwdGlvbi5qcyIsIm5vZGVfbW9kdWxlc1xccnhqc1xcb2JzZXJ2YWJsZVxcQXJyYXlPYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzXFxyeGpzXFxvYnNlcnZhYmxlXFxDb25uZWN0YWJsZU9ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXNcXHJ4anNcXG9ic2VydmFibGVcXEVtcHR5T2JzZXJ2YWJsZS5qcyIsIm5vZGVfbW9kdWxlc1xccnhqc1xcb2JzZXJ2YWJsZVxcRnJvbUV2ZW50T2JzZXJ2YWJsZS5qcyIsIm5vZGVfbW9kdWxlc1xccnhqc1xcb2JzZXJ2YWJsZVxcU2NhbGFyT2JzZXJ2YWJsZS5qcyIsIm5vZGVfbW9kdWxlc1xccnhqc1xcb2JzZXJ2YWJsZVxcVGltZXJPYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzXFxyeGpzXFxvYnNlcnZhYmxlXFxlbXB0eS5qcyIsIm5vZGVfbW9kdWxlc1xccnhqc1xcb2JzZXJ2YWJsZVxcZnJvbUV2ZW50LmpzIiwibm9kZV9tb2R1bGVzXFxyeGpzXFxvYnNlcnZhYmxlXFx0aW1lci5qcyIsIm5vZGVfbW9kdWxlc1xccnhqc1xcb3BlcmF0b3JcXGNhdGNoLmpzIiwibm9kZV9tb2R1bGVzXFxyeGpzXFxvcGVyYXRvclxcY29uY2F0LmpzIiwibm9kZV9tb2R1bGVzXFxyeGpzXFxvcGVyYXRvclxcZGVib3VuY2VUaW1lLmpzIiwibm9kZV9tb2R1bGVzXFxyeGpzXFxvcGVyYXRvclxcZG8uanMiLCJub2RlX21vZHVsZXNcXHJ4anNcXG9wZXJhdG9yXFxleGhhdXN0TWFwLmpzIiwibm9kZV9tb2R1bGVzXFxyeGpzXFxvcGVyYXRvclxcZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzXFxyeGpzXFxvcGVyYXRvclxcZmluYWxseS5qcyIsIm5vZGVfbW9kdWxlc1xccnhqc1xcb3BlcmF0b3JcXG1hcC5qcyIsIm5vZGVfbW9kdWxlc1xccnhqc1xcb3BlcmF0b3JcXG1lcmdlQWxsLmpzIiwibm9kZV9tb2R1bGVzXFxyeGpzXFxvcGVyYXRvclxcbWVyZ2VNYXAuanMiLCJub2RlX21vZHVsZXNcXHJ4anNcXG9wZXJhdG9yXFxtdWx0aWNhc3QuanMiLCJub2RlX21vZHVsZXNcXHJ4anNcXG9wZXJhdG9yXFxwYWlyd2lzZS5qcyIsIm5vZGVfbW9kdWxlc1xccnhqc1xcb3BlcmF0b3JcXHNoYXJlLmpzIiwibm9kZV9tb2R1bGVzXFxyeGpzXFxvcGVyYXRvclxcc3RhcnRXaXRoLmpzIiwibm9kZV9tb2R1bGVzXFxyeGpzXFxvcGVyYXRvclxcc3dpdGNoTWFwLmpzIiwibm9kZV9tb2R1bGVzXFxyeGpzXFxvcGVyYXRvclxcdGFrZVVudGlsLmpzIiwibm9kZV9tb2R1bGVzXFxyeGpzXFxvcGVyYXRvclxcemlwLmpzIiwibm9kZV9tb2R1bGVzXFxyeGpzXFxzY2hlZHVsZXJcXEFjdGlvbi5qcyIsIm5vZGVfbW9kdWxlc1xccnhqc1xcc2NoZWR1bGVyXFxBc3luY0FjdGlvbi5qcyIsIm5vZGVfbW9kdWxlc1xccnhqc1xcc2NoZWR1bGVyXFxBc3luY1NjaGVkdWxlci5qcyIsIm5vZGVfbW9kdWxlc1xccnhqc1xcc2NoZWR1bGVyXFxhc3luYy5qcyIsIm5vZGVfbW9kdWxlc1xccnhqc1xcc3ltYm9sXFxpdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlc1xccnhqc1xcc3ltYm9sXFxvYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzXFxyeGpzXFxzeW1ib2xcXHJ4U3Vic2NyaWJlci5qcyIsIm5vZGVfbW9kdWxlc1xccnhqc1xcdXRpbFxcT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IuanMiLCJub2RlX21vZHVsZXNcXHJ4anNcXHV0aWxcXFVuc3Vic2NyaXB0aW9uRXJyb3IuanMiLCJub2RlX21vZHVsZXNcXHJ4anNcXHV0aWxcXGVycm9yT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzXFxyeGpzXFx1dGlsXFxpc0FycmF5LmpzIiwibm9kZV9tb2R1bGVzXFxyeGpzXFx1dGlsXFxpc0FycmF5TGlrZS5qcyIsIm5vZGVfbW9kdWxlc1xccnhqc1xcdXRpbFxcaXNEYXRlLmpzIiwibm9kZV9tb2R1bGVzXFxyeGpzXFx1dGlsXFxpc0Z1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzXFxyeGpzXFx1dGlsXFxpc051bWVyaWMuanMiLCJub2RlX21vZHVsZXNcXHJ4anNcXHV0aWxcXGlzT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzXFxyeGpzXFx1dGlsXFxpc1Byb21pc2UuanMiLCJub2RlX21vZHVsZXNcXHJ4anNcXHV0aWxcXGlzU2NoZWR1bGVyLmpzIiwibm9kZV9tb2R1bGVzXFxyeGpzXFx1dGlsXFxub2RlX21vZHVsZXNcXHJ4anNcXHV0aWxcXHJvb3QuanMiLCJub2RlX21vZHVsZXNcXHJ4anNcXHV0aWxcXHN1YnNjcmliZVRvUmVzdWx0LmpzIiwibm9kZV9tb2R1bGVzXFxyeGpzXFx1dGlsXFx0b1N1YnNjcmliZXIuanMiLCJub2RlX21vZHVsZXNcXHJ4anNcXHV0aWxcXHRyeUNhdGNoLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1zd2l6emxlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3dlYi1hbmltYXRpb25zLWpzL3dlYi1hbmltYXRpb25zLm1pbi5qcyIsIm5vZGVfbW9kdWxlc1xceS1jb21wb25lbnRcXHNyY1xcbm9kZV9tb2R1bGVzXFx5LWNvbXBvbmVudFxcc3JjXFxjb21wb25lbnQtY29yZS5qcyIsIm5vZGVfbW9kdWxlc1xceS1kcmF3ZXJcXHNyY1xcY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzXFx5LWRyYXdlclxcc3JjXFxjb3JlXFxub2RlX21vZHVsZXNcXHktZHJhd2VyXFxzcmNcXGNvcmVcXGluZGV4LmpzIiwibm9kZV9tb2R1bGVzXFx5LWRyYXdlclxcc3JjXFx2YW5pbGxhXFxpbmRleC5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXElubmVyU3Vic2NyaWJlci5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXE5vdGlmaWNhdGlvbi5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXE9ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxPYnNlcnZlci5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXE91dGVyU3Vic2NyaWJlci5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXFN1YmplY3QuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxTdWJqZWN0U3Vic2NyaXB0aW9uLmpzIiwibm9kZV9tb2R1bGVzXFx5LXB1c2gtc3RhdGVcXG5vZGVfbW9kdWxlc1xccnhqc1xcU3Vic2NyaWJlci5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXFN1YnNjcmlwdGlvbi5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXGFkZFxcb2JzZXJ2YWJsZVxcZGVmZXIuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxhZGRcXG9ic2VydmFibGVcXGRvbVxcYWpheC5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXGFkZFxcb2JzZXJ2YWJsZVxcZnJvbS5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXGFkZFxcb2JzZXJ2YWJsZVxcZnJvbUV2ZW50LmpzIiwibm9kZV9tb2R1bGVzXFx5LXB1c2gtc3RhdGVcXG5vZGVfbW9kdWxlc1xccnhqc1xcYWRkXFxvYnNlcnZhYmxlXFxtZXJnZS5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXGFkZFxcb2JzZXJ2YWJsZVxcb2YuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxhZGRcXG9ic2VydmFibGVcXHRocm93LmpzIiwibm9kZV9tb2R1bGVzXFx5LXB1c2gtc3RhdGVcXG5vZGVfbW9kdWxlc1xccnhqc1xcYWRkXFxvYnNlcnZhYmxlXFx0aW1lci5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXGFkZFxcb3BlcmF0b3JcXGNhdGNoLmpzIiwibm9kZV9tb2R1bGVzXFx5LXB1c2gtc3RhdGVcXG5vZGVfbW9kdWxlc1xccnhqc1xcYWRkXFxvcGVyYXRvclxcY29uY2F0TWFwLmpzIiwibm9kZV9tb2R1bGVzXFx5LXB1c2gtc3RhdGVcXG5vZGVfbW9kdWxlc1xccnhqc1xcYWRkXFxvcGVyYXRvclxcZGVib3VuY2VUaW1lLmpzIiwibm9kZV9tb2R1bGVzXFx5LXB1c2gtc3RhdGVcXG5vZGVfbW9kdWxlc1xccnhqc1xcYWRkXFxvcGVyYXRvclxcZGVsYXkuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxhZGRcXG9wZXJhdG9yXFxkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZC5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXGFkZFxcb3BlcmF0b3JcXGRvLmpzIiwibm9kZV9tb2R1bGVzXFx5LXB1c2gtc3RhdGVcXG5vZGVfbW9kdWxlc1xccnhqc1xcYWRkXFxvcGVyYXRvclxcZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzXFx5LXB1c2gtc3RhdGVcXG5vZGVfbW9kdWxlc1xccnhqc1xcYWRkXFxvcGVyYXRvclxcbWFwLmpzIiwibm9kZV9tb2R1bGVzXFx5LXB1c2gtc3RhdGVcXG5vZGVfbW9kdWxlc1xccnhqc1xcYWRkXFxvcGVyYXRvclxcbWVyZ2VNYXAuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxhZGRcXG9wZXJhdG9yXFxwYXJ0aXRpb24uanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxhZGRcXG9wZXJhdG9yXFxyZXRyeVdoZW4uanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxhZGRcXG9wZXJhdG9yXFxzaGFyZS5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXGFkZFxcb3BlcmF0b3JcXHN0YXJ0V2l0aC5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXGFkZFxcb3BlcmF0b3JcXHN3aXRjaC5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXGFkZFxcb3BlcmF0b3JcXHN3aXRjaE1hcC5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXGFkZFxcb3BlcmF0b3JcXHRha2UuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxhZGRcXG9wZXJhdG9yXFx0YWtlVW50aWwuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxhZGRcXG9wZXJhdG9yXFx0aHJvdHRsZVRpbWUuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxhZGRcXG9wZXJhdG9yXFx3aXRoTGF0ZXN0RnJvbS5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXGFkZFxcb3BlcmF0b3JcXHppcC5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXG9ic2VydmFibGVcXEFycmF5TGlrZU9ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxvYnNlcnZhYmxlXFxBcnJheU9ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxvYnNlcnZhYmxlXFxDb25uZWN0YWJsZU9ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxvYnNlcnZhYmxlXFxEZWZlck9ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxvYnNlcnZhYmxlXFxFbXB0eU9ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxvYnNlcnZhYmxlXFxFcnJvck9ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxvYnNlcnZhYmxlXFxGcm9tRXZlbnRPYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzXFx5LXB1c2gtc3RhdGVcXG5vZGVfbW9kdWxlc1xccnhqc1xcb2JzZXJ2YWJsZVxcRnJvbU9ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxvYnNlcnZhYmxlXFxJdGVyYXRvck9ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxvYnNlcnZhYmxlXFxQcm9taXNlT2JzZXJ2YWJsZS5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXG9ic2VydmFibGVcXFNjYWxhck9ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxvYnNlcnZhYmxlXFxUaW1lck9ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxvYnNlcnZhYmxlXFxkZWZlci5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXG9ic2VydmFibGVcXGRvbVxcQWpheE9ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxvYnNlcnZhYmxlXFxkb21cXGFqYXguanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxvYnNlcnZhYmxlXFxmcm9tLmpzIiwibm9kZV9tb2R1bGVzXFx5LXB1c2gtc3RhdGVcXG5vZGVfbW9kdWxlc1xccnhqc1xcb2JzZXJ2YWJsZVxcbWVyZ2UuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxvYnNlcnZhYmxlXFxvZi5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXG9ic2VydmFibGVcXHRocm93LmpzIiwibm9kZV9tb2R1bGVzXFx5LXB1c2gtc3RhdGVcXG5vZGVfbW9kdWxlc1xccnhqc1xcb3BlcmF0b3JcXGNhdGNoLmpzIiwibm9kZV9tb2R1bGVzXFx5LXB1c2gtc3RhdGVcXG5vZGVfbW9kdWxlc1xccnhqc1xcb3BlcmF0b3JcXGNvbmNhdE1hcC5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXG9wZXJhdG9yXFxkZWJvdW5jZVRpbWUuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxvcGVyYXRvclxcZGVsYXkuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxvcGVyYXRvclxcZGlzdGluY3RVbnRpbENoYW5nZWQuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxvcGVyYXRvclxcZGlzdGluY3RVbnRpbEtleUNoYW5nZWQuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxvcGVyYXRvclxcZG8uanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxvcGVyYXRvclxcZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzXFx5LXB1c2gtc3RhdGVcXG5vZGVfbW9kdWxlc1xccnhqc1xcb3BlcmF0b3JcXG1hcC5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXG9wZXJhdG9yXFxtZXJnZS5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXG9wZXJhdG9yXFxtZXJnZUFsbC5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXG9wZXJhdG9yXFxtZXJnZU1hcC5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXG9wZXJhdG9yXFxvYnNlcnZlT24uanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxvcGVyYXRvclxccGFydGl0aW9uLmpzIiwibm9kZV9tb2R1bGVzXFx5LXB1c2gtc3RhdGVcXG5vZGVfbW9kdWxlc1xccnhqc1xcb3BlcmF0b3JcXHJldHJ5V2hlbi5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXG9wZXJhdG9yXFxzd2l0Y2guanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxvcGVyYXRvclxcc3dpdGNoTWFwLmpzIiwibm9kZV9tb2R1bGVzXFx5LXB1c2gtc3RhdGVcXG5vZGVfbW9kdWxlc1xccnhqc1xcb3BlcmF0b3JcXHRha2UuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxvcGVyYXRvclxcdGFrZVVudGlsLmpzIiwibm9kZV9tb2R1bGVzXFx5LXB1c2gtc3RhdGVcXG5vZGVfbW9kdWxlc1xccnhqc1xcb3BlcmF0b3JcXHRocm90dGxlVGltZS5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXG9wZXJhdG9yXFx3aXRoTGF0ZXN0RnJvbS5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXG9wZXJhdG9yXFx6aXAuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxzY2hlZHVsZXJcXEFjdGlvbi5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXHNjaGVkdWxlclxcQXN5bmNBY3Rpb24uanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFxzY2hlZHVsZXJcXEFzeW5jU2NoZWR1bGVyLmpzIiwibm9kZV9tb2R1bGVzXFx5LXB1c2gtc3RhdGVcXG5vZGVfbW9kdWxlc1xccnhqc1xcc3ltYm9sXFxpdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXHN5bWJvbFxcb2JzZXJ2YWJsZS5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXHN5bWJvbFxccnhTdWJzY3JpYmVyLmpzIiwibm9kZV9tb2R1bGVzXFx5LXB1c2gtc3RhdGVcXG5vZGVfbW9kdWxlc1xccnhqc1xcdXRpbFxcQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFx1dGlsXFxPYmplY3RVbnN1YnNjcmliZWRFcnJvci5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXHV0aWxcXFVuc3Vic2NyaXB0aW9uRXJyb3IuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcbm9kZV9tb2R1bGVzXFxyeGpzXFx1dGlsXFxpc09iamVjdC5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXHV0aWxcXG5vdC5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXHV0aWxcXG5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxub2RlX21vZHVsZXNcXHJ4anNcXHV0aWxcXHJvb3QuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcc3JjXFxjb21tb24uanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcc3JjXFxjb3JlXFxpbmRleC5qcyIsIm5vZGVfbW9kdWxlc1xceS1wdXNoLXN0YXRlXFxzcmNcXGNvcmVcXGtpbmQuanMiLCJub2RlX21vZHVsZXNcXHktcHVzaC1zdGF0ZVxcc3JjXFx2YW5pbGxhXFxpbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FDQUE7O0FBRUEsQ0FBQyxVQUFTLENBQVQsRUFBVyxDQUFYLEVBQWEsQ0FBYixFQUFlO0FBQUMsV0FBUyxDQUFULENBQVcsQ0FBWCxFQUFhLENBQWIsRUFBZTtBQUFDLFdBQU8sT0FBTyxDQUFQLEtBQVcsQ0FBbEI7QUFBb0IsWUFBUyxDQUFULEdBQVk7QUFBQyxRQUFJLENBQUosRUFBTSxDQUFOLEVBQVEsQ0FBUixFQUFVLENBQVYsRUFBWSxDQUFaLEVBQWMsQ0FBZCxFQUFnQixDQUFoQixDQUFrQixLQUFJLElBQUksQ0FBUixJQUFhLENBQWIsRUFBZSxJQUFHLEVBQUUsY0FBRixDQUFpQixDQUFqQixDQUFILEVBQXVCO0FBQUMsVUFBRyxJQUFFLEVBQUYsRUFBSyxJQUFFLEVBQUUsQ0FBRixDQUFQLEVBQVksRUFBRSxJQUFGLEtBQVMsRUFBRSxJQUFGLENBQU8sRUFBRSxJQUFGLENBQU8sV0FBUCxFQUFQLEdBQTZCLEVBQUUsT0FBRixJQUFXLEVBQUUsT0FBRixDQUFVLE9BQXJCLElBQThCLEVBQUUsT0FBRixDQUFVLE9BQVYsQ0FBa0IsTUFBdEYsQ0FBZixFQUE2RyxLQUFJLElBQUUsQ0FBTixFQUFRLElBQUUsRUFBRSxPQUFGLENBQVUsT0FBVixDQUFrQixNQUE1QixFQUFtQyxHQUFuQyxFQUF1QyxFQUFFLElBQUYsQ0FBTyxFQUFFLE9BQUYsQ0FBVSxPQUFWLENBQWtCLENBQWxCLEVBQXFCLFdBQXJCLEVBQVAsRUFBMkMsS0FBSSxJQUFFLEVBQUUsRUFBRSxFQUFKLEVBQU8sVUFBUCxJQUFtQixFQUFFLEVBQUYsRUFBbkIsR0FBMEIsRUFBRSxFQUE5QixFQUFpQyxJQUFFLENBQXZDLEVBQXlDLElBQUUsRUFBRSxNQUE3QyxFQUFvRCxHQUFwRCxFQUF3RCxJQUFFLEVBQUUsQ0FBRixDQUFGLEVBQU8sSUFBRSxFQUFFLEtBQUYsQ0FBUSxHQUFSLENBQVQsRUFBc0IsTUFBSSxFQUFFLE1BQU4sR0FBYSxVQUFVLEVBQUUsQ0FBRixDQUFWLElBQWdCLENBQTdCLElBQWdDLENBQUMsVUFBVSxFQUFFLENBQUYsQ0FBVixDQUFELElBQWtCLFVBQVUsRUFBRSxDQUFGLENBQVYsYUFBMEIsT0FBNUMsS0FBc0QsVUFBVSxFQUFFLENBQUYsQ0FBVixJQUFnQixJQUFJLE9BQUosQ0FBWSxVQUFVLEVBQUUsQ0FBRixDQUFWLENBQVosQ0FBdEUsR0FBb0csVUFBVSxFQUFFLENBQUYsQ0FBVixFQUFnQixFQUFFLENBQUYsQ0FBaEIsSUFBc0IsQ0FBMUosQ0FBdEIsRUFBbUwsRUFBRSxJQUFGLENBQU8sQ0FBQyxJQUFFLEVBQUYsR0FBSyxLQUFOLElBQWEsRUFBRSxJQUFGLENBQU8sR0FBUCxDQUFwQixDQUFuTDtBQUFvTjtBQUFDLFlBQVMsQ0FBVCxDQUFXLENBQVgsRUFBYTtBQUFDLFdBQU8sRUFBRSxPQUFGLENBQVUsa0JBQVYsRUFBNkIsVUFBUyxDQUFULEVBQVcsQ0FBWCxFQUFhLENBQWIsRUFBZTtBQUFDLGFBQU8sSUFBRSxFQUFFLFdBQUYsRUFBVDtBQUF5QixLQUF0RSxFQUF3RSxPQUF4RSxDQUFnRixJQUFoRixFQUFxRixFQUFyRixDQUFQO0FBQWdHLFlBQVMsQ0FBVCxHQUFZO0FBQUMsV0FBTSxjQUFZLE9BQU8sRUFBRSxhQUFyQixHQUFtQyxFQUFFLGFBQUYsQ0FBZ0IsVUFBVSxDQUFWLENBQWhCLENBQW5DLEdBQWlFLElBQUUsRUFBRSxlQUFGLENBQWtCLElBQWxCLENBQXVCLENBQXZCLEVBQXlCLDRCQUF6QixFQUFzRCxVQUFVLENBQVYsQ0FBdEQsQ0FBRixHQUFzRSxFQUFFLGFBQUYsQ0FBZ0IsS0FBaEIsQ0FBc0IsQ0FBdEIsRUFBd0IsU0FBeEIsQ0FBN0k7QUFBZ0wsWUFBUyxDQUFULEdBQVk7QUFBQyxRQUFJLElBQUUsRUFBRSxJQUFSLENBQWEsT0FBTyxNQUFJLElBQUUsRUFBRSxJQUFFLEtBQUYsR0FBUSxNQUFWLENBQUYsRUFBb0IsRUFBRSxJQUFGLEdBQU8sQ0FBQyxDQUFoQyxHQUFtQyxDQUExQztBQUE0QyxZQUFTLENBQVQsQ0FBVyxDQUFYLEVBQWEsQ0FBYixFQUFlLENBQWYsRUFBaUIsQ0FBakIsRUFBbUI7QUFBQyxRQUFJLENBQUo7QUFBQSxRQUFNLENBQU47QUFBQSxRQUFRLENBQVI7QUFBQSxRQUFVLENBQVY7QUFBQSxRQUFZLElBQUUsV0FBZDtBQUFBLFFBQTBCLElBQUUsRUFBRSxLQUFGLENBQTVCO0FBQUEsUUFBcUMsSUFBRSxHQUF2QyxDQUEyQyxJQUFHLFNBQVMsQ0FBVCxFQUFXLEVBQVgsQ0FBSCxFQUFrQixPQUFLLEdBQUwsR0FBVSxJQUFFLEVBQUUsS0FBRixDQUFGLEVBQVcsRUFBRSxFQUFGLEdBQUssSUFBRSxFQUFFLENBQUYsQ0FBRixHQUFPLEtBQUcsSUFBRSxDQUFMLENBQXZCLEVBQStCLEVBQUUsV0FBRixDQUFjLENBQWQsQ0FBL0IsQ0FBZ0QsT0FBTyxJQUFFLEVBQUUsT0FBRixDQUFGLEVBQWEsRUFBRSxJQUFGLEdBQU8sVUFBcEIsRUFBK0IsRUFBRSxFQUFGLEdBQUssTUFBSSxDQUF4QyxFQUEwQyxDQUFDLEVBQUUsSUFBRixHQUFPLENBQVAsR0FBUyxDQUFWLEVBQWEsV0FBYixDQUF5QixDQUF6QixDQUExQyxFQUFzRSxFQUFFLFdBQUYsQ0FBYyxDQUFkLENBQXRFLEVBQXVGLEVBQUUsVUFBRixHQUFhLEVBQUUsVUFBRixDQUFhLE9BQWIsR0FBcUIsQ0FBbEMsR0FBb0MsRUFBRSxXQUFGLENBQWMsRUFBRSxjQUFGLENBQWlCLENBQWpCLENBQWQsQ0FBM0gsRUFBOEosRUFBRSxFQUFGLEdBQUssQ0FBbkssRUFBcUssRUFBRSxJQUFGLEtBQVMsRUFBRSxLQUFGLENBQVEsVUFBUixHQUFtQixFQUFuQixFQUFzQixFQUFFLEtBQUYsQ0FBUSxRQUFSLEdBQWlCLFFBQXZDLEVBQWdELElBQUUsRUFBRSxLQUFGLENBQVEsUUFBMUQsRUFBbUUsRUFBRSxLQUFGLENBQVEsUUFBUixHQUFpQixRQUFwRixFQUE2RixFQUFFLFdBQUYsQ0FBYyxDQUFkLENBQXRHLENBQXJLLEVBQTZSLElBQUUsRUFBRSxDQUFGLEVBQUksQ0FBSixDQUEvUixFQUFzUyxFQUFFLElBQUYsSUFBUSxFQUFFLFVBQUYsQ0FBYSxXQUFiLENBQXlCLENBQXpCLEdBQTRCLEVBQUUsS0FBRixDQUFRLFFBQVIsR0FBaUIsQ0FBN0MsRUFBK0MsRUFBRSxZQUF6RCxJQUF1RSxFQUFFLFVBQUYsQ0FBYSxXQUFiLENBQXlCLENBQXpCLENBQTdXLEVBQXlZLENBQUMsQ0FBQyxDQUFsWjtBQUFvWixZQUFTLENBQVQsQ0FBVyxDQUFYLEVBQWEsQ0FBYixFQUFlO0FBQUMsV0FBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUcsQ0FBSixFQUFPLE9BQVAsQ0FBZSxDQUFmLENBQVQ7QUFBMkIsWUFBUyxDQUFULENBQVcsQ0FBWCxFQUFhLENBQWIsRUFBZTtBQUFDLFdBQU8sWUFBVTtBQUFDLGFBQU8sRUFBRSxLQUFGLENBQVEsQ0FBUixFQUFVLFNBQVYsQ0FBUDtBQUE0QixLQUE5QztBQUErQyxZQUFTLENBQVQsQ0FBVyxDQUFYLEVBQWEsQ0FBYixFQUFlLENBQWYsRUFBaUI7QUFBQyxRQUFJLENBQUosQ0FBTSxLQUFJLElBQUksQ0FBUixJQUFhLENBQWIsRUFBZSxJQUFHLEVBQUUsQ0FBRixLQUFPLENBQVYsRUFBWSxPQUFPLE1BQUksQ0FBQyxDQUFMLEdBQU8sRUFBRSxDQUFGLENBQVAsSUFBYSxJQUFFLEVBQUUsRUFBRSxDQUFGLENBQUYsQ0FBRixFQUFVLEVBQUUsQ0FBRixFQUFJLFVBQUosSUFBZ0IsRUFBRSxDQUFGLEVBQUksS0FBRyxDQUFQLENBQWhCLEdBQTBCLENBQWpELENBQVAsQ0FBMkQsT0FBTSxDQUFDLENBQVA7QUFBUyxZQUFTLENBQVQsQ0FBVyxDQUFYLEVBQWE7QUFBQyxXQUFPLEVBQUUsT0FBRixDQUFVLFVBQVYsRUFBcUIsVUFBUyxDQUFULEVBQVcsQ0FBWCxFQUFhO0FBQUMsYUFBTSxNQUFJLEVBQUUsV0FBRixFQUFWO0FBQTBCLEtBQTdELEVBQStELE9BQS9ELENBQXVFLE1BQXZFLEVBQThFLE1BQTlFLENBQVA7QUFBNkYsWUFBUyxDQUFULENBQVcsQ0FBWCxFQUFhLENBQWIsRUFBZSxDQUFmLEVBQWlCO0FBQUMsUUFBSSxDQUFKLENBQU0sSUFBRyxzQkFBcUIsQ0FBeEIsRUFBMEI7QUFBQyxVQUFFLGlCQUFpQixJQUFqQixDQUFzQixDQUF0QixFQUF3QixDQUF4QixFQUEwQixDQUExQixDQUFGLENBQStCLElBQUksSUFBRSxFQUFFLE9BQVIsQ0FBZ0IsSUFBRyxTQUFPLENBQVYsRUFBWSxNQUFJLElBQUUsRUFBRSxnQkFBRixDQUFtQixDQUFuQixDQUFOLEVBQVosS0FBOEMsSUFBRyxDQUFILEVBQUs7QUFBQyxZQUFJLElBQUUsRUFBRSxLQUFGLEdBQVEsT0FBUixHQUFnQixLQUF0QixDQUE0QixFQUFFLENBQUYsRUFBSyxJQUFMLENBQVUsQ0FBVixFQUFZLHFGQUFaO0FBQW1HO0FBQUMsS0FBOVAsTUFBbVEsSUFBRSxDQUFDLENBQUQsSUFBSSxFQUFFLFlBQU4sSUFBb0IsRUFBRSxZQUFGLENBQWUsQ0FBZixDQUF0QixDQUF3QyxPQUFPLENBQVA7QUFBUyxZQUFTLENBQVQsQ0FBVyxDQUFYLEVBQWEsQ0FBYixFQUFlO0FBQUMsUUFBSSxJQUFFLEVBQUUsTUFBUixDQUFlLElBQUcsU0FBUSxDQUFSLElBQVcsY0FBYSxFQUFFLEdBQTdCLEVBQWlDO0FBQUMsYUFBSyxHQUFMLEdBQVUsSUFBRyxFQUFFLEdBQUYsQ0FBTSxRQUFOLENBQWUsRUFBRSxFQUFFLENBQUYsQ0FBRixDQUFmLEVBQXVCLENBQXZCLENBQUgsRUFBNkIsT0FBTSxDQUFDLENBQVAsQ0FBUyxPQUFNLENBQUMsQ0FBUDtBQUFTLFNBQUcscUJBQW9CLENBQXZCLEVBQXlCO0FBQUMsV0FBSSxJQUFJLElBQUUsRUFBVixFQUFhLEdBQWIsR0FBa0IsRUFBRSxJQUFGLENBQU8sTUFBSSxFQUFFLEVBQUUsQ0FBRixDQUFGLENBQUosR0FBWSxHQUFaLEdBQWdCLENBQWhCLEdBQWtCLEdBQXpCLEVBQThCLE9BQU8sSUFBRSxFQUFFLElBQUYsQ0FBTyxNQUFQLENBQUYsRUFBaUIsRUFBRSxnQkFBYyxDQUFkLEdBQWdCLDBDQUFsQixFQUE2RCxVQUFTLENBQVQsRUFBVztBQUFDLGVBQU0sY0FBWSxFQUFFLENBQUYsRUFBSSxJQUFKLEVBQVMsVUFBVCxDQUFsQjtBQUF1QyxPQUFoSCxDQUF4QjtBQUEwSSxZQUFPLENBQVA7QUFBUyxZQUFTLENBQVQsQ0FBVyxDQUFYLEVBQWEsQ0FBYixFQUFlLENBQWYsRUFBaUIsQ0FBakIsRUFBbUI7QUFBQyxhQUFTLENBQVQsR0FBWTtBQUFDLFlBQUksT0FBTyxFQUFFLEtBQVQsRUFBZSxPQUFPLEVBQUUsT0FBNUI7QUFBcUMsU0FBRyxJQUFFLEVBQUUsQ0FBRixFQUFJLFdBQUosSUFBaUIsQ0FBQyxDQUFsQixHQUFvQixDQUF0QixFQUF3QixDQUFDLEVBQUUsQ0FBRixFQUFJLFdBQUosQ0FBNUIsRUFBNkM7QUFBQyxVQUFJLElBQUUsRUFBRSxDQUFGLEVBQUksQ0FBSixDQUFOLENBQWEsSUFBRyxDQUFDLEVBQUUsQ0FBRixFQUFJLFdBQUosQ0FBSixFQUFxQixPQUFPLENBQVA7QUFBUyxVQUFJLElBQUksQ0FBSixFQUFNLENBQU4sRUFBUSxDQUFSLEVBQVUsQ0FBVixFQUFZLENBQVosRUFBYyxJQUFFLENBQUMsV0FBRCxFQUFhLE9BQWIsRUFBcUIsTUFBckIsQ0FBcEIsRUFBaUQsQ0FBQyxFQUFFLEtBQUgsSUFBVSxFQUFFLE1BQTdELEdBQXFFLElBQUUsQ0FBQyxDQUFILEVBQUssRUFBRSxPQUFGLEdBQVUsRUFBRSxFQUFFLEtBQUYsRUFBRixDQUFmLEVBQTRCLEVBQUUsS0FBRixHQUFRLEVBQUUsT0FBRixDQUFVLEtBQTlDLENBQW9ELEtBQUksSUFBRSxFQUFFLE1BQUosRUFBVyxJQUFFLENBQWpCLEVBQW1CLElBQUUsQ0FBckIsRUFBdUIsR0FBdkIsRUFBMkIsSUFBRyxJQUFFLEVBQUUsQ0FBRixDQUFGLEVBQU8sSUFBRSxFQUFFLEtBQUYsQ0FBUSxDQUFSLENBQVQsRUFBb0IsRUFBRSxDQUFGLEVBQUksR0FBSixNQUFXLElBQUUsRUFBRSxDQUFGLENBQWIsQ0FBcEIsRUFBdUMsRUFBRSxLQUFGLENBQVEsQ0FBUixNQUFhLENBQXZELEVBQXlEO0FBQUMsVUFBRyxLQUFHLEVBQUUsQ0FBRixFQUFJLFdBQUosQ0FBTixFQUF1QixPQUFPLEtBQUksU0FBTyxDQUFQLEdBQVMsQ0FBVCxHQUFXLENBQUMsQ0FBdkIsQ0FBeUIsSUFBRztBQUFDLFVBQUUsS0FBRixDQUFRLENBQVIsSUFBVyxDQUFYO0FBQWEsT0FBakIsQ0FBaUIsT0FBTSxDQUFOLEVBQVEsQ0FBRSxLQUFHLEVBQUUsS0FBRixDQUFRLENBQVIsS0FBWSxDQUFmLEVBQWlCLE9BQU8sS0FBSSxTQUFPLENBQVAsR0FBUyxDQUFULEdBQVcsQ0FBQyxDQUF2QjtBQUF5QixZQUFPLEtBQUksQ0FBQyxDQUFaO0FBQWMsWUFBUyxDQUFULENBQVcsQ0FBWCxFQUFhLENBQWIsRUFBZSxDQUFmLEVBQWlCLENBQWpCLEVBQW1CLENBQW5CLEVBQXFCO0FBQUMsUUFBSSxJQUFFLEVBQUUsTUFBRixDQUFTLENBQVQsRUFBWSxXQUFaLEtBQTBCLEVBQUUsS0FBRixDQUFRLENBQVIsQ0FBaEM7QUFBQSxRQUEyQyxJQUFFLENBQUMsSUFBRSxHQUFGLEdBQU0sRUFBRSxJQUFGLENBQU8sSUFBRSxHQUFULENBQU4sR0FBb0IsQ0FBckIsRUFBd0IsS0FBeEIsQ0FBOEIsR0FBOUIsQ0FBN0MsQ0FBZ0YsT0FBTyxFQUFFLENBQUYsRUFBSSxRQUFKLEtBQWUsRUFBRSxDQUFGLEVBQUksV0FBSixDQUFmLEdBQWdDLEVBQUUsQ0FBRixFQUFJLENBQUosRUFBTSxDQUFOLEVBQVEsQ0FBUixDQUFoQyxJQUE0QyxJQUFFLENBQUMsSUFBRSxHQUFGLEdBQU0sRUFBRSxJQUFGLENBQU8sSUFBRSxHQUFULENBQU4sR0FBb0IsQ0FBckIsRUFBd0IsS0FBeEIsQ0FBOEIsR0FBOUIsQ0FBRixFQUFxQyxFQUFFLENBQUYsRUFBSSxDQUFKLEVBQU0sQ0FBTixDQUFqRixDQUFQO0FBQWtHLFlBQVMsQ0FBVCxDQUFXLENBQVgsRUFBYSxDQUFiLEVBQWUsQ0FBZixFQUFpQjtBQUFDLFdBQU8sRUFBRSxDQUFGLEVBQUksQ0FBSixFQUFNLENBQU4sRUFBUSxDQUFSLEVBQVUsQ0FBVixDQUFQO0FBQW9CLE9BQUksSUFBRSxFQUFOO0FBQUEsTUFBUyxJQUFFLEVBQUMsVUFBUyxPQUFWLEVBQWtCLFNBQVEsRUFBQyxhQUFZLEVBQWIsRUFBZ0IsZUFBYyxDQUFDLENBQS9CLEVBQWlDLGVBQWMsQ0FBQyxDQUFoRCxFQUFrRCxhQUFZLENBQUMsQ0FBL0QsRUFBMUIsRUFBNEYsSUFBRyxFQUEvRixFQUFrRyxJQUFHLFVBQVMsQ0FBVCxFQUFXLENBQVgsRUFBYTtBQUFDLFVBQUksSUFBRSxJQUFOLENBQVcsV0FBVyxZQUFVO0FBQUMsVUFBRSxFQUFFLENBQUYsQ0FBRjtBQUFRLE9BQTlCLEVBQStCLENBQS9CO0FBQWtDLEtBQWhLLEVBQWlLLFNBQVEsVUFBUyxDQUFULEVBQVcsQ0FBWCxFQUFhLENBQWIsRUFBZTtBQUFDLFFBQUUsSUFBRixDQUFPLEVBQUMsTUFBSyxDQUFOLEVBQVEsSUFBRyxDQUFYLEVBQWEsU0FBUSxDQUFyQixFQUFQO0FBQWdDLEtBQXpOLEVBQTBOLGNBQWEsVUFBUyxDQUFULEVBQVc7QUFBQyxRQUFFLElBQUYsQ0FBTyxFQUFDLE1BQUssSUFBTixFQUFXLElBQUcsQ0FBZCxFQUFQO0FBQXlCLEtBQTVRLEVBQVg7QUFBQSxNQUF5UixZQUFVLFlBQVUsQ0FBRSxDQUEvUyxDQUFnVCxVQUFVLFNBQVYsR0FBb0IsQ0FBcEIsRUFBc0IsWUFBVSxJQUFJLFNBQUosRUFBaEMsRUFBOEMsVUFBVSxPQUFWLENBQWtCLGVBQWxCLEVBQWtDLHNCQUFxQixDQUF2RCxDQUE5QyxFQUF3RyxVQUFVLE9BQVYsQ0FBa0IsU0FBbEIsRUFBNEIsWUFBVTtBQUFDLFFBQUksSUFBRSxVQUFVLFNBQWhCLENBQTBCLE9BQU0sQ0FBQyxDQUFELEtBQUssRUFBRSxPQUFGLENBQVUsWUFBVixDQUFMLElBQThCLENBQUMsQ0FBRCxLQUFLLEVBQUUsT0FBRixDQUFVLGFBQVYsQ0FBbkMsSUFBNkQsQ0FBQyxDQUFELEtBQUssRUFBRSxPQUFGLENBQVUsZUFBVixDQUFsRSxJQUE4RixDQUFDLENBQUQsS0FBSyxFQUFFLE9BQUYsQ0FBVSxRQUFWLENBQW5HLElBQXdILENBQUMsQ0FBRCxLQUFLLEVBQUUsT0FBRixDQUFVLGVBQVYsQ0FBN0gsSUFBeUosWUFBVSxTQUFTLFFBQTVLLEdBQXFMLEVBQUUsT0FBRixJQUFXLGVBQWMsRUFBRSxPQUFoTixHQUF3TixDQUFDLENBQS9OO0FBQWlPLEdBQWxTLENBQXhHLEVBQTRZLFVBQVUsT0FBVixDQUFrQixlQUFsQixFQUFrQyxtQkFBa0IsQ0FBbEIsSUFBcUIsc0JBQXFCLENBQTVFLENBQTVZLENBQTJkLElBQUksSUFBRSxFQUFOO0FBQUEsTUFBUyxJQUFFLEVBQUUsT0FBRixDQUFVLFdBQVYsR0FBc0IsNEJBQTRCLEtBQTVCLENBQWtDLEdBQWxDLENBQXRCLEdBQTZELENBQUMsRUFBRCxFQUFJLEVBQUosQ0FBeEUsQ0FBZ0YsRUFBRSxTQUFGLEdBQVksQ0FBWixDQUFjLElBQUksSUFBRSxFQUFFLGVBQVIsQ0FBd0IsVUFBVSxPQUFWLENBQWtCLFdBQWxCLEVBQThCLGVBQWMsQ0FBNUMsR0FBK0MsVUFBVSxPQUFWLENBQWtCLGtCQUFsQixFQUFxQyxZQUFVO0FBQUMsV0FBTSw0QkFBMkIsQ0FBM0IsSUFBOEIsaUJBQWdCLENBQXBEO0FBQXNELEdBQXRHLENBQS9DLENBQXVKLElBQUksSUFBRSxVQUFRLEVBQUUsUUFBRixDQUFXLFdBQVgsRUFBZCxDQUF1QyxVQUFVLE9BQVYsQ0FBa0IsU0FBbEIsRUFBNEIsWUFBVTtBQUFDLFFBQUksSUFBRSxFQUFFLEdBQUYsRUFBTyxLQUFiLENBQW1CLE9BQU8sRUFBRSxPQUFGLEdBQVUsRUFBRSxJQUFGLENBQU8sY0FBUCxDQUFWLEVBQWlDLFNBQVMsSUFBVCxDQUFjLEVBQUUsT0FBaEIsQ0FBeEM7QUFBaUUsR0FBM0gsR0FBNkgsVUFBVSxPQUFWLENBQWtCLGtCQUFsQixFQUFxQyxZQUFVO0FBQUMsUUFBSSxJQUFFLEVBQUUsR0FBRixFQUFPLEtBQWIsQ0FBbUIsT0FBTyxFQUFFLE9BQUYsR0FBVSxxQkFBVixFQUFnQyxXQUFTLEVBQUUsYUFBbEQ7QUFBZ0UsR0FBbkksQ0FBN0gsRUFBa1EsVUFBVSxPQUFWLENBQWtCLFlBQWxCLEVBQStCLFlBQVU7QUFBQyxRQUFJLElBQUUsRUFBRSxHQUFGLEVBQU8sS0FBYixDQUFtQixJQUFHO0FBQUMsUUFBRSxRQUFGLEdBQVcsTUFBWDtBQUFrQixLQUF0QixDQUFzQixPQUFNLENBQU4sRUFBUSxDQUFFLFFBQU0sT0FBTSxJQUFOLENBQVcsRUFBRSxRQUFiO0FBQU47QUFBNkIsR0FBMUgsQ0FBbFEsQ0FBOFgsSUFBSSxJQUFFLEVBQUUsVUFBRixHQUFhLENBQW5CLENBQXFCLFVBQVUsT0FBVixDQUFrQixhQUFsQixFQUFnQyxZQUFVO0FBQUMsUUFBSSxDQUFKLENBQU0sSUFBRyxrQkFBaUIsQ0FBakIsSUFBb0IsRUFBRSxhQUFGLElBQWlCLGFBQWEsYUFBckQsRUFBbUUsSUFBRSxDQUFDLENBQUgsQ0FBbkUsS0FBNEU7QUFBQyxVQUFJLElBQUUsQ0FBQyxVQUFELEVBQVksRUFBRSxJQUFGLENBQU8sa0JBQVAsQ0FBWixFQUF1QyxRQUF2QyxFQUFnRCxHQUFoRCxFQUFvRCx5Q0FBcEQsRUFBK0YsSUFBL0YsQ0FBb0csRUFBcEcsQ0FBTixDQUE4RyxFQUFFLENBQUYsRUFBSSxVQUFTLENBQVQsRUFBVztBQUFDLFlBQUUsTUFBSSxFQUFFLFNBQVI7QUFBa0IsT0FBbEM7QUFBb0MsWUFBTyxDQUFQO0FBQVMsR0FBelIsRUFBMlIsSUFBSSxJQUFFLGlCQUFOO0FBQUEsTUFBd0IsSUFBRSxFQUFFLE9BQUYsQ0FBVSxXQUFWLEdBQXNCLEVBQUUsS0FBRixDQUFRLEdBQVIsQ0FBdEIsR0FBbUMsRUFBN0QsQ0FBZ0UsRUFBRSxjQUFGLEdBQWlCLENBQWpCLENBQW1CLElBQUksSUFBRSxVQUFTLENBQVQsRUFBVztBQUFDLFFBQUksQ0FBSjtBQUFBLFFBQU0sSUFBRSxFQUFFLE1BQVY7QUFBQSxRQUFpQixJQUFFLEVBQUUsT0FBckIsQ0FBNkIsSUFBRyxlQUFhLE9BQU8sQ0FBdkIsRUFBeUIsT0FBTyxDQUFQLENBQVMsSUFBRyxDQUFDLENBQUosRUFBTSxPQUFNLENBQUMsQ0FBUCxDQUFTLElBQUcsSUFBRSxFQUFFLE9BQUYsQ0FBVSxJQUFWLEVBQWUsRUFBZixDQUFGLEVBQXFCLElBQUUsRUFBRSxPQUFGLENBQVUsSUFBVixFQUFlLEdBQWYsRUFBb0IsV0FBcEIsS0FBa0MsT0FBekQsRUFBaUUsS0FBSyxDQUF6RSxFQUEyRSxPQUFNLE1BQUksQ0FBVixDQUFZLEtBQUksSUFBSSxJQUFFLENBQVYsRUFBWSxJQUFFLENBQWQsRUFBZ0IsR0FBaEIsRUFBb0I7QUFBQyxVQUFJLElBQUUsRUFBRSxDQUFGLENBQU47QUFBQSxVQUFXLElBQUUsRUFBRSxXQUFGLEtBQWdCLEdBQWhCLEdBQW9CLENBQWpDLENBQW1DLElBQUcsS0FBSyxDQUFSLEVBQVUsT0FBTSxPQUFLLEVBQUUsV0FBRixFQUFMLEdBQXFCLEdBQXJCLEdBQXlCLENBQS9CO0FBQWlDLFlBQU0sQ0FBQyxDQUFQO0FBQVMsR0FBblMsQ0FBb1MsRUFBRSxNQUFGLEdBQVMsQ0FBVCxDQUFXLElBQUksSUFBRSxFQUFFLE9BQUYsQ0FBVSxXQUFWLEdBQXNCLEVBQUUsV0FBRixHQUFnQixLQUFoQixDQUFzQixHQUF0QixDQUF0QixHQUFpRCxFQUF2RCxDQUEwRCxFQUFFLFlBQUYsR0FBZSxDQUFmLENBQWlCLElBQUksSUFBRSxFQUFDLE1BQUssRUFBRSxXQUFGLENBQU4sRUFBTixDQUE0QixVQUFVLEVBQVYsQ0FBYSxJQUFiLENBQWtCLFlBQVU7QUFBQyxXQUFPLEVBQUUsSUFBVDtBQUFjLEdBQTNDLEVBQTZDLElBQUksSUFBRSxFQUFDLE9BQU0sRUFBRSxJQUFGLENBQU8sS0FBZCxFQUFOLENBQTJCLFVBQVUsRUFBVixDQUFhLE9BQWIsQ0FBcUIsWUFBVTtBQUFDLFdBQU8sRUFBRSxLQUFUO0FBQWUsR0FBL0MsR0FBaUQsRUFBRSxZQUFGLEdBQWUsQ0FBaEUsQ0FBa0UsSUFBSSxJQUFFLEVBQUUsUUFBRixHQUFXLFVBQVMsQ0FBVCxFQUFXLENBQVgsRUFBYSxDQUFiLEVBQWU7QUFBQyxXQUFPLE1BQUksRUFBRSxPQUFGLENBQVUsR0FBVixDQUFKLEdBQW1CLEVBQUUsQ0FBRixDQUFuQixJQUF5QixDQUFDLENBQUQsSUFBSSxFQUFFLE9BQUYsQ0FBVSxHQUFWLENBQUosS0FBcUIsSUFBRSxFQUFFLENBQUYsQ0FBdkIsR0FBNkIsSUFBRSxFQUFFLENBQUYsRUFBSSxDQUFKLEVBQU0sQ0FBTixDQUFGLEdBQVcsRUFBRSxDQUFGLEVBQUksS0FBSixDQUFqRSxDQUFQO0FBQW9GLEdBQXJILENBQXNILFVBQVUsT0FBVixDQUFrQix1QkFBbEIsRUFBMEMsQ0FBQyxDQUFDLEVBQUUsdUJBQUYsRUFBMEIsQ0FBMUIsQ0FBNUMsRUFBeUUsRUFBQyxTQUFRLENBQUMsS0FBRCxDQUFULEVBQXpFLEdBQTRGLFVBQVUsT0FBVixDQUFrQixZQUFsQixFQUErQixDQUFDLENBQUMsRUFBRSxZQUFGLEVBQWUsQ0FBZixDQUFqQyxDQUE1RixFQUFnSixFQUFFLFlBQUYsR0FBZSxDQUEvSixFQUFpSyxVQUFVLE9BQVYsQ0FBa0IsZUFBbEIsRUFBa0MsRUFBRSxlQUFGLEVBQWtCLEdBQWxCLEVBQXNCLENBQUMsQ0FBdkIsQ0FBbEMsQ0FBakssRUFBOE4sVUFBVSxPQUFWLENBQWtCLGVBQWxCLEVBQWtDLFlBQVU7QUFBQyxXQUFNLENBQUMsQ0FBRCxLQUFLLFVBQVUsU0FBVixDQUFvQixPQUFwQixDQUE0QixZQUE1QixDQUFMLElBQWdELEVBQUUsV0FBRixFQUFjLFVBQWQsRUFBeUIsQ0FBQyxDQUExQixDQUF0RDtBQUFtRixHQUFoSSxDQUE5TixFQUFnVyxHQUFoVyxFQUFvVyxPQUFPLEVBQUUsT0FBN1csRUFBcVgsT0FBTyxFQUFFLFlBQTlYLENBQTJZLEtBQUksSUFBSSxJQUFFLENBQVYsRUFBWSxJQUFFLFVBQVUsRUFBVixDQUFhLE1BQTNCLEVBQWtDLEdBQWxDLEVBQXNDLFVBQVUsRUFBVixDQUFhLENBQWIsSUFBa0IsRUFBRSxTQUFGLEdBQVksU0FBWjtBQUFzQixDQUFsbE0sQ0FBbWxNLE1BQW5sTSxFQUEwbE0sUUFBMWxNLENBQUQ7Ozs7O0FDRkEsUUFBUSxHQUFSLENBQVksMjFCQUFaO0FBQ0EsUUFBUSxHQUFSLENBQVksMERBQVo7Ozs7Ozs7OztRQ01nQixXLEdBQUEsVztRQVdBLEksR0FBQSxJO1FBS0EsSSxHQUFBLEk7UUFLQSxNLEdBQUEsTTtRQU9BLE8sR0FBQSxPO1FBS0EsTyxHQUFBLE87O0FBbkNoQjs7QUFFTyxTQUFTLFdBQVQsQ0FBcUIsUUFBckIsRUFBK0I7QUFDcEMsTUFBSSxNQUFNLElBQVY7QUFDQSxPQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksU0FBUyxNQUE3QixFQUFxQyxLQUFLLENBQTFDLEVBQTZDO0FBQzNDLFVBQU0sVUFBVSxTQUFTLENBQVQsQ0FBaEI7QUFDQSxVQUFNLGFBQWEsT0FBTyxTQUFQLENBQWlCLE9BQWpCLENBQW5CO0FBQ0E7QUFDQSxVQUFNLE9BQU8sVUFBYjtBQUNEO0FBQ0QsU0FBTyxHQUFQO0FBQ0QsQyxDQWhCRDtBQUNBOztBQUVBOztBQWVPLFNBQVMsSUFBVCxDQUFjLEVBQWQsRUFBa0I7QUFDdkIsS0FBRyxLQUFILENBQVMsT0FBVCxHQUFtQixPQUFuQjtBQUNBLEtBQUcsS0FBSCxDQUFTLFVBQVQsR0FBc0IsU0FBdEI7QUFDRDs7QUFFTSxTQUFTLElBQVQsQ0FBYyxFQUFkLEVBQWtCO0FBQ3ZCLEtBQUcsS0FBSCxDQUFTLE9BQVQsR0FBbUIsTUFBbkI7QUFDQSxLQUFHLEtBQUgsQ0FBUyxVQUFULEdBQXNCLFFBQXRCO0FBQ0Q7O0FBRU0sU0FBUyxNQUFULENBQWdCLEVBQWhCLEVBQW9CO0FBQ3pCLEtBQUcsS0FBSCxDQUFTLE9BQVQsR0FBbUIsRUFBbkI7QUFDQSxLQUFHLEtBQUgsQ0FBUyxVQUFULEdBQXNCLEVBQXRCO0FBQ0Q7O0FBRU0sTUFBTSwwQkFBUyxNQUFmOztBQUVBLFNBQVMsT0FBVCxDQUFpQixFQUFqQixFQUFxQixRQUFyQixFQUErQjtBQUNwQyxTQUFPLENBQUMsR0FBRyxPQUFILElBQWMsR0FBRyxlQUFqQixJQUFvQyxHQUFHLGlCQUF2QyxJQUE0RCxHQUFHLGtCQUEvRCxJQUNOLEdBQUcscUJBREcsSUFDc0IsR0FBRyxnQkFEMUIsRUFDNEMsSUFENUMsQ0FDaUQsRUFEakQsRUFDcUQsUUFEckQsQ0FBUDtBQUVEOztBQUVNLFNBQVMsT0FBVCxDQUFpQixFQUFqQixFQUFxQixTQUFyQixFQUFnQyxPQUFoQyxFQUF5QztBQUM5QyxTQUFPLHVCQUFXLE1BQVgsQ0FBbUIsUUFBRCxJQUFjO0FBQ3JDLFVBQU0sT0FBTyxHQUFHLE9BQUgsQ0FBVyxTQUFYLEVBQXNCLE9BQXRCLENBQWI7O0FBRUEsU0FBSyxnQkFBTCxDQUFzQixRQUF0QixFQUFpQyxDQUFELElBQU87QUFDckMsZUFBUyxJQUFULENBQWMsQ0FBZDtBQUNBLGVBQVMsUUFBVDtBQUNELEtBSEQ7O0FBS0EsV0FBTyxNQUFNO0FBQ1g7QUFDRCxLQUZEO0FBR0QsR0FYTSxDQUFQO0FBWUQ7Ozs7Ozs7OztBQ3pDRDs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOzs7O0FBdkJBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztBQXNCQSxNQUFNLEVBQUUsSUFBRixLQUFXLE1BQU0sU0FBdkI7O0FBRUEsTUFBTSxvQkFBb0IsR0FBMUI7O0FBRUEsU0FBUyxXQUFULENBQXFCLEVBQUUsUUFBUSxNQUFWLEtBQXFCLEVBQTFDLEVBQThDO0FBQzVDLE9BQUssS0FBTCxDQUFXLENBQVgsRUFBYyxLQUFkLENBQW9CLEtBQXBCLEdBQTRCLEtBQTVCLENBRDRDLENBQ1Q7QUFDbkMsT0FBSyxLQUFMLENBQVcsQ0FBWCxFQUFjLEtBQWQsQ0FBb0IsV0FBcEIsR0FBa0MscUJBQU0sS0FBTixFQUFhLElBQWIsQ0FBa0IsaUJBQWxCLEVBQXFDLE1BQXJDLEVBQWxDO0FBQ0EsT0FBSyxLQUFMLENBQVcsQ0FBWCxFQUFjLEtBQWQsQ0FBb0IsV0FBcEIsR0FBa0MsS0FBbEM7QUFDQSxPQUFLLEtBQUwsQ0FBVyxDQUFYLEVBQWMsS0FBZCxDQUFvQixZQUFwQixHQUFtQyxLQUFuQyxDQUo0QyxDQUlGO0FBQzFDLE9BQUssS0FBTCxDQUFXLENBQVgsRUFBYyxLQUFkLENBQW9CLGVBQXBCLEdBQXNDLEtBQXRDLENBTDRDLENBS0M7QUFDOUM7O0FBRWMsTUFBTSxVQUFOLENBQWlCO0FBQzlCLGNBQVksRUFBRSxRQUFGLEVBQVosRUFBMEI7QUFBQTs7QUFDeEIsVUFBTSxPQUFPLFNBQVMsY0FBVCxDQUF3QixPQUF4QixDQUFiO0FBQ0EsVUFBTSxZQUFZLFNBQVMsY0FBVCxDQUF3QixZQUF4QixDQUFsQjtBQUNBLFVBQU0sYUFBYSxxQkFBUyxXQUFULEVBQXNCLElBQXRCLGlCQUEyQixNQUFNLEdBQUcsU0FBSCxLQUFpQixTQUFsRCxDQUFuQjs7QUFFQSxTQUFLLE9BQUwsR0FBZSxTQUFTLGNBQVQsQ0FBd0IsVUFBeEIsQ0FBZjs7QUFFQSxTQUFLLFFBQUwsR0FBZ0IsUUFBaEI7QUFDQSxTQUFLLEtBQUwsR0FBYSxXQUFXLFFBQVgsSUFBdUIsV0FBVyxLQUEvQztBQUNBLFNBQUssU0FBTCxHQUFpQixLQUFLLFlBQUwsQ0FBa0IsWUFBbEIsQ0FBakI7QUFDQSxTQUFLLFNBQUwsR0FBaUIsS0FBSyxZQUFMLENBQWtCLFlBQWxCLENBQWpCO0FBQ0Q7O0FBRUQsYUFBVyxPQUFYLEVBQW9CO0FBQUE7O0FBQ2xCLFVBQU0sRUFBRSxLQUFGLEVBQVMsS0FBVCxLQUFtQixPQUF6Qjs7QUFFQSxRQUFJLFVBQVUsS0FBSyxTQUFmLElBQTRCLFVBQVUsS0FBSyxTQUEvQyxFQUEwRDtBQUN4RCxhQUFPLHlDQUFQO0FBQ0Q7O0FBRUQsUUFBSSxJQUFKOztBQUVBLFFBQUksVUFBVSxFQUFWLElBQWdCLFVBQVUsS0FBSyxTQUFuQyxFQUE4QztBQUM1QyxhQUFPLDBDQUFrQixLQUFLLFFBQXZCLENBQVA7QUFDRCxLQUZELE1BRU87QUFBQTs7QUFDTCxZQUFNLFNBQVMsSUFBSSxLQUFKLEVBQWY7O0FBRUEsYUFBTyw0RUFBc0IsTUFBdEIsRUFBOEIsTUFBOUIsa0NBQ0ssMENBQWtCLEtBQUssUUFBdkIsQ0FETCxFQUN1QyxLQUFLLENBRDVDLHNDQUVLLE1BQU07QUFBRSxlQUFPLEdBQVAsR0FBYSxFQUFiO0FBQWtCLE9BRi9CLENBQVA7O0FBSUEsYUFBTyxHQUFQLEdBQWEsS0FBYjtBQUNEOztBQUVELFdBQU8seURBQ0ksTUFBTTtBQUNQLGlCQUFOLFlBQWtCLE9BQWxCO0FBQ0EsV0FBSyxTQUFMLEdBQWlCLEtBQWpCO0FBQ0EsV0FBSyxTQUFMLEdBQWlCLEtBQWpCO0FBQ0QsS0FMSSw2QkFNQyxNQUFNO0FBQ1YsWUFBTSxNQUFNLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUFaO0FBQ0EsVUFBSSxTQUFKLENBQWMsR0FBZCxDQUFrQixZQUFsQjtBQUNBLFVBQUksS0FBSixDQUFVLGVBQVYsR0FBNEIsS0FBNUI7QUFDQSxVQUFJLFVBQVUsRUFBZCxFQUFrQixJQUFJLEtBQUosQ0FBVSxlQUFWLEdBQTZCLE9BQU0sS0FBTSxHQUF6QztBQUNsQixhQUFPLEdBQVA7QUFDRCxLQVpJLENBQVA7QUFhRDs7QUFFRCxZQUFVLENBQUMsT0FBRCxFQUFVLEdBQVYsQ0FBVixFQUEwQjtBQUFBOztBQUN4QixZQUFRLFVBQVIsQ0FBbUIsWUFBbkIsQ0FBZ0MsR0FBaEMsRUFBcUMsUUFBUSxrQkFBN0M7O0FBRUEsV0FBTyxrQ0FBUSxHQUFSLEVBQWEsQ0FDbEIsRUFBRSxTQUFTLENBQVgsRUFEa0IsRUFFbEIsRUFBRSxTQUFTLENBQVgsRUFGa0IsQ0FBYixFQUdKO0FBQ0QsZ0JBQVUsS0FBSztBQUNmO0FBRkMsS0FISSxzQ0FPRyxNQUFNLFFBQVEsVUFBUixDQUFtQixXQUFuQixDQUErQixPQUEvQixDQVBULENBQVA7QUFRRDtBQTdENkI7a0JBQVgsVTs7Ozs7QUNoQ3JCOzs7O0FBRUE7Ozs7QUFQQTtBQUNBOztBQUVBOztBQU1BLE1BQU0sZUFBZSxDQUNuQixlQURtQixFQUVuQixlQUZtQixFQUduQixZQUhtQixFQUluQix1QkFKbUIsRUFLbkIsV0FMbUIsRUFNbkIsU0FObUIsRUFPbkIsZUFQbUIsRUFRbkIsa0JBUm1CLEVBU25CLFlBVG1CLENBQXJCOztBQVlBLE1BQU0sY0FBYyxtQkFBcEI7O0FBRUEsU0FBUyxjQUFULEdBQTBCO0FBQ3hCLFFBQU0sYUFBYSxPQUFPLFNBQVAsS0FBcUIsT0FBTyxVQUFQLENBQWtCLFdBQWxCLEVBQStCLE9BQXZFO0FBQ0EsTUFBSSxVQUFKLEVBQWdCO0FBQ2QsV0FBTyxTQUFQLEdBQW1CLENBQUMsT0FBTyxTQUEzQjtBQUNBLFdBQU8sTUFBUCxDQUFjLFVBQWQsR0FBMkIsT0FBTyxTQUFsQztBQUNBLFdBQU8sTUFBUCxDQUFjLE1BQWQsQ0FBcUIsT0FBTyxTQUE1QjtBQUNEO0FBQ0Y7O0FBRUQsU0FBUyxrQkFBVCxDQUE0QixDQUE1QixFQUErQjtBQUM3QixNQUFJLENBQUMsT0FBTyxTQUFaLEVBQXVCO0FBQ3JCLE1BQUUsY0FBRjtBQUNBLFdBQU8sTUFBUCxDQUFjLE1BQWQ7QUFDRDtBQUNGOztBQUVELFNBQVMsaUJBQVQsQ0FBMkIsTUFBM0IsRUFBbUM7QUFDakMsU0FBTyxNQUFQLEdBQWdCLE1BQWhCO0FBQ0EsU0FBTyxnQkFBUCxDQUF3QixRQUF4QixFQUFrQyxjQUFsQztBQUNBLFdBQVMsY0FBVCxDQUF3QixPQUF4QixFQUFpQyxnQkFBakMsQ0FBa0QsT0FBbEQsRUFBMkQsa0JBQTNEO0FBQ0Q7O0FBRUQsSUFBSSxDQUFDLE9BQU8sYUFBUixJQUF5Qix5QkFBWSxZQUFaLENBQTdCLEVBQXdEO0FBQ3RELFNBQU8sU0FBUCxHQUFtQixPQUFPLFVBQVAsQ0FBa0IsV0FBbEIsRUFBK0IsT0FBbEQ7QUFDQSxRQUFNLFNBQVMsU0FBUyxjQUFULENBQXdCLFVBQXhCLENBQWY7O0FBRUEsb0JBQWtCLHNCQUFZLE1BQVosRUFBb0I7QUFDcEMsWUFBUSxPQUFPLFNBRHFCO0FBRXBDLGdCQUFZLE9BQU8sU0FGaUI7QUFHcEMsd0JBQW9CO0FBSGdCLEdBQXBCLENBQWxCOztBQU1BLFNBQU8sU0FBUCxDQUFpQixHQUFqQixDQUFxQixRQUFyQjtBQUNEOzs7Ozs7Ozs7QUNoREQ7O0FBQ0E7O0FBVEE7QUFDQTs7QUFFQTs7Ozs7QUFRZSxNQUFNLElBQU4sQ0FBVztBQUN4QixTQUFPLE1BQVAsQ0FBYyxJQUFkLEVBQW9CLEdBQUcsSUFBdkIsRUFBNkI7QUFDM0IsV0FBTyxLQUFLLEtBQUwsQ0FBVyxJQUFYLEtBQW9CLElBQXBCLEdBQ0wsSUFBSSxLQUFLLEtBQUwsQ0FBVyxJQUFYLENBQUosQ0FBcUIsR0FBRyxJQUF4QixDQURLLEdBRUwsSUFBSSxJQUFKLENBQVMsR0FBRyxJQUFaLENBRkY7QUFHRDs7QUFFRCxjQUFZLEVBQUUsYUFBRixFQUFpQixRQUFqQixFQUFaLEVBQXlDO0FBQ3ZDLFNBQUssYUFBTCxHQUFxQixhQUFyQjtBQUNBLFNBQUssUUFBTCxHQUFnQixRQUFoQjtBQUNEOztBQUVELFVBQVE7QUFDTjtBQUNBLFNBQUssYUFBTCxDQUFtQixLQUFuQixDQUF5QixPQUF6QixHQUFtQyxDQUFuQztBQUNBLFNBQUssYUFBTCxDQUFtQixLQUFuQixDQUF5QixVQUF6QixHQUFzQyxFQUF0Qzs7QUFFQSxXQUFPLHlDQUFQO0FBQ0Q7O0FBRUQsVUFBUTtBQUNOLFdBQU8seUNBQVA7QUFDRDtBQXRCdUI7O2tCQUFMLEk7QUF5QnJCLEtBQUssS0FBTCxHQUFhLEVBQWI7Ozs7O0FDeEJBOztBQUNBOztBQUVBOztBQUNBOztBQUVBOztBQUNBOzs7Ozs7QUFuQkE7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FBa0JBLE1BQU0saUJBQWlCLDBCQUF2Qjs7QUFFQSxNQUFNLFNBQU4sd0JBQTZCO0FBQzNCLFFBQU0sYUFBTixFQUFxQjtBQUFBOztBQUNuQixVQUFNLFFBQVEsU0FBUyxhQUFULENBQXVCLElBQXZCLENBQWQ7O0FBRUEsVUFBTSxTQUFOLENBQWdCLEdBQWhCLENBQW9CLFlBQXBCO0FBQ0EsVUFBTSxXQUFOLEdBQW9CLGNBQWMsV0FBbEM7QUFDQSxVQUFNLEtBQU4sQ0FBWSxlQUFaLEdBQThCLFVBQTlCOztBQUVBLFNBQUssYUFBTCxDQUFtQixhQUFuQixDQUFpQyxPQUFqQyxFQUEwQyxTQUExQyxHQUFzRCxFQUF0RDtBQUNBLFNBQUssYUFBTCxDQUFtQixhQUFuQixDQUFpQyxPQUFqQyxFQUEwQyxXQUExQyxDQUFzRCxLQUF0RDtBQUNBLFNBQUssYUFBTCxDQUFtQixLQUFuQixDQUF5QixRQUF6QixHQUFvQyxPQUFwQztBQUNBLFNBQUssYUFBTCxDQUFtQixLQUFuQixDQUF5QixPQUF6QixHQUFtQyxDQUFuQzs7QUFFQSxVQUFNLFFBQVEsY0FBYyxxQkFBZCxFQUFkO0FBQ0EsVUFBTSxnQkFBZ0IsU0FBUyxpQkFBaUIsYUFBakIsRUFBZ0MsUUFBekMsRUFBbUQsRUFBbkQsQ0FBdEI7QUFDQSxVQUFNLE9BQU8sTUFBTSxxQkFBTixFQUFiO0FBQ0EsVUFBTSxlQUFlLFNBQVMsaUJBQWlCLEtBQWpCLEVBQXdCLFFBQWpDLEVBQTJDLEVBQTNDLENBQXJCOztBQUVBLFVBQU0sVUFBVSxNQUFNLElBQU4sR0FBYSxLQUFLLElBQWxDO0FBQ0EsVUFBTSxVQUFVLE1BQU0sR0FBTixHQUFZLEtBQUssR0FBakM7QUFDQSxVQUFNLGNBQWMsZ0JBQWdCLFlBQXBDOztBQUVBLGtCQUFjLEtBQWQsQ0FBb0IsT0FBcEIsR0FBOEIsQ0FBOUI7O0FBRUEsV0FBTyxpQ0FBUSxLQUFSLEVBQWUsQ0FDcEIsRUFBRSxXQUFZLGVBQWMsT0FBUSxPQUFNLE9BQVEsZ0JBQWUsV0FBWSxHQUE3RSxFQURvQixFQUVwQixFQUFFLFdBQVcsK0JBQWIsRUFGb0IsQ0FBZixFQUdKO0FBQ0QsZ0JBQVUsS0FBSyxRQURkO0FBRUQ7QUFDQSxjQUFRO0FBSFAsS0FISSwyQkFRSSxNQUFNO0FBQUUsV0FBSyxhQUFMLENBQW1CLEtBQW5CLENBQXlCLFFBQXpCLEdBQW9DLFVBQXBDO0FBQWlELEtBUjdELENBQVA7QUFTRDs7QUFFRCxRQUFNLElBQU4sRUFBWTtBQUFBOztBQUNWLFNBQUssYUFBTCxDQUFtQixLQUFuQixDQUF5QixVQUF6QixHQUFzQyxTQUF0Qzs7QUFFQSxVQUFNLFFBQVEsS0FBSyxhQUFMLENBQW1CLGNBQW5CLENBQWQ7O0FBRUEsUUFBSSxTQUFTLElBQWIsRUFBbUI7QUFDakIsWUFBTSxLQUFOLENBQVksT0FBWixHQUFzQixDQUF0QjtBQUNBLFlBQU0sS0FBTixDQUFZLFVBQVosR0FBeUIsU0FBekI7QUFDRDs7QUFFRDtBQUNBLFdBQU8sb0VBQWtCLEtBQUssUUFBTCxHQUFnQixHQUFsQyw0QkFDSSxNQUFNO0FBQ2IsVUFBSSxTQUFTLElBQWIsRUFBbUI7QUFDakIsY0FBTSxLQUFOLENBQVksT0FBWixHQUFzQixDQUF0QjtBQUNBLGNBQU0sS0FBTixDQUFZLFVBQVosR0FBeUIsRUFBekI7QUFDRDtBQUNGLEtBTkksc0NBT0ssTUFBTTtBQUNkLFdBQUssYUFBTCxDQUFtQixLQUFuQixDQUF5QixPQUF6QixHQUFtQyxDQUFuQztBQUNBLFdBQUssYUFBTCxDQUFtQixLQUFuQixDQUF5QixVQUF6QixHQUFzQyxFQUF0QztBQUNELEtBVkksQ0FBUDtBQVdEO0FBekQwQjs7QUE0RDdCLGVBQUssS0FBTCxDQUFXLEtBQVgsR0FBbUIsU0FBbkI7Ozs7O0FDckVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOzs7Ozs7OztrQkNzQndCLGlCOztBQTlDeEI7Ozs7QUFFQTs7OztBQVBBO0FBQ0E7O0FBRUE7O0FBTUEsTUFBTSxlQUFlLENBQ25CLGVBRG1CLEVBRW5CLGVBRm1CLENBQXJCOztBQUtBLFNBQVMsaUJBQVQsQ0FBMkIsVUFBM0IsRUFBdUM7QUFDckMsUUFBTSxTQUFOLENBQWdCLE9BQWhCLENBQXdCLElBQXhCLENBQTZCLFVBQTdCLEVBQTBDLEVBQUQsSUFBUTtBQUMvQyxPQUFHLEtBQUgsQ0FBUyxVQUFULEdBQXNCLFNBQXRCLENBRCtDLENBQ2Q7QUFDbEMsR0FGRDtBQUdEOztBQUVELFNBQVMsZ0JBQVQsQ0FBMEIsRUFBMUIsRUFBOEIsR0FBOUIsRUFBbUM7QUFDakMsS0FBRyxTQUFILEdBQWUsZ0JBQU0sY0FBTixDQUFxQixHQUFyQixFQUEwQjtBQUN2QyxpQkFBYSxHQUFHLElBQUgsS0FBWTtBQURjLEdBQTFCLENBQWY7QUFHRDs7QUFFRCxTQUFTLFdBQVQsQ0FBcUIsRUFBckIsRUFBeUIsR0FBekIsRUFBOEI7QUFDNUIsTUFBSTtBQUNGLFVBQU0sT0FBTyxHQUFHLHNCQUFoQjtBQUNBLHFCQUFpQixFQUFqQixFQUFxQixHQUFyQjtBQUNBLFFBQUksUUFBUSxxQkFBUSxJQUFSLEVBQWMsa0JBQWQsQ0FBWixFQUErQyxrQkFBSyxJQUFMO0FBQ2hELEdBSkQsQ0FJRSxPQUFPLENBQVAsRUFBVTtBQUNWO0FBQ0EsWUFBUSxLQUFSLENBQWMsQ0FBZCxFQUZVLENBRVE7QUFDbkIsR0FQRCxTQU9VO0FBQ1IsT0FBRyxLQUFILENBQVMsVUFBVCxHQUFzQixFQUF0QjtBQUNEO0FBQ0Y7O0FBRUQsU0FBUyxhQUFULENBQXVCLEVBQXZCLEVBQTJCO0FBQ3pCLFNBQU8sR0FBRyxXQUFILENBQWUsT0FBZixDQUF1QixhQUF2QixFQUFzQyxFQUF0QyxFQUEwQyxPQUExQyxDQUFrRCxNQUFsRCxFQUEwRCxFQUExRCxDQUFQO0FBQ0Q7O0FBRUQsU0FBUyxhQUFULENBQXVCLFVBQXZCLEVBQW1DO0FBQ2pDO0FBQ0EsUUFBTSxTQUFOLENBQWdCLE9BQWhCLENBQXdCLElBQXhCLENBQTZCLFVBQTdCLEVBQTBDLE1BQUQsSUFBWTtBQUNuRCxVQUFNLE1BQU0sY0FBYyxNQUFkLENBQVo7QUFDQSxnQkFBWSxNQUFaLEVBQW9CLEdBQXBCO0FBQ0QsR0FIRDtBQUlEOztBQUVjLFNBQVMsaUJBQVQsR0FBNkI7QUFDMUMsTUFBSSx5QkFBWSxZQUFaLENBQUosRUFBK0I7QUFDN0IsVUFBTSxhQUFhLFNBQVMsZ0JBQVQsQ0FBMEIsMEJBQTFCLENBQW5CO0FBQ0EsUUFBSSxXQUFXLE1BQWYsRUFBdUI7QUFDckIsd0JBQWtCLFVBQWxCO0FBQ0Esb0JBQWMsVUFBZDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxJQUFJLHlCQUFZLFlBQVosQ0FBSixFQUErQjtBQUM3QjtBQUNBLFFBQU0sTUFBTSxTQUFTLG9CQUFULENBQThCLE9BQTlCLEVBQXVDLENBQXZDLENBQVo7QUFDQSxRQUFNLFFBQVEsUUFBUSxrREFBUixFQUE0RCxHQUE1RCxDQUFkO0FBQ0EsUUFBTSxnQkFBTixDQUF1QixNQUF2QixFQUErQixpQkFBL0I7QUFDRDs7Ozs7QUN2REQ7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7Ozs7QUFDQTs7OztBQUVBOztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQUNBOzs7O0FBcENBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FBbUNBLE1BQU0sZUFBZSxDQUNuQixlQURtQixFQUVuQixlQUZtQixFQUduQix1QkFIbUIsRUFJbkIsV0FKbUIsRUFLbkIsa0JBTG1CLEVBTW5CLFNBTm1CLEVBT25CLFNBUG1CLEVBUW5CLGVBUm1CLENBQXJCOztBQVdBLE1BQU0sV0FBVyxHQUFqQjtBQUNBLE1BQU0sZ0JBQWdCLEdBQXRCOztBQUVBO0FBQ0E7QUFDQSxTQUFTLGVBQVQsR0FBMkI7QUFDekIsU0FBTyx5QkFBYyxDQUFDLEtBQUQsRUFBUSxNQUFSLEtBQW1CO0FBQ3RDLFlBQVEsS0FBUixDQUFjLEtBQWQsRUFEc0MsQ0FDaEI7QUFDdEIsV0FBTyxNQUFQO0FBQ0QsR0FITSxDQUFQO0FBSUQ7O0FBRUQsSUFBSSxDQUFDLE9BQU8sZ0JBQVIsSUFBNEIseUJBQVksWUFBWixDQUFoQyxFQUEyRDtBQUFBOztBQUN6RCxRQUFNLEtBQUssVUFBVSxTQUFWLENBQW9CLFdBQXBCLEVBQVg7QUFDQSxRQUFNLFdBQVcsR0FBRyxPQUFILENBQVcsUUFBWCxJQUF1QixDQUF2QixJQUE0QixHQUFHLE9BQUgsQ0FBVyxRQUFYLElBQXVCLENBQXBFOztBQUVBLFFBQU0sYUFBYSx5QkFBZSxFQUFFLFVBQVUsYUFBWixFQUFmLENBQW5COztBQUVBLFFBQU0sWUFBWSxTQUFTLGNBQVQsQ0FBd0IsYUFBeEIsQ0FBbEI7O0FBRUEsUUFBTSxnQkFBZ0IsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQXRCO0FBQ0EsZ0JBQWMsU0FBZCxDQUF3QixHQUF4QixDQUE0QixnQkFBNUI7QUFDQSxnQkFBYyxTQUFkLENBQXdCLEdBQXhCLENBQTRCLFdBQTVCO0FBQ0EsZ0JBQWMsU0FBZCxHQUEyQjs7O1dBQTNCO0FBSUEsWUFBVSxVQUFWLENBQXFCLFlBQXJCLENBQWtDLGFBQWxDLEVBQWlELFNBQWpEOztBQUVBLFFBQU0sVUFBVSxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBaEI7QUFDQSxVQUFRLFNBQVIsQ0FBa0IsR0FBbEIsQ0FBc0IsU0FBdEI7QUFDQSxVQUFRLFNBQVIsR0FBcUI7Ozs7Ozs7O0dBQXJCO0FBU0EsV0FBUyxhQUFULENBQXVCLGtCQUF2QixFQUEyQyxXQUEzQyxDQUF1RCxPQUF2RDs7QUFFQSxRQUFNLFNBQVMsa0dBQXNCLFNBQXRCLEVBQWlDLG9CQUFqQyw0QkFDUCxDQUFDLEVBQUUsTUFBRixFQUFELEtBQWdCLE1BRFQsNEJBRVAsVUFBVSxDQUFDLE1BQUQsRUFBUyxTQUFTLGNBQVQsQ0FBd0IsT0FBeEIsQ0FBVCxDQUZILDJCQUdKLE1BQU07QUFDYjtBQUNBLFFBQUksQ0FBQyxPQUFPLFNBQVIsSUFBcUIsT0FBTyxNQUFQLENBQWMsTUFBdkMsRUFBK0M7QUFDN0MsYUFBTyxNQUFQLENBQWMsS0FBZDtBQUNEO0FBQ0YsR0FSWSwrQkFBZjs7QUFXQSxRQUFNLFNBQVMsMEVBQXNCLFNBQXRCLEVBQWlDLG9CQUFqQyw0QkFDUCxDQUFDLEVBQUUsTUFBRixFQUFELEtBQWdCLE1BRFQsK0JBQWY7O0FBSUEsUUFBTSxZQUFZLDhEQUFzQixTQUF0QixFQUFpQyx1QkFBakMsNEJBQ1YsQ0FBQyxFQUFFLE1BQUYsRUFBRCxLQUFnQixNQUROLENBQWxCO0FBRUU7O0FBRUYsUUFBTSxTQUFTLDBFQUFzQixTQUF0QixFQUFpQyxvQkFBakMsNEJBQ1AsQ0FBQyxFQUFFLE1BQUYsRUFBRCxLQUFnQixNQURULCtCQUFmOztBQUlBOztBQUVBO0FBQ0EsTUFBSSxRQUFKLEVBQWM7QUFDWixzREFBc0IsTUFBdEIsRUFBOEIsVUFBOUIsRUFDRyxTQURILENBQ2EsTUFBTTtBQUFFLGVBQVMsSUFBVCxDQUFjLEtBQWQsQ0FBb0IsU0FBcEIsR0FBZ0MsVUFBaEM7QUFBNkMsS0FEbEU7O0FBR0EsV0FDRyxTQURILENBQ2EsTUFBTTtBQUFFLGVBQVMsSUFBVCxDQUFjLEtBQWQsQ0FBb0IsU0FBcEIsR0FBZ0MsRUFBaEM7QUFBcUMsS0FEMUQ7QUFFRDs7QUFFRDtBQUNBLGdEQUNjLENBQUMsQ0FBQyxNQUFELENBQUQsS0FBYztBQUN4QixVQUFNLEVBQUUsT0FBTyxFQUFFLGFBQUYsRUFBVCxLQUErQixNQUFyQzs7QUFFQSxVQUFNLE9BQU8sZUFBSyxNQUFMLENBQ1gsY0FBYyxZQUFkLElBQ0EsY0FBYyxZQUFkLENBQTJCLFdBQTNCLENBRlcsRUFFOEI7QUFDdkMsbUJBRHVDO0FBRXZDLG1CQUZ1QztBQUd2QyxnQkFBVTtBQUg2QixLQUY5QixDQUFiOztBQVFBO0FBQ0E7QUFDQTtBQUNBLFdBQU8sSUFBUCxHQUFjLElBQWQ7O0FBRUEsV0FBTyxLQUFLLEtBQUwsQ0FBVyxhQUFYLENBQVA7QUFDRCxHQWxCSCxHQW1CSSxlQW5CSixpQkFvQkcsU0FwQkg7O0FBc0JBO0FBQ0EsMkRBQ1csQ0FBQyxHQUFHLElBQUgsQ0FBRCxLQUFjO0FBQUUsU0FBSyxLQUFMLENBQVcsT0FBWCxHQUFxQixDQUFyQjtBQUF5QixHQURwRCxrQ0FFVyxDQUFDLENBQUMsRUFBRSxJQUFGLEVBQUQsQ0FBRCxLQUFnQixTQUFTLE1BQVQsSUFBbUIsQ0FBQyxRQUYvQywwQ0FHZSxDQUFDLENBQUMsRUFBRSxJQUFGLEVBQUQsRUFBVyxJQUFYLENBQUQ7QUFBQTs7QUFBQSxXQUNYLCtDQUFRLElBQVIsRUFBYyxDQUNaLEVBQUUsU0FBUyxDQUFYLEVBRFksRUFFWixFQUFFLFNBQVMsQ0FBWCxFQUZZLENBQWQsRUFHRztBQUNELGdCQUFVLFFBRFQ7QUFFRDtBQUNBLGNBQVE7QUFIUCxLQUhILDRCQVFXLE1BQU07QUFBRSxVQUFJLFNBQVMsTUFBYixFQUFxQixPQUFPLE1BQVAsQ0FBYyxDQUFkLEVBQWlCLENBQWpCO0FBQXNCLEtBUjlELGtDQVNZLE1BVFosQ0FEVztBQUFBLEdBSGYsR0FjSSxlQWRKLGlCQWVHLFNBZkg7O0FBaUJBO0FBQ0Esc0NBQ1csTUFBTTtBQUFFLFlBQVEsS0FBUixDQUFjLE9BQWQsR0FBd0IsT0FBeEI7QUFBa0MsR0FEckQsR0FFSSxlQUZKLGlCQUdHLFNBSEg7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyREFDVyxNQUFNO0FBQUUsWUFBUSxLQUFSLENBQWMsT0FBZCxHQUF3QixNQUF4QjtBQUFpQyxHQURwRCxrQ0FFVyxDQUFDLEVBQUUsSUFBRixFQUFELEtBQWMsU0FBUyxNQUFULElBQW1CLENBQUMsUUFGN0Msd0NBR2MsQ0FBQyxFQUFFLElBQUYsRUFBUSxTQUFTLENBQUMsSUFBRCxDQUFqQixFQUFEO0FBQUE7O0FBQUEsV0FBK0Isa0JBQUssS0FBTCxDQUFXLElBQVgseUNBQTRCLE1BQTVCLENBQS9CO0FBQUEsR0FIZCxHQUlJLGVBSkosaUJBS0csU0FMSDs7QUFPQSxvRkFDYyxDQUFDLEVBQUUsU0FBUyxDQUFDLElBQUQsQ0FBWCxFQUFEO0FBQUE7O0FBQUEsV0FDVix3QkFBVyxVQUFYLENBQXNCLDJCQUFZLElBQVosQ0FBdEIseUNBQW9ELE1BQXBELENBRFU7QUFBQSxHQURkLHdDQUdjLFNBQVMsYUFBVCxDQUF1QixhQUF2QixDQUhkLDBFQUtlLFdBQVcsU0FMMUIsTUFLZSxVQUxmLElBTUksZUFOSixpQkFPRyxTQVBIOztBQVNBO0FBQ0Esa0VBQ1csQ0FBQyxFQUFFLElBQUYsRUFBRCxLQUFjLFNBQVMsTUFBVCxJQUFtQixDQUFDLFFBRDdDLDRCQUVRLFFBQVEsQ0FBQyxJQUFELEVBQU8sU0FBUyxhQUFULENBQXVCLE1BQXZCLENBQVAsQ0FGaEIsd0NBR2MsQ0FBQyxHQUFHLElBQUgsQ0FBRCxLQUNWLHFCQUFRLElBQVIsRUFBYyxDQUNaLEVBQUUsV0FBVyxtQkFBYixFQUFrQyxTQUFTLENBQTNDLEVBRFksRUFFWixFQUFFLFdBQVcsZUFBYixFQUE4QixTQUFTLENBQXZDLEVBRlksQ0FBZCxFQUdHO0FBQ0QsY0FBVSxRQURUO0FBRUQ7QUFDQSxZQUFRO0FBSFAsR0FISCxDQUpKLEdBWUksZUFaSixpQkFhRyxTQWJIOztBQWVBO0FBQ0U7QUFERiwwQ0FFaUIsSUFBSSxRQUZyQiwyQkFHVyxNQUFNO0FBQ2I7QUFDQSxRQUFJLE9BQU8sRUFBWCxFQUFlLE9BQU8sRUFBUCxDQUFVLE1BQVYsRUFBa0IsVUFBbEI7O0FBRWY7QUFDQTtBQUNELEdBVEgsR0FVSSxlQVZKLGlCQVdHLFNBWEg7O0FBYUEsd0JBQWMsU0FBZCxFQUF5QjtBQUN2QixnQkFBWSxDQUFDLE9BQUQsQ0FEVztBQUV2QixrQkFBYyxjQUZTO0FBR3ZCLG9CQUFnQixnQ0FITztBQUl2QixjQUFVLFFBSmE7QUFLdkIsbUJBQWUsUUFMUTtBQU12Qix1QkFBbUIsQ0FBQztBQU5HLEdBQXpCLEVBT0csWUFQSDtBQVFEOzs7QUMxT0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9kQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTs7QUNBQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2oxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqaURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNya0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4dERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNocUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFBQTtrQkFDWDs7Z0JBQUEsQUFBWSxPQUFPOzBCQUFBOzs0R0FBQSxBQUNYLEFBQ047O1VBQUEsQUFBSyxPQUFPLE1BQUEsQUFBTSxjQUZELEFBRWpCLEFBQWdDO1dBQ2pDOzs7Ozt3QkFFVSxBQUFFO2FBQUEsQUFBTyxBQUFTOzs7OztFLEFBTkw7O0ksQUFTYixlLEFBQUE7a0JBQ1g7O2dCQUFBLEFBQVksT0FBTzswQkFBQTs7NkdBQUEsQUFDWCxBQUNOOztXQUFBLEFBQUssT0FBTyxNQUFBLEFBQU0sY0FGRCxBQUVqQixBQUFnQztXQUNqQzs7Ozs7d0JBRVUsQUFBRTthQUFBLEFBQU8sQUFBUzs7Ozs7RSxBQU5MOztJLEFBU2IsYyxBQUFBO2lCQUNYOztlQUFBLEFBQVksT0FBTzswQkFBQTs7MkdBQUEsQUFDWCxBQUNOOztXQUFBLEFBQUssT0FBTyxPQUFBLEFBQU8sU0FGRixBQUVqQixBQUE0QjtXQUM3Qjs7Ozs7d0JBRVUsQUFBRTthQUFBLEFBQU8sQUFBUTs7Ozs7RSxBQU5MOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4QnpCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFIQTtBQUNBOztJLEFBSXFCO3VCQUNuQjs7cUJBQUEsQUFBWSxJQUFaLEFBQWdCLE9BQU87MEJBQUE7O2dIQUVyQjs7VUFBQSxBQUFLLGVBQUwsQUFBb0IsSUFGQyxBQUVyQixBQUF3QjtXQUN6QjtBQUVEOzs7Ozs7OzZCLEFBQ1MsSUFBSSxBQUNYO1VBQUksQ0FBSixBQUFLLElBQUksTUFBTSxNQUFOLEFBQU0sQUFBTSxBQUNyQjthQUFBLEFBQU8sQUFDUjs7Ozs7RUFWb0MsVzs7a0IsQUFBbEIiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLyohIG1vZGVybml6ciAzLjQuMCAoQ3VzdG9tIEJ1aWxkKSB8IE1JVCAqXHJcbiAqIGh0dHBzOi8vbW9kZXJuaXpyLmNvbS9kb3dubG9hZC8/LWNsYXNzbGlzdC1jc3NhbmltYXRpb25zLWNzc3BvaW50ZXJldmVudHMtY3NzcmVtdW5pdC1jc3N0cmFuc2Zvcm1zLWRvY3VtZW50ZnJhZ21lbnQtZXZlbnRsaXN0ZW5lci1oaXN0b3J5LW1hdGNobWVkaWEtb3BhY2l0eS1xdWVyeXNlbGVjdG9yLXJlcXVlc3RhbmltYXRpb25mcmFtZS10b3VjaGV2ZW50cyAhKi9cclxuIWZ1bmN0aW9uKGUsdCxuKXtmdW5jdGlvbiByKGUsdCl7cmV0dXJuIHR5cGVvZiBlPT09dH1mdW5jdGlvbiBvKCl7dmFyIGUsdCxuLG8saSxzLGE7Zm9yKHZhciB1IGluIGcpaWYoZy5oYXNPd25Qcm9wZXJ0eSh1KSl7aWYoZT1bXSx0PWdbdV0sdC5uYW1lJiYoZS5wdXNoKHQubmFtZS50b0xvd2VyQ2FzZSgpKSx0Lm9wdGlvbnMmJnQub3B0aW9ucy5hbGlhc2VzJiZ0Lm9wdGlvbnMuYWxpYXNlcy5sZW5ndGgpKWZvcihuPTA7bjx0Lm9wdGlvbnMuYWxpYXNlcy5sZW5ndGg7bisrKWUucHVzaCh0Lm9wdGlvbnMuYWxpYXNlc1tuXS50b0xvd2VyQ2FzZSgpKTtmb3Iobz1yKHQuZm4sXCJmdW5jdGlvblwiKT90LmZuKCk6dC5mbixpPTA7aTxlLmxlbmd0aDtpKyspcz1lW2ldLGE9cy5zcGxpdChcIi5cIiksMT09PWEubGVuZ3RoP01vZGVybml6clthWzBdXT1vOighTW9kZXJuaXpyW2FbMF1dfHxNb2Rlcm5penJbYVswXV1pbnN0YW5jZW9mIEJvb2xlYW58fChNb2Rlcm5penJbYVswXV09bmV3IEJvb2xlYW4oTW9kZXJuaXpyW2FbMF1dKSksTW9kZXJuaXpyW2FbMF1dW2FbMV1dPW8pLFMucHVzaCgobz9cIlwiOlwibm8tXCIpK2Euam9pbihcIi1cIikpfX1mdW5jdGlvbiBpKGUpe3JldHVybiBlLnJlcGxhY2UoLyhbYS16XSktKFthLXpdKS9nLGZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdCtuLnRvVXBwZXJDYXNlKCl9KS5yZXBsYWNlKC9eLS8sXCJcIil9ZnVuY3Rpb24gcygpe3JldHVyblwiZnVuY3Rpb25cIiE9dHlwZW9mIHQuY3JlYXRlRWxlbWVudD90LmNyZWF0ZUVsZW1lbnQoYXJndW1lbnRzWzBdKTp3P3QuY3JlYXRlRWxlbWVudE5TLmNhbGwodCxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsYXJndW1lbnRzWzBdKTp0LmNyZWF0ZUVsZW1lbnQuYXBwbHkodCxhcmd1bWVudHMpfWZ1bmN0aW9uIGEoKXt2YXIgZT10LmJvZHk7cmV0dXJuIGV8fChlPXModz9cInN2Z1wiOlwiYm9keVwiKSxlLmZha2U9ITApLGV9ZnVuY3Rpb24gdShlLG4scixvKXt2YXIgaSx1LGwsZixkPVwibW9kZXJuaXpyXCIsYz1zKFwiZGl2XCIpLHA9YSgpO2lmKHBhcnNlSW50KHIsMTApKWZvcig7ci0tOylsPXMoXCJkaXZcIiksbC5pZD1vP29bcl06ZCsocisxKSxjLmFwcGVuZENoaWxkKGwpO3JldHVybiBpPXMoXCJzdHlsZVwiKSxpLnR5cGU9XCJ0ZXh0L2Nzc1wiLGkuaWQ9XCJzXCIrZCwocC5mYWtlP3A6YykuYXBwZW5kQ2hpbGQoaSkscC5hcHBlbmRDaGlsZChjKSxpLnN0eWxlU2hlZXQ/aS5zdHlsZVNoZWV0LmNzc1RleHQ9ZTppLmFwcGVuZENoaWxkKHQuY3JlYXRlVGV4dE5vZGUoZSkpLGMuaWQ9ZCxwLmZha2UmJihwLnN0eWxlLmJhY2tncm91bmQ9XCJcIixwLnN0eWxlLm92ZXJmbG93PVwiaGlkZGVuXCIsZj1ULnN0eWxlLm92ZXJmbG93LFQuc3R5bGUub3ZlcmZsb3c9XCJoaWRkZW5cIixULmFwcGVuZENoaWxkKHApKSx1PW4oYyxlKSxwLmZha2U/KHAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwKSxULnN0eWxlLm92ZXJmbG93PWYsVC5vZmZzZXRIZWlnaHQpOmMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjKSwhIXV9ZnVuY3Rpb24gbChlLHQpe3JldHVybiEhfihcIlwiK2UpLmluZGV4T2YodCl9ZnVuY3Rpb24gZihlLHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBlLmFwcGx5KHQsYXJndW1lbnRzKX19ZnVuY3Rpb24gZChlLHQsbil7dmFyIG87Zm9yKHZhciBpIGluIGUpaWYoZVtpXWluIHQpcmV0dXJuIG49PT0hMT9lW2ldOihvPXRbZVtpXV0scihvLFwiZnVuY3Rpb25cIik/ZihvLG58fHQpOm8pO3JldHVybiExfWZ1bmN0aW9uIGMoZSl7cmV0dXJuIGUucmVwbGFjZSgvKFtBLVpdKS9nLGZ1bmN0aW9uKGUsdCl7cmV0dXJuXCItXCIrdC50b0xvd2VyQ2FzZSgpfSkucmVwbGFjZSgvXm1zLS8sXCItbXMtXCIpfWZ1bmN0aW9uIHAodCxuLHIpe3ZhciBvO2lmKFwiZ2V0Q29tcHV0ZWRTdHlsZVwiaW4gZSl7bz1nZXRDb21wdXRlZFN0eWxlLmNhbGwoZSx0LG4pO3ZhciBpPWUuY29uc29sZTtpZihudWxsIT09bylyJiYobz1vLmdldFByb3BlcnR5VmFsdWUocikpO2Vsc2UgaWYoaSl7dmFyIHM9aS5lcnJvcj9cImVycm9yXCI6XCJsb2dcIjtpW3NdLmNhbGwoaSxcImdldENvbXB1dGVkU3R5bGUgcmV0dXJuaW5nIG51bGwsIGl0cyBwb3NzaWJsZSBtb2Rlcm5penIgdGVzdCByZXN1bHRzIGFyZSBpbmFjY3VyYXRlXCIpfX1lbHNlIG89IW4mJnQuY3VycmVudFN0eWxlJiZ0LmN1cnJlbnRTdHlsZVtyXTtyZXR1cm4gb31mdW5jdGlvbiBtKHQscil7dmFyIG89dC5sZW5ndGg7aWYoXCJDU1NcImluIGUmJlwic3VwcG9ydHNcImluIGUuQ1NTKXtmb3IoO28tLTspaWYoZS5DU1Muc3VwcG9ydHMoYyh0W29dKSxyKSlyZXR1cm4hMDtyZXR1cm4hMX1pZihcIkNTU1N1cHBvcnRzUnVsZVwiaW4gZSl7Zm9yKHZhciBpPVtdO28tLTspaS5wdXNoKFwiKFwiK2ModFtvXSkrXCI6XCIrcitcIilcIik7cmV0dXJuIGk9aS5qb2luKFwiIG9yIFwiKSx1KFwiQHN1cHBvcnRzIChcIitpK1wiKSB7ICNtb2Rlcm5penIgeyBwb3NpdGlvbjogYWJzb2x1dGU7IH0gfVwiLGZ1bmN0aW9uKGUpe3JldHVyblwiYWJzb2x1dGVcIj09cChlLG51bGwsXCJwb3NpdGlvblwiKX0pfXJldHVybiBufWZ1bmN0aW9uIHYoZSx0LG8sYSl7ZnVuY3Rpb24gdSgpe2QmJihkZWxldGUgUC5zdHlsZSxkZWxldGUgUC5tb2RFbGVtKX1pZihhPXIoYSxcInVuZGVmaW5lZFwiKT8hMTphLCFyKG8sXCJ1bmRlZmluZWRcIikpe3ZhciBmPW0oZSxvKTtpZighcihmLFwidW5kZWZpbmVkXCIpKXJldHVybiBmfWZvcih2YXIgZCxjLHAsdix5LGg9W1wibW9kZXJuaXpyXCIsXCJ0c3BhblwiLFwic2FtcFwiXTshUC5zdHlsZSYmaC5sZW5ndGg7KWQ9ITAsUC5tb2RFbGVtPXMoaC5zaGlmdCgpKSxQLnN0eWxlPVAubW9kRWxlbS5zdHlsZTtmb3IocD1lLmxlbmd0aCxjPTA7cD5jO2MrKylpZih2PWVbY10seT1QLnN0eWxlW3ZdLGwodixcIi1cIikmJih2PWkodikpLFAuc3R5bGVbdl0hPT1uKXtpZihhfHxyKG8sXCJ1bmRlZmluZWRcIikpcmV0dXJuIHUoKSxcInBmeFwiPT10P3Y6ITA7dHJ5e1Auc3R5bGVbdl09b31jYXRjaChnKXt9aWYoUC5zdHlsZVt2XSE9eSlyZXR1cm4gdSgpLFwicGZ4XCI9PXQ/djohMH1yZXR1cm4gdSgpLCExfWZ1bmN0aW9uIHkoZSx0LG4sbyxpKXt2YXIgcz1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Uuc2xpY2UoMSksYT0oZStcIiBcIitiLmpvaW4ocytcIiBcIikrcykuc3BsaXQoXCIgXCIpO3JldHVybiByKHQsXCJzdHJpbmdcIil8fHIodCxcInVuZGVmaW5lZFwiKT92KGEsdCxvLGkpOihhPShlK1wiIFwiK0Uuam9pbihzK1wiIFwiKStzKS5zcGxpdChcIiBcIiksZChhLHQsbikpfWZ1bmN0aW9uIGgoZSx0LHIpe3JldHVybiB5KGUsbixuLHQscil9dmFyIGc9W10sQz17X3ZlcnNpb246XCIzLjQuMFwiLF9jb25maWc6e2NsYXNzUHJlZml4OlwiXCIsZW5hYmxlQ2xhc3NlczohMCxlbmFibGVKU0NsYXNzOiEwLHVzZVByZWZpeGVzOiEwfSxfcTpbXSxvbjpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7c2V0VGltZW91dChmdW5jdGlvbigpe3QobltlXSl9LDApfSxhZGRUZXN0OmZ1bmN0aW9uKGUsdCxuKXtnLnB1c2goe25hbWU6ZSxmbjp0LG9wdGlvbnM6bn0pfSxhZGRBc3luY1Rlc3Q6ZnVuY3Rpb24oZSl7Zy5wdXNoKHtuYW1lOm51bGwsZm46ZX0pfX0sTW9kZXJuaXpyPWZ1bmN0aW9uKCl7fTtNb2Rlcm5penIucHJvdG90eXBlPUMsTW9kZXJuaXpyPW5ldyBNb2Rlcm5penIsTW9kZXJuaXpyLmFkZFRlc3QoXCJldmVudGxpc3RlbmVyXCIsXCJhZGRFdmVudExpc3RlbmVyXCJpbiBlKSxNb2Rlcm5penIuYWRkVGVzdChcImhpc3RvcnlcIixmdW5jdGlvbigpe3ZhciB0PW5hdmlnYXRvci51c2VyQWdlbnQ7cmV0dXJuLTE9PT10LmluZGV4T2YoXCJBbmRyb2lkIDIuXCIpJiYtMT09PXQuaW5kZXhPZihcIkFuZHJvaWQgNC4wXCIpfHwtMT09PXQuaW5kZXhPZihcIk1vYmlsZSBTYWZhcmlcIil8fC0xIT09dC5pbmRleE9mKFwiQ2hyb21lXCIpfHwtMSE9PXQuaW5kZXhPZihcIldpbmRvd3MgUGhvbmVcIil8fFwiZmlsZTpcIj09PWxvY2F0aW9uLnByb3RvY29sP2UuaGlzdG9yeSYmXCJwdXNoU3RhdGVcImluIGUuaGlzdG9yeTohMX0pLE1vZGVybml6ci5hZGRUZXN0KFwicXVlcnlzZWxlY3RvclwiLFwicXVlcnlTZWxlY3RvclwiaW4gdCYmXCJxdWVyeVNlbGVjdG9yQWxsXCJpbiB0KTt2YXIgUz1bXSx4PUMuX2NvbmZpZy51c2VQcmVmaXhlcz9cIiAtd2Via2l0LSAtbW96LSAtby0gLW1zLSBcIi5zcGxpdChcIiBcIik6W1wiXCIsXCJcIl07Qy5fcHJlZml4ZXM9eDt2YXIgVD10LmRvY3VtZW50RWxlbWVudDtNb2Rlcm5penIuYWRkVGVzdChcImNsYXNzbGlzdFwiLFwiY2xhc3NMaXN0XCJpbiBUKSxNb2Rlcm5penIuYWRkVGVzdChcImRvY3VtZW50ZnJhZ21lbnRcIixmdW5jdGlvbigpe3JldHVyblwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudFwiaW4gdCYmXCJhcHBlbmRDaGlsZFwiaW4gVH0pO3ZhciB3PVwic3ZnXCI9PT1ULm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7TW9kZXJuaXpyLmFkZFRlc3QoXCJvcGFjaXR5XCIsZnVuY3Rpb24oKXt2YXIgZT1zKFwiYVwiKS5zdHlsZTtyZXR1cm4gZS5jc3NUZXh0PXguam9pbihcIm9wYWNpdHk6LjU1O1wiKSwvXjAuNTUkLy50ZXN0KGUub3BhY2l0eSl9KSxNb2Rlcm5penIuYWRkVGVzdChcImNzc3BvaW50ZXJldmVudHNcIixmdW5jdGlvbigpe3ZhciBlPXMoXCJhXCIpLnN0eWxlO3JldHVybiBlLmNzc1RleHQ9XCJwb2ludGVyLWV2ZW50czphdXRvXCIsXCJhdXRvXCI9PT1lLnBvaW50ZXJFdmVudHN9KSxNb2Rlcm5penIuYWRkVGVzdChcImNzc3JlbXVuaXRcIixmdW5jdGlvbigpe3ZhciBlPXMoXCJhXCIpLnN0eWxlO3RyeXtlLmZvbnRTaXplPVwiM3JlbVwifWNhdGNoKHQpe31yZXR1cm4vcmVtLy50ZXN0KGUuZm9udFNpemUpfSk7dmFyIF89Qy50ZXN0U3R5bGVzPXU7TW9kZXJuaXpyLmFkZFRlc3QoXCJ0b3VjaGV2ZW50c1wiLGZ1bmN0aW9uKCl7dmFyIG47aWYoXCJvbnRvdWNoc3RhcnRcImluIGV8fGUuRG9jdW1lbnRUb3VjaCYmdCBpbnN0YW5jZW9mIERvY3VtZW50VG91Y2gpbj0hMDtlbHNle3ZhciByPVtcIkBtZWRpYSAoXCIseC5qb2luKFwidG91Y2gtZW5hYmxlZCksKFwiKSxcImhlYXJ0elwiLFwiKVwiLFwieyNtb2Rlcm5penJ7dG9wOjlweDtwb3NpdGlvbjphYnNvbHV0ZX19XCJdLmpvaW4oXCJcIik7XyhyLGZ1bmN0aW9uKGUpe249OT09PWUub2Zmc2V0VG9wfSl9cmV0dXJuIG59KTt2YXIgej1cIk1veiBPIG1zIFdlYmtpdFwiLGI9Qy5fY29uZmlnLnVzZVByZWZpeGVzP3ouc3BsaXQoXCIgXCIpOltdO0MuX2Nzc29tUHJlZml4ZXM9Yjt2YXIgQT1mdW5jdGlvbih0KXt2YXIgcixvPXgubGVuZ3RoLGk9ZS5DU1NSdWxlO2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBpKXJldHVybiBuO2lmKCF0KXJldHVybiExO2lmKHQ9dC5yZXBsYWNlKC9eQC8sXCJcIikscj10LnJlcGxhY2UoLy0vZyxcIl9cIikudG9VcHBlckNhc2UoKStcIl9SVUxFXCIsciBpbiBpKXJldHVyblwiQFwiK3Q7Zm9yKHZhciBzPTA7bz5zO3MrKyl7dmFyIGE9eFtzXSx1PWEudG9VcHBlckNhc2UoKStcIl9cIityO2lmKHUgaW4gaSlyZXR1cm5cIkAtXCIrYS50b0xvd2VyQ2FzZSgpK1wiLVwiK3R9cmV0dXJuITF9O0MuYXRSdWxlPUE7dmFyIEU9Qy5fY29uZmlnLnVzZVByZWZpeGVzP3oudG9Mb3dlckNhc2UoKS5zcGxpdChcIiBcIik6W107Qy5fZG9tUHJlZml4ZXM9RTt2YXIgTz17ZWxlbTpzKFwibW9kZXJuaXpyXCIpfTtNb2Rlcm5penIuX3EucHVzaChmdW5jdGlvbigpe2RlbGV0ZSBPLmVsZW19KTt2YXIgUD17c3R5bGU6Ty5lbGVtLnN0eWxlfTtNb2Rlcm5penIuX3EudW5zaGlmdChmdW5jdGlvbigpe2RlbGV0ZSBQLnN0eWxlfSksQy50ZXN0QWxsUHJvcHM9eTt2YXIgcT1DLnByZWZpeGVkPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gMD09PWUuaW5kZXhPZihcIkBcIik/QShlKTooLTEhPWUuaW5kZXhPZihcIi1cIikmJihlPWkoZSkpLHQ/eShlLHQsbik6eShlLFwicGZ4XCIpKX07TW9kZXJuaXpyLmFkZFRlc3QoXCJyZXF1ZXN0YW5pbWF0aW9uZnJhbWVcIiwhIXEoXCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIixlKSx7YWxpYXNlczpbXCJyYWZcIl19KSxNb2Rlcm5penIuYWRkVGVzdChcIm1hdGNobWVkaWFcIiwhIXEoXCJtYXRjaE1lZGlhXCIsZSkpLEMudGVzdEFsbFByb3BzPWgsTW9kZXJuaXpyLmFkZFRlc3QoXCJjc3NhbmltYXRpb25zXCIsaChcImFuaW1hdGlvbk5hbWVcIixcImFcIiwhMCkpLE1vZGVybml6ci5hZGRUZXN0KFwiY3NzdHJhbnNmb3Jtc1wiLGZ1bmN0aW9uKCl7cmV0dXJuLTE9PT1uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJBbmRyb2lkIDIuXCIpJiZoKFwidHJhbnNmb3JtXCIsXCJzY2FsZSgxKVwiLCEwKX0pLG8oKSxkZWxldGUgQy5hZGRUZXN0LGRlbGV0ZSBDLmFkZEFzeW5jVGVzdDtmb3IodmFyIEw9MDtMPE1vZGVybml6ci5fcS5sZW5ndGg7TCsrKU1vZGVybml6ci5fcVtMXSgpO2UuTW9kZXJuaXpyPU1vZGVybml6cn0od2luZG93LGRvY3VtZW50KTtcclxuIiwiY29uc29sZS5sb2coJyBfXyAgX18gICAgICAgICAgICAgICAgX18gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX18gICAgICAgICBcXHJcXG5cXC9cXFxcIFxcXFxcXC9cXFxcIFxcXFwgICAgICAgICAgICAgIFxcL1xcXFwgXFxcXCAgICAgICAgICAgICBfXyAgICAgICAgICAgICAgICAgICAgXFwvXFxcXCBcXFxcICAgICAgICBcXHJcXG5cXFxcIFxcXFwgXFxcXF9cXFxcIFxcXFwgICBfXyAgX18gICAgXFxcXF9cXFxcIFxcXFwgICAgICBfXyAgIFxcL1xcXFxfXFxcXCAgICAgIF9fICAgICAgIF9fXyBcXFxcIFxcXFwgXFxcXFxcL1xcJ1xcXFwgICAgXFxyXFxuIFxcXFwgXFxcXCAgXyAgXFxcXCBcXC9cXFxcIFxcXFxcXC9cXFxcIFxcXFwgICBcXC9cXCdfYCBcXFxcICAgXFwvXFwnX19gXFxcXCBcXFxcXFwvXFxcXCBcXFxcICAgXFwvXFwnX19gXFxcXCAgICBcXC9cXCdfX19cXFxcXFxcXCBcXFxcICwgPCAgICBcXHJcXG4gIFxcXFwgXFxcXCBcXFxcIFxcXFwgXFxcXFxcXFwgXFxcXCBcXFxcX1xcXFwgXFxcXCBcXC9cXFxcIFxcXFxMXFxcXCBcXFxcIFxcL1xcXFwgIF9fXFwvICBcXFxcIFxcXFwgXFxcXCBcXC9cXFxcIFxcXFxMXFxcXC5cXFxcXyBcXC9cXFxcIFxcXFxfX1xcLyBcXFxcIFxcXFwgXFxcXFxcXFxgXFxcXCAgXFxyXFxuICAgXFxcXCBcXFxcX1xcXFwgXFxcXF9cXFxcXFxcXFxcL2BfX19fIFxcXFxcXFxcIFxcXFxfX18sX1xcXFxcXFxcIFxcXFxfX19fXFxcXCBfXFxcXCBcXFxcIFxcXFxcXFxcIFxcXFxfX1xcLy5cXFxcX1xcXFxcXFxcIFxcXFxfX19fXFxcXCBcXFxcIFxcXFxfXFxcXCBcXFxcX1xcXFxcXHJcXG4gICAgXFxcXFxcL19cXC9cXFxcXFwvX1xcLyBgXFwvX19fXFwvPiBcXFxcXFxcXFxcL19fLF8gXFwvIFxcXFxcXC9fX19fXFwvXFwvXFxcXCBcXFxcX1xcXFwgXFxcXFxcXFxcXC9fX1xcL1xcXFxcXC9fXFwvIFxcXFxcXC9fX19fXFwvICBcXFxcXFwvX1xcL1xcXFxcXC9fXFwvXFxyXFxuICAgICAgICAgICAgICAgIFxcL1xcXFxfX19cXC8gICAgICAgICAgICAgICAgXFxcXCBcXFxcX19fX1xcLyAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcclxcbiAgICAgICAgICAgICAgICBcXFxcXFwvX19cXC8gICAgICAgICAgICAgICAgICBcXFxcXFwvX19fXFwvICAgICAgICAgICAgICAgICAgICAgICAgICAgICcpO1xyXG5jb25zb2xlLmxvZygnUG93ZXJlZCBieSBIeWRlamFjayB2Ni40LjAgKGh0dHBzOi8vcXd0ZWwuY29tL2h5ZGVqYWNrLyknKTtcclxuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDE3IEZsb3JpYW4gS2xhbXBmZXJcclxuLy8gTGljZW5zZWQgdW5kZXIgTUlUXHJcblxyXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xyXG5cclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaGFzRmVhdHVyZXMoZmVhdHVyZXMpIHtcclxuICBsZXQgYWNjID0gdHJ1ZTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGZlYXR1cmVzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICBjb25zdCBmZWF0dXJlID0gZmVhdHVyZXNbaV07XHJcbiAgICBjb25zdCBoYXNGZWF0dXJlID0gd2luZG93Lk1vZGVybml6cltmZWF0dXJlXTtcclxuICAgIC8vIGlmICghaGFzRmVhdHVyZSkgY29uc29sZS53YXJuKCdGZWF0dXJlIFwiJyArIGZlYXR1cmUgKyAnXCIgbWlzc2luZyEnKTtcclxuICAgIGFjYyA9IGFjYyAmJiBoYXNGZWF0dXJlO1xyXG4gIH1cclxuICByZXR1cm4gYWNjO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2hvdyhlbCkge1xyXG4gIGVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gIGVsLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBoaWRlKGVsKSB7XHJcbiAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICBlbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1bnNob3coZWwpIHtcclxuICBlbC5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcbiAgZWwuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgdW5oaWRlID0gdW5zaG93O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoZXMoZWwsIHNlbGVjdG9yKSB7XHJcbiAgcmV0dXJuIChlbC5tYXRjaGVzIHx8IGVsLm1hdGNoZXNTZWxlY3RvciB8fCBlbC5tc01hdGNoZXNTZWxlY3RvciB8fCBlbC5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcclxuICAgIGVsLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBlbC5vTWF0Y2hlc1NlbGVjdG9yKS5jYWxsKGVsLCBzZWxlY3Rvcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhbmltYXRlKGVsLCBrZXlmcmFtZXMsIG9wdGlvbnMpIHtcclxuICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUoKG9ic2VydmVyKSA9PiB7XHJcbiAgICBjb25zdCBhbmltID0gZWwuYW5pbWF0ZShrZXlmcmFtZXMsIG9wdGlvbnMpO1xyXG5cclxuICAgIGFuaW0uYWRkRXZlbnRMaXN0ZW5lcignZmluaXNoJywgKGUpID0+IHtcclxuICAgICAgb2JzZXJ2ZXIubmV4dChlKTtcclxuICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIC8vIGlmIChhbmltLnBsYXlTdGF0ZSAhPT0gJ2ZpbmlzaGVkJykgYW5pbS5jYW5jZWwoKTtcclxuICAgIH07XHJcbiAgfSk7XHJcbn1cclxuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDE3IEZsb3JpYW4gS2xhbXBmZXJcclxuLy8gTGljZW5zZWQgdW5kZXIgTUlUXHJcblxyXG4vKlxyXG5lc2xpbnQtZGlzYWJsZVxyXG5uby1wYXJhbS1yZWFzc2lnbixcclxuaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzLFxyXG5pbXBvcnQvbm8tdW5yZXNvbHZlZCxcclxuaW1wb3J0L2V4dGVuc2lvbnMsXHJcbmNsYXNzLW1ldGhvZHMtdXNlLXRoaXMsXHJcbiovXHJcblxyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcclxuaW1wb3J0IHsgZW1wdHkgfSBmcm9tICdyeGpzL29ic2VydmFibGUvZW1wdHknO1xyXG5pbXBvcnQgeyBmcm9tRXZlbnQgfSBmcm9tICdyeGpzL29ic2VydmFibGUvZnJvbUV2ZW50JztcclxuaW1wb3J0IHsgdGltZXIgfSBmcm9tICdyeGpzL29ic2VydmFibGUvdGltZXInO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSAnY29sb3InO1xyXG5cclxuaW1wb3J0IHsgX2RvIGFzIGVmZmVjdCB9IGZyb20gJ3J4anMvb3BlcmF0b3IvZG8nO1xyXG5pbXBvcnQgeyBfZmluYWxseSBhcyBjbGVhbnVwIH0gZnJvbSAncnhqcy9vcGVyYXRvci9maW5hbGx5JztcclxuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvci9tYXAnO1xyXG5pbXBvcnQgeyB6aXBQcm90byBhcyB6aXBXaXRoIH0gZnJvbSAncnhqcy9vcGVyYXRvci96aXAnO1xyXG5cclxuaW1wb3J0IHsgYW5pbWF0ZSB9IGZyb20gJy4vY29tbW9uJztcclxuXHJcbmNvbnN0IHsgZmluZCB9ID0gQXJyYXkucHJvdG90eXBlO1xyXG5cclxuY29uc3QgQk9SREVSX0NPTE9SX0ZBREUgPSAwLjg7XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSh7IGNvbG9yID0gJyMwMGYnIH0gPSB7fSkge1xyXG4gIHRoaXMucnVsZXNbMF0uc3R5bGUuY29sb3IgPSBjb2xvcjsgLy8gLmNvbnRlbnQgYVxyXG4gIHRoaXMucnVsZXNbMF0uc3R5bGUuYm9yZGVyQ29sb3IgPSBDb2xvcihjb2xvcikuZmFkZShCT1JERVJfQ09MT1JfRkFERSkuc3RyaW5nKCk7XHJcbiAgdGhpcy5ydWxlc1sxXS5zdHlsZS5ib3JkZXJDb2xvciA9IGNvbG9yO1xyXG4gIHRoaXMucnVsZXNbMl0uc3R5bGUub3V0bGluZUNvbG9yID0gY29sb3I7IC8vIDpmb2N1c1xyXG4gIHRoaXMucnVsZXNbM10uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3I7IC8vIDo6c2VsZWN0aW9uXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENyb3NzRmFkZXIge1xyXG4gIGNvbnN0cnVjdG9yKHsgZHVyYXRpb24gfSkge1xyXG4gICAgY29uc3QgbWFpbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdfbWFpbicpO1xyXG4gICAgY29uc3QgcGFnZVN0eWxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ19wYWdlU3R5bGUnKTtcclxuICAgIGNvbnN0IHN0eWxlU2hlZXQgPSBkb2N1bWVudC5zdHlsZVNoZWV0czo6ZmluZChzcyA9PiBzcy5vd25lck5vZGUgPT09IHBhZ2VTdHlsZSk7XHJcblxyXG4gICAgdGhpcy5zaWRlYmFyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ19zaWRlYmFyJyk7XHJcblxyXG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG4gICAgdGhpcy5ydWxlcyA9IHN0eWxlU2hlZXQuY3NzUnVsZXMgfHwgc3R5bGVTaGVldC5ydWxlcztcclxuICAgIHRoaXMucHJldkltYWdlID0gbWFpbi5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW1hZ2UnKTtcclxuICAgIHRoaXMucHJldkNvbG9yID0gbWFpbi5nZXRBdHRyaWJ1dGUoJ2RhdGEtY29sb3InKTtcclxuICB9XHJcblxyXG4gIGZldGNoSW1hZ2UoZGF0YXNldCkge1xyXG4gICAgY29uc3QgeyBjb2xvciwgaW1hZ2UgfSA9IGRhdGFzZXQ7XHJcblxyXG4gICAgaWYgKGltYWdlID09PSB0aGlzLnByZXZJbWFnZSAmJiBjb2xvciA9PT0gdGhpcy5wcmV2Q29sb3IpIHtcclxuICAgICAgcmV0dXJuIE9ic2VydmFibGU6OmVtcHR5KCk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHJlcyQ7XHJcblxyXG4gICAgaWYgKGltYWdlID09PSAnJyB8fCBpbWFnZSA9PT0gdGhpcy5wcmV2SW1hZ2UpIHtcclxuICAgICAgcmVzJCA9IE9ic2VydmFibGU6OnRpbWVyKHRoaXMuZHVyYXRpb24pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgaW1nT2JqID0gbmV3IEltYWdlKCk7XHJcblxyXG4gICAgICByZXMkID0gT2JzZXJ2YWJsZTo6ZnJvbUV2ZW50KGltZ09iaiwgJ2xvYWQnKVxyXG4gICAgICAgIDo6emlwV2l0aChPYnNlcnZhYmxlOjp0aW1lcih0aGlzLmR1cmF0aW9uKSwgeCA9PiB4KVxyXG4gICAgICAgIDo6Y2xlYW51cCgoKSA9PiB7IGltZ09iai5zcmMgPSAnJzsgfSk7XHJcblxyXG4gICAgICBpbWdPYmouc3JjID0gaW1hZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlcyRcclxuICAgICAgOjplZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHRoaXM6OnVwZGF0ZVN0eWxlKGRhdGFzZXQpO1xyXG4gICAgICAgIHRoaXMucHJldkltYWdlID0gaW1hZ2U7XHJcbiAgICAgICAgdGhpcy5wcmV2Q29sb3IgPSBjb2xvcjtcclxuICAgICAgfSlcclxuICAgICAgOjptYXAoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKCdzaWRlYmFyLWJnJyk7XHJcbiAgICAgICAgZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO1xyXG4gICAgICAgIGlmIChpbWFnZSAhPT0gJycpIGRpdi5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKCR7aW1hZ2V9KWA7XHJcbiAgICAgICAgcmV0dXJuIGRpdjtcclxuICAgICAgfSk7XHJcbiAgfVxyXG5cclxuICBjcm9zc0ZhZGUoW3ByZXZEaXYsIGRpdl0pIHtcclxuICAgIHByZXZEaXYucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZGl2LCBwcmV2RGl2Lm5leHRFbGVtZW50U2libGluZyk7XHJcblxyXG4gICAgcmV0dXJuIGFuaW1hdGUoZGl2LCBbXHJcbiAgICAgIHsgb3BhY2l0eTogMCB9LFxyXG4gICAgICB7IG9wYWNpdHk6IDEgfSxcclxuICAgIF0sIHtcclxuICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgIC8vIGVhc2luZzogJ2N1YmljLWJlemllcigwLDAsMC4zMiwxKScsXHJcbiAgICB9KVxyXG4gICAgOjpjbGVhbnVwKCgpID0+IHByZXZEaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwcmV2RGl2KSk7XHJcbiAgfVxyXG59XHJcbiIsIi8vIENvcHlyaWdodCAoYykgMjAxNyBGbG9yaWFuIEtsYW1wZmVyXHJcbi8vIExpY2Vuc2VkIHVuZGVyIE1JVFxyXG5cclxuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzLCBpbXBvcnQvbm8tdW5yZXNvbHZlZCwgaW1wb3J0L2V4dGVuc2lvbnMgKi9cclxuXHJcbmltcG9ydCBZRHJhd2VyIGZyb20gJ3ktZHJhd2VyL3NyYy92YW5pbGxhJztcclxuXHJcbmltcG9ydCB7IGhhc0ZlYXR1cmVzIH0gZnJvbSAnLi9jb21tb24nO1xyXG5cclxuY29uc3QgUkVRVUlSRU1FTlRTID0gW1xyXG4gICdldmVudGxpc3RlbmVyJyxcclxuICAncXVlcnlzZWxlY3RvcicsXHJcbiAgJ21hdGNobWVkaWEnLFxyXG4gICdyZXF1ZXN0YW5pbWF0aW9uZnJhbWUnLFxyXG4gICdjbGFzc2xpc3QnLFxyXG4gICdvcGFjaXR5JyxcclxuICAnY3NzdHJhbnNmb3JtcycsXHJcbiAgJ2Nzc3BvaW50ZXJldmVudHMnLFxyXG4gICdjc3NyZW11bml0JyxcclxuXTtcclxuXHJcbmNvbnN0IE1FRElBX1FVRVJZID0gJyhtaW4td2lkdGg6IDU0ZW0pJztcclxuXHJcbmZ1bmN0aW9uIHJlc2l6ZUNhbGxiYWNrKCkge1xyXG4gIGNvbnN0IGhhc0NoYW5nZWQgPSB3aW5kb3cuaXNEZXNrdG9wICE9PSB3aW5kb3cubWF0Y2hNZWRpYShNRURJQV9RVUVSWSkubWF0Y2hlcztcclxuICBpZiAoaGFzQ2hhbmdlZCkge1xyXG4gICAgd2luZG93LmlzRGVza3RvcCA9ICF3aW5kb3cuaXNEZXNrdG9wO1xyXG4gICAgd2luZG93LmRyYXdlci5wZXJzaXN0ZW50ID0gd2luZG93LmlzRGVza3RvcDtcclxuICAgIHdpbmRvdy5kcmF3ZXIuanVtcFRvKHdpbmRvdy5pc0Rlc2t0b3ApO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gbWVudUNsaWNrQ2xhbGxiYWNrKGUpIHtcclxuICBpZiAoIXdpbmRvdy5pc0Rlc2t0b3ApIHtcclxuICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgIHdpbmRvdy5kcmF3ZXIudG9nZ2xlKCk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVycyhkcmF3ZXIpIHtcclxuICB3aW5kb3cuZHJhd2VyID0gZHJhd2VyO1xyXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemVDYWxsYmFjayk7XHJcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ19tZW51JykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBtZW51Q2xpY2tDbGFsbGJhY2spO1xyXG59XHJcblxyXG5pZiAoIXdpbmRvdy5kaXNhYmxlRHJhd2VyICYmIGhhc0ZlYXR1cmVzKFJFUVVJUkVNRU5UUykpIHtcclxuICB3aW5kb3cuaXNEZXNrdG9wID0gd2luZG93Lm1hdGNoTWVkaWEoTUVESUFfUVVFUlkpLm1hdGNoZXM7XHJcbiAgY29uc3QgZHJhd2VyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ195RHJhd2VyJyk7XHJcblxyXG4gIGFkZEV2ZW50TGlzdGVuZXJzKG5ldyBZRHJhd2VyKGRyYXdlciwge1xyXG4gICAgb3BlbmVkOiB3aW5kb3cuaXNEZXNrdG9wLFxyXG4gICAgcGVyc2lzdGVudDogd2luZG93LmlzRGVza3RvcCxcclxuICAgIHRyYW5zaXRpb25EdXJhdGlvbjogMTUwLFxyXG4gIH0pKTtcclxuXHJcbiAgZHJhd2VyLmNsYXNzTGlzdC5hZGQoJ2xvYWRlZCcpO1xyXG59XHJcbiIsIi8vIENvcHlyaWdodCAoYykgMjAxNyBGbG9yaWFuIEtsYW1wZmVyXHJcbi8vIExpY2Vuc2VkIHVuZGVyIE1JVFxyXG5cclxuLypcclxuZXNsaW50LWRpc2FibGVcclxuY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xyXG4qL1xyXG5cclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XHJcbmltcG9ydCB7IGVtcHR5IH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL2VtcHR5JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZsaXAge1xyXG4gIHN0YXRpYyBjcmVhdGUodHlwZSwgLi4uYXJncykge1xyXG4gICAgcmV0dXJuIEZsaXAudHlwZXNbdHlwZV0gIT0gbnVsbCA/XHJcbiAgICAgIG5ldyBGbGlwLnR5cGVzW3R5cGVdKC4uLmFyZ3MpIDpcclxuICAgICAgbmV3IEZsaXAoLi4uYXJncyk7XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3Rvcih7IGFuaW1hdGlvbk1haW4sIGR1cmF0aW9uIH0pIHtcclxuICAgIHRoaXMuYW5pbWF0aW9uTWFpbiA9IGFuaW1hdGlvbk1haW47XHJcbiAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XHJcbiAgfVxyXG5cclxuICBzdGFydCgpIHtcclxuICAgIC8vIEhBQ0s6IHVzZSBwcm9wZXIgY2xlYW51cCBpbnN0ZWFkXHJcbiAgICB0aGlzLmFuaW1hdGlvbk1haW4uc3R5bGUub3BhY2l0eSA9IDA7XHJcbiAgICB0aGlzLmFuaW1hdGlvbk1haW4uc3R5bGUud2lsbENoYW5nZSA9ICcnO1xyXG5cclxuICAgIHJldHVybiBPYnNlcnZhYmxlOjplbXB0eSgpO1xyXG4gIH1cclxuXHJcbiAgcmVhZHkoKSB7XHJcbiAgICByZXR1cm4gT2JzZXJ2YWJsZTo6ZW1wdHkoKTtcclxuICB9XHJcbn1cclxuXHJcbkZsaXAudHlwZXMgPSB7fTtcclxuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDE3IEZsb3JpYW4gS2xhbXBmZXJcclxuLy8gTGljZW5zZWQgdW5kZXIgTUlUXHJcblxyXG4vKlxyXG5lc2xpbnQtZGlzYWJsZVxyXG5uby1wYXJhbS1yZWFzc2lnbixcclxuaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzLFxyXG5pbXBvcnQvbm8tdW5yZXNvbHZlZCxcclxuaW1wb3J0L2V4dGVuc2lvbnMsXHJcbmNsYXNzLW1ldGhvZHMtdXNlLXRoaXMsXHJcbiovXHJcblxyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcclxuaW1wb3J0IHsgdGltZXIgfSBmcm9tICdyeGpzL29ic2VydmFibGUvdGltZXInO1xyXG5cclxuaW1wb3J0IHsgX2RvIGFzIGVmZmVjdCB9IGZyb20gJ3J4anMvb3BlcmF0b3IvZG8nO1xyXG5pbXBvcnQgeyBfZmluYWxseSBhcyBjbGVhbnVwIH0gZnJvbSAncnhqcy9vcGVyYXRvci9maW5hbGx5JztcclxuXHJcbmltcG9ydCB7IGFuaW1hdGUgfSBmcm9tICcuLi9jb21tb24nO1xyXG5pbXBvcnQgRmxpcCBmcm9tICcuL2ZsaXAnO1xyXG5cclxuY29uc3QgVElUTEVfU0VMRUNUT1IgPSAnLnBhZ2UtdGl0bGUsIC5wb3N0LXRpdGxlJztcclxuXHJcbmNsYXNzIFRpdGxlRmxpcCBleHRlbmRzIEZsaXAge1xyXG4gIHN0YXJ0KGN1cnJlbnRUYXJnZXQpIHtcclxuICAgIGNvbnN0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDEnKTtcclxuXHJcbiAgICB0aXRsZS5jbGFzc0xpc3QuYWRkKCdwYWdlLXRpdGxlJyk7XHJcbiAgICB0aXRsZS50ZXh0Q29udGVudCA9IGN1cnJlbnRUYXJnZXQudGV4dENvbnRlbnQ7XHJcbiAgICB0aXRsZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnbGVmdCB0b3AnO1xyXG5cclxuICAgIHRoaXMuYW5pbWF0aW9uTWFpbi5xdWVyeVNlbGVjdG9yKCcucGFnZScpLmlubmVySFRNTCA9ICcnO1xyXG4gICAgdGhpcy5hbmltYXRpb25NYWluLnF1ZXJ5U2VsZWN0b3IoJy5wYWdlJykuYXBwZW5kQ2hpbGQodGl0bGUpO1xyXG4gICAgdGhpcy5hbmltYXRpb25NYWluLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcclxuICAgIHRoaXMuYW5pbWF0aW9uTWFpbi5zdHlsZS5vcGFjaXR5ID0gMTtcclxuXHJcbiAgICBjb25zdCBmaXJzdCA9IGN1cnJlbnRUYXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICBjb25zdCBmaXJzdEZvbnRTaXplID0gcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50VGFyZ2V0KS5mb250U2l6ZSwgMTApO1xyXG4gICAgY29uc3QgbGFzdCA9IHRpdGxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgY29uc3QgbGFzdEZvbnRTaXplID0gcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZSh0aXRsZSkuZm9udFNpemUsIDEwKTtcclxuXHJcbiAgICBjb25zdCBpbnZlcnRYID0gZmlyc3QubGVmdCAtIGxhc3QubGVmdDtcclxuICAgIGNvbnN0IGludmVydFkgPSBmaXJzdC50b3AgLSBsYXN0LnRvcDtcclxuICAgIGNvbnN0IGludmVydFNjYWxlID0gZmlyc3RGb250U2l6ZSAvIGxhc3RGb250U2l6ZTtcclxuXHJcbiAgICBjdXJyZW50VGFyZ2V0LnN0eWxlLm9wYWNpdHkgPSAwO1xyXG5cclxuICAgIHJldHVybiBhbmltYXRlKHRpdGxlLCBbXHJcbiAgICAgIHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHtpbnZlcnRYfXB4LCAke2ludmVydFl9cHgsIDApIHNjYWxlKCR7aW52ZXJ0U2NhbGV9KWAgfSxcclxuICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSBzY2FsZSgxKScgfSxcclxuICAgIF0sIHtcclxuICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgIC8vIGVhc2luZzogJ2Vhc2UnLFxyXG4gICAgICBlYXNpbmc6ICdjdWJpYy1iZXppZXIoMCwwLDAuMzIsMSknLFxyXG4gICAgfSlcclxuICAgICAgOjplZmZlY3QoKCkgPT4geyB0aGlzLmFuaW1hdGlvbk1haW4uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnOyB9KTtcclxuICB9XHJcblxyXG4gIHJlYWR5KG1haW4pIHtcclxuICAgIHRoaXMuYW5pbWF0aW9uTWFpbi5zdHlsZS53aWxsQ2hhbmdlID0gJ29wYWNpdHknO1xyXG5cclxuICAgIGNvbnN0IHRpdGxlID0gbWFpbi5xdWVyeVNlbGVjdG9yKFRJVExFX1NFTEVDVE9SKTtcclxuXHJcbiAgICBpZiAodGl0bGUgIT0gbnVsbCkge1xyXG4gICAgICB0aXRsZS5zdHlsZS5vcGFjaXR5ID0gMDtcclxuICAgICAgdGl0bGUuc3R5bGUud2lsbENoYW5nZSA9ICdvcGFjaXR5JztcclxuICAgIH1cclxuXHJcbiAgICAvLyBIQUNLOiBhZGQgc29tZSBleHRyYSB0aW1lIHRvIHByZXZlbnQgaGljY3Vwc1xyXG4gICAgcmV0dXJuIE9ic2VydmFibGU6OnRpbWVyKHRoaXMuZHVyYXRpb24gKyAxMDApXHJcbiAgICAgIDo6ZWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAodGl0bGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgdGl0bGUuc3R5bGUub3BhY2l0eSA9IDE7XHJcbiAgICAgICAgICB0aXRsZS5zdHlsZS53aWxsQ2hhbmdlID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgICA6OmNsZWFudXAoKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uTWFpbi5zdHlsZS5vcGFjaXR5ID0gMDtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbk1haW4uc3R5bGUud2lsbENoYW5nZSA9ICcnO1xyXG4gICAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbkZsaXAudHlwZXMudGl0bGUgPSBUaXRsZUZsaXA7XHJcbiIsIi8vICBfXyAgX18gICAgICAgICAgICAgICAgX18gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX19cclxuLy8gL1xcIFxcL1xcIFxcICAgICAgICAgICAgICAvXFwgXFwgICAgICAgICAgICAgX18gICAgICAgICAgICAgICAgICAgIC9cXCBcXFxyXG4vLyBcXCBcXCBcXF9cXCBcXCAgIF9fICBfXyAgICBcXF9cXCBcXCAgICAgIF9fICAgL1xcX1xcICAgICAgX18gICAgICAgX19fIFxcIFxcIFxcLydcXFxyXG4vLyAgXFwgXFwgIF8gIFxcIC9cXCBcXC9cXCBcXCAgIC8nX2AgXFwgICAvJ19fYFxcIFxcL1xcIFxcICAgLydfX2BcXCAgICAvJ19fX1xcXFwgXFwgLCA8XHJcbi8vICAgXFwgXFwgXFwgXFwgXFxcXCBcXCBcXF9cXCBcXCAvXFwgXFxMXFwgXFwgL1xcICBfXy8gIFxcIFxcIFxcIC9cXCBcXExcXC5cXF8gL1xcIFxcX18vIFxcIFxcIFxcXFxgXFxcclxuLy8gICAgXFwgXFxfXFwgXFxfXFxcXC9gX19fXyBcXFxcIFxcX19fLF9cXFxcIFxcX19fX1xcIF9cXCBcXCBcXFxcIFxcX18vLlxcX1xcXFwgXFxfX19fXFwgXFwgXFxfXFwgXFxfXFxcclxuLy8gICAgIFxcL18vXFwvXy8gYC9fX18vPiBcXFxcL19fLF8gLyBcXC9fX19fLy9cXCBcXF9cXCBcXFxcL19fL1xcL18vIFxcL19fX18vICBcXC9fL1xcL18vXHJcbi8vICAgICAgICAgICAgICAgICAvXFxfX18vICAgICAgICAgICAgICAgIFxcIFxcX19fXy9cclxuLy8gICAgICAgICAgICAgICAgIFxcL19fLyAgICAgICAgICAgICAgICAgIFxcL19fXy9cclxuLy9cclxuLy8gQ29weXJpZ2h0IChjKSAyMDE3IEZsb3JpYW4gS2xhbXBmZXJcclxuLy8gTGljZW5zZWQgdW5kZXIgTUlUXHJcbi8vIFBvd2VyZWQgYnkgSHlkZWphY2sgKGh0dHBzOi8vcXd0ZWwuY29tL2h5ZGVqYWNrKVxyXG5cclxuaW1wb3J0ICdjb3JlLWpzL2ZuL2FycmF5L2Zvci1lYWNoJztcclxuaW1wb3J0ICdjb3JlLWpzL2ZuL2FycmF5L2ZpbmQnO1xyXG5pbXBvcnQgJ2NvcmUtanMvZm4vZnVuY3Rpb24vYmluZCc7XHJcbmltcG9ydCAnY29yZS1qcy9mbi9udW1iZXIvY29uc3RydWN0b3InO1xyXG5pbXBvcnQgJ2NvcmUtanMvZm4vb2JqZWN0L2Fzc2lnbic7XHJcbmltcG9ydCAnY29yZS1qcy9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5JztcclxuaW1wb3J0ICdjb3JlLWpzL2ZuL29iamVjdC9rZXlzJztcclxuaW1wb3J0ICdjb3JlLWpzL2ZuL2FycmF5L3JlZHVjZSc7XHJcbmltcG9ydCAnd2ViLWFuaW1hdGlvbnMtanMnO1xyXG5cclxuaW1wb3J0ICcuLi9saWIvbW9kZXJuaXpyJztcclxuaW1wb3J0ICcuLi9saWIvdmVyc2lvbic7XHJcblxyXG5pbXBvcnQgJy4va2F0ZXgnO1xyXG5pbXBvcnQgJy4vZHJhd2VyJztcclxuaW1wb3J0ICcuL3B1c2gtc3RhdGUnO1xyXG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTcgRmxvcmlhbiBLbGFtcGZlclxyXG4vLyBMaWNlbnNlZCB1bmRlciBNSVRcclxuXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXHJcblxyXG5pbXBvcnQga2F0ZXggZnJvbSAna2F0ZXgnO1xyXG5cclxuaW1wb3J0IHsgaGFzRmVhdHVyZXMsIGhpZGUsIG1hdGNoZXMgfSBmcm9tICcuL2NvbW1vbic7XHJcblxyXG5jb25zdCBSRVFVSVJFTUVOVFMgPSBbXHJcbiAgJ2V2ZW50bGlzdGVuZXInLFxyXG4gICdxdWVyeXNlbGVjdG9yJyxcclxuXTtcclxuXHJcbmZ1bmN0aW9uIHdpbGxDaGFuZ2VDb250ZW50KG1hdGhCbG9ja3MpIHtcclxuICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKG1hdGhCbG9ja3MsIChlbCkgPT4ge1xyXG4gICAgZWwuc3R5bGUud2lsbENoYW5nZSA9ICdjb250ZW50JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXBsYWNlTWF0aEJsb2NrKGVsLCB0ZXgpIHtcclxuICBlbC5vdXRlckhUTUwgPSBrYXRleC5yZW5kZXJUb1N0cmluZyh0ZXgsIHtcclxuICAgIGRpc3BsYXlNb2RlOiBlbC50eXBlID09PSAnbWF0aC90ZXg7IG1vZGU9ZGlzcGxheScsXHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbmRlckthdGV4KGVsLCB0ZXgpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcHJldiA9IGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XHJcbiAgICByZXBsYWNlTWF0aEJsb2NrKGVsLCB0ZXgpO1xyXG4gICAgaWYgKHByZXYgJiYgbWF0Y2hlcyhwcmV2LCAnLk1hdGhKYXhfUHJldmlldycpKSBoaWRlKHByZXYpO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIC8vIFRPRE86IHJlbW92ZSBpbiBwcm9kdWN0aW9uIGJ1aWxkcz9cclxuICAgIGNvbnNvbGUuZXJyb3IoZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxyXG4gIH0gZmluYWxseSB7XHJcbiAgICBlbC5zdHlsZS53aWxsQ2hhbmdlID0gJyc7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkVGV4U291cmNlKGVsKSB7XHJcbiAgcmV0dXJuIGVsLnRleHRDb250ZW50LnJlcGxhY2UoJyUgPCFbQ0RBVEFbJywgJycpLnJlcGxhY2UoJyVdXT4nLCAnJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoYW5nZUNvbnRlbnQobWF0aEJsb2Nrcykge1xyXG4gIC8vIGtyYW1kb3duIGdlbmVyYXRlcyBzY3JpcHQgdGFncyB3aXRoIHR5cGUgXCJtYXRoL3RleFwiXHJcbiAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChtYXRoQmxvY2tzLCAoc2NyaXB0KSA9PiB7XHJcbiAgICBjb25zdCB0ZXggPSByZWFkVGV4U291cmNlKHNjcmlwdCk7XHJcbiAgICByZW5kZXJLYXRleChzY3JpcHQsIHRleCk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVwZ3JhZGVNYXRoQmxvY2tzKCkge1xyXG4gIGlmIChoYXNGZWF0dXJlcyhSRVFVSVJFTUVOVFMpKSB7XHJcbiAgICBjb25zdCBtYXRoQmxvY2tzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc2NyaXB0W3R5cGVePVwibWF0aC90ZXhcIl0nKTtcclxuICAgIGlmIChtYXRoQmxvY2tzLmxlbmd0aCkge1xyXG4gICAgICB3aWxsQ2hhbmdlQ29udGVudChtYXRoQmxvY2tzKTtcclxuICAgICAgY2hhbmdlQ29udGVudChtYXRoQmxvY2tzKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmlmIChoYXNGZWF0dXJlcyhSRVFVSVJFTUVOVFMpKSB7XHJcbiAgLy8gVE9ETzogbG9hZCBvbiBkZW1hbmQ/XHJcbiAgY29uc3QgcmVmID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3N0eWxlJylbMF07XHJcbiAgY29uc3Qgc3R5bGUgPSBsb2FkQ1NTKCdodHRwczovL3VucGtnLmNvbS9rYXRleEAwLjcuMS9kaXN0L2thdGV4Lm1pbi5jc3MnLCByZWYpO1xyXG4gIHN0eWxlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB1cGdyYWRlTWF0aEJsb2Nrcyk7XHJcbn1cclxuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDE3IEZsb3JpYW4gS2xhbXBmZXJcclxuLy8gTGljZW5zZWQgdW5kZXIgTUlUXHJcblxyXG4vKlxyXG5lc2xpbnQtZGlzYWJsZVxyXG5uby1wYXJhbS1yZWFzc2lnbixcclxuaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzLFxyXG5pbXBvcnQvbm8tdW5yZXNvbHZlZCxcclxuaW1wb3J0L2V4dGVuc2lvbnNcclxuKi9cclxuXHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xyXG5pbXBvcnQgeyBmcm9tRXZlbnQgfSBmcm9tICdyeGpzL29ic2VydmFibGUvZnJvbUV2ZW50JztcclxuXHJcbmltcG9ydCB7IF9jYXRjaCBhcyByZWNvdmVyIH0gZnJvbSAncnhqcy9vcGVyYXRvci9jYXRjaCc7XHJcbmltcG9ydCB7IF9kbyBhcyBlZmZlY3QgfSBmcm9tICdyeGpzL29wZXJhdG9yL2RvJztcclxuaW1wb3J0IHsgZGVib3VuY2VUaW1lIH0gZnJvbSAncnhqcy9vcGVyYXRvci9kZWJvdW5jZVRpbWUnO1xyXG5pbXBvcnQgeyBleGhhdXN0TWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvci9leGhhdXN0TWFwJztcclxuaW1wb3J0IHsgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvci9maWx0ZXInO1xyXG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9yL21hcCc7XHJcbmltcG9ydCB7IG1lcmdlTWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvci9tZXJnZU1hcCc7XHJcbmltcG9ydCB7IHBhaXJ3aXNlIH0gZnJvbSAncnhqcy9vcGVyYXRvci9wYWlyd2lzZSc7XHJcbmltcG9ydCB7IHNoYXJlIH0gZnJvbSAncnhqcy9vcGVyYXRvci9zaGFyZSc7XHJcbmltcG9ydCB7IHN0YXJ0V2l0aCB9IGZyb20gJ3J4anMvb3BlcmF0b3Ivc3RhcnRXaXRoJztcclxuaW1wb3J0IHsgc3dpdGNoTWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvci9zd2l0Y2hNYXAnO1xyXG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9yL3Rha2VVbnRpbCc7XHJcbmltcG9ydCB7IHppcFByb3RvIGFzIHppcFdpdGggfSBmcm9tICdyeGpzL29wZXJhdG9yL3ppcCc7XHJcblxyXG5pbXBvcnQgUHVzaFN0YXRlIGZyb20gJ3ktcHVzaC1zdGF0ZS9zcmMvdmFuaWxsYSc7XHJcbmltcG9ydCBlbGVtRGF0YXNldCBmcm9tICdlbGVtLWRhdGFzZXQnO1xyXG5cclxuaW1wb3J0IHsgaGFzRmVhdHVyZXMsIGFuaW1hdGUgfSBmcm9tICcuL2NvbW1vbic7XHJcbmltcG9ydCBDcm9zc0ZhZGVyIGZyb20gJy4vY3Jvc3MtZmFkZXInO1xyXG5pbXBvcnQgdXBncmFkZU1hdGhCbG9ja3MgZnJvbSAnLi9rYXRleCc7XHJcblxyXG5pbXBvcnQgRmxpcCBmcm9tICcuL2ZsaXAvZmxpcCc7XHJcbmltcG9ydCAnLi9mbGlwL3RpdGxlJztcclxuXHJcbmNvbnN0IFJFUVVJUkVNRU5UUyA9IFtcclxuICAnZXZlbnRsaXN0ZW5lcicsXHJcbiAgJ3F1ZXJ5c2VsZWN0b3InLFxyXG4gICdyZXF1ZXN0YW5pbWF0aW9uZnJhbWUnLFxyXG4gICdjbGFzc2xpc3QnLFxyXG4gICdkb2N1bWVudGZyYWdtZW50JyxcclxuICAnaGlzdG9yeScsXHJcbiAgJ29wYWNpdHknLFxyXG4gICdjc3NhbmltYXRpb25zJyxcclxuXTtcclxuXHJcbmNvbnN0IERVUkFUSU9OID0gMjUwO1xyXG5jb25zdCBGQURFX0RVUkFUSU9OID0gNTAwO1xyXG5cclxuLy8gd2hlbmV2ZXIgdGhlIHNvdXJjZSBvYnNlcnZhYmxlIGVuY291bnRlcnMgYW4gZXJyb3IsXHJcbi8vIHdlIGxvZyBpdCB0byB0aGUgY29uc29sZSwgYnV0IGNvbnRpbnVlIGFzIGlmIGl0IG5ldmVyIGhhcHBlbmRcclxuZnVuY3Rpb24gbWFrZVVuc3RvcHBhYmxlKCkge1xyXG4gIHJldHVybiB0aGlzOjpyZWNvdmVyKChlcnJvciwgY2F1Z2h0KSA9PiB7XHJcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxyXG4gICAgcmV0dXJuIGNhdWdodDtcclxuICB9KTtcclxufVxyXG5cclxuaWYgKCF3aW5kb3cuZGlzYWJsZVB1c2hTdGF0ZSAmJiBoYXNGZWF0dXJlcyhSRVFVSVJFTUVOVFMpKSB7XHJcbiAgY29uc3QgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XHJcbiAgY29uc3QgaXNTYWZhcmkgPSB1YS5pbmRleE9mKCdzYWZhcmknKSA+IDAgJiYgdWEuaW5kZXhPZignY2hyb21lJykgPCAwO1xyXG5cclxuICBjb25zdCBjcm9zc0ZhZGVyID0gbmV3IENyb3NzRmFkZXIoeyBkdXJhdGlvbjogRkFERV9EVVJBVElPTiB9KTtcclxuXHJcbiAgY29uc3QgcHVzaFN0YXRlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ195UHVzaFN0YXRlJyk7XHJcblxyXG4gIGNvbnN0IGFuaW1hdGlvbk1haW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICBhbmltYXRpb25NYWluLmNsYXNzTGlzdC5hZGQoJ2FuaW1hdGlvbi1tYWluJyk7XHJcbiAgYW5pbWF0aW9uTWFpbi5jbGFzc0xpc3QuYWRkKCdmaXhlZC10b3AnKTtcclxuICBhbmltYXRpb25NYWluLmlubmVySFRNTCA9IGBcclxuICAgIDxkaXYgY2xhc3M9XCJjb250ZW50XCI+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJwYWdlXCI+PC9kaXY+XHJcbiAgICA8L2Rpdj5gO1xyXG4gIHB1c2hTdGF0ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhbmltYXRpb25NYWluLCBwdXNoU3RhdGUpO1xyXG5cclxuICBjb25zdCBsb2FkaW5nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgbG9hZGluZy5jbGFzc0xpc3QuYWRkKCdsb2FkaW5nJyk7XHJcbiAgbG9hZGluZy5pbm5lckhUTUwgPSBgXHJcbiAgICA8c3BhbiBjbGFzcz1cInNyLW9ubHlcIj5Mb2FkaW5nLi4uPC9zcGFuPlxyXG4gICAgPGRpdiBjbGFzcz1cInNrLWZvbGRpbmctY3ViZVwiPlxyXG4gICAgICA8ZGl2IGNsYXNzPVwic2stY3ViZTEgc2stY3ViZVwiPjwvZGl2PlxyXG4gICAgICA8ZGl2IGNsYXNzPVwic2stY3ViZTIgc2stY3ViZVwiPjwvZGl2PlxyXG4gICAgICA8ZGl2IGNsYXNzPVwic2stY3ViZTQgc2stY3ViZVwiPjwvZGl2PlxyXG4gICAgICA8ZGl2IGNsYXNzPVwic2stY3ViZTMgc2stY3ViZVwiPjwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgYDtcclxuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubmF2YmFyIC5jb250ZW50JykuYXBwZW5kQ2hpbGQobG9hZGluZyk7XHJcblxyXG4gIGNvbnN0IHN0YXJ0JCA9IE9ic2VydmFibGU6OmZyb21FdmVudChwdXNoU3RhdGUsICd5LXB1c2gtc3RhdGUtc3RhcnQnKVxyXG4gICAgOjptYXAoKHsgZGV0YWlsIH0pID0+IGRldGFpbClcclxuICAgIDo6bWFwKGRldGFpbCA9PiBbZGV0YWlsLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnX21haW4nKV0pXHJcbiAgICA6OmVmZmVjdCgoKSA9PiB7XHJcbiAgICAgIC8vIElmIGEgbGluayBvbiB0aGUgZHJhd2VyIGhhcyBiZWVuIGNsaWNrZWQsIGNsb3NlIGl0XHJcbiAgICAgIGlmICghd2luZG93LmlzRGVza3RvcCAmJiB3aW5kb3cuZHJhd2VyLm9wZW5lZCkge1xyXG4gICAgICAgIHdpbmRvdy5kcmF3ZXIuY2xvc2UoKTtcclxuICAgICAgfVxyXG4gICAgfSlcclxuICAgIDo6c2hhcmUoKTtcclxuXHJcbiAgY29uc3QgcmVhZHkkID0gT2JzZXJ2YWJsZTo6ZnJvbUV2ZW50KHB1c2hTdGF0ZSwgJ3ktcHVzaC1zdGF0ZS1yZWFkeScpXHJcbiAgICA6Om1hcCgoeyBkZXRhaWwgfSkgPT4gZGV0YWlsKVxyXG4gICAgOjpzaGFyZSgpO1xyXG5cclxuICBjb25zdCBwcm9ncmVzcyQgPSBPYnNlcnZhYmxlOjpmcm9tRXZlbnQocHVzaFN0YXRlLCAneS1wdXNoLXN0YXRlLXByb2dyZXNzJylcclxuICAgIDo6bWFwKCh7IGRldGFpbCB9KSA9PiBkZXRhaWwpO1xyXG4gICAgLy8gOjpzaGFyZSgpO1xyXG5cclxuICBjb25zdCBhZnRlciQgPSBPYnNlcnZhYmxlOjpmcm9tRXZlbnQocHVzaFN0YXRlLCAneS1wdXNoLXN0YXRlLWFmdGVyJylcclxuICAgIDo6bWFwKCh7IGRldGFpbCB9KSA9PiBkZXRhaWwpXHJcbiAgICA6OnNoYXJlKCk7XHJcblxyXG4gIC8vIGNvbnN0IGVycm9yJCA9IE9ic2VydmFibGUuZnJvbUV2ZW50KHB1c2hTdGF0ZSwgJ3ktcHVzaC1zdGF0ZS1lcnJvcicpO1xyXG5cclxuICAvLyBIQUNLXHJcbiAgaWYgKGlzU2FmYXJpKSB7XHJcbiAgICBPYnNlcnZhYmxlOjpmcm9tRXZlbnQod2luZG93LCAncG9wc3RhdGUnKVxyXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHsgZG9jdW1lbnQuYm9keS5zdHlsZS5taW5IZWlnaHQgPSAnOTk5OTk5cHgnOyB9KTtcclxuXHJcbiAgICBhZnRlciRcclxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB7IGRvY3VtZW50LmJvZHkuc3R5bGUubWluSGVpZ2h0ID0gJyc7IH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gRkxJUCBhbmltYXRpb24gKHdoZW4gYXBwbGljYWJsZSlcclxuICBzdGFydCRcclxuICAgIDo6c3dpdGNoTWFwKChbZGV0YWlsXSkgPT4ge1xyXG4gICAgICBjb25zdCB7IGV2ZW50OiB7IGN1cnJlbnRUYXJnZXQgfSB9ID0gZGV0YWlsO1xyXG5cclxuICAgICAgY29uc3QgZmxpcCA9IEZsaXAuY3JlYXRlKFxyXG4gICAgICAgIGN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlICYmXHJcbiAgICAgICAgY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZmxpcCcpLCB7XHJcbiAgICAgICAgICBhbmltYXRpb25NYWluLFxyXG4gICAgICAgICAgY3VycmVudFRhcmdldCxcclxuICAgICAgICAgIGR1cmF0aW9uOiBEVVJBVElPTixcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgIC8vIEhBQ0s6IFRoaXMgYXNzdW1lcyBrbm93bGVkZ2Ugb2YgdGhlIGludGVybmFsIHJ4IHBpcGVsaW5lLlxyXG4gICAgICAvLyBDb3VsZCBwb3NzaWJseSBiZSByZXBsYWNlZCB3aXRoIGB3aXRoTGF0ZXN0RnJvbWAgc2hpbmFuaWdhbnMsXHJcbiAgICAgIC8vIGJ1dCBpdCdzIG1vcmUgY29udmVuaWVudCBsaWtlIHRoYXQuXHJcbiAgICAgIGRldGFpbC5mbGlwID0gZmxpcDtcclxuXHJcbiAgICAgIHJldHVybiBmbGlwLnN0YXJ0KGN1cnJlbnRUYXJnZXQpO1xyXG4gICAgfSlcclxuICAgIDo6bWFrZVVuc3RvcHBhYmxlKClcclxuICAgIC5zdWJzY3JpYmUoKTtcclxuXHJcbiAgLy8gRmFkZSBtYWluIGNvbnRlbnQgb3V0XHJcbiAgc3RhcnQkXHJcbiAgICA6OmVmZmVjdCgoWywgbWFpbl0pID0+IHsgbWFpbi5zdHlsZS5vcGFjaXR5ID0gMDsgfSlcclxuICAgIDo6ZmlsdGVyKChbeyB0eXBlIH1dKSA9PiB0eXBlID09PSAncHVzaCcgfHwgIWlzU2FmYXJpKVxyXG4gICAgOjpleGhhdXN0TWFwKChbeyB0eXBlIH0sIG1haW5dKSA9PlxyXG4gICAgICBhbmltYXRlKG1haW4sIFtcclxuICAgICAgICB7IG9wYWNpdHk6IDEgfSxcclxuICAgICAgICB7IG9wYWNpdHk6IDAgfSxcclxuICAgICAgXSwge1xyXG4gICAgICAgIGR1cmF0aW9uOiBEVVJBVElPTixcclxuICAgICAgICAvLyBlYXNpbmc6ICdlYXNlJyxcclxuICAgICAgICBlYXNpbmc6ICdjdWJpYy1iZXppZXIoMCwwLDAuMzIsMSknLFxyXG4gICAgICB9KVxyXG4gICAgICAgIDo6ZWZmZWN0KCgpID0+IHsgaWYgKHR5cGUgPT09ICdwdXNoJykgd2luZG93LnNjcm9sbCgwLCAwKTsgfSlcclxuICAgICAgICA6OnppcFdpdGgoYWZ0ZXIkKSlcclxuICAgIDo6bWFrZVVuc3RvcHBhYmxlKClcclxuICAgIC5zdWJzY3JpYmUoKTtcclxuXHJcbiAgLy8gU2hvdyBsb2FkaW5nIGJhciB3aGVuIHRha2luZyBsb25nZXIgdGhhbiBleHBlY3RlZFxyXG4gIHByb2dyZXNzJFxyXG4gICAgOjplZmZlY3QoKCkgPT4geyBsb2FkaW5nLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snOyB9KVxyXG4gICAgOjptYWtlVW5zdG9wcGFibGUoKVxyXG4gICAgLnN1YnNjcmliZSgpO1xyXG5cclxuICAvLyBUT0RPOiBlcnJvciBtZXNzYWdlIT9cclxuICAvLyBlcnJvciRcclxuICAvLyAgIC8vIC5kZWxheShEVVJBVElPTikgLy8gSEFDS1xyXG4gIC8vICAgLmRvKCgpID0+IHtcclxuICAvLyAgICAgbG9hZGluZy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gIC8vICAgfSlcclxuICAvLyAgIC5zdWJzY3JpYmUoKTtcclxuXHJcbiAgLy8gUHJlcGFyZSBzaG93aW5nIHRoZSBuZXcgY29udGVudFxyXG4gIHJlYWR5JFxyXG4gICAgOjplZmZlY3QoKCkgPT4geyBsb2FkaW5nLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7IH0pXHJcbiAgICA6OmZpbHRlcigoeyB0eXBlIH0pID0+IHR5cGUgPT09ICdwdXNoJyB8fCAhaXNTYWZhcmkpXHJcbiAgICA6OnN3aXRjaE1hcCgoeyBmbGlwLCBjb250ZW50OiBbbWFpbl0gfSkgPT4gZmxpcC5yZWFkeShtYWluKTo6dGFrZVVudGlsKHN0YXJ0JCkpXHJcbiAgICA6Om1ha2VVbnN0b3BwYWJsZSgpXHJcbiAgICAuc3Vic2NyaWJlKCk7XHJcblxyXG4gIHJlYWR5JFxyXG4gICAgOjpzd2l0Y2hNYXAoKHsgY29udGVudDogW21haW5dIH0pID0+XHJcbiAgICAgIGNyb3NzRmFkZXIuZmV0Y2hJbWFnZShlbGVtRGF0YXNldChtYWluKSk6OnRha2VVbnRpbChzdGFydCQpKVxyXG4gICAgOjpzdGFydFdpdGgoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNpZGViYXItYmcnKSlcclxuICAgIDo6cGFpcndpc2UoKVxyXG4gICAgOjptZXJnZU1hcCg6OmNyb3NzRmFkZXIuY3Jvc3NGYWRlKVxyXG4gICAgOjptYWtlVW5zdG9wcGFibGUoKVxyXG4gICAgLnN1YnNjcmliZSgpO1xyXG5cclxuICAvLyBBbmltYXRlIHRoZSBuZXcgY29udGVudFxyXG4gIGFmdGVyJFxyXG4gICAgOjpmaWx0ZXIoKHsgdHlwZSB9KSA9PiB0eXBlID09PSAncHVzaCcgfHwgIWlzU2FmYXJpKVxyXG4gICAgOjptYXAoa2luZCA9PiBba2luZCwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWFpbicpXSlcclxuICAgIDo6c3dpdGNoTWFwKChbLCBtYWluXSkgPT5cclxuICAgICAgYW5pbWF0ZShtYWluLCBbXHJcbiAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKC0ycmVtKScsIG9wYWNpdHk6IDAgfSxcclxuICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoMCknLCBvcGFjaXR5OiAxIH0sXHJcbiAgICAgIF0sIHtcclxuICAgICAgICBkdXJhdGlvbjogRFVSQVRJT04sXHJcbiAgICAgICAgLy8gZWFzaW5nOiAnZWFzZScsXHJcbiAgICAgICAgZWFzaW5nOiAnY3ViaWMtYmV6aWVyKDAsMCwwLjMyLDEpJyxcclxuICAgICAgfSkpXHJcbiAgICA6Om1ha2VVbnN0b3BwYWJsZSgpXHJcbiAgICAuc3Vic2NyaWJlKCk7XHJcblxyXG4gIGFmdGVyJFxyXG4gICAgLy8gRG9uJ3Qgc2VuZCBhIHBhZ2V2aWV3IHdoZW4gdGhlIHVzZXIgYmxhc3RzIHRocm91Z2ggdGhlIGhpc3RvcnkuLlxyXG4gICAgOjpkZWJvdW5jZVRpbWUoMiAqIERVUkFUSU9OKVxyXG4gICAgOjplZmZlY3QoKCkgPT4ge1xyXG4gICAgICAvLyBTZW5kIGdvb2dsZSBhbmFseXRpY3MgcGFnZXZpZXdcclxuICAgICAgaWYgKHdpbmRvdy5nYSkgd2luZG93LmdhKCdzZW5kJywgJ3BhZ2V2aWV3Jyk7XHJcblxyXG4gICAgICAvLyBVcGdyYWRlIG1hdGggYmxvY2tzXHJcbiAgICAgIHVwZ3JhZGVNYXRoQmxvY2tzKCk7XHJcbiAgICB9KVxyXG4gICAgOjptYWtlVW5zdG9wcGFibGUoKVxyXG4gICAgLnN1YnNjcmliZSgpO1xyXG5cclxuICBuZXcgUHVzaFN0YXRlKHB1c2hTdGF0ZSwge1xyXG4gICAgcmVwbGFjZUlkczogWydfbWFpbiddLFxyXG4gICAgbGlua1NlbGVjdG9yOiAnYVtocmVmXj1cIi9cIl0nLFxyXG4gICAgc2NyaXB0U2VsZWN0b3I6ICdzY3JpcHQ6bm90KFt0eXBlXj1cIm1hdGgvdGV4XCJdKScsXHJcbiAgICBkdXJhdGlvbjogRFVSQVRJT04sXHJcbiAgICBub1BvcER1cmF0aW9uOiBpc1NhZmFyaSxcclxuICAgIHNjcm9sbFJlc3RvcmF0aW9uOiAhaXNTYWZhcmksXHJcbiAgfSkuc3RhcnRIaXN0b3J5KCk7XHJcbn1cclxuIiwiLyogTUlUIGxpY2Vuc2UgKi9cbnZhciBjc3NLZXl3b3JkcyA9IHJlcXVpcmUoJ2NvbG9yLW5hbWUnKTtcblxuLy8gTk9URTogY29udmVyc2lvbnMgc2hvdWxkIG9ubHkgcmV0dXJuIHByaW1pdGl2ZSB2YWx1ZXMgKGkuZS4gYXJyYXlzLCBvclxuLy8gICAgICAgdmFsdWVzIHRoYXQgZ2l2ZSBjb3JyZWN0IGB0eXBlb2ZgIHJlc3VsdHMpLlxuLy8gICAgICAgZG8gbm90IHVzZSBib3ggdmFsdWVzIHR5cGVzIChpLmUuIE51bWJlcigpLCBTdHJpbmcoKSwgZXRjLilcblxudmFyIHJldmVyc2VLZXl3b3JkcyA9IHt9O1xuZm9yICh2YXIga2V5IGluIGNzc0tleXdvcmRzKSB7XG5cdGlmIChjc3NLZXl3b3Jkcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0cmV2ZXJzZUtleXdvcmRzW2Nzc0tleXdvcmRzW2tleV1dID0ga2V5O1xuXHR9XG59XG5cbnZhciBjb252ZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSB7XG5cdHJnYjoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICdyZ2InfSxcblx0aHNsOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ2hzbCd9LFxuXHRoc3Y6IHtjaGFubmVsczogMywgbGFiZWxzOiAnaHN2J30sXG5cdGh3Yjoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICdod2InfSxcblx0Y215azoge2NoYW5uZWxzOiA0LCBsYWJlbHM6ICdjbXlrJ30sXG5cdHh5ejoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICd4eXonfSxcblx0bGFiOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ2xhYid9LFxuXHRsY2g6IHtjaGFubmVsczogMywgbGFiZWxzOiAnbGNoJ30sXG5cdGhleDoge2NoYW5uZWxzOiAxLCBsYWJlbHM6IFsnaGV4J119LFxuXHRrZXl3b3JkOiB7Y2hhbm5lbHM6IDEsIGxhYmVsczogWydrZXl3b3JkJ119LFxuXHRhbnNpMTY6IHtjaGFubmVsczogMSwgbGFiZWxzOiBbJ2Fuc2kxNiddfSxcblx0YW5zaTI1Njoge2NoYW5uZWxzOiAxLCBsYWJlbHM6IFsnYW5zaTI1NiddfSxcblx0aGNnOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogWydoJywgJ2MnLCAnZyddfSxcblx0YXBwbGU6IHtjaGFubmVsczogMywgbGFiZWxzOiBbJ3IxNicsICdnMTYnLCAnYjE2J119LFxuXHRncmF5OiB7Y2hhbm5lbHM6IDEsIGxhYmVsczogWydncmF5J119XG59O1xuXG4vLyBoaWRlIC5jaGFubmVscyBhbmQgLmxhYmVscyBwcm9wZXJ0aWVzXG5mb3IgKHZhciBtb2RlbCBpbiBjb252ZXJ0KSB7XG5cdGlmIChjb252ZXJ0Lmhhc093blByb3BlcnR5KG1vZGVsKSkge1xuXHRcdGlmICghKCdjaGFubmVscycgaW4gY29udmVydFttb2RlbF0pKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgY2hhbm5lbHMgcHJvcGVydHk6ICcgKyBtb2RlbCk7XG5cdFx0fVxuXG5cdFx0aWYgKCEoJ2xhYmVscycgaW4gY29udmVydFttb2RlbF0pKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgY2hhbm5lbCBsYWJlbHMgcHJvcGVydHk6ICcgKyBtb2RlbCk7XG5cdFx0fVxuXG5cdFx0aWYgKGNvbnZlcnRbbW9kZWxdLmxhYmVscy5sZW5ndGggIT09IGNvbnZlcnRbbW9kZWxdLmNoYW5uZWxzKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2NoYW5uZWwgYW5kIGxhYmVsIGNvdW50cyBtaXNtYXRjaDogJyArIG1vZGVsKTtcblx0XHR9XG5cblx0XHR2YXIgY2hhbm5lbHMgPSBjb252ZXJ0W21vZGVsXS5jaGFubmVscztcblx0XHR2YXIgbGFiZWxzID0gY29udmVydFttb2RlbF0ubGFiZWxzO1xuXHRcdGRlbGV0ZSBjb252ZXJ0W21vZGVsXS5jaGFubmVscztcblx0XHRkZWxldGUgY29udmVydFttb2RlbF0ubGFiZWxzO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb252ZXJ0W21vZGVsXSwgJ2NoYW5uZWxzJywge3ZhbHVlOiBjaGFubmVsc30pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb252ZXJ0W21vZGVsXSwgJ2xhYmVscycsIHt2YWx1ZTogbGFiZWxzfSk7XG5cdH1cbn1cblxuY29udmVydC5yZ2IuaHNsID0gZnVuY3Rpb24gKHJnYikge1xuXHR2YXIgciA9IHJnYlswXSAvIDI1NTtcblx0dmFyIGcgPSByZ2JbMV0gLyAyNTU7XG5cdHZhciBiID0gcmdiWzJdIC8gMjU1O1xuXHR2YXIgbWluID0gTWF0aC5taW4ociwgZywgYik7XG5cdHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcblx0dmFyIGRlbHRhID0gbWF4IC0gbWluO1xuXHR2YXIgaDtcblx0dmFyIHM7XG5cdHZhciBsO1xuXG5cdGlmIChtYXggPT09IG1pbikge1xuXHRcdGggPSAwO1xuXHR9IGVsc2UgaWYgKHIgPT09IG1heCkge1xuXHRcdGggPSAoZyAtIGIpIC8gZGVsdGE7XG5cdH0gZWxzZSBpZiAoZyA9PT0gbWF4KSB7XG5cdFx0aCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG5cdH0gZWxzZSBpZiAoYiA9PT0gbWF4KSB7XG5cdFx0aCA9IDQgKyAociAtIGcpIC8gZGVsdGE7XG5cdH1cblxuXHRoID0gTWF0aC5taW4oaCAqIDYwLCAzNjApO1xuXG5cdGlmIChoIDwgMCkge1xuXHRcdGggKz0gMzYwO1xuXHR9XG5cblx0bCA9IChtaW4gKyBtYXgpIC8gMjtcblxuXHRpZiAobWF4ID09PSBtaW4pIHtcblx0XHRzID0gMDtcblx0fSBlbHNlIGlmIChsIDw9IDAuNSkge1xuXHRcdHMgPSBkZWx0YSAvIChtYXggKyBtaW4pO1xuXHR9IGVsc2Uge1xuXHRcdHMgPSBkZWx0YSAvICgyIC0gbWF4IC0gbWluKTtcblx0fVxuXG5cdHJldHVybiBbaCwgcyAqIDEwMCwgbCAqIDEwMF07XG59O1xuXG5jb252ZXJ0LnJnYi5oc3YgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciByID0gcmdiWzBdO1xuXHR2YXIgZyA9IHJnYlsxXTtcblx0dmFyIGIgPSByZ2JbMl07XG5cdHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcblx0dmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuXHR2YXIgZGVsdGEgPSBtYXggLSBtaW47XG5cdHZhciBoO1xuXHR2YXIgcztcblx0dmFyIHY7XG5cblx0aWYgKG1heCA9PT0gMCkge1xuXHRcdHMgPSAwO1xuXHR9IGVsc2Uge1xuXHRcdHMgPSAoZGVsdGEgLyBtYXggKiAxMDAwKSAvIDEwO1xuXHR9XG5cblx0aWYgKG1heCA9PT0gbWluKSB7XG5cdFx0aCA9IDA7XG5cdH0gZWxzZSBpZiAociA9PT0gbWF4KSB7XG5cdFx0aCA9IChnIC0gYikgLyBkZWx0YTtcblx0fSBlbHNlIGlmIChnID09PSBtYXgpIHtcblx0XHRoID0gMiArIChiIC0gcikgLyBkZWx0YTtcblx0fSBlbHNlIGlmIChiID09PSBtYXgpIHtcblx0XHRoID0gNCArIChyIC0gZykgLyBkZWx0YTtcblx0fVxuXG5cdGggPSBNYXRoLm1pbihoICogNjAsIDM2MCk7XG5cblx0aWYgKGggPCAwKSB7XG5cdFx0aCArPSAzNjA7XG5cdH1cblxuXHR2ID0gKChtYXggLyAyNTUpICogMTAwMCkgLyAxMDtcblxuXHRyZXR1cm4gW2gsIHMsIHZdO1xufTtcblxuY29udmVydC5yZ2IuaHdiID0gZnVuY3Rpb24gKHJnYikge1xuXHR2YXIgciA9IHJnYlswXTtcblx0dmFyIGcgPSByZ2JbMV07XG5cdHZhciBiID0gcmdiWzJdO1xuXHR2YXIgaCA9IGNvbnZlcnQucmdiLmhzbChyZ2IpWzBdO1xuXHR2YXIgdyA9IDEgLyAyNTUgKiBNYXRoLm1pbihyLCBNYXRoLm1pbihnLCBiKSk7XG5cblx0YiA9IDEgLSAxIC8gMjU1ICogTWF0aC5tYXgociwgTWF0aC5tYXgoZywgYikpO1xuXG5cdHJldHVybiBbaCwgdyAqIDEwMCwgYiAqIDEwMF07XG59O1xuXG5jb252ZXJ0LnJnYi5jbXlrID0gZnVuY3Rpb24gKHJnYikge1xuXHR2YXIgciA9IHJnYlswXSAvIDI1NTtcblx0dmFyIGcgPSByZ2JbMV0gLyAyNTU7XG5cdHZhciBiID0gcmdiWzJdIC8gMjU1O1xuXHR2YXIgYztcblx0dmFyIG07XG5cdHZhciB5O1xuXHR2YXIgaztcblxuXHRrID0gTWF0aC5taW4oMSAtIHIsIDEgLSBnLCAxIC0gYik7XG5cdGMgPSAoMSAtIHIgLSBrKSAvICgxIC0gaykgfHwgMDtcblx0bSA9ICgxIC0gZyAtIGspIC8gKDEgLSBrKSB8fCAwO1xuXHR5ID0gKDEgLSBiIC0gaykgLyAoMSAtIGspIHx8IDA7XG5cblx0cmV0dXJuIFtjICogMTAwLCBtICogMTAwLCB5ICogMTAwLCBrICogMTAwXTtcbn07XG5cbi8qKlxuICogU2VlIGh0dHBzOi8vZW4ubS53aWtpcGVkaWEub3JnL3dpa2kvRXVjbGlkZWFuX2Rpc3RhbmNlI1NxdWFyZWRfRXVjbGlkZWFuX2Rpc3RhbmNlXG4gKiAqL1xuZnVuY3Rpb24gY29tcGFyYXRpdmVEaXN0YW5jZSh4LCB5KSB7XG5cdHJldHVybiAoXG5cdFx0TWF0aC5wb3coeFswXSAtIHlbMF0sIDIpICtcblx0XHRNYXRoLnBvdyh4WzFdIC0geVsxXSwgMikgK1xuXHRcdE1hdGgucG93KHhbMl0gLSB5WzJdLCAyKVxuXHQpO1xufVxuXG5jb252ZXJ0LnJnYi5rZXl3b3JkID0gZnVuY3Rpb24gKHJnYikge1xuXHR2YXIgcmV2ZXJzZWQgPSByZXZlcnNlS2V5d29yZHNbcmdiXTtcblx0aWYgKHJldmVyc2VkKSB7XG5cdFx0cmV0dXJuIHJldmVyc2VkO1xuXHR9XG5cblx0dmFyIGN1cnJlbnRDbG9zZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcblx0dmFyIGN1cnJlbnRDbG9zZXN0S2V5d29yZDtcblxuXHRmb3IgKHZhciBrZXl3b3JkIGluIGNzc0tleXdvcmRzKSB7XG5cdFx0aWYgKGNzc0tleXdvcmRzLmhhc093blByb3BlcnR5KGtleXdvcmQpKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBjc3NLZXl3b3Jkc1trZXl3b3JkXTtcblxuXHRcdFx0Ly8gQ29tcHV0ZSBjb21wYXJhdGl2ZSBkaXN0YW5jZVxuXHRcdFx0dmFyIGRpc3RhbmNlID0gY29tcGFyYXRpdmVEaXN0YW5jZShyZ2IsIHZhbHVlKTtcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgaXRzIGxlc3MsIGlmIHNvIHNldCBhcyBjbG9zZXN0XG5cdFx0XHRpZiAoZGlzdGFuY2UgPCBjdXJyZW50Q2xvc2VzdERpc3RhbmNlKSB7XG5cdFx0XHRcdGN1cnJlbnRDbG9zZXN0RGlzdGFuY2UgPSBkaXN0YW5jZTtcblx0XHRcdFx0Y3VycmVudENsb3Nlc3RLZXl3b3JkID0ga2V5d29yZDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY3VycmVudENsb3Nlc3RLZXl3b3JkO1xufTtcblxuY29udmVydC5rZXl3b3JkLnJnYiA9IGZ1bmN0aW9uIChrZXl3b3JkKSB7XG5cdHJldHVybiBjc3NLZXl3b3Jkc1trZXl3b3JkXTtcbn07XG5cbmNvbnZlcnQucmdiLnh5eiA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHIgPSByZ2JbMF0gLyAyNTU7XG5cdHZhciBnID0gcmdiWzFdIC8gMjU1O1xuXHR2YXIgYiA9IHJnYlsyXSAvIDI1NTtcblxuXHQvLyBhc3N1bWUgc1JHQlxuXHRyID0gciA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKHIgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAociAvIDEyLjkyKTtcblx0ZyA9IGcgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChnICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKGcgLyAxMi45Mik7XG5cdGIgPSBiID4gMC4wNDA0NSA/IE1hdGgucG93KCgoYiArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChiIC8gMTIuOTIpO1xuXG5cdHZhciB4ID0gKHIgKiAwLjQxMjQpICsgKGcgKiAwLjM1NzYpICsgKGIgKiAwLjE4MDUpO1xuXHR2YXIgeSA9IChyICogMC4yMTI2KSArIChnICogMC43MTUyKSArIChiICogMC4wNzIyKTtcblx0dmFyIHogPSAociAqIDAuMDE5MykgKyAoZyAqIDAuMTE5MikgKyAoYiAqIDAuOTUwNSk7XG5cblx0cmV0dXJuIFt4ICogMTAwLCB5ICogMTAwLCB6ICogMTAwXTtcbn07XG5cbmNvbnZlcnQucmdiLmxhYiA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHh5eiA9IGNvbnZlcnQucmdiLnh5eihyZ2IpO1xuXHR2YXIgeCA9IHh5elswXTtcblx0dmFyIHkgPSB4eXpbMV07XG5cdHZhciB6ID0geHl6WzJdO1xuXHR2YXIgbDtcblx0dmFyIGE7XG5cdHZhciBiO1xuXG5cdHggLz0gOTUuMDQ3O1xuXHR5IC89IDEwMDtcblx0eiAvPSAxMDguODgzO1xuXG5cdHggPSB4ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxIC8gMykgOiAoNy43ODcgKiB4KSArICgxNiAvIDExNik7XG5cdHkgPSB5ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh5LCAxIC8gMykgOiAoNy43ODcgKiB5KSArICgxNiAvIDExNik7XG5cdHogPSB6ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh6LCAxIC8gMykgOiAoNy43ODcgKiB6KSArICgxNiAvIDExNik7XG5cblx0bCA9ICgxMTYgKiB5KSAtIDE2O1xuXHRhID0gNTAwICogKHggLSB5KTtcblx0YiA9IDIwMCAqICh5IC0geik7XG5cblx0cmV0dXJuIFtsLCBhLCBiXTtcbn07XG5cbmNvbnZlcnQuaHNsLnJnYiA9IGZ1bmN0aW9uIChoc2wpIHtcblx0dmFyIGggPSBoc2xbMF0gLyAzNjA7XG5cdHZhciBzID0gaHNsWzFdIC8gMTAwO1xuXHR2YXIgbCA9IGhzbFsyXSAvIDEwMDtcblx0dmFyIHQxO1xuXHR2YXIgdDI7XG5cdHZhciB0Mztcblx0dmFyIHJnYjtcblx0dmFyIHZhbDtcblxuXHRpZiAocyA9PT0gMCkge1xuXHRcdHZhbCA9IGwgKiAyNTU7XG5cdFx0cmV0dXJuIFt2YWwsIHZhbCwgdmFsXTtcblx0fVxuXG5cdGlmIChsIDwgMC41KSB7XG5cdFx0dDIgPSBsICogKDEgKyBzKTtcblx0fSBlbHNlIHtcblx0XHR0MiA9IGwgKyBzIC0gbCAqIHM7XG5cdH1cblxuXHR0MSA9IDIgKiBsIC0gdDI7XG5cblx0cmdiID0gWzAsIDAsIDBdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdHQzID0gaCArIDEgLyAzICogLShpIC0gMSk7XG5cdFx0aWYgKHQzIDwgMCkge1xuXHRcdFx0dDMrKztcblx0XHR9XG5cdFx0aWYgKHQzID4gMSkge1xuXHRcdFx0dDMtLTtcblx0XHR9XG5cblx0XHRpZiAoNiAqIHQzIDwgMSkge1xuXHRcdFx0dmFsID0gdDEgKyAodDIgLSB0MSkgKiA2ICogdDM7XG5cdFx0fSBlbHNlIGlmICgyICogdDMgPCAxKSB7XG5cdFx0XHR2YWwgPSB0Mjtcblx0XHR9IGVsc2UgaWYgKDMgKiB0MyA8IDIpIHtcblx0XHRcdHZhbCA9IHQxICsgKHQyIC0gdDEpICogKDIgLyAzIC0gdDMpICogNjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFsID0gdDE7XG5cdFx0fVxuXG5cdFx0cmdiW2ldID0gdmFsICogMjU1O1xuXHR9XG5cblx0cmV0dXJuIHJnYjtcbn07XG5cbmNvbnZlcnQuaHNsLmhzdiA9IGZ1bmN0aW9uIChoc2wpIHtcblx0dmFyIGggPSBoc2xbMF07XG5cdHZhciBzID0gaHNsWzFdIC8gMTAwO1xuXHR2YXIgbCA9IGhzbFsyXSAvIDEwMDtcblx0dmFyIHNtaW4gPSBzO1xuXHR2YXIgbG1pbiA9IE1hdGgubWF4KGwsIDAuMDEpO1xuXHR2YXIgc3Y7XG5cdHZhciB2O1xuXG5cdGwgKj0gMjtcblx0cyAqPSAobCA8PSAxKSA/IGwgOiAyIC0gbDtcblx0c21pbiAqPSBsbWluIDw9IDEgPyBsbWluIDogMiAtIGxtaW47XG5cdHYgPSAobCArIHMpIC8gMjtcblx0c3YgPSBsID09PSAwID8gKDIgKiBzbWluKSAvIChsbWluICsgc21pbikgOiAoMiAqIHMpIC8gKGwgKyBzKTtcblxuXHRyZXR1cm4gW2gsIHN2ICogMTAwLCB2ICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaHN2LnJnYiA9IGZ1bmN0aW9uIChoc3YpIHtcblx0dmFyIGggPSBoc3ZbMF0gLyA2MDtcblx0dmFyIHMgPSBoc3ZbMV0gLyAxMDA7XG5cdHZhciB2ID0gaHN2WzJdIC8gMTAwO1xuXHR2YXIgaGkgPSBNYXRoLmZsb29yKGgpICUgNjtcblxuXHR2YXIgZiA9IGggLSBNYXRoLmZsb29yKGgpO1xuXHR2YXIgcCA9IDI1NSAqIHYgKiAoMSAtIHMpO1xuXHR2YXIgcSA9IDI1NSAqIHYgKiAoMSAtIChzICogZikpO1xuXHR2YXIgdCA9IDI1NSAqIHYgKiAoMSAtIChzICogKDEgLSBmKSkpO1xuXHR2ICo9IDI1NTtcblxuXHRzd2l0Y2ggKGhpKSB7XG5cdFx0Y2FzZSAwOlxuXHRcdFx0cmV0dXJuIFt2LCB0LCBwXTtcblx0XHRjYXNlIDE6XG5cdFx0XHRyZXR1cm4gW3EsIHYsIHBdO1xuXHRcdGNhc2UgMjpcblx0XHRcdHJldHVybiBbcCwgdiwgdF07XG5cdFx0Y2FzZSAzOlxuXHRcdFx0cmV0dXJuIFtwLCBxLCB2XTtcblx0XHRjYXNlIDQ6XG5cdFx0XHRyZXR1cm4gW3QsIHAsIHZdO1xuXHRcdGNhc2UgNTpcblx0XHRcdHJldHVybiBbdiwgcCwgcV07XG5cdH1cbn07XG5cbmNvbnZlcnQuaHN2LmhzbCA9IGZ1bmN0aW9uIChoc3YpIHtcblx0dmFyIGggPSBoc3ZbMF07XG5cdHZhciBzID0gaHN2WzFdIC8gMTAwO1xuXHR2YXIgdiA9IGhzdlsyXSAvIDEwMDtcblx0dmFyIHZtaW4gPSBNYXRoLm1heCh2LCAwLjAxKTtcblx0dmFyIGxtaW47XG5cdHZhciBzbDtcblx0dmFyIGw7XG5cblx0bCA9ICgyIC0gcykgKiB2O1xuXHRsbWluID0gKDIgLSBzKSAqIHZtaW47XG5cdHNsID0gcyAqIHZtaW47XG5cdHNsIC89IChsbWluIDw9IDEpID8gbG1pbiA6IDIgLSBsbWluO1xuXHRzbCA9IHNsIHx8IDA7XG5cdGwgLz0gMjtcblxuXHRyZXR1cm4gW2gsIHNsICogMTAwLCBsICogMTAwXTtcbn07XG5cbi8vIGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy1jb2xvci8jaHdiLXRvLXJnYlxuY29udmVydC5od2IucmdiID0gZnVuY3Rpb24gKGh3Yikge1xuXHR2YXIgaCA9IGh3YlswXSAvIDM2MDtcblx0dmFyIHdoID0gaHdiWzFdIC8gMTAwO1xuXHR2YXIgYmwgPSBod2JbMl0gLyAxMDA7XG5cdHZhciByYXRpbyA9IHdoICsgYmw7XG5cdHZhciBpO1xuXHR2YXIgdjtcblx0dmFyIGY7XG5cdHZhciBuO1xuXG5cdC8vIHdoICsgYmwgY2FudCBiZSA+IDFcblx0aWYgKHJhdGlvID4gMSkge1xuXHRcdHdoIC89IHJhdGlvO1xuXHRcdGJsIC89IHJhdGlvO1xuXHR9XG5cblx0aSA9IE1hdGguZmxvb3IoNiAqIGgpO1xuXHR2ID0gMSAtIGJsO1xuXHRmID0gNiAqIGggLSBpO1xuXG5cdGlmICgoaSAmIDB4MDEpICE9PSAwKSB7XG5cdFx0ZiA9IDEgLSBmO1xuXHR9XG5cblx0biA9IHdoICsgZiAqICh2IC0gd2gpOyAvLyBsaW5lYXIgaW50ZXJwb2xhdGlvblxuXG5cdHZhciByO1xuXHR2YXIgZztcblx0dmFyIGI7XG5cdHN3aXRjaCAoaSkge1xuXHRcdGRlZmF1bHQ6XG5cdFx0Y2FzZSA2OlxuXHRcdGNhc2UgMDogciA9IHY7IGcgPSBuOyBiID0gd2g7IGJyZWFrO1xuXHRcdGNhc2UgMTogciA9IG47IGcgPSB2OyBiID0gd2g7IGJyZWFrO1xuXHRcdGNhc2UgMjogciA9IHdoOyBnID0gdjsgYiA9IG47IGJyZWFrO1xuXHRcdGNhc2UgMzogciA9IHdoOyBnID0gbjsgYiA9IHY7IGJyZWFrO1xuXHRcdGNhc2UgNDogciA9IG47IGcgPSB3aDsgYiA9IHY7IGJyZWFrO1xuXHRcdGNhc2UgNTogciA9IHY7IGcgPSB3aDsgYiA9IG47IGJyZWFrO1xuXHR9XG5cblx0cmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn07XG5cbmNvbnZlcnQuY215ay5yZ2IgPSBmdW5jdGlvbiAoY215aykge1xuXHR2YXIgYyA9IGNteWtbMF0gLyAxMDA7XG5cdHZhciBtID0gY215a1sxXSAvIDEwMDtcblx0dmFyIHkgPSBjbXlrWzJdIC8gMTAwO1xuXHR2YXIgayA9IGNteWtbM10gLyAxMDA7XG5cdHZhciByO1xuXHR2YXIgZztcblx0dmFyIGI7XG5cblx0ciA9IDEgLSBNYXRoLm1pbigxLCBjICogKDEgLSBrKSArIGspO1xuXHRnID0gMSAtIE1hdGgubWluKDEsIG0gKiAoMSAtIGspICsgayk7XG5cdGIgPSAxIC0gTWF0aC5taW4oMSwgeSAqICgxIC0gaykgKyBrKTtcblxuXHRyZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufTtcblxuY29udmVydC54eXoucmdiID0gZnVuY3Rpb24gKHh5eikge1xuXHR2YXIgeCA9IHh5elswXSAvIDEwMDtcblx0dmFyIHkgPSB4eXpbMV0gLyAxMDA7XG5cdHZhciB6ID0geHl6WzJdIC8gMTAwO1xuXHR2YXIgcjtcblx0dmFyIGc7XG5cdHZhciBiO1xuXG5cdHIgPSAoeCAqIDMuMjQwNikgKyAoeSAqIC0xLjUzNzIpICsgKHogKiAtMC40OTg2KTtcblx0ZyA9ICh4ICogLTAuOTY4OSkgKyAoeSAqIDEuODc1OCkgKyAoeiAqIDAuMDQxNSk7XG5cdGIgPSAoeCAqIDAuMDU1NykgKyAoeSAqIC0wLjIwNDApICsgKHogKiAxLjA1NzApO1xuXG5cdC8vIGFzc3VtZSBzUkdCXG5cdHIgPSByID4gMC4wMDMxMzA4XG5cdFx0PyAoKDEuMDU1ICogTWF0aC5wb3cociwgMS4wIC8gMi40KSkgLSAwLjA1NSlcblx0XHQ6IHIgKiAxMi45MjtcblxuXHRnID0gZyA+IDAuMDAzMTMwOFxuXHRcdD8gKCgxLjA1NSAqIE1hdGgucG93KGcsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG5cdFx0OiBnICogMTIuOTI7XG5cblx0YiA9IGIgPiAwLjAwMzEzMDhcblx0XHQ/ICgoMS4wNTUgKiBNYXRoLnBvdyhiLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuXHRcdDogYiAqIDEyLjkyO1xuXG5cdHIgPSBNYXRoLm1pbihNYXRoLm1heCgwLCByKSwgMSk7XG5cdGcgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBnKSwgMSk7XG5cdGIgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBiKSwgMSk7XG5cblx0cmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn07XG5cbmNvbnZlcnQueHl6LmxhYiA9IGZ1bmN0aW9uICh4eXopIHtcblx0dmFyIHggPSB4eXpbMF07XG5cdHZhciB5ID0geHl6WzFdO1xuXHR2YXIgeiA9IHh5elsyXTtcblx0dmFyIGw7XG5cdHZhciBhO1xuXHR2YXIgYjtcblxuXHR4IC89IDk1LjA0Nztcblx0eSAvPSAxMDA7XG5cdHogLz0gMTA4Ljg4MztcblxuXHR4ID0geCA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeCwgMSAvIDMpIDogKDcuNzg3ICogeCkgKyAoMTYgLyAxMTYpO1xuXHR5ID0geSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeSwgMSAvIDMpIDogKDcuNzg3ICogeSkgKyAoMTYgLyAxMTYpO1xuXHR6ID0geiA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeiwgMSAvIDMpIDogKDcuNzg3ICogeikgKyAoMTYgLyAxMTYpO1xuXG5cdGwgPSAoMTE2ICogeSkgLSAxNjtcblx0YSA9IDUwMCAqICh4IC0geSk7XG5cdGIgPSAyMDAgKiAoeSAtIHopO1xuXG5cdHJldHVybiBbbCwgYSwgYl07XG59O1xuXG5jb252ZXJ0LmxhYi54eXogPSBmdW5jdGlvbiAobGFiKSB7XG5cdHZhciBsID0gbGFiWzBdO1xuXHR2YXIgYSA9IGxhYlsxXTtcblx0dmFyIGIgPSBsYWJbMl07XG5cdHZhciB4O1xuXHR2YXIgeTtcblx0dmFyIHo7XG5cblx0eSA9IChsICsgMTYpIC8gMTE2O1xuXHR4ID0gYSAvIDUwMCArIHk7XG5cdHogPSB5IC0gYiAvIDIwMDtcblxuXHR2YXIgeTIgPSBNYXRoLnBvdyh5LCAzKTtcblx0dmFyIHgyID0gTWF0aC5wb3coeCwgMyk7XG5cdHZhciB6MiA9IE1hdGgucG93KHosIDMpO1xuXHR5ID0geTIgPiAwLjAwODg1NiA/IHkyIDogKHkgLSAxNiAvIDExNikgLyA3Ljc4Nztcblx0eCA9IHgyID4gMC4wMDg4NTYgPyB4MiA6ICh4IC0gMTYgLyAxMTYpIC8gNy43ODc7XG5cdHogPSB6MiA+IDAuMDA4ODU2ID8gejIgOiAoeiAtIDE2IC8gMTE2KSAvIDcuNzg3O1xuXG5cdHggKj0gOTUuMDQ3O1xuXHR5ICo9IDEwMDtcblx0eiAqPSAxMDguODgzO1xuXG5cdHJldHVybiBbeCwgeSwgel07XG59O1xuXG5jb252ZXJ0LmxhYi5sY2ggPSBmdW5jdGlvbiAobGFiKSB7XG5cdHZhciBsID0gbGFiWzBdO1xuXHR2YXIgYSA9IGxhYlsxXTtcblx0dmFyIGIgPSBsYWJbMl07XG5cdHZhciBocjtcblx0dmFyIGg7XG5cdHZhciBjO1xuXG5cdGhyID0gTWF0aC5hdGFuMihiLCBhKTtcblx0aCA9IGhyICogMzYwIC8gMiAvIE1hdGguUEk7XG5cblx0aWYgKGggPCAwKSB7XG5cdFx0aCArPSAzNjA7XG5cdH1cblxuXHRjID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuXG5cdHJldHVybiBbbCwgYywgaF07XG59O1xuXG5jb252ZXJ0LmxjaC5sYWIgPSBmdW5jdGlvbiAobGNoKSB7XG5cdHZhciBsID0gbGNoWzBdO1xuXHR2YXIgYyA9IGxjaFsxXTtcblx0dmFyIGggPSBsY2hbMl07XG5cdHZhciBhO1xuXHR2YXIgYjtcblx0dmFyIGhyO1xuXG5cdGhyID0gaCAvIDM2MCAqIDIgKiBNYXRoLlBJO1xuXHRhID0gYyAqIE1hdGguY29zKGhyKTtcblx0YiA9IGMgKiBNYXRoLnNpbihocik7XG5cblx0cmV0dXJuIFtsLCBhLCBiXTtcbn07XG5cbmNvbnZlcnQucmdiLmFuc2kxNiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdHZhciByID0gYXJnc1swXTtcblx0dmFyIGcgPSBhcmdzWzFdO1xuXHR2YXIgYiA9IGFyZ3NbMl07XG5cdHZhciB2YWx1ZSA9IDEgaW4gYXJndW1lbnRzID8gYXJndW1lbnRzWzFdIDogY29udmVydC5yZ2IuaHN2KGFyZ3MpWzJdOyAvLyBoc3YgLT4gYW5zaTE2IG9wdGltaXphdGlvblxuXG5cdHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAvIDUwKTtcblxuXHRpZiAodmFsdWUgPT09IDApIHtcblx0XHRyZXR1cm4gMzA7XG5cdH1cblxuXHR2YXIgYW5zaSA9IDMwXG5cdFx0KyAoKE1hdGgucm91bmQoYiAvIDI1NSkgPDwgMilcblx0XHR8IChNYXRoLnJvdW5kKGcgLyAyNTUpIDw8IDEpXG5cdFx0fCBNYXRoLnJvdW5kKHIgLyAyNTUpKTtcblxuXHRpZiAodmFsdWUgPT09IDIpIHtcblx0XHRhbnNpICs9IDYwO1xuXHR9XG5cblx0cmV0dXJuIGFuc2k7XG59O1xuXG5jb252ZXJ0Lmhzdi5hbnNpMTYgPSBmdW5jdGlvbiAoYXJncykge1xuXHQvLyBvcHRpbWl6YXRpb24gaGVyZTsgd2UgYWxyZWFkeSBrbm93IHRoZSB2YWx1ZSBhbmQgZG9uJ3QgbmVlZCB0byBnZXRcblx0Ly8gaXQgY29udmVydGVkIGZvciB1cy5cblx0cmV0dXJuIGNvbnZlcnQucmdiLmFuc2kxNihjb252ZXJ0Lmhzdi5yZ2IoYXJncyksIGFyZ3NbMl0pO1xufTtcblxuY29udmVydC5yZ2IuYW5zaTI1NiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdHZhciByID0gYXJnc1swXTtcblx0dmFyIGcgPSBhcmdzWzFdO1xuXHR2YXIgYiA9IGFyZ3NbMl07XG5cblx0Ly8gd2UgdXNlIHRoZSBleHRlbmRlZCBncmV5c2NhbGUgcGFsZXR0ZSBoZXJlLCB3aXRoIHRoZSBleGNlcHRpb24gb2Zcblx0Ly8gYmxhY2sgYW5kIHdoaXRlLiBub3JtYWwgcGFsZXR0ZSBvbmx5IGhhcyA0IGdyZXlzY2FsZSBzaGFkZXMuXG5cdGlmIChyID09PSBnICYmIGcgPT09IGIpIHtcblx0XHRpZiAociA8IDgpIHtcblx0XHRcdHJldHVybiAxNjtcblx0XHR9XG5cblx0XHRpZiAociA+IDI0OCkge1xuXHRcdFx0cmV0dXJuIDIzMTtcblx0XHR9XG5cblx0XHRyZXR1cm4gTWF0aC5yb3VuZCgoKHIgLSA4KSAvIDI0NykgKiAyNCkgKyAyMzI7XG5cdH1cblxuXHR2YXIgYW5zaSA9IDE2XG5cdFx0KyAoMzYgKiBNYXRoLnJvdW5kKHIgLyAyNTUgKiA1KSlcblx0XHQrICg2ICogTWF0aC5yb3VuZChnIC8gMjU1ICogNSkpXG5cdFx0KyBNYXRoLnJvdW5kKGIgLyAyNTUgKiA1KTtcblxuXHRyZXR1cm4gYW5zaTtcbn07XG5cbmNvbnZlcnQuYW5zaTE2LnJnYiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdHZhciBjb2xvciA9IGFyZ3MgJSAxMDtcblxuXHQvLyBoYW5kbGUgZ3JleXNjYWxlXG5cdGlmIChjb2xvciA9PT0gMCB8fCBjb2xvciA9PT0gNykge1xuXHRcdGlmIChhcmdzID4gNTApIHtcblx0XHRcdGNvbG9yICs9IDMuNTtcblx0XHR9XG5cblx0XHRjb2xvciA9IGNvbG9yIC8gMTAuNSAqIDI1NTtcblxuXHRcdHJldHVybiBbY29sb3IsIGNvbG9yLCBjb2xvcl07XG5cdH1cblxuXHR2YXIgbXVsdCA9ICh+fihhcmdzID4gNTApICsgMSkgKiAwLjU7XG5cdHZhciByID0gKChjb2xvciAmIDEpICogbXVsdCkgKiAyNTU7XG5cdHZhciBnID0gKCgoY29sb3IgPj4gMSkgJiAxKSAqIG11bHQpICogMjU1O1xuXHR2YXIgYiA9ICgoKGNvbG9yID4+IDIpICYgMSkgKiBtdWx0KSAqIDI1NTtcblxuXHRyZXR1cm4gW3IsIGcsIGJdO1xufTtcblxuY29udmVydC5hbnNpMjU2LnJnYiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdC8vIGhhbmRsZSBncmV5c2NhbGVcblx0aWYgKGFyZ3MgPj0gMjMyKSB7XG5cdFx0dmFyIGMgPSAoYXJncyAtIDIzMikgKiAxMCArIDg7XG5cdFx0cmV0dXJuIFtjLCBjLCBjXTtcblx0fVxuXG5cdGFyZ3MgLT0gMTY7XG5cblx0dmFyIHJlbTtcblx0dmFyIHIgPSBNYXRoLmZsb29yKGFyZ3MgLyAzNikgLyA1ICogMjU1O1xuXHR2YXIgZyA9IE1hdGguZmxvb3IoKHJlbSA9IGFyZ3MgJSAzNikgLyA2KSAvIDUgKiAyNTU7XG5cdHZhciBiID0gKHJlbSAlIDYpIC8gNSAqIDI1NTtcblxuXHRyZXR1cm4gW3IsIGcsIGJdO1xufTtcblxuY29udmVydC5yZ2IuaGV4ID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0dmFyIGludGVnZXIgPSAoKE1hdGgucm91bmQoYXJnc1swXSkgJiAweEZGKSA8PCAxNilcblx0XHQrICgoTWF0aC5yb3VuZChhcmdzWzFdKSAmIDB4RkYpIDw8IDgpXG5cdFx0KyAoTWF0aC5yb3VuZChhcmdzWzJdKSAmIDB4RkYpO1xuXG5cdHZhciBzdHJpbmcgPSBpbnRlZ2VyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHRyZXR1cm4gJzAwMDAwMCcuc3Vic3RyaW5nKHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xufTtcblxuY29udmVydC5oZXgucmdiID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0dmFyIG1hdGNoID0gYXJncy50b1N0cmluZygxNikubWF0Y2goL1thLWYwLTldezZ9fFthLWYwLTldezN9L2kpO1xuXHRpZiAoIW1hdGNoKSB7XG5cdFx0cmV0dXJuIFswLCAwLCAwXTtcblx0fVxuXG5cdHZhciBjb2xvclN0cmluZyA9IG1hdGNoWzBdO1xuXG5cdGlmIChtYXRjaFswXS5sZW5ndGggPT09IDMpIHtcblx0XHRjb2xvclN0cmluZyA9IGNvbG9yU3RyaW5nLnNwbGl0KCcnKS5tYXAoZnVuY3Rpb24gKGNoYXIpIHtcblx0XHRcdHJldHVybiBjaGFyICsgY2hhcjtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdHZhciBpbnRlZ2VyID0gcGFyc2VJbnQoY29sb3JTdHJpbmcsIDE2KTtcblx0dmFyIHIgPSAoaW50ZWdlciA+PiAxNikgJiAweEZGO1xuXHR2YXIgZyA9IChpbnRlZ2VyID4+IDgpICYgMHhGRjtcblx0dmFyIGIgPSBpbnRlZ2VyICYgMHhGRjtcblxuXHRyZXR1cm4gW3IsIGcsIGJdO1xufTtcblxuY29udmVydC5yZ2IuaGNnID0gZnVuY3Rpb24gKHJnYikge1xuXHR2YXIgciA9IHJnYlswXSAvIDI1NTtcblx0dmFyIGcgPSByZ2JbMV0gLyAyNTU7XG5cdHZhciBiID0gcmdiWzJdIC8gMjU1O1xuXHR2YXIgbWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgociwgZyksIGIpO1xuXHR2YXIgbWluID0gTWF0aC5taW4oTWF0aC5taW4ociwgZyksIGIpO1xuXHR2YXIgY2hyb21hID0gKG1heCAtIG1pbik7XG5cdHZhciBncmF5c2NhbGU7XG5cdHZhciBodWU7XG5cblx0aWYgKGNocm9tYSA8IDEpIHtcblx0XHRncmF5c2NhbGUgPSBtaW4gLyAoMSAtIGNocm9tYSk7XG5cdH0gZWxzZSB7XG5cdFx0Z3JheXNjYWxlID0gMDtcblx0fVxuXG5cdGlmIChjaHJvbWEgPD0gMCkge1xuXHRcdGh1ZSA9IDA7XG5cdH0gZWxzZVxuXHRpZiAobWF4ID09PSByKSB7XG5cdFx0aHVlID0gKChnIC0gYikgLyBjaHJvbWEpICUgNjtcblx0fSBlbHNlXG5cdGlmIChtYXggPT09IGcpIHtcblx0XHRodWUgPSAyICsgKGIgLSByKSAvIGNocm9tYTtcblx0fSBlbHNlIHtcblx0XHRodWUgPSA0ICsgKHIgLSBnKSAvIGNocm9tYSArIDQ7XG5cdH1cblxuXHRodWUgLz0gNjtcblx0aHVlICU9IDE7XG5cblx0cmV0dXJuIFtodWUgKiAzNjAsIGNocm9tYSAqIDEwMCwgZ3JheXNjYWxlICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaHNsLmhjZyA9IGZ1bmN0aW9uIChoc2wpIHtcblx0dmFyIHMgPSBoc2xbMV0gLyAxMDA7XG5cdHZhciBsID0gaHNsWzJdIC8gMTAwO1xuXHR2YXIgYyA9IDE7XG5cdHZhciBmID0gMDtcblxuXHRpZiAobCA8IDAuNSkge1xuXHRcdGMgPSAyLjAgKiBzICogbDtcblx0fSBlbHNlIHtcblx0XHRjID0gMi4wICogcyAqICgxLjAgLSBsKTtcblx0fVxuXG5cdGlmIChjIDwgMS4wKSB7XG5cdFx0ZiA9IChsIC0gMC41ICogYykgLyAoMS4wIC0gYyk7XG5cdH1cblxuXHRyZXR1cm4gW2hzbFswXSwgYyAqIDEwMCwgZiAqIDEwMF07XG59O1xuXG5jb252ZXJ0Lmhzdi5oY2cgPSBmdW5jdGlvbiAoaHN2KSB7XG5cdHZhciBzID0gaHN2WzFdIC8gMTAwO1xuXHR2YXIgdiA9IGhzdlsyXSAvIDEwMDtcblxuXHR2YXIgYyA9IHMgKiB2O1xuXHR2YXIgZiA9IDA7XG5cblx0aWYgKGMgPCAxLjApIHtcblx0XHRmID0gKHYgLSBjKSAvICgxIC0gYyk7XG5cdH1cblxuXHRyZXR1cm4gW2hzdlswXSwgYyAqIDEwMCwgZiAqIDEwMF07XG59O1xuXG5jb252ZXJ0LmhjZy5yZ2IgPSBmdW5jdGlvbiAoaGNnKSB7XG5cdHZhciBoID0gaGNnWzBdIC8gMzYwO1xuXHR2YXIgYyA9IGhjZ1sxXSAvIDEwMDtcblx0dmFyIGcgPSBoY2dbMl0gLyAxMDA7XG5cblx0aWYgKGMgPT09IDAuMCkge1xuXHRcdHJldHVybiBbZyAqIDI1NSwgZyAqIDI1NSwgZyAqIDI1NV07XG5cdH1cblxuXHR2YXIgcHVyZSA9IFswLCAwLCAwXTtcblx0dmFyIGhpID0gKGggJSAxKSAqIDY7XG5cdHZhciB2ID0gaGkgJSAxO1xuXHR2YXIgdyA9IDEgLSB2O1xuXHR2YXIgbWcgPSAwO1xuXG5cdHN3aXRjaCAoTWF0aC5mbG9vcihoaSkpIHtcblx0XHRjYXNlIDA6XG5cdFx0XHRwdXJlWzBdID0gMTsgcHVyZVsxXSA9IHY7IHB1cmVbMl0gPSAwOyBicmVhaztcblx0XHRjYXNlIDE6XG5cdFx0XHRwdXJlWzBdID0gdzsgcHVyZVsxXSA9IDE7IHB1cmVbMl0gPSAwOyBicmVhaztcblx0XHRjYXNlIDI6XG5cdFx0XHRwdXJlWzBdID0gMDsgcHVyZVsxXSA9IDE7IHB1cmVbMl0gPSB2OyBicmVhaztcblx0XHRjYXNlIDM6XG5cdFx0XHRwdXJlWzBdID0gMDsgcHVyZVsxXSA9IHc7IHB1cmVbMl0gPSAxOyBicmVhaztcblx0XHRjYXNlIDQ6XG5cdFx0XHRwdXJlWzBdID0gdjsgcHVyZVsxXSA9IDA7IHB1cmVbMl0gPSAxOyBicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0cHVyZVswXSA9IDE7IHB1cmVbMV0gPSAwOyBwdXJlWzJdID0gdztcblx0fVxuXG5cdG1nID0gKDEuMCAtIGMpICogZztcblxuXHRyZXR1cm4gW1xuXHRcdChjICogcHVyZVswXSArIG1nKSAqIDI1NSxcblx0XHQoYyAqIHB1cmVbMV0gKyBtZykgKiAyNTUsXG5cdFx0KGMgKiBwdXJlWzJdICsgbWcpICogMjU1XG5cdF07XG59O1xuXG5jb252ZXJ0LmhjZy5oc3YgPSBmdW5jdGlvbiAoaGNnKSB7XG5cdHZhciBjID0gaGNnWzFdIC8gMTAwO1xuXHR2YXIgZyA9IGhjZ1syXSAvIDEwMDtcblxuXHR2YXIgdiA9IGMgKyBnICogKDEuMCAtIGMpO1xuXHR2YXIgZiA9IDA7XG5cblx0aWYgKHYgPiAwLjApIHtcblx0XHRmID0gYyAvIHY7XG5cdH1cblxuXHRyZXR1cm4gW2hjZ1swXSwgZiAqIDEwMCwgdiAqIDEwMF07XG59O1xuXG5jb252ZXJ0LmhjZy5oc2wgPSBmdW5jdGlvbiAoaGNnKSB7XG5cdHZhciBjID0gaGNnWzFdIC8gMTAwO1xuXHR2YXIgZyA9IGhjZ1syXSAvIDEwMDtcblxuXHR2YXIgbCA9IGcgKiAoMS4wIC0gYykgKyAwLjUgKiBjO1xuXHR2YXIgcyA9IDA7XG5cblx0aWYgKGwgPiAwLjAgJiYgbCA8IDAuNSkge1xuXHRcdHMgPSBjIC8gKDIgKiBsKTtcblx0fSBlbHNlXG5cdGlmIChsID49IDAuNSAmJiBsIDwgMS4wKSB7XG5cdFx0cyA9IGMgLyAoMiAqICgxIC0gbCkpO1xuXHR9XG5cblx0cmV0dXJuIFtoY2dbMF0sIHMgKiAxMDAsIGwgKiAxMDBdO1xufTtcblxuY29udmVydC5oY2cuaHdiID0gZnVuY3Rpb24gKGhjZykge1xuXHR2YXIgYyA9IGhjZ1sxXSAvIDEwMDtcblx0dmFyIGcgPSBoY2dbMl0gLyAxMDA7XG5cdHZhciB2ID0gYyArIGcgKiAoMS4wIC0gYyk7XG5cdHJldHVybiBbaGNnWzBdLCAodiAtIGMpICogMTAwLCAoMSAtIHYpICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaHdiLmhjZyA9IGZ1bmN0aW9uIChod2IpIHtcblx0dmFyIHcgPSBod2JbMV0gLyAxMDA7XG5cdHZhciBiID0gaHdiWzJdIC8gMTAwO1xuXHR2YXIgdiA9IDEgLSBiO1xuXHR2YXIgYyA9IHYgLSB3O1xuXHR2YXIgZyA9IDA7XG5cblx0aWYgKGMgPCAxKSB7XG5cdFx0ZyA9ICh2IC0gYykgLyAoMSAtIGMpO1xuXHR9XG5cblx0cmV0dXJuIFtod2JbMF0sIGMgKiAxMDAsIGcgKiAxMDBdO1xufTtcblxuY29udmVydC5hcHBsZS5yZ2IgPSBmdW5jdGlvbiAoYXBwbGUpIHtcblx0cmV0dXJuIFsoYXBwbGVbMF0gLyA2NTUzNSkgKiAyNTUsIChhcHBsZVsxXSAvIDY1NTM1KSAqIDI1NSwgKGFwcGxlWzJdIC8gNjU1MzUpICogMjU1XTtcbn07XG5cbmNvbnZlcnQucmdiLmFwcGxlID0gZnVuY3Rpb24gKHJnYikge1xuXHRyZXR1cm4gWyhyZ2JbMF0gLyAyNTUpICogNjU1MzUsIChyZ2JbMV0gLyAyNTUpICogNjU1MzUsIChyZ2JbMl0gLyAyNTUpICogNjU1MzVdO1xufTtcblxuY29udmVydC5ncmF5LnJnYiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdHJldHVybiBbYXJnc1swXSAvIDEwMCAqIDI1NSwgYXJnc1swXSAvIDEwMCAqIDI1NSwgYXJnc1swXSAvIDEwMCAqIDI1NV07XG59O1xuXG5jb252ZXJ0LmdyYXkuaHNsID0gY29udmVydC5ncmF5LmhzdiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdHJldHVybiBbMCwgMCwgYXJnc1swXV07XG59O1xuXG5jb252ZXJ0LmdyYXkuaHdiID0gZnVuY3Rpb24gKGdyYXkpIHtcblx0cmV0dXJuIFswLCAxMDAsIGdyYXlbMF1dO1xufTtcblxuY29udmVydC5ncmF5LmNteWsgPSBmdW5jdGlvbiAoZ3JheSkge1xuXHRyZXR1cm4gWzAsIDAsIDAsIGdyYXlbMF1dO1xufTtcblxuY29udmVydC5ncmF5LmxhYiA9IGZ1bmN0aW9uIChncmF5KSB7XG5cdHJldHVybiBbZ3JheVswXSwgMCwgMF07XG59O1xuXG5jb252ZXJ0LmdyYXkuaGV4ID0gZnVuY3Rpb24gKGdyYXkpIHtcblx0dmFyIHZhbCA9IE1hdGgucm91bmQoZ3JheVswXSAvIDEwMCAqIDI1NSkgJiAweEZGO1xuXHR2YXIgaW50ZWdlciA9ICh2YWwgPDwgMTYpICsgKHZhbCA8PCA4KSArIHZhbDtcblxuXHR2YXIgc3RyaW5nID0gaW50ZWdlci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblx0cmV0dXJuICcwMDAwMDAnLnN1YnN0cmluZyhzdHJpbmcubGVuZ3RoKSArIHN0cmluZztcbn07XG5cbmNvbnZlcnQucmdiLmdyYXkgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciB2YWwgPSAocmdiWzBdICsgcmdiWzFdICsgcmdiWzJdKSAvIDM7XG5cdHJldHVybiBbdmFsIC8gMjU1ICogMTAwXTtcbn07XG4iLCJ2YXIgY29udmVyc2lvbnMgPSByZXF1aXJlKCcuL2NvbnZlcnNpb25zJyk7XG52YXIgcm91dGUgPSByZXF1aXJlKCcuL3JvdXRlJyk7XG5cbnZhciBjb252ZXJ0ID0ge307XG5cbnZhciBtb2RlbHMgPSBPYmplY3Qua2V5cyhjb252ZXJzaW9ucyk7XG5cbmZ1bmN0aW9uIHdyYXBSYXcoZm4pIHtcblx0dmFyIHdyYXBwZWRGbiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdFx0aWYgKGFyZ3MgPT09IHVuZGVmaW5lZCB8fCBhcmdzID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gYXJncztcblx0XHR9XG5cblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmbihhcmdzKTtcblx0fTtcblxuXHQvLyBwcmVzZXJ2ZSAuY29udmVyc2lvbiBwcm9wZXJ0eSBpZiB0aGVyZSBpcyBvbmVcblx0aWYgKCdjb252ZXJzaW9uJyBpbiBmbikge1xuXHRcdHdyYXBwZWRGbi5jb252ZXJzaW9uID0gZm4uY29udmVyc2lvbjtcblx0fVxuXG5cdHJldHVybiB3cmFwcGVkRm47XG59XG5cbmZ1bmN0aW9uIHdyYXBSb3VuZGVkKGZuKSB7XG5cdHZhciB3cmFwcGVkRm4gPSBmdW5jdGlvbiAoYXJncykge1xuXHRcdGlmIChhcmdzID09PSB1bmRlZmluZWQgfHwgYXJncyA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIGFyZ3M7XG5cdFx0fVxuXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHR9XG5cblx0XHR2YXIgcmVzdWx0ID0gZm4oYXJncyk7XG5cblx0XHQvLyB3ZSdyZSBhc3N1bWluZyB0aGUgcmVzdWx0IGlzIGFuIGFycmF5IGhlcmUuXG5cdFx0Ly8gc2VlIG5vdGljZSBpbiBjb252ZXJzaW9ucy5qczsgZG9uJ3QgdXNlIGJveCB0eXBlc1xuXHRcdC8vIGluIGNvbnZlcnNpb24gZnVuY3Rpb25zLlxuXHRcdGlmICh0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0Jykge1xuXHRcdFx0Zm9yICh2YXIgbGVuID0gcmVzdWx0Lmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRyZXN1bHRbaV0gPSBNYXRoLnJvdW5kKHJlc3VsdFtpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHQvLyBwcmVzZXJ2ZSAuY29udmVyc2lvbiBwcm9wZXJ0eSBpZiB0aGVyZSBpcyBvbmVcblx0aWYgKCdjb252ZXJzaW9uJyBpbiBmbikge1xuXHRcdHdyYXBwZWRGbi5jb252ZXJzaW9uID0gZm4uY29udmVyc2lvbjtcblx0fVxuXG5cdHJldHVybiB3cmFwcGVkRm47XG59XG5cbm1vZGVscy5mb3JFYWNoKGZ1bmN0aW9uIChmcm9tTW9kZWwpIHtcblx0Y29udmVydFtmcm9tTW9kZWxdID0ge307XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnRbZnJvbU1vZGVsXSwgJ2NoYW5uZWxzJywge3ZhbHVlOiBjb252ZXJzaW9uc1tmcm9tTW9kZWxdLmNoYW5uZWxzfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb252ZXJ0W2Zyb21Nb2RlbF0sICdsYWJlbHMnLCB7dmFsdWU6IGNvbnZlcnNpb25zW2Zyb21Nb2RlbF0ubGFiZWxzfSk7XG5cblx0dmFyIHJvdXRlcyA9IHJvdXRlKGZyb21Nb2RlbCk7XG5cdHZhciByb3V0ZU1vZGVscyA9IE9iamVjdC5rZXlzKHJvdXRlcyk7XG5cblx0cm91dGVNb2RlbHMuZm9yRWFjaChmdW5jdGlvbiAodG9Nb2RlbCkge1xuXHRcdHZhciBmbiA9IHJvdXRlc1t0b01vZGVsXTtcblxuXHRcdGNvbnZlcnRbZnJvbU1vZGVsXVt0b01vZGVsXSA9IHdyYXBSb3VuZGVkKGZuKTtcblx0XHRjb252ZXJ0W2Zyb21Nb2RlbF1bdG9Nb2RlbF0ucmF3ID0gd3JhcFJhdyhmbik7XG5cdH0pO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gY29udmVydDtcbiIsInZhciBjb252ZXJzaW9ucyA9IHJlcXVpcmUoJy4vY29udmVyc2lvbnMnKTtcblxuLypcblx0dGhpcyBmdW5jdGlvbiByb3V0ZXMgYSBtb2RlbCB0byBhbGwgb3RoZXIgbW9kZWxzLlxuXG5cdGFsbCBmdW5jdGlvbnMgdGhhdCBhcmUgcm91dGVkIGhhdmUgYSBwcm9wZXJ0eSBgLmNvbnZlcnNpb25gIGF0dGFjaGVkXG5cdHRvIHRoZSByZXR1cm5lZCBzeW50aGV0aWMgZnVuY3Rpb24uIFRoaXMgcHJvcGVydHkgaXMgYW4gYXJyYXlcblx0b2Ygc3RyaW5ncywgZWFjaCB3aXRoIHRoZSBzdGVwcyBpbiBiZXR3ZWVuIHRoZSAnZnJvbScgYW5kICd0bydcblx0Y29sb3IgbW9kZWxzIChpbmNsdXNpdmUpLlxuXG5cdGNvbnZlcnNpb25zIHRoYXQgYXJlIG5vdCBwb3NzaWJsZSBzaW1wbHkgYXJlIG5vdCBpbmNsdWRlZC5cbiovXG5cbi8vIGh0dHBzOi8vanNwZXJmLmNvbS9vYmplY3Qta2V5cy12cy1mb3ItaW4td2l0aC1jbG9zdXJlLzNcbnZhciBtb2RlbHMgPSBPYmplY3Qua2V5cyhjb252ZXJzaW9ucyk7XG5cbmZ1bmN0aW9uIGJ1aWxkR3JhcGgoKSB7XG5cdHZhciBncmFwaCA9IHt9O1xuXG5cdGZvciAodmFyIGxlbiA9IG1vZGVscy5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRncmFwaFttb2RlbHNbaV1dID0ge1xuXHRcdFx0Ly8gaHR0cDovL2pzcGVyZi5jb20vMS12cy1pbmZpbml0eVxuXHRcdFx0Ly8gbWljcm8tb3B0LCBidXQgdGhpcyBpcyBzaW1wbGUuXG5cdFx0XHRkaXN0YW5jZTogLTEsXG5cdFx0XHRwYXJlbnQ6IG51bGxcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIGdyYXBoO1xufVxuXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CcmVhZHRoLWZpcnN0X3NlYXJjaFxuZnVuY3Rpb24gZGVyaXZlQkZTKGZyb21Nb2RlbCkge1xuXHR2YXIgZ3JhcGggPSBidWlsZEdyYXBoKCk7XG5cdHZhciBxdWV1ZSA9IFtmcm9tTW9kZWxdOyAvLyB1bnNoaWZ0IC0+IHF1ZXVlIC0+IHBvcFxuXG5cdGdyYXBoW2Zyb21Nb2RlbF0uZGlzdGFuY2UgPSAwO1xuXG5cdHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcblx0XHR2YXIgY3VycmVudCA9IHF1ZXVlLnBvcCgpO1xuXHRcdHZhciBhZGphY2VudHMgPSBPYmplY3Qua2V5cyhjb252ZXJzaW9uc1tjdXJyZW50XSk7XG5cblx0XHRmb3IgKHZhciBsZW4gPSBhZGphY2VudHMubGVuZ3RoLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR2YXIgYWRqYWNlbnQgPSBhZGphY2VudHNbaV07XG5cdFx0XHR2YXIgbm9kZSA9IGdyYXBoW2FkamFjZW50XTtcblxuXHRcdFx0aWYgKG5vZGUuZGlzdGFuY2UgPT09IC0xKSB7XG5cdFx0XHRcdG5vZGUuZGlzdGFuY2UgPSBncmFwaFtjdXJyZW50XS5kaXN0YW5jZSArIDE7XG5cdFx0XHRcdG5vZGUucGFyZW50ID0gY3VycmVudDtcblx0XHRcdFx0cXVldWUudW5zaGlmdChhZGphY2VudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGdyYXBoO1xufVxuXG5mdW5jdGlvbiBsaW5rKGZyb20sIHRvKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoYXJncykge1xuXHRcdHJldHVybiB0byhmcm9tKGFyZ3MpKTtcblx0fTtcbn1cblxuZnVuY3Rpb24gd3JhcENvbnZlcnNpb24odG9Nb2RlbCwgZ3JhcGgpIHtcblx0dmFyIHBhdGggPSBbZ3JhcGhbdG9Nb2RlbF0ucGFyZW50LCB0b01vZGVsXTtcblx0dmFyIGZuID0gY29udmVyc2lvbnNbZ3JhcGhbdG9Nb2RlbF0ucGFyZW50XVt0b01vZGVsXTtcblxuXHR2YXIgY3VyID0gZ3JhcGhbdG9Nb2RlbF0ucGFyZW50O1xuXHR3aGlsZSAoZ3JhcGhbY3VyXS5wYXJlbnQpIHtcblx0XHRwYXRoLnVuc2hpZnQoZ3JhcGhbY3VyXS5wYXJlbnQpO1xuXHRcdGZuID0gbGluayhjb252ZXJzaW9uc1tncmFwaFtjdXJdLnBhcmVudF1bY3VyXSwgZm4pO1xuXHRcdGN1ciA9IGdyYXBoW2N1cl0ucGFyZW50O1xuXHR9XG5cblx0Zm4uY29udmVyc2lvbiA9IHBhdGg7XG5cdHJldHVybiBmbjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZnJvbU1vZGVsKSB7XG5cdHZhciBncmFwaCA9IGRlcml2ZUJGUyhmcm9tTW9kZWwpO1xuXHR2YXIgY29udmVyc2lvbiA9IHt9O1xuXG5cdHZhciBtb2RlbHMgPSBPYmplY3Qua2V5cyhncmFwaCk7XG5cdGZvciAodmFyIGxlbiA9IG1vZGVscy5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHR2YXIgdG9Nb2RlbCA9IG1vZGVsc1tpXTtcblx0XHR2YXIgbm9kZSA9IGdyYXBoW3RvTW9kZWxdO1xuXG5cdFx0aWYgKG5vZGUucGFyZW50ID09PSBudWxsKSB7XG5cdFx0XHQvLyBubyBwb3NzaWJsZSBjb252ZXJzaW9uLCBvciB0aGlzIG5vZGUgaXMgdGhlIHNvdXJjZSBtb2RlbC5cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNvbnZlcnNpb25bdG9Nb2RlbF0gPSB3cmFwQ29udmVyc2lvbih0b01vZGVsLCBncmFwaCk7XG5cdH1cblxuXHRyZXR1cm4gY29udmVyc2lvbjtcbn07XG5cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cdFwiYWxpY2VibHVlXCI6IFsyNDAsIDI0OCwgMjU1XSxcclxuXHRcImFudGlxdWV3aGl0ZVwiOiBbMjUwLCAyMzUsIDIxNV0sXHJcblx0XCJhcXVhXCI6IFswLCAyNTUsIDI1NV0sXHJcblx0XCJhcXVhbWFyaW5lXCI6IFsxMjcsIDI1NSwgMjEyXSxcclxuXHRcImF6dXJlXCI6IFsyNDAsIDI1NSwgMjU1XSxcclxuXHRcImJlaWdlXCI6IFsyNDUsIDI0NSwgMjIwXSxcclxuXHRcImJpc3F1ZVwiOiBbMjU1LCAyMjgsIDE5Nl0sXHJcblx0XCJibGFja1wiOiBbMCwgMCwgMF0sXHJcblx0XCJibGFuY2hlZGFsbW9uZFwiOiBbMjU1LCAyMzUsIDIwNV0sXHJcblx0XCJibHVlXCI6IFswLCAwLCAyNTVdLFxyXG5cdFwiYmx1ZXZpb2xldFwiOiBbMTM4LCA0MywgMjI2XSxcclxuXHRcImJyb3duXCI6IFsxNjUsIDQyLCA0Ml0sXHJcblx0XCJidXJseXdvb2RcIjogWzIyMiwgMTg0LCAxMzVdLFxyXG5cdFwiY2FkZXRibHVlXCI6IFs5NSwgMTU4LCAxNjBdLFxyXG5cdFwiY2hhcnRyZXVzZVwiOiBbMTI3LCAyNTUsIDBdLFxyXG5cdFwiY2hvY29sYXRlXCI6IFsyMTAsIDEwNSwgMzBdLFxyXG5cdFwiY29yYWxcIjogWzI1NSwgMTI3LCA4MF0sXHJcblx0XCJjb3JuZmxvd2VyYmx1ZVwiOiBbMTAwLCAxNDksIDIzN10sXHJcblx0XCJjb3Juc2lsa1wiOiBbMjU1LCAyNDgsIDIyMF0sXHJcblx0XCJjcmltc29uXCI6IFsyMjAsIDIwLCA2MF0sXHJcblx0XCJjeWFuXCI6IFswLCAyNTUsIDI1NV0sXHJcblx0XCJkYXJrYmx1ZVwiOiBbMCwgMCwgMTM5XSxcclxuXHRcImRhcmtjeWFuXCI6IFswLCAxMzksIDEzOV0sXHJcblx0XCJkYXJrZ29sZGVucm9kXCI6IFsxODQsIDEzNCwgMTFdLFxyXG5cdFwiZGFya2dyYXlcIjogWzE2OSwgMTY5LCAxNjldLFxyXG5cdFwiZGFya2dyZWVuXCI6IFswLCAxMDAsIDBdLFxyXG5cdFwiZGFya2dyZXlcIjogWzE2OSwgMTY5LCAxNjldLFxyXG5cdFwiZGFya2toYWtpXCI6IFsxODksIDE4MywgMTA3XSxcclxuXHRcImRhcmttYWdlbnRhXCI6IFsxMzksIDAsIDEzOV0sXHJcblx0XCJkYXJrb2xpdmVncmVlblwiOiBbODUsIDEwNywgNDddLFxyXG5cdFwiZGFya29yYW5nZVwiOiBbMjU1LCAxNDAsIDBdLFxyXG5cdFwiZGFya29yY2hpZFwiOiBbMTUzLCA1MCwgMjA0XSxcclxuXHRcImRhcmtyZWRcIjogWzEzOSwgMCwgMF0sXHJcblx0XCJkYXJrc2FsbW9uXCI6IFsyMzMsIDE1MCwgMTIyXSxcclxuXHRcImRhcmtzZWFncmVlblwiOiBbMTQzLCAxODgsIDE0M10sXHJcblx0XCJkYXJrc2xhdGVibHVlXCI6IFs3MiwgNjEsIDEzOV0sXHJcblx0XCJkYXJrc2xhdGVncmF5XCI6IFs0NywgNzksIDc5XSxcclxuXHRcImRhcmtzbGF0ZWdyZXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3R1cnF1b2lzZVwiOiBbMCwgMjA2LCAyMDldLFxyXG5cdFwiZGFya3Zpb2xldFwiOiBbMTQ4LCAwLCAyMTFdLFxyXG5cdFwiZGVlcHBpbmtcIjogWzI1NSwgMjAsIDE0N10sXHJcblx0XCJkZWVwc2t5Ymx1ZVwiOiBbMCwgMTkxLCAyNTVdLFxyXG5cdFwiZGltZ3JheVwiOiBbMTA1LCAxMDUsIDEwNV0sXHJcblx0XCJkaW1ncmV5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRvZGdlcmJsdWVcIjogWzMwLCAxNDQsIDI1NV0sXHJcblx0XCJmaXJlYnJpY2tcIjogWzE3OCwgMzQsIDM0XSxcclxuXHRcImZsb3JhbHdoaXRlXCI6IFsyNTUsIDI1MCwgMjQwXSxcclxuXHRcImZvcmVzdGdyZWVuXCI6IFszNCwgMTM5LCAzNF0sXHJcblx0XCJmdWNoc2lhXCI6IFsyNTUsIDAsIDI1NV0sXHJcblx0XCJnYWluc2Jvcm9cIjogWzIyMCwgMjIwLCAyMjBdLFxyXG5cdFwiZ2hvc3R3aGl0ZVwiOiBbMjQ4LCAyNDgsIDI1NV0sXHJcblx0XCJnb2xkXCI6IFsyNTUsIDIxNSwgMF0sXHJcblx0XCJnb2xkZW5yb2RcIjogWzIxOCwgMTY1LCAzMl0sXHJcblx0XCJncmF5XCI6IFsxMjgsIDEyOCwgMTI4XSxcclxuXHRcImdyZWVuXCI6IFswLCAxMjgsIDBdLFxyXG5cdFwiZ3JlZW55ZWxsb3dcIjogWzE3MywgMjU1LCA0N10sXHJcblx0XCJncmV5XCI6IFsxMjgsIDEyOCwgMTI4XSxcclxuXHRcImhvbmV5ZGV3XCI6IFsyNDAsIDI1NSwgMjQwXSxcclxuXHRcImhvdHBpbmtcIjogWzI1NSwgMTA1LCAxODBdLFxyXG5cdFwiaW5kaWFucmVkXCI6IFsyMDUsIDkyLCA5Ml0sXHJcblx0XCJpbmRpZ29cIjogWzc1LCAwLCAxMzBdLFxyXG5cdFwiaXZvcnlcIjogWzI1NSwgMjU1LCAyNDBdLFxyXG5cdFwia2hha2lcIjogWzI0MCwgMjMwLCAxNDBdLFxyXG5cdFwibGF2ZW5kZXJcIjogWzIzMCwgMjMwLCAyNTBdLFxyXG5cdFwibGF2ZW5kZXJibHVzaFwiOiBbMjU1LCAyNDAsIDI0NV0sXHJcblx0XCJsYXduZ3JlZW5cIjogWzEyNCwgMjUyLCAwXSxcclxuXHRcImxlbW9uY2hpZmZvblwiOiBbMjU1LCAyNTAsIDIwNV0sXHJcblx0XCJsaWdodGJsdWVcIjogWzE3MywgMjE2LCAyMzBdLFxyXG5cdFwibGlnaHRjb3JhbFwiOiBbMjQwLCAxMjgsIDEyOF0sXHJcblx0XCJsaWdodGN5YW5cIjogWzIyNCwgMjU1LCAyNTVdLFxyXG5cdFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogWzI1MCwgMjUwLCAyMTBdLFxyXG5cdFwibGlnaHRncmF5XCI6IFsyMTEsIDIxMSwgMjExXSxcclxuXHRcImxpZ2h0Z3JlZW5cIjogWzE0NCwgMjM4LCAxNDRdLFxyXG5cdFwibGlnaHRncmV5XCI6IFsyMTEsIDIxMSwgMjExXSxcclxuXHRcImxpZ2h0cGlua1wiOiBbMjU1LCAxODIsIDE5M10sXHJcblx0XCJsaWdodHNhbG1vblwiOiBbMjU1LCAxNjAsIDEyMl0sXHJcblx0XCJsaWdodHNlYWdyZWVuXCI6IFszMiwgMTc4LCAxNzBdLFxyXG5cdFwibGlnaHRza3libHVlXCI6IFsxMzUsIDIwNiwgMjUwXSxcclxuXHRcImxpZ2h0c2xhdGVncmF5XCI6IFsxMTksIDEzNiwgMTUzXSxcclxuXHRcImxpZ2h0c2xhdGVncmV5XCI6IFsxMTksIDEzNiwgMTUzXSxcclxuXHRcImxpZ2h0c3RlZWxibHVlXCI6IFsxNzYsIDE5NiwgMjIyXSxcclxuXHRcImxpZ2h0eWVsbG93XCI6IFsyNTUsIDI1NSwgMjI0XSxcclxuXHRcImxpbWVcIjogWzAsIDI1NSwgMF0sXHJcblx0XCJsaW1lZ3JlZW5cIjogWzUwLCAyMDUsIDUwXSxcclxuXHRcImxpbmVuXCI6IFsyNTAsIDI0MCwgMjMwXSxcclxuXHRcIm1hZ2VudGFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcIm1hcm9vblwiOiBbMTI4LCAwLCAwXSxcclxuXHRcIm1lZGl1bWFxdWFtYXJpbmVcIjogWzEwMiwgMjA1LCAxNzBdLFxyXG5cdFwibWVkaXVtYmx1ZVwiOiBbMCwgMCwgMjA1XSxcclxuXHRcIm1lZGl1bW9yY2hpZFwiOiBbMTg2LCA4NSwgMjExXSxcclxuXHRcIm1lZGl1bXB1cnBsZVwiOiBbMTQ3LCAxMTIsIDIxOV0sXHJcblx0XCJtZWRpdW1zZWFncmVlblwiOiBbNjAsIDE3OSwgMTEzXSxcclxuXHRcIm1lZGl1bXNsYXRlYmx1ZVwiOiBbMTIzLCAxMDQsIDIzOF0sXHJcblx0XCJtZWRpdW1zcHJpbmdncmVlblwiOiBbMCwgMjUwLCAxNTRdLFxyXG5cdFwibWVkaXVtdHVycXVvaXNlXCI6IFs3MiwgMjA5LCAyMDRdLFxyXG5cdFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTksIDIxLCAxMzNdLFxyXG5cdFwibWlkbmlnaHRibHVlXCI6IFsyNSwgMjUsIDExMl0sXHJcblx0XCJtaW50Y3JlYW1cIjogWzI0NSwgMjU1LCAyNTBdLFxyXG5cdFwibWlzdHlyb3NlXCI6IFsyNTUsIDIyOCwgMjI1XSxcclxuXHRcIm1vY2Nhc2luXCI6IFsyNTUsIDIyOCwgMTgxXSxcclxuXHRcIm5hdmFqb3doaXRlXCI6IFsyNTUsIDIyMiwgMTczXSxcclxuXHRcIm5hdnlcIjogWzAsIDAsIDEyOF0sXHJcblx0XCJvbGRsYWNlXCI6IFsyNTMsIDI0NSwgMjMwXSxcclxuXHRcIm9saXZlXCI6IFsxMjgsIDEyOCwgMF0sXHJcblx0XCJvbGl2ZWRyYWJcIjogWzEwNywgMTQyLCAzNV0sXHJcblx0XCJvcmFuZ2VcIjogWzI1NSwgMTY1LCAwXSxcclxuXHRcIm9yYW5nZXJlZFwiOiBbMjU1LCA2OSwgMF0sXHJcblx0XCJvcmNoaWRcIjogWzIxOCwgMTEyLCAyMTRdLFxyXG5cdFwicGFsZWdvbGRlbnJvZFwiOiBbMjM4LCAyMzIsIDE3MF0sXHJcblx0XCJwYWxlZ3JlZW5cIjogWzE1MiwgMjUxLCAxNTJdLFxyXG5cdFwicGFsZXR1cnF1b2lzZVwiOiBbMTc1LCAyMzgsIDIzOF0sXHJcblx0XCJwYWxldmlvbGV0cmVkXCI6IFsyMTksIDExMiwgMTQ3XSxcclxuXHRcInBhcGF5YXdoaXBcIjogWzI1NSwgMjM5LCAyMTNdLFxyXG5cdFwicGVhY2hwdWZmXCI6IFsyNTUsIDIxOCwgMTg1XSxcclxuXHRcInBlcnVcIjogWzIwNSwgMTMzLCA2M10sXHJcblx0XCJwaW5rXCI6IFsyNTUsIDE5MiwgMjAzXSxcclxuXHRcInBsdW1cIjogWzIyMSwgMTYwLCAyMjFdLFxyXG5cdFwicG93ZGVyYmx1ZVwiOiBbMTc2LCAyMjQsIDIzMF0sXHJcblx0XCJwdXJwbGVcIjogWzEyOCwgMCwgMTI4XSxcclxuXHRcInJlYmVjY2FwdXJwbGVcIjogWzEwMiwgNTEsIDE1M10sXHJcblx0XCJyZWRcIjogWzI1NSwgMCwgMF0sXHJcblx0XCJyb3N5YnJvd25cIjogWzE4OCwgMTQzLCAxNDNdLFxyXG5cdFwicm95YWxibHVlXCI6IFs2NSwgMTA1LCAyMjVdLFxyXG5cdFwic2FkZGxlYnJvd25cIjogWzEzOSwgNjksIDE5XSxcclxuXHRcInNhbG1vblwiOiBbMjUwLCAxMjgsIDExNF0sXHJcblx0XCJzYW5keWJyb3duXCI6IFsyNDQsIDE2NCwgOTZdLFxyXG5cdFwic2VhZ3JlZW5cIjogWzQ2LCAxMzksIDg3XSxcclxuXHRcInNlYXNoZWxsXCI6IFsyNTUsIDI0NSwgMjM4XSxcclxuXHRcInNpZW5uYVwiOiBbMTYwLCA4MiwgNDVdLFxyXG5cdFwic2lsdmVyXCI6IFsxOTIsIDE5MiwgMTkyXSxcclxuXHRcInNreWJsdWVcIjogWzEzNSwgMjA2LCAyMzVdLFxyXG5cdFwic2xhdGVibHVlXCI6IFsxMDYsIDkwLCAyMDVdLFxyXG5cdFwic2xhdGVncmF5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNsYXRlZ3JleVwiOiBbMTEyLCAxMjgsIDE0NF0sXHJcblx0XCJzbm93XCI6IFsyNTUsIDI1MCwgMjUwXSxcclxuXHRcInNwcmluZ2dyZWVuXCI6IFswLCAyNTUsIDEyN10sXHJcblx0XCJzdGVlbGJsdWVcIjogWzcwLCAxMzAsIDE4MF0sXHJcblx0XCJ0YW5cIjogWzIxMCwgMTgwLCAxNDBdLFxyXG5cdFwidGVhbFwiOiBbMCwgMTI4LCAxMjhdLFxyXG5cdFwidGhpc3RsZVwiOiBbMjE2LCAxOTEsIDIxNl0sXHJcblx0XCJ0b21hdG9cIjogWzI1NSwgOTksIDcxXSxcclxuXHRcInR1cnF1b2lzZVwiOiBbNjQsIDIyNCwgMjA4XSxcclxuXHRcInZpb2xldFwiOiBbMjM4LCAxMzAsIDIzOF0sXHJcblx0XCJ3aGVhdFwiOiBbMjQ1LCAyMjIsIDE3OV0sXHJcblx0XCJ3aGl0ZVwiOiBbMjU1LCAyNTUsIDI1NV0sXHJcblx0XCJ3aGl0ZXNtb2tlXCI6IFsyNDUsIDI0NSwgMjQ1XSxcclxuXHRcInllbGxvd1wiOiBbMjU1LCAyNTUsIDBdLFxyXG5cdFwieWVsbG93Z3JlZW5cIjogWzE1NCwgMjA1LCA1MF1cclxufTsiLCIvKiBNSVQgbGljZW5zZSAqL1xudmFyIGNvbG9yTmFtZXMgPSByZXF1aXJlKCdjb2xvci1uYW1lJyk7XG52YXIgc3dpenpsZSA9IHJlcXVpcmUoJ3NpbXBsZS1zd2l6emxlJyk7XG5cbnZhciByZXZlcnNlTmFtZXMgPSB7fTtcblxuLy8gY3JlYXRlIGEgbGlzdCBvZiByZXZlcnNlIGNvbG9yIG5hbWVzXG5mb3IgKHZhciBuYW1lIGluIGNvbG9yTmFtZXMpIHtcblx0aWYgKGNvbG9yTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcblx0XHRyZXZlcnNlTmFtZXNbY29sb3JOYW1lc1tuYW1lXV0gPSBuYW1lO1xuXHR9XG59XG5cbnZhciBjcyA9IG1vZHVsZS5leHBvcnRzID0ge1xuXHR0bzoge31cbn07XG5cbmNzLmdldCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblx0dmFyIHByZWZpeCA9IHN0cmluZy5zdWJzdHJpbmcoMCwgMykudG9Mb3dlckNhc2UoKTtcblx0dmFyIHZhbDtcblx0dmFyIG1vZGVsO1xuXHRzd2l0Y2ggKHByZWZpeCkge1xuXHRcdGNhc2UgJ2hzbCc6XG5cdFx0XHR2YWwgPSBjcy5nZXQuaHNsKHN0cmluZyk7XG5cdFx0XHRtb2RlbCA9ICdoc2wnO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnaHdiJzpcblx0XHRcdHZhbCA9IGNzLmdldC5od2Ioc3RyaW5nKTtcblx0XHRcdG1vZGVsID0gJ2h3Yic7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0dmFsID0gY3MuZ2V0LnJnYihzdHJpbmcpO1xuXHRcdFx0bW9kZWwgPSAncmdiJztcblx0XHRcdGJyZWFrO1xuXHR9XG5cblx0aWYgKCF2YWwpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHJldHVybiB7bW9kZWw6IG1vZGVsLCB2YWx1ZTogdmFsfTtcbn07XG5cbmNzLmdldC5yZ2IgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cdGlmICghc3RyaW5nKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHR2YXIgYWJiciA9IC9eIyhbYS1mMC05XXszLDR9KSQvaTtcblx0dmFyIGhleCA9IC9eIyhbYS1mMC05XXs2fSkoW2EtZjAtOV17Mn0pPyQvaTtcblx0dmFyIHJnYmEgPSAvXnJnYmE/XFwoXFxzKihbKy1dP1xcZCspXFxzKixcXHMqKFsrLV0/XFxkKylcXHMqLFxccyooWystXT9cXGQrKVxccyooPzosXFxzKihbKy1dP1tcXGRcXC5dKylcXHMqKT9cXCkkLztcblx0dmFyIHBlciA9IC9ecmdiYT9cXChcXHMqKFsrLV0/W1xcZFxcLl0rKVxcJVxccyosXFxzKihbKy1dP1tcXGRcXC5dKylcXCVcXHMqLFxccyooWystXT9bXFxkXFwuXSspXFwlXFxzKig/OixcXHMqKFsrLV0/W1xcZFxcLl0rKVxccyopP1xcKSQvO1xuXHR2YXIga2V5d29yZCA9IC8oXFxEKykvO1xuXG5cdHZhciByZ2IgPSBbMCwgMCwgMCwgMV07XG5cdHZhciBtYXRjaDtcblx0dmFyIGk7XG5cdHZhciBoZXhBbHBoYTtcblxuXHRpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goaGV4KSkge1xuXHRcdGhleEFscGhhID0gbWF0Y2hbMl07XG5cdFx0bWF0Y2ggPSBtYXRjaFsxXTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRcdC8vIGh0dHBzOi8vanNwZXJmLmNvbS9zbGljZS12cy1zdWJzdHItdnMtc3Vic3RyaW5nLW1ldGhvZHMtbG9uZy1zdHJpbmcvMTlcblx0XHRcdHZhciBpMiA9IGkgKiAyO1xuXHRcdFx0cmdiW2ldID0gcGFyc2VJbnQobWF0Y2guc2xpY2UoaTIsIGkyICsgMiksIDE2KTtcblx0XHR9XG5cblx0XHRpZiAoaGV4QWxwaGEpIHtcblx0XHRcdHJnYlszXSA9IE1hdGgucm91bmQoKHBhcnNlSW50KGhleEFscGhhLCAxNikgLyAyNTUpICogMTAwKSAvIDEwMDtcblx0XHR9XG5cdH0gZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goYWJicikpIHtcblx0XHRtYXRjaCA9IG1hdGNoWzFdO1xuXHRcdGhleEFscGhhID0gbWF0Y2hbM107XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRyZ2JbaV0gPSBwYXJzZUludChtYXRjaFtpXSArIG1hdGNoW2ldLCAxNik7XG5cdFx0fVxuXG5cdFx0aWYgKGhleEFscGhhKSB7XG5cdFx0XHRyZ2JbM10gPSBNYXRoLnJvdW5kKChwYXJzZUludChoZXhBbHBoYSArIGhleEFscGhhLCAxNikgLyAyNTUpICogMTAwKSAvIDEwMDtcblx0XHR9XG5cdH0gZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2gocmdiYSkpIHtcblx0XHRmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRyZ2JbaV0gPSBwYXJzZUludChtYXRjaFtpICsgMV0sIDApO1xuXHRcdH1cblxuXHRcdGlmIChtYXRjaFs0XSkge1xuXHRcdFx0cmdiWzNdID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKHBlcikpIHtcblx0XHRmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRyZ2JbaV0gPSBNYXRoLnJvdW5kKHBhcnNlRmxvYXQobWF0Y2hbaSArIDFdKSAqIDIuNTUpO1xuXHRcdH1cblxuXHRcdGlmIChtYXRjaFs0XSkge1xuXHRcdFx0cmdiWzNdID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKGtleXdvcmQpKSB7XG5cdFx0aWYgKG1hdGNoWzFdID09PSAndHJhbnNwYXJlbnQnKSB7XG5cdFx0XHRyZXR1cm4gWzAsIDAsIDAsIDBdO1xuXHRcdH1cblxuXHRcdHJnYiA9IGNvbG9yTmFtZXNbbWF0Y2hbMV1dO1xuXG5cdFx0aWYgKCFyZ2IpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHJnYlszXSA9IDE7XG5cblx0XHRyZXR1cm4gcmdiO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Zm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdHJnYltpXSA9IGNsYW1wKHJnYltpXSwgMCwgMjU1KTtcblx0fVxuXHRyZ2JbM10gPSBjbGFtcChyZ2JbM10sIDAsIDEpO1xuXG5cdHJldHVybiByZ2I7XG59O1xuXG5jcy5nZXQuaHNsID0gZnVuY3Rpb24gKHN0cmluZykge1xuXHRpZiAoIXN0cmluZykge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFyIGhzbCA9IC9eaHNsYT9cXChcXHMqKFsrLV0/XFxkKltcXC5dP1xcZCspKD86ZGVnKT9cXHMqLFxccyooWystXT9bXFxkXFwuXSspJVxccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKig/OixcXHMqKFsrLV0/W1xcZFxcLl0rKVxccyopP1xcKSQvO1xuXHR2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2goaHNsKTtcblxuXHRpZiAobWF0Y2gpIHtcblx0XHR2YXIgYWxwaGEgPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcblx0XHR2YXIgaCA9ICgocGFyc2VGbG9hdChtYXRjaFsxXSkgJSAzNjApICsgMzYwKSAlIDM2MDtcblx0XHR2YXIgcyA9IGNsYW1wKHBhcnNlRmxvYXQobWF0Y2hbMl0pLCAwLCAxMDApO1xuXHRcdHZhciBsID0gY2xhbXAocGFyc2VGbG9hdChtYXRjaFszXSksIDAsIDEwMCk7XG5cdFx0dmFyIGEgPSBjbGFtcChpc05hTihhbHBoYSkgPyAxIDogYWxwaGEsIDAsIDEpO1xuXG5cdFx0cmV0dXJuIFtoLCBzLCBsLCBhXTtcblx0fVxuXG5cdHJldHVybiBudWxsO1xufTtcblxuY3MuZ2V0Lmh3YiA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblx0aWYgKCFzdHJpbmcpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHZhciBod2IgPSAvXmh3YlxcKFxccyooWystXT9cXGQqW1xcLl0/XFxkKykoPzpkZWcpP1xccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKSVcXHMqKD86LFxccyooWystXT9bXFxkXFwuXSspXFxzKik/XFwpJC87XG5cdHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaChod2IpO1xuXG5cdGlmIChtYXRjaCkge1xuXHRcdHZhciBhbHBoYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuXHRcdHZhciBoID0gKChwYXJzZUZsb2F0KG1hdGNoWzFdKSAlIDM2MCkgKyAzNjApICUgMzYwO1xuXHRcdHZhciB3ID0gY2xhbXAocGFyc2VGbG9hdChtYXRjaFsyXSksIDAsIDEwMCk7XG5cdFx0dmFyIGIgPSBjbGFtcChwYXJzZUZsb2F0KG1hdGNoWzNdKSwgMCwgMTAwKTtcblx0XHR2YXIgYSA9IGNsYW1wKGlzTmFOKGFscGhhKSA/IDEgOiBhbHBoYSwgMCwgMSk7XG5cdFx0cmV0dXJuIFtoLCB3LCBiLCBhXTtcblx0fVxuXG5cdHJldHVybiBudWxsO1xufTtcblxuY3MudG8uaGV4ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgcmdiYSA9IHN3aXp6bGUoYXJndW1lbnRzKTtcblxuXHRyZXR1cm4gKFxuXHRcdCcjJyArXG5cdFx0aGV4RG91YmxlKHJnYmFbMF0pICtcblx0XHRoZXhEb3VibGUocmdiYVsxXSkgK1xuXHRcdGhleERvdWJsZShyZ2JhWzJdKSArXG5cdFx0KHJnYmFbM10gPCAxXG5cdFx0XHQ/IChoZXhEb3VibGUoTWF0aC5yb3VuZChyZ2JhWzNdICogMjU1KSkpXG5cdFx0XHQ6ICcnKVxuXHQpO1xufTtcblxuY3MudG8ucmdiID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgcmdiYSA9IHN3aXp6bGUoYXJndW1lbnRzKTtcblxuXHRyZXR1cm4gcmdiYS5sZW5ndGggPCA0IHx8IHJnYmFbM10gPT09IDFcblx0XHQ/ICdyZ2IoJyArIE1hdGgucm91bmQocmdiYVswXSkgKyAnLCAnICsgTWF0aC5yb3VuZChyZ2JhWzFdKSArICcsICcgKyBNYXRoLnJvdW5kKHJnYmFbMl0pICsgJyknXG5cdFx0OiAncmdiYSgnICsgTWF0aC5yb3VuZChyZ2JhWzBdKSArICcsICcgKyBNYXRoLnJvdW5kKHJnYmFbMV0pICsgJywgJyArIE1hdGgucm91bmQocmdiYVsyXSkgKyAnLCAnICsgcmdiYVszXSArICcpJztcbn07XG5cbmNzLnRvLnJnYi5wZXJjZW50ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgcmdiYSA9IHN3aXp6bGUoYXJndW1lbnRzKTtcblxuXHR2YXIgciA9IE1hdGgucm91bmQocmdiYVswXSAvIDI1NSAqIDEwMCk7XG5cdHZhciBnID0gTWF0aC5yb3VuZChyZ2JhWzFdIC8gMjU1ICogMTAwKTtcblx0dmFyIGIgPSBNYXRoLnJvdW5kKHJnYmFbMl0gLyAyNTUgKiAxMDApO1xuXG5cdHJldHVybiByZ2JhLmxlbmd0aCA8IDQgfHwgcmdiYVszXSA9PT0gMVxuXHRcdD8gJ3JnYignICsgciArICclLCAnICsgZyArICclLCAnICsgYiArICclKSdcblx0XHQ6ICdyZ2JhKCcgKyByICsgJyUsICcgKyBnICsgJyUsICcgKyBiICsgJyUsICcgKyByZ2JhWzNdICsgJyknO1xufTtcblxuY3MudG8uaHNsID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaHNsYSA9IHN3aXp6bGUoYXJndW1lbnRzKTtcblx0cmV0dXJuIGhzbGEubGVuZ3RoIDwgNCB8fCBoc2xhWzNdID09PSAxXG5cdFx0PyAnaHNsKCcgKyBoc2xhWzBdICsgJywgJyArIGhzbGFbMV0gKyAnJSwgJyArIGhzbGFbMl0gKyAnJSknXG5cdFx0OiAnaHNsYSgnICsgaHNsYVswXSArICcsICcgKyBoc2xhWzFdICsgJyUsICcgKyBoc2xhWzJdICsgJyUsICcgKyBoc2xhWzNdICsgJyknO1xufTtcblxuLy8gaHdiIGlzIGEgYml0IGRpZmZlcmVudCB0aGFuIHJnYihhKSAmIGhzbChhKSBzaW5jZSB0aGVyZSBpcyBubyBhbHBoYSBzcGVjaWZpYyBzeW50YXhcbi8vIChod2IgaGF2ZSBhbHBoYSBvcHRpb25hbCAmIDEgaXMgZGVmYXVsdCB2YWx1ZSlcbmNzLnRvLmh3YiA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGh3YmEgPSBzd2l6emxlKGFyZ3VtZW50cyk7XG5cblx0dmFyIGEgPSAnJztcblx0aWYgKGh3YmEubGVuZ3RoID49IDQgJiYgaHdiYVszXSAhPT0gMSkge1xuXHRcdGEgPSAnLCAnICsgaHdiYVszXTtcblx0fVxuXG5cdHJldHVybiAnaHdiKCcgKyBod2JhWzBdICsgJywgJyArIGh3YmFbMV0gKyAnJSwgJyArIGh3YmFbMl0gKyAnJScgKyBhICsgJyknO1xufTtcblxuY3MudG8ua2V5d29yZCA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0cmV0dXJuIHJldmVyc2VOYW1lc1tyZ2Iuc2xpY2UoMCwgMyldO1xufTtcblxuLy8gaGVscGVyc1xuZnVuY3Rpb24gY2xhbXAobnVtLCBtaW4sIG1heCkge1xuXHRyZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobWluLCBudW0pLCBtYXgpO1xufVxuXG5mdW5jdGlvbiBoZXhEb3VibGUobnVtKSB7XG5cdHZhciBzdHIgPSBudW0udG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cdHJldHVybiAoc3RyLmxlbmd0aCA8IDIpID8gJzAnICsgc3RyIDogc3RyO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29sb3JTdHJpbmcgPSByZXF1aXJlKCdjb2xvci1zdHJpbmcnKTtcbnZhciBjb252ZXJ0ID0gcmVxdWlyZSgnY29sb3ItY29udmVydCcpO1xuXG52YXIgX3NsaWNlID0gW10uc2xpY2U7XG5cbnZhciBza2lwcGVkTW9kZWxzID0gW1xuXHQvLyB0byBiZSBob25lc3QsIEkgZG9uJ3QgcmVhbGx5IGZlZWwgbGlrZSBrZXl3b3JkIGJlbG9uZ3MgaW4gY29sb3IgY29udmVydCwgYnV0IGVoLlxuXHQna2V5d29yZCcsXG5cblx0Ly8gZ3JheSBjb25mbGljdHMgd2l0aCBzb21lIG1ldGhvZCBuYW1lcywgYW5kIGhhcyBpdHMgb3duIG1ldGhvZCBkZWZpbmVkLlxuXHQnZ3JheScsXG5cblx0Ly8gc2hvdWxkbid0IHJlYWxseSBiZSBpbiBjb2xvci1jb252ZXJ0IGVpdGhlci4uLlxuXHQnaGV4J1xuXTtcblxudmFyIGhhc2hlZE1vZGVsS2V5cyA9IHt9O1xuT2JqZWN0LmtleXMoY29udmVydCkuZm9yRWFjaChmdW5jdGlvbiAobW9kZWwpIHtcblx0aGFzaGVkTW9kZWxLZXlzW19zbGljZS5jYWxsKGNvbnZlcnRbbW9kZWxdLmxhYmVscykuc29ydCgpLmpvaW4oJycpXSA9IG1vZGVsO1xufSk7XG5cbnZhciBsaW1pdGVycyA9IHt9O1xuXG5mdW5jdGlvbiBDb2xvcihvYmosIG1vZGVsKSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb2xvcikpIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKG9iaiwgbW9kZWwpO1xuXHR9XG5cblx0aWYgKG1vZGVsICYmIG1vZGVsIGluIHNraXBwZWRNb2RlbHMpIHtcblx0XHRtb2RlbCA9IG51bGw7XG5cdH1cblxuXHRpZiAobW9kZWwgJiYgIShtb2RlbCBpbiBjb252ZXJ0KSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignVW5rbm93biBtb2RlbDogJyArIG1vZGVsKTtcblx0fVxuXG5cdHZhciBpO1xuXHR2YXIgY2hhbm5lbHM7XG5cblx0aWYgKCFvYmopIHtcblx0XHR0aGlzLm1vZGVsID0gJ3JnYic7XG5cdFx0dGhpcy5jb2xvciA9IFswLCAwLCAwXTtcblx0XHR0aGlzLnZhbHBoYSA9IDE7XG5cdH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgQ29sb3IpIHtcblx0XHR0aGlzLm1vZGVsID0gb2JqLm1vZGVsO1xuXHRcdHRoaXMuY29sb3IgPSBvYmouY29sb3Iuc2xpY2UoKTtcblx0XHR0aGlzLnZhbHBoYSA9IG9iai52YWxwaGE7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcblx0XHR2YXIgcmVzdWx0ID0gY29sb3JTdHJpbmcuZ2V0KG9iaik7XG5cdFx0aWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFyc2UgY29sb3IgZnJvbSBzdHJpbmc6ICcgKyBvYmopO1xuXHRcdH1cblxuXHRcdHRoaXMubW9kZWwgPSByZXN1bHQubW9kZWw7XG5cdFx0Y2hhbm5lbHMgPSBjb252ZXJ0W3RoaXMubW9kZWxdLmNoYW5uZWxzO1xuXHRcdHRoaXMuY29sb3IgPSByZXN1bHQudmFsdWUuc2xpY2UoMCwgY2hhbm5lbHMpO1xuXHRcdHRoaXMudmFscGhhID0gdHlwZW9mIHJlc3VsdC52YWx1ZVtjaGFubmVsc10gPT09ICdudW1iZXInID8gcmVzdWx0LnZhbHVlW2NoYW5uZWxzXSA6IDE7XG5cdH0gZWxzZSBpZiAob2JqLmxlbmd0aCkge1xuXHRcdHRoaXMubW9kZWwgPSBtb2RlbCB8fCAncmdiJztcblx0XHRjaGFubmVscyA9IGNvbnZlcnRbdGhpcy5tb2RlbF0uY2hhbm5lbHM7XG5cdFx0dmFyIG5ld0FyciA9IF9zbGljZS5jYWxsKG9iaiwgMCwgY2hhbm5lbHMpO1xuXHRcdHRoaXMuY29sb3IgPSB6ZXJvQXJyYXkobmV3QXJyLCBjaGFubmVscyk7XG5cdFx0dGhpcy52YWxwaGEgPSB0eXBlb2Ygb2JqW2NoYW5uZWxzXSA9PT0gJ251bWJlcicgPyBvYmpbY2hhbm5lbHNdIDogMTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnbnVtYmVyJykge1xuXHRcdC8vIHRoaXMgaXMgYWx3YXlzIFJHQiAtIGNhbiBiZSBjb252ZXJ0ZWQgbGF0ZXIgb24uXG5cdFx0b2JqICY9IDB4RkZGRkZGO1xuXHRcdHRoaXMubW9kZWwgPSAncmdiJztcblx0XHR0aGlzLmNvbG9yID0gW1xuXHRcdFx0KG9iaiA+PiAxNikgJiAweEZGLFxuXHRcdFx0KG9iaiA+PiA4KSAmIDB4RkYsXG5cdFx0XHRvYmogJiAweEZGXG5cdFx0XTtcblx0XHR0aGlzLnZhbHBoYSA9IDE7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy52YWxwaGEgPSAxO1xuXG5cdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuXHRcdGlmICgnYWxwaGEnIGluIG9iaikge1xuXHRcdFx0a2V5cy5zcGxpY2Uoa2V5cy5pbmRleE9mKCdhbHBoYScpLCAxKTtcblx0XHRcdHRoaXMudmFscGhhID0gdHlwZW9mIG9iai5hbHBoYSA9PT0gJ251bWJlcicgPyBvYmouYWxwaGEgOiAwO1xuXHRcdH1cblxuXHRcdHZhciBoYXNoZWRLZXlzID0ga2V5cy5zb3J0KCkuam9pbignJyk7XG5cdFx0aWYgKCEoaGFzaGVkS2V5cyBpbiBoYXNoZWRNb2RlbEtleXMpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBwYXJzZSBjb2xvciBmcm9tIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KG9iaikpO1xuXHRcdH1cblxuXHRcdHRoaXMubW9kZWwgPSBoYXNoZWRNb2RlbEtleXNbaGFzaGVkS2V5c107XG5cblx0XHR2YXIgbGFiZWxzID0gY29udmVydFt0aGlzLm1vZGVsXS5sYWJlbHM7XG5cdFx0dmFyIGNvbG9yID0gW107XG5cdFx0Zm9yIChpID0gMDsgaSA8IGxhYmVscy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29sb3IucHVzaChvYmpbbGFiZWxzW2ldXSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5jb2xvciA9IHplcm9BcnJheShjb2xvcik7XG5cdH1cblxuXHQvLyBwZXJmb3JtIGxpbWl0YXRpb25zIChjbGFtcGluZywgZXRjLilcblx0aWYgKGxpbWl0ZXJzW3RoaXMubW9kZWxdKSB7XG5cdFx0Y2hhbm5lbHMgPSBjb252ZXJ0W3RoaXMubW9kZWxdLmNoYW5uZWxzO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBjaGFubmVsczsgaSsrKSB7XG5cdFx0XHR2YXIgbGltaXQgPSBsaW1pdGVyc1t0aGlzLm1vZGVsXVtpXTtcblx0XHRcdGlmIChsaW1pdCkge1xuXHRcdFx0XHR0aGlzLmNvbG9yW2ldID0gbGltaXQodGhpcy5jb2xvcltpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dGhpcy52YWxwaGEgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB0aGlzLnZhbHBoYSkpO1xuXG5cdGlmIChPYmplY3QuZnJlZXplKSB7XG5cdFx0T2JqZWN0LmZyZWV6ZSh0aGlzKTtcblx0fVxufVxuXG5Db2xvci5wcm90b3R5cGUgPSB7XG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3RyaW5nKCk7XG5cdH0sXG5cblx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXNbdGhpcy5tb2RlbF0oKTtcblx0fSxcblxuXHRzdHJpbmc6IGZ1bmN0aW9uIChwbGFjZXMpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXMubW9kZWwgaW4gY29sb3JTdHJpbmcudG8gPyB0aGlzIDogdGhpcy5yZ2IoKTtcblx0XHRzZWxmID0gc2VsZi5yb3VuZCh0eXBlb2YgcGxhY2VzID09PSAnbnVtYmVyJyA/IHBsYWNlcyA6IDEpO1xuXHRcdHZhciBhcmdzID0gc2VsZi52YWxwaGEgPT09IDEgPyBzZWxmLmNvbG9yIDogc2VsZi5jb2xvci5jb25jYXQodGhpcy52YWxwaGEpO1xuXHRcdHJldHVybiBjb2xvclN0cmluZy50b1tzZWxmLm1vZGVsXShhcmdzKTtcblx0fSxcblxuXHRwZXJjZW50U3RyaW5nOiBmdW5jdGlvbiAocGxhY2VzKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLnJnYigpLnJvdW5kKHR5cGVvZiBwbGFjZXMgPT09ICdudW1iZXInID8gcGxhY2VzIDogMSk7XG5cdFx0dmFyIGFyZ3MgPSBzZWxmLnZhbHBoYSA9PT0gMSA/IHNlbGYuY29sb3IgOiBzZWxmLmNvbG9yLmNvbmNhdCh0aGlzLnZhbHBoYSk7XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLnRvLnJnYi5wZXJjZW50KGFyZ3MpO1xuXHR9LFxuXG5cdGFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFscGhhID09PSAxID8gdGhpcy5jb2xvci5zbGljZSgpIDogdGhpcy5jb2xvci5jb25jYXQodGhpcy52YWxwaGEpO1xuXHR9LFxuXG5cdG9iamVjdDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByZXN1bHQgPSB7fTtcblx0XHR2YXIgY2hhbm5lbHMgPSBjb252ZXJ0W3RoaXMubW9kZWxdLmNoYW5uZWxzO1xuXHRcdHZhciBsYWJlbHMgPSBjb252ZXJ0W3RoaXMubW9kZWxdLmxhYmVscztcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbm5lbHM7IGkrKykge1xuXHRcdFx0cmVzdWx0W2xhYmVsc1tpXV0gPSB0aGlzLmNvbG9yW2ldO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLnZhbHBoYSAhPT0gMSkge1xuXHRcdFx0cmVzdWx0LmFscGhhID0gdGhpcy52YWxwaGE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHR1bml0QXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmdiID0gdGhpcy5yZ2IoKS5jb2xvcjtcblx0XHRyZ2JbMF0gLz0gMjU1O1xuXHRcdHJnYlsxXSAvPSAyNTU7XG5cdFx0cmdiWzJdIC89IDI1NTtcblxuXHRcdGlmICh0aGlzLnZhbHBoYSAhPT0gMSkge1xuXHRcdFx0cmdiLnB1c2godGhpcy52YWxwaGEpO1xuXHRcdH1cblxuXHRcdHJldHVybiByZ2I7XG5cdH0sXG5cblx0dW5pdE9iamVjdDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByZ2IgPSB0aGlzLnJnYigpLm9iamVjdCgpO1xuXHRcdHJnYi5yIC89IDI1NTtcblx0XHRyZ2IuZyAvPSAyNTU7XG5cdFx0cmdiLmIgLz0gMjU1O1xuXG5cdFx0aWYgKHRoaXMudmFscGhhICE9PSAxKSB7XG5cdFx0XHRyZ2IuYWxwaGEgPSB0aGlzLnZhbHBoYTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmdiO1xuXHR9LFxuXG5cdHJvdW5kOiBmdW5jdGlvbiAocGxhY2VzKSB7XG5cdFx0cGxhY2VzID0gTWF0aC5tYXgocGxhY2VzIHx8IDAsIDApO1xuXHRcdHJldHVybiBuZXcgQ29sb3IodGhpcy5jb2xvci5tYXAocm91bmRUb1BsYWNlKHBsYWNlcykpLmNvbmNhdCh0aGlzLnZhbHBoYSksIHRoaXMubW9kZWwpO1xuXHR9LFxuXG5cdGFscGhhOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBuZXcgQ29sb3IodGhpcy5jb2xvci5jb25jYXQoTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdmFsKSkpLCB0aGlzLm1vZGVsKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy52YWxwaGE7XG5cdH0sXG5cblx0Ly8gcmdiXG5cdHJlZDogZ2V0c2V0KCdyZ2InLCAwLCBtYXhmbigyNTUpKSxcblx0Z3JlZW46IGdldHNldCgncmdiJywgMSwgbWF4Zm4oMjU1KSksXG5cdGJsdWU6IGdldHNldCgncmdiJywgMiwgbWF4Zm4oMjU1KSksXG5cblx0aHVlOiBnZXRzZXQoWydoc2wnLCAnaHN2JywgJ2hzbCcsICdod2InLCAnaGNnJ10sIDAsIGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuICgodmFsICUgMzYwKSArIDM2MCkgJSAzNjA7IH0pLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJyYWNlLXN0eWxlXG5cblx0c2F0dXJhdGlvbmw6IGdldHNldCgnaHNsJywgMSwgbWF4Zm4oMTAwKSksXG5cdGxpZ2h0bmVzczogZ2V0c2V0KCdoc2wnLCAyLCBtYXhmbigxMDApKSxcblxuXHRzYXR1cmF0aW9udjogZ2V0c2V0KCdoc3YnLCAxLCBtYXhmbigxMDApKSxcblx0dmFsdWU6IGdldHNldCgnaHN2JywgMiwgbWF4Zm4oMTAwKSksXG5cblx0Y2hyb21hOiBnZXRzZXQoJ2hjZycsIDEsIG1heGZuKDEwMCkpLFxuXHRncmF5OiBnZXRzZXQoJ2hjZycsIDIsIG1heGZuKDEwMCkpLFxuXG5cdHdoaXRlOiBnZXRzZXQoJ2h3YicsIDEsIG1heGZuKDEwMCkpLFxuXHR3YmxhY2s6IGdldHNldCgnaHdiJywgMiwgbWF4Zm4oMTAwKSksXG5cblx0Y3lhbjogZ2V0c2V0KCdjbXlrJywgMCwgbWF4Zm4oMTAwKSksXG5cdG1hZ2VudGE6IGdldHNldCgnY215aycsIDEsIG1heGZuKDEwMCkpLFxuXHR5ZWxsb3c6IGdldHNldCgnY215aycsIDIsIG1heGZuKDEwMCkpLFxuXHRibGFjazogZ2V0c2V0KCdjbXlrJywgMywgbWF4Zm4oMTAwKSksXG5cblx0eDogZ2V0c2V0KCd4eXonLCAwLCBtYXhmbigxMDApKSxcblx0eTogZ2V0c2V0KCd4eXonLCAxLCBtYXhmbigxMDApKSxcblx0ejogZ2V0c2V0KCd4eXonLCAyLCBtYXhmbigxMDApKSxcblxuXHRsOiBnZXRzZXQoJ2xhYicsIDAsIG1heGZuKDEwMCkpLFxuXHRhOiBnZXRzZXQoJ2xhYicsIDEpLFxuXHRiOiBnZXRzZXQoJ2xhYicsIDIpLFxuXG5cdGtleXdvcmQ6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIG5ldyBDb2xvcih2YWwpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb252ZXJ0W3RoaXMubW9kZWxdLmtleXdvcmQodGhpcy5jb2xvcik7XG5cdH0sXG5cblx0aGV4OiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBuZXcgQ29sb3IodmFsKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29sb3JTdHJpbmcudG8uaGV4KHRoaXMucmdiKCkucm91bmQoKS5jb2xvcik7XG5cdH0sXG5cblx0cmdiTnVtYmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJnYiA9IHRoaXMucmdiKCkuY29sb3I7XG5cdFx0cmV0dXJuICgocmdiWzBdICYgMHhGRikgPDwgMTYpIHwgKChyZ2JbMV0gJiAweEZGKSA8PCA4KSB8IChyZ2JbMl0gJiAweEZGKTtcblx0fSxcblxuXHRsdW1pbm9zaXR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLyNyZWxhdGl2ZWx1bWluYW5jZWRlZlxuXHRcdHZhciByZ2IgPSB0aGlzLnJnYigpLmNvbG9yO1xuXG5cdFx0dmFyIGx1bSA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hhbiA9IHJnYltpXSAvIDI1NTtcblx0XHRcdGx1bVtpXSA9IChjaGFuIDw9IDAuMDM5MjgpID8gY2hhbiAvIDEyLjkyIDogTWF0aC5wb3coKChjaGFuICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO1xuXHRcdH1cblxuXHRcdHJldHVybiAwLjIxMjYgKiBsdW1bMF0gKyAwLjcxNTIgKiBsdW1bMV0gKyAwLjA3MjIgKiBsdW1bMl07XG5cdH0sXG5cblx0Y29udHJhc3Q6IGZ1bmN0aW9uIChjb2xvcjIpIHtcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAvI2NvbnRyYXN0LXJhdGlvZGVmXG5cdFx0dmFyIGx1bTEgPSB0aGlzLmx1bWlub3NpdHkoKTtcblx0XHR2YXIgbHVtMiA9IGNvbG9yMi5sdW1pbm9zaXR5KCk7XG5cblx0XHRpZiAobHVtMSA+IGx1bTIpIHtcblx0XHRcdHJldHVybiAobHVtMSArIDAuMDUpIC8gKGx1bTIgKyAwLjA1KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKGx1bTIgKyAwLjA1KSAvIChsdW0xICsgMC4wNSk7XG5cdH0sXG5cblx0bGV2ZWw6IGZ1bmN0aW9uIChjb2xvcjIpIHtcblx0XHR2YXIgY29udHJhc3RSYXRpbyA9IHRoaXMuY29udHJhc3QoY29sb3IyKTtcblx0XHRpZiAoY29udHJhc3RSYXRpbyA+PSA3LjEpIHtcblx0XHRcdHJldHVybiAnQUFBJztcblx0XHR9XG5cblx0XHRyZXR1cm4gKGNvbnRyYXN0UmF0aW8gPj0gNC41KSA/ICdBQScgOiAnJztcblx0fSxcblxuXHRkYXJrOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gWUlRIGVxdWF0aW9uIGZyb20gaHR0cDovLzI0d2F5cy5vcmcvMjAxMC9jYWxjdWxhdGluZy1jb2xvci1jb250cmFzdFxuXHRcdHZhciByZ2IgPSB0aGlzLnJnYigpLmNvbG9yO1xuXHRcdHZhciB5aXEgPSAocmdiWzBdICogMjk5ICsgcmdiWzFdICogNTg3ICsgcmdiWzJdICogMTE0KSAvIDEwMDA7XG5cdFx0cmV0dXJuIHlpcSA8IDEyODtcblx0fSxcblxuXHRsaWdodDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhdGhpcy5kYXJrKCk7XG5cdH0sXG5cblx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJnYiA9IHRoaXMucmdiKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRcdHJnYi5jb2xvcltpXSA9IDI1NSAtIHJnYi5jb2xvcltpXTtcblx0XHR9XG5cdFx0cmV0dXJuIHJnYjtcblx0fSxcblxuXHRsaWdodGVuOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHNsID0gdGhpcy5oc2woKTtcblx0XHRoc2wuY29sb3JbMl0gKz0gaHNsLmNvbG9yWzJdICogcmF0aW87XG5cdFx0cmV0dXJuIGhzbDtcblx0fSxcblxuXHRkYXJrZW46IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBoc2wgPSB0aGlzLmhzbCgpO1xuXHRcdGhzbC5jb2xvclsyXSAtPSBoc2wuY29sb3JbMl0gKiByYXRpbztcblx0XHRyZXR1cm4gaHNsO1xuXHR9LFxuXG5cdHNhdHVyYXRlOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHNsID0gdGhpcy5oc2woKTtcblx0XHRoc2wuY29sb3JbMV0gKz0gaHNsLmNvbG9yWzFdICogcmF0aW87XG5cdFx0cmV0dXJuIGhzbDtcblx0fSxcblxuXHRkZXNhdHVyYXRlOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHNsID0gdGhpcy5oc2woKTtcblx0XHRoc2wuY29sb3JbMV0gLT0gaHNsLmNvbG9yWzFdICogcmF0aW87XG5cdFx0cmV0dXJuIGhzbDtcblx0fSxcblxuXHR3aGl0ZW46IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBod2IgPSB0aGlzLmh3YigpO1xuXHRcdGh3Yi5jb2xvclsxXSArPSBod2IuY29sb3JbMV0gKiByYXRpbztcblx0XHRyZXR1cm4gaHdiO1xuXHR9LFxuXG5cdGJsYWNrZW46IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBod2IgPSB0aGlzLmh3YigpO1xuXHRcdGh3Yi5jb2xvclsyXSArPSBod2IuY29sb3JbMl0gKiByYXRpbztcblx0XHRyZXR1cm4gaHdiO1xuXHR9LFxuXG5cdGdyYXlzY2FsZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR3JheXNjYWxlI0NvbnZlcnRpbmdfY29sb3JfdG9fZ3JheXNjYWxlXG5cdFx0dmFyIHJnYiA9IHRoaXMucmdiKCkuY29sb3I7XG5cdFx0dmFyIHZhbCA9IHJnYlswXSAqIDAuMyArIHJnYlsxXSAqIDAuNTkgKyByZ2JbMl0gKiAwLjExO1xuXHRcdHJldHVybiBDb2xvci5yZ2IodmFsLCB2YWwsIHZhbCk7XG5cdH0sXG5cblx0ZmFkZTogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWxwaGEodGhpcy52YWxwaGEgLSAodGhpcy52YWxwaGEgKiByYXRpbykpO1xuXHR9LFxuXG5cdG9wYXF1ZXI6IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHJldHVybiB0aGlzLmFscGhhKHRoaXMudmFscGhhICsgKHRoaXMudmFscGhhICogcmF0aW8pKTtcblx0fSxcblxuXHRyb3RhdGU6IGZ1bmN0aW9uIChkZWdyZWVzKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMuaHNsKCk7XG5cdFx0dmFyIGh1ZSA9IGhzbC5jb2xvclswXTtcblx0XHRodWUgPSAoaHVlICsgZGVncmVlcykgJSAzNjA7XG5cdFx0aHVlID0gaHVlIDwgMCA/IDM2MCArIGh1ZSA6IGh1ZTtcblx0XHRoc2wuY29sb3JbMF0gPSBodWU7XG5cdFx0cmV0dXJuIGhzbDtcblx0fSxcblxuXHRtaXg6IGZ1bmN0aW9uIChtaXhpbkNvbG9yLCB3ZWlnaHQpIHtcblx0XHQvLyBwb3J0ZWQgZnJvbSBzYXNzIGltcGxlbWVudGF0aW9uIGluIENcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vc2Fzcy9saWJzYXNzL2Jsb2IvMGU2YjRhMjg1MDA5MjM1NmFhM2VjZTA3YzZiMjQ5ZjAyMjFjYWNlZC9mdW5jdGlvbnMuY3BwI0wyMDlcblx0XHR2YXIgY29sb3IxID0gdGhpcy5yZ2IoKTtcblx0XHR2YXIgY29sb3IyID0gbWl4aW5Db2xvci5yZ2IoKTtcblx0XHR2YXIgcCA9IHdlaWdodCA9PT0gdW5kZWZpbmVkID8gMC41IDogd2VpZ2h0O1xuXG5cdFx0dmFyIHcgPSAyICogcCAtIDE7XG5cdFx0dmFyIGEgPSBjb2xvcjEuYWxwaGEoKSAtIGNvbG9yMi5hbHBoYSgpO1xuXG5cdFx0dmFyIHcxID0gKCgodyAqIGEgPT09IC0xKSA/IHcgOiAodyArIGEpIC8gKDEgKyB3ICogYSkpICsgMSkgLyAyLjA7XG5cdFx0dmFyIHcyID0gMSAtIHcxO1xuXG5cdFx0cmV0dXJuIENvbG9yLnJnYihcblx0XHRcdFx0dzEgKiBjb2xvcjEucmVkKCkgKyB3MiAqIGNvbG9yMi5yZWQoKSxcblx0XHRcdFx0dzEgKiBjb2xvcjEuZ3JlZW4oKSArIHcyICogY29sb3IyLmdyZWVuKCksXG5cdFx0XHRcdHcxICogY29sb3IxLmJsdWUoKSArIHcyICogY29sb3IyLmJsdWUoKSxcblx0XHRcdFx0Y29sb3IxLmFscGhhKCkgKiBwICsgY29sb3IyLmFscGhhKCkgKiAoMSAtIHApKTtcblx0fVxufTtcblxuLy8gbW9kZWwgY29udmVyc2lvbiBtZXRob2RzIGFuZCBzdGF0aWMgY29uc3RydWN0b3JzXG5PYmplY3Qua2V5cyhjb252ZXJ0KS5mb3JFYWNoKGZ1bmN0aW9uIChtb2RlbCkge1xuXHRpZiAoc2tpcHBlZE1vZGVscy5pbmRleE9mKG1vZGVsKSAhPT0gLTEpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXIgY2hhbm5lbHMgPSBjb252ZXJ0W21vZGVsXS5jaGFubmVscztcblxuXHQvLyBjb252ZXJzaW9uIG1ldGhvZHNcblx0Q29sb3IucHJvdG90eXBlW21vZGVsXSA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5tb2RlbCA9PT0gbW9kZWwpIHtcblx0XHRcdHJldHVybiBuZXcgQ29sb3IodGhpcyk7XG5cdFx0fVxuXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBuZXcgQ29sb3IoYXJndW1lbnRzLCBtb2RlbCk7XG5cdFx0fVxuXG5cdFx0dmFyIG5ld0FscGhhID0gdHlwZW9mIGFyZ3VtZW50c1tjaGFubmVsc10gPT09ICdudW1iZXInID8gY2hhbm5lbHMgOiB0aGlzLnZhbHBoYTtcblx0XHRyZXR1cm4gbmV3IENvbG9yKGFzc2VydEFycmF5KGNvbnZlcnRbdGhpcy5tb2RlbF1bbW9kZWxdLnJhdyh0aGlzLmNvbG9yKSkuY29uY2F0KG5ld0FscGhhKSwgbW9kZWwpO1xuXHR9O1xuXG5cdC8vICdzdGF0aWMnIGNvbnN0cnVjdGlvbiBtZXRob2RzXG5cdENvbG9yW21vZGVsXSA9IGZ1bmN0aW9uIChjb2xvcikge1xuXHRcdGlmICh0eXBlb2YgY29sb3IgPT09ICdudW1iZXInKSB7XG5cdFx0XHRjb2xvciA9IHplcm9BcnJheShfc2xpY2UuY2FsbChhcmd1bWVudHMpLCBjaGFubmVscyk7XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgQ29sb3IoY29sb3IsIG1vZGVsKTtcblx0fTtcbn0pO1xuXG5mdW5jdGlvbiByb3VuZFRvKG51bSwgcGxhY2VzKSB7XG5cdHJldHVybiBOdW1iZXIobnVtLnRvRml4ZWQocGxhY2VzKSk7XG59XG5cbmZ1bmN0aW9uIHJvdW5kVG9QbGFjZShwbGFjZXMpIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChudW0pIHtcblx0XHRyZXR1cm4gcm91bmRUbyhudW0sIHBsYWNlcyk7XG5cdH07XG59XG5cbmZ1bmN0aW9uIGdldHNldChtb2RlbCwgY2hhbm5lbCwgbW9kaWZpZXIpIHtcblx0bW9kZWwgPSBBcnJheS5pc0FycmF5KG1vZGVsKSA/IG1vZGVsIDogW21vZGVsXTtcblxuXHRtb2RlbC5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG5cdFx0KGxpbWl0ZXJzW21dIHx8IChsaW1pdGVyc1ttXSA9IFtdKSlbY2hhbm5lbF0gPSBtb2RpZmllcjtcblx0fSk7XG5cblx0bW9kZWwgPSBtb2RlbFswXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKHZhbCkge1xuXHRcdHZhciByZXN1bHQ7XG5cblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0aWYgKG1vZGlmaWVyKSB7XG5cdFx0XHRcdHZhbCA9IG1vZGlmaWVyKHZhbCk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3VsdCA9IHRoaXNbbW9kZWxdKCk7XG5cdFx0XHRyZXN1bHQuY29sb3JbY2hhbm5lbF0gPSB2YWw7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblxuXHRcdHJlc3VsdCA9IHRoaXNbbW9kZWxdKCkuY29sb3JbY2hhbm5lbF07XG5cdFx0aWYgKG1vZGlmaWVyKSB7XG5cdFx0XHRyZXN1bHQgPSBtb2RpZmllcihyZXN1bHQpO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG59XG5cbmZ1bmN0aW9uIG1heGZuKG1heCkge1xuXHRyZXR1cm4gZnVuY3Rpb24gKHYpIHtcblx0XHRyZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4LCB2KSk7XG5cdH07XG59XG5cbmZ1bmN0aW9uIGFzc2VydEFycmF5KHZhbCkge1xuXHRyZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsIDogW3ZhbF07XG59XG5cbmZ1bmN0aW9uIHplcm9BcnJheShhcnIsIGxlbmd0aCkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKHR5cGVvZiBhcnJbaV0gIT09ICdudW1iZXInKSB7XG5cdFx0XHRhcnJbaV0gPSAwO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sb3I7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5hcnJheS5maW5kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5BcnJheS5maW5kOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LmFycmF5LmZvci1lYWNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5BcnJheS5mb3JFYWNoOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuQXJyYXkucmVkdWNlOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmJpbmQnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLkZ1bmN0aW9uLmJpbmQ7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYubnVtYmVyLmNvbnN0cnVjdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlcjsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3QuYXNzaWduOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyl7XG4gIHJldHVybiAkT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpO1xufTsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmtleXM7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07IiwiLy8gMjIuMS4zLjMxIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxudmFyIFVOU0NPUEFCTEVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3Vuc2NvcGFibGVzJylcbiAgLCBBcnJheVByb3RvICA9IEFycmF5LnByb3RvdHlwZTtcbmlmKEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZClyZXF1aXJlKCcuL19oaWRlJykoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgQXJyYXlQcm90b1tVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59OyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59OyIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCB0b0luZGV4ICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihJU19JTkNMVURFUyl7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgZWwsIGZyb21JbmRleCl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCgkdGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IHRvSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpXG4gICAgICAsIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICBpZihJU19JTkNMVURFUyAmJiBlbCAhPSBlbCl3aGlsZShsZW5ndGggPiBpbmRleCl7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICBpZih2YWx1ZSAhPSB2YWx1ZSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSN0b0luZGV4IGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTyl7XG4gICAgICBpZihPW2luZGV4XSA9PT0gZWwpcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTsiLCIvLyAwIC0+IEFycmF5I2ZvckVhY2hcbi8vIDEgLT4gQXJyYXkjbWFwXG4vLyAyIC0+IEFycmF5I2ZpbHRlclxuLy8gMyAtPiBBcnJheSNzb21lXG4vLyA0IC0+IEFycmF5I2V2ZXJ5XG4vLyA1IC0+IEFycmF5I2ZpbmRcbi8vIDYgLT4gQXJyYXkjZmluZEluZGV4XG52YXIgY3R4ICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIElPYmplY3QgID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBhc2MgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRZUEUsICRjcmVhdGUpe1xuICB2YXIgSVNfTUFQICAgICAgICA9IFRZUEUgPT0gMVxuICAgICwgSVNfRklMVEVSICAgICA9IFRZUEUgPT0gMlxuICAgICwgSVNfU09NRSAgICAgICA9IFRZUEUgPT0gM1xuICAgICwgSVNfRVZFUlkgICAgICA9IFRZUEUgPT0gNFxuICAgICwgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNlxuICAgICwgTk9fSE9MRVMgICAgICA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYXG4gICAgLCBjcmVhdGUgICAgICAgID0gJGNyZWF0ZSB8fCBhc2M7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCl7XG4gICAgdmFyIE8gICAgICA9IHRvT2JqZWN0KCR0aGlzKVxuICAgICAgLCBzZWxmICAgPSBJT2JqZWN0KE8pXG4gICAgICAsIGYgICAgICA9IGN0eChjYWxsYmFja2ZuLCB0aGF0LCAzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gMFxuICAgICAgLCByZXN1bHQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkXG4gICAgICAsIHZhbCwgcmVzO1xuICAgIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZil7XG4gICAgICB2YWwgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XG4gICAgICBpZihUWVBFKXtcbiAgICAgICAgaWYoSVNfTUFQKXJlc3VsdFtpbmRleF0gPSByZXM7ICAgICAgICAgICAgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYocmVzKXN3aXRjaChUWVBFKXtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbDsgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuICAgICAgICAgIGNhc2UgMjogcmVzdWx0LnB1c2godmFsKTsgICAgICAgICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIGlmKElTX0VWRVJZKXJldHVybiBmYWxzZTsgICAgICAgICAgLy8gZXZlcnlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHJlc3VsdDtcbiAgfTtcbn07IiwidmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIHRvT2JqZWN0ICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgSU9iamVjdCAgID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGhhdCwgY2FsbGJhY2tmbiwgYUxlbiwgbWVtbywgaXNSaWdodCl7XG4gIGFGdW5jdGlvbihjYWxsYmFja2ZuKTtcbiAgdmFyIE8gICAgICA9IHRvT2JqZWN0KHRoYXQpXG4gICAgLCBzZWxmICAgPSBJT2JqZWN0KE8pXG4gICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAsIGluZGV4ICA9IGlzUmlnaHQgPyBsZW5ndGggLSAxIDogMFxuICAgICwgaSAgICAgID0gaXNSaWdodCA/IC0xIDogMTtcbiAgaWYoYUxlbiA8IDIpZm9yKDs7KXtcbiAgICBpZihpbmRleCBpbiBzZWxmKXtcbiAgICAgIG1lbW8gPSBzZWxmW2luZGV4XTtcbiAgICAgIGluZGV4ICs9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaW5kZXggKz0gaTtcbiAgICBpZihpc1JpZ2h0ID8gaW5kZXggPCAwIDogbGVuZ3RoIDw9IGluZGV4KXtcbiAgICAgIHRocm93IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgIH1cbiAgfVxuICBmb3IoO2lzUmlnaHQgPyBpbmRleCA+PSAwIDogbGVuZ3RoID4gaW5kZXg7IGluZGV4ICs9IGkpaWYoaW5kZXggaW4gc2VsZil7XG4gICAgbWVtbyA9IGNhbGxiYWNrZm4obWVtbywgc2VsZltpbmRleF0sIGluZGV4LCBPKTtcbiAgfVxuICByZXR1cm4gbWVtbztcbn07IiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBpc0FycmF5ICA9IHJlcXVpcmUoJy4vX2lzLWFycmF5JylcbiAgLCBTUEVDSUVTICA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3JpZ2luYWwpe1xuICB2YXIgQztcbiAgaWYoaXNBcnJheShvcmlnaW5hbCkpe1xuICAgIEMgPSBvcmlnaW5hbC5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSlDID0gdW5kZWZpbmVkO1xuICAgIGlmKGlzT2JqZWN0KEMpKXtcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xuICAgICAgaWYoQyA9PT0gbnVsbClDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDO1xufTsiLCIvLyA5LjQuMi4zIEFycmF5U3BlY2llc0NyZWF0ZShvcmlnaW5hbEFycmF5LCBsZW5ndGgpXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsLCBsZW5ndGgpe1xuICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWwpKShsZW5ndGgpO1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgYUZ1bmN0aW9uICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIGlzT2JqZWN0ICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGludm9rZSAgICAgPSByZXF1aXJlKCcuL19pbnZva2UnKVxuICAsIGFycmF5U2xpY2UgPSBbXS5zbGljZVxuICAsIGZhY3RvcmllcyAgPSB7fTtcblxudmFyIGNvbnN0cnVjdCA9IGZ1bmN0aW9uKEYsIGxlbiwgYXJncyl7XG4gIGlmKCEobGVuIGluIGZhY3Rvcmllcykpe1xuICAgIGZvcih2YXIgbiA9IFtdLCBpID0gMDsgaSA8IGxlbjsgaSsrKW5baV0gPSAnYVsnICsgaSArICddJztcbiAgICBmYWN0b3JpZXNbbGVuXSA9IEZ1bmN0aW9uKCdGLGEnLCAncmV0dXJuIG5ldyBGKCcgKyBuLmpvaW4oJywnKSArICcpJyk7XG4gIH0gcmV0dXJuIGZhY3Rvcmllc1tsZW5dKEYsIGFyZ3MpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5iaW5kIHx8IGZ1bmN0aW9uIGJpbmQodGhhdCAvKiwgYXJncy4uLiAqLyl7XG4gIHZhciBmbiAgICAgICA9IGFGdW5jdGlvbih0aGlzKVxuICAgICwgcGFydEFyZ3MgPSBhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgdmFyIGJvdW5kID0gZnVuY3Rpb24oLyogYXJncy4uLiAqLyl7XG4gICAgdmFyIGFyZ3MgPSBwYXJ0QXJncy5jb25jYXQoYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgYm91bmQgPyBjb25zdHJ1Y3QoZm4sIGFyZ3MubGVuZ3RoLCBhcmdzKSA6IGludm9rZShmbiwgYXJncywgdGhhdCk7XG4gIH07XG4gIGlmKGlzT2JqZWN0KGZuLnByb3RvdHlwZSkpYm91bmQucHJvdG90eXBlID0gZm4ucHJvdG90eXBlO1xuICByZXR1cm4gYm91bmQ7XG59OyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07IiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMi40LjAnfTtcbmlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZiIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIHRoYXQsIGxlbmd0aCl7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmKHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XG4gIHN3aXRjaChsZW5ndGgpe1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07IiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59OyIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pOyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudFxuICAvLyBpbiBvbGQgSUUgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCdcbiAgLCBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTsiLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTsiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBoaWRlICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCByZWRlZmluZSAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgY3R4ICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIHx8IChnbG9iYWxbbmFtZV0gPSB7fSkgOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdXG4gICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxuICAgICwgZXhwUHJvdG8gID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSlcbiAgICAsIGtleSwgb3duLCBvdXQsIGV4cDtcbiAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gKG93biA/IHRhcmdldCA6IHNvdXJjZSlba2V5XTtcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIGV4cCA9IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4dGVuZCBnbG9iYWxcbiAgICBpZih0YXJnZXQpcmVkZWZpbmUodGFyZ2V0LCBrZXksIG91dCwgdHlwZSAmICRleHBvcnQuVSk7XG4gICAgLy8gZXhwb3J0XG4gICAgaWYoZXhwb3J0c1trZXldICE9IG91dCloaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZihJU19QUk9UTyAmJiBleHBQcm90b1trZXldICE9IG91dClleHBQcm90b1trZXldID0gb3V0O1xuICB9XG59O1xuZ2xvYmFsLmNvcmUgPSBjb3JlO1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YCBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07IiwidmFyIGRQICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50OyIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7IiwidmFyIGlzT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGhhdCwgdGFyZ2V0LCBDKXtcbiAgdmFyIFAsIFMgPSB0YXJnZXQuY29uc3RydWN0b3I7XG4gIGlmKFMgIT09IEMgJiYgdHlwZW9mIFMgPT0gJ2Z1bmN0aW9uJyAmJiAoUCA9IFMucHJvdG90eXBlKSAhPT0gQy5wcm90b3R5cGUgJiYgaXNPYmplY3QoUCkgJiYgc2V0UHJvdG90eXBlT2Ype1xuICAgIHNldFByb3RvdHlwZU9mKHRoYXQsIFApO1xuICB9IHJldHVybiB0aGF0O1xufTsiLCIvLyBmYXN0IGFwcGx5LCBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIGFyZ3MsIHRoYXQpe1xuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XG4gIHN3aXRjaChhcmdzLmxlbmd0aCl7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbn07IiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07IiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZyl7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07IiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIGdldEtleXMgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUFMgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKVxuICAsIHBJRSAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpXG4gICwgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIElPYmplY3QgID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgJGFzc2lnbiAgPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICB2YXIgQSA9IHt9XG4gICAgLCBCID0ge31cbiAgICAsIFMgPSBTeW1ib2woKVxuICAgICwgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uKGspeyBCW2tdID0gazsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUICAgICA9IHRvT2JqZWN0KHRhcmdldClcbiAgICAsIGFMZW4gID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgaW5kZXggPSAxXG4gICAgLCBnZXRTeW1ib2xzID0gZ09QUy5mXG4gICAgLCBpc0VudW0gICAgID0gcElFLmY7XG4gIHdoaWxlKGFMZW4gPiBpbmRleCl7XG4gICAgdmFyIFMgICAgICA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKVxuICAgICAgLCBrZXlzICAgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAsIGogICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKGxlbmd0aCA+IGopaWYoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSlUW2tleV0gPSBTW2tleV07XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjsiLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZFBzICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJylcbiAgLCBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKVxuICAsIElFX1BST1RPICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpXG4gICwgRW1wdHkgICAgICAgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9XG4gICwgUFJPVE9UWVBFICAgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbigpe1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKVxuICAgICwgaSAgICAgID0gZW51bUJ1Z0tleXMubGVuZ3RoXG4gICAgLCBsdCAgICAgPSAnPCdcbiAgICAsIGd0ICAgICA9ICc+J1xuICAgICwgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUoaS0tKWRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKXtcbiAgdmFyIHJlc3VsdDtcbiAgaWYoTyAhPT0gbnVsbCl7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBkUCAgICAgICAgICAgICA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpe1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgaWYoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKXRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmKCd2YWx1ZScgaW4gQXR0cmlidXRlcylPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59OyIsInZhciBkUCAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGdldEtleXMgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpe1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgICA9IGdldEtleXMoUHJvcGVydGllcylcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgLCBpID0gMFxuICAgICwgUDtcbiAgd2hpbGUobGVuZ3RoID4gaSlkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuICByZXR1cm4gTztcbn07IiwidmFyIHBJRSAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgZ09QRCAgICAgICAgICAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKXtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKGhhcyhPLCBQKSlyZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59OyIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxuICAsIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTyl7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07IiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sczsiLCJ2YXIgaGFzICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCB0b0lPYmplY3QgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKVxuICAsIElFX1BST1RPICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIG5hbWVzKXtcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwga2V5O1xuICBmb3Ioa2V5IGluIE8paWYoa2V5ICE9IElFX1BST1RPKWhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZihoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpe1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07IiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKXtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07IiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7IiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY29yZSAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGZhaWxzICAgPSByZXF1aXJlKCcuL19mYWlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIGV4ZWMpe1xuICB2YXIgZm4gID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldXG4gICAgLCBleHAgPSB7fTtcbiAgZXhwW0tFWV0gPSBleGVjKGZuKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbigpeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJpdG1hcCwgdmFsdWUpe1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGUgIDogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGUgICAgOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlICAgICAgIDogdmFsdWVcbiAgfTtcbn07IiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgaGFzICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBTUkMgICAgICAgPSByZXF1aXJlKCcuL191aWQnKSgnc3JjJylcbiAgLCBUT19TVFJJTkcgPSAndG9TdHJpbmcnXG4gICwgJHRvU3RyaW5nID0gRnVuY3Rpb25bVE9fU1RSSU5HXVxuICAsIFRQTCAgICAgICA9ICgnJyArICR0b1N0cmluZykuc3BsaXQoVE9fU1RSSU5HKTtcblxucmVxdWlyZSgnLi9fY29yZScpLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG59O1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihPLCBrZXksIHZhbCwgc2FmZSl7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHZhbCA9PSAnZnVuY3Rpb24nO1xuICBpZihpc0Z1bmN0aW9uKWhhcyh2YWwsICduYW1lJykgfHwgaGlkZSh2YWwsICduYW1lJywga2V5KTtcbiAgaWYoT1trZXldID09PSB2YWwpcmV0dXJuO1xuICBpZihpc0Z1bmN0aW9uKWhhcyh2YWwsIFNSQykgfHwgaGlkZSh2YWwsIFNSQywgT1trZXldID8gJycgKyBPW2tleV0gOiBUUEwuam9pbihTdHJpbmcoa2V5KSkpO1xuICBpZihPID09PSBnbG9iYWwpe1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBpZighc2FmZSl7XG4gICAgICBkZWxldGUgT1trZXldO1xuICAgICAgaGlkZShPLCBrZXksIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKE9ba2V5XSlPW2tleV0gPSB2YWw7XG4gICAgICBlbHNlIGhpZGUoTywga2V5LCB2YWwpO1xuICAgIH1cbiAgfVxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgdGhpc1tTUkNdIHx8ICR0b1N0cmluZy5jYWxsKHRoaXMpO1xufSk7IiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGNoZWNrID0gZnVuY3Rpb24oTywgcHJvdG8pe1xuICBhbk9iamVjdChPKTtcbiAgaWYoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCl0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmdW5jdGlvbih0ZXN0LCBidWdneSwgc2V0KXtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldCA9IHJlcXVpcmUoJy4vX2N0eCcpKEZ1bmN0aW9uLmNhbGwsIHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0LCAyKTtcbiAgICAgICAgc2V0KHRlc3QsIFtdKTtcbiAgICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7XG4gICAgICB9IGNhdGNoKGUpeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90byl7XG4gICAgICAgIGNoZWNrKE8sIHByb3RvKTtcbiAgICAgICAgaWYoYnVnZ3kpTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59OyIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpXG4gICwgdWlkICAgID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XG59OyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXG4gICwgc3RvcmUgID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07IiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtZXRob2QsIGFyZyl7XG4gIHJldHVybiAhIW1ldGhvZCAmJiBmYWlscyhmdW5jdGlvbigpe1xuICAgIGFyZyA/IG1ldGhvZC5jYWxsKG51bGwsIGZ1bmN0aW9uKCl7fSwgMSkgOiBtZXRob2QuY2FsbChudWxsKTtcbiAgfSk7XG59OyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBzcGFjZXMgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXdzJylcbiAgLCBzcGFjZSAgID0gJ1snICsgc3BhY2VzICsgJ10nXG4gICwgbm9uICAgICA9ICdcXHUyMDBiXFx1MDA4NSdcbiAgLCBsdHJpbSAgID0gUmVnRXhwKCdeJyArIHNwYWNlICsgc3BhY2UgKyAnKicpXG4gICwgcnRyaW0gICA9IFJlZ0V4cChzcGFjZSArIHNwYWNlICsgJyokJyk7XG5cbnZhciBleHBvcnRlciA9IGZ1bmN0aW9uKEtFWSwgZXhlYywgQUxJQVMpe1xuICB2YXIgZXhwICAgPSB7fTtcbiAgdmFyIEZPUkNFID0gZmFpbHMoZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gISFzcGFjZXNbS0VZXSgpIHx8IG5vbltLRVldKCkgIT0gbm9uO1xuICB9KTtcbiAgdmFyIGZuID0gZXhwW0tFWV0gPSBGT1JDRSA/IGV4ZWModHJpbSkgOiBzcGFjZXNbS0VZXTtcbiAgaWYoQUxJQVMpZXhwW0FMSUFTXSA9IGZuO1xuICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIEZPUkNFLCAnU3RyaW5nJywgZXhwKTtcbn07XG5cbi8vIDEgLT4gU3RyaW5nI3RyaW1MZWZ0XG4vLyAyIC0+IFN0cmluZyN0cmltUmlnaHRcbi8vIDMgLT4gU3RyaW5nI3RyaW1cbnZhciB0cmltID0gZXhwb3J0ZXIudHJpbSA9IGZ1bmN0aW9uKHN0cmluZywgVFlQRSl7XG4gIHN0cmluZyA9IFN0cmluZyhkZWZpbmVkKHN0cmluZykpO1xuICBpZihUWVBFICYgMSlzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShsdHJpbSwgJycpO1xuICBpZihUWVBFICYgMilzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShydHJpbSwgJycpO1xuICByZXR1cm4gc3RyaW5nO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRlcjsiLCJtb2R1bGUuZXhwb3J0cyA9ICdcXHgwOVxceDBBXFx4MEJcXHgwQ1xceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwMycgK1xuICAnXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7IiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1heCAgICAgICA9IE1hdGgubWF4XG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpe1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTsiLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsICA9IE1hdGguY2VpbFxuICAsIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07IiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTsiLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTsiLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07IiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgUyl7XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZih0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07IiwidmFyIGlkID0gMFxuICAsIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07IiwidmFyIHN0b3JlICAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJylcbiAgLCB1aWQgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgLCBTeW1ib2wgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sXG4gICwgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjggQXJyYXkucHJvdG90eXBlLmZpbmQocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRmaW5kICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNSlcbiAgLCBLRVkgICAgID0gJ2ZpbmQnXG4gICwgZm9yY2VkICA9IHRydWU7XG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYoS0VZIGluIFtdKUFycmF5KDEpW0tFWV0oZnVuY3Rpb24oKXsgZm9yY2VkID0gZmFsc2U7IH0pO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZDogZnVuY3Rpb24gZmluZChjYWxsYmFja2ZuLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoS0VZKTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRmb3JFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApXG4gICwgU1RSSUNUICAgPSByZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uZm9yRWFjaCwgdHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIVNUUklDVCwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTAgLyAxNS40LjQuMTggQXJyYXkucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLyl7XG4gICAgcmV0dXJuICRmb3JFYWNoKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXktcmVkdWNlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5yZWR1Y2UsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xOCAvIDE1LjQuNC4yMSBBcnJheS5wcm90b3R5cGUucmVkdWNlKGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLyl7XG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzWzFdLCBmYWxzZSk7XG4gIH1cbn0pOyIsIi8vIDE5LjIuMy4yIC8gMTUuMy40LjUgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQodGhpc0FyZywgYXJncy4uLilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnRnVuY3Rpb24nLCB7YmluZDogcmVxdWlyZSgnLi9fYmluZCcpfSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoYXMgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgY29mICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jb2YnKVxuICAsIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpXG4gICwgdG9QcmltaXRpdmUgICAgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGZhaWxzICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGdPUE4gICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgZ09QRCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmZcbiAgLCBkUCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCAkdHJpbSAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbVxuICAsIE5VTUJFUiAgICAgICAgICAgID0gJ051bWJlcidcbiAgLCAkTnVtYmVyICAgICAgICAgICA9IGdsb2JhbFtOVU1CRVJdXG4gICwgQmFzZSAgICAgICAgICAgICAgPSAkTnVtYmVyXG4gICwgcHJvdG8gICAgICAgICAgICAgPSAkTnVtYmVyLnByb3RvdHlwZVxuICAvLyBPcGVyYSB+MTIgaGFzIGJyb2tlbiBPYmplY3QjdG9TdHJpbmdcbiAgLCBCUk9LRU5fQ09GICAgICAgICA9IGNvZihyZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJykocHJvdG8pKSA9PSBOVU1CRVJcbiAgLCBUUklNICAgICAgICAgICAgICA9ICd0cmltJyBpbiBTdHJpbmcucHJvdG90eXBlO1xuXG4vLyA3LjEuMyBUb051bWJlcihhcmd1bWVudClcbnZhciB0b051bWJlciA9IGZ1bmN0aW9uKGFyZ3VtZW50KXtcbiAgdmFyIGl0ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsIGZhbHNlKTtcbiAgaWYodHlwZW9mIGl0ID09ICdzdHJpbmcnICYmIGl0Lmxlbmd0aCA+IDIpe1xuICAgIGl0ID0gVFJJTSA/IGl0LnRyaW0oKSA6ICR0cmltKGl0LCAzKTtcbiAgICB2YXIgZmlyc3QgPSBpdC5jaGFyQ29kZUF0KDApXG4gICAgICAsIHRoaXJkLCByYWRpeCwgbWF4Q29kZTtcbiAgICBpZihmaXJzdCA9PT0gNDMgfHwgZmlyc3QgPT09IDQ1KXtcbiAgICAgIHRoaXJkID0gaXQuY2hhckNvZGVBdCgyKTtcbiAgICAgIGlmKHRoaXJkID09PSA4OCB8fCB0aGlyZCA9PT0gMTIwKXJldHVybiBOYU47IC8vIE51bWJlcignKzB4MScpIHNob3VsZCBiZSBOYU4sIG9sZCBWOCBmaXhcbiAgICB9IGVsc2UgaWYoZmlyc3QgPT09IDQ4KXtcbiAgICAgIHN3aXRjaChpdC5jaGFyQ29kZUF0KDEpKXtcbiAgICAgICAgY2FzZSA2NiA6IGNhc2UgOTggIDogcmFkaXggPSAyOyBtYXhDb2RlID0gNDk7IGJyZWFrOyAvLyBmYXN0IGVxdWFsIC9eMGJbMDFdKyQvaVxuICAgICAgICBjYXNlIDc5IDogY2FzZSAxMTEgOiByYWRpeCA9IDg7IG1heENvZGUgPSA1NTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgL14wb1swLTddKyQvaVxuICAgICAgICBkZWZhdWx0IDogcmV0dXJuICtpdDtcbiAgICAgIH1cbiAgICAgIGZvcih2YXIgZGlnaXRzID0gaXQuc2xpY2UoMiksIGkgPSAwLCBsID0gZGlnaXRzLmxlbmd0aCwgY29kZTsgaSA8IGw7IGkrKyl7XG4gICAgICAgIGNvZGUgPSBkaWdpdHMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgLy8gcGFyc2VJbnQgcGFyc2VzIGEgc3RyaW5nIHRvIGEgZmlyc3QgdW5hdmFpbGFibGUgc3ltYm9sXG4gICAgICAgIC8vIGJ1dCBUb051bWJlciBzaG91bGQgcmV0dXJuIE5hTiBpZiBhIHN0cmluZyBjb250YWlucyB1bmF2YWlsYWJsZSBzeW1ib2xzXG4gICAgICAgIGlmKGNvZGUgPCA0OCB8fCBjb2RlID4gbWF4Q29kZSlyZXR1cm4gTmFOO1xuICAgICAgfSByZXR1cm4gcGFyc2VJbnQoZGlnaXRzLCByYWRpeCk7XG4gICAgfVxuICB9IHJldHVybiAraXQ7XG59O1xuXG5pZighJE51bWJlcignIDBvMScpIHx8ICEkTnVtYmVyKCcwYjEnKSB8fCAkTnVtYmVyKCcrMHgxJykpe1xuICAkTnVtYmVyID0gZnVuY3Rpb24gTnVtYmVyKHZhbHVlKXtcbiAgICB2YXIgaXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMSA/IDAgOiB2YWx1ZVxuICAgICAgLCB0aGF0ID0gdGhpcztcbiAgICByZXR1cm4gdGhhdCBpbnN0YW5jZW9mICROdW1iZXJcbiAgICAgIC8vIGNoZWNrIG9uIDEuLmNvbnN0cnVjdG9yKGZvbykgY2FzZVxuICAgICAgJiYgKEJST0tFTl9DT0YgPyBmYWlscyhmdW5jdGlvbigpeyBwcm90by52YWx1ZU9mLmNhbGwodGhhdCk7IH0pIDogY29mKHRoYXQpICE9IE5VTUJFUilcbiAgICAgICAgPyBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSh0b051bWJlcihpdCkpLCB0aGF0LCAkTnVtYmVyKSA6IHRvTnVtYmVyKGl0KTtcbiAgfTtcbiAgZm9yKHZhciBrZXlzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUE4oQmFzZSkgOiAoXG4gICAgLy8gRVMzOlxuICAgICdNQVhfVkFMVUUsTUlOX1ZBTFVFLE5hTixORUdBVElWRV9JTkZJTklUWSxQT1NJVElWRV9JTkZJTklUWSwnICtcbiAgICAvLyBFUzYgKGluIGNhc2UsIGlmIG1vZHVsZXMgd2l0aCBFUzYgTnVtYmVyIHN0YXRpY3MgcmVxdWlyZWQgYmVmb3JlKTpcbiAgICAnRVBTSUxPTixpc0Zpbml0ZSxpc0ludGVnZXIsaXNOYU4saXNTYWZlSW50ZWdlcixNQVhfU0FGRV9JTlRFR0VSLCcgK1xuICAgICdNSU5fU0FGRV9JTlRFR0VSLHBhcnNlRmxvYXQscGFyc2VJbnQsaXNJbnRlZ2VyJ1xuICApLnNwbGl0KCcsJyksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajsgaisrKXtcbiAgICBpZihoYXMoQmFzZSwga2V5ID0ga2V5c1tqXSkgJiYgIWhhcygkTnVtYmVyLCBrZXkpKXtcbiAgICAgIGRQKCROdW1iZXIsIGtleSwgZ09QRChCYXNlLCBrZXkpKTtcbiAgICB9XG4gIH1cbiAgJE51bWJlci5wcm90b3R5cGUgPSBwcm90bztcbiAgcHJvdG8uY29uc3RydWN0b3IgPSAkTnVtYmVyO1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKGdsb2JhbCwgTlVNQkVSLCAkTnVtYmVyKTtcbn0iLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7YXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJyl9KTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7ZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZ9KTsiLCIvLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgJGtleXMgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2tleXMnLCBmdW5jdGlvbigpe1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCl7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbi8vIDwzIE1vZGVybml6clxuLy8gaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL01vZGVybml6ci9Nb2Rlcm5penIvbWFzdGVyL2ZlYXR1cmUtZGV0ZWN0cy9kb20vZGF0YXNldC5qc1xuXG5mdW5jdGlvbiB1c2VOYXRpdmUoKSB7XG5cdHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdGVsZW0uc2V0QXR0cmlidXRlKCdkYXRhLWEtYicsICdjJyk7XG5cblx0cmV0dXJuIEJvb2xlYW4oZWxlbS5kYXRhc2V0ICYmIGVsZW0uZGF0YXNldC5hQiA9PT0gJ2MnKTtcbn1cblxuZnVuY3Rpb24gbmF0aXZlRGF0YXNldChlbGVtZW50KSB7XG5cdHJldHVybiBlbGVtZW50LmRhdGFzZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdXNlTmF0aXZlKCkgPyBuYXRpdmVEYXRhc2V0IDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0dmFyIG1hcCA9IHt9O1xuXHR2YXIgYXR0cmlidXRlcyA9IGVsZW1lbnQuYXR0cmlidXRlcztcblxuXHRmdW5jdGlvbiBnZXR0ZXIoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWU7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXR0ZXIobmFtZSwgdmFsdWUpIHtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0dGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcblx0XHR9XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMCwgaiA9IGF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaV07XG5cblx0XHRpZiAoYXR0cmlidXRlKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGF0dHJpYnV0ZS5uYW1lO1xuXG5cdFx0XHRpZiAobmFtZS5pbmRleE9mKCdkYXRhLScpID09PSAwKSB7XG5cdFx0XHRcdHZhciBwcm9wID0gbmFtZS5zbGljZSg1KS5yZXBsYWNlKC8tLi9nLCBmdW5jdGlvbiAodSkge1xuXHRcdFx0XHRcdHJldHVybiB1LmNoYXJBdCgxKS50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHR2YXIgdmFsdWUgPSBhdHRyaWJ1dGUudmFsdWU7XG5cblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1hcCwgcHJvcCwge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Z2V0OiBnZXR0ZXIuYmluZCh7IHZhbHVlOiB2YWx1ZSB8fCAnJyB9KSxcblx0XHRcdFx0XHRzZXQ6IHNldHRlci5iaW5kKGVsZW1lbnQsIG5hbWUpXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBtYXA7XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBcnJheWlzaChvYmopIHtcblx0aWYgKCFvYmogfHwgdHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgQXJyYXkgfHwgQXJyYXkuaXNBcnJheShvYmopIHx8XG5cdFx0KG9iai5sZW5ndGggPj0gMCAmJiAob2JqLnNwbGljZSBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8XG5cdFx0XHQoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIChvYmoubGVuZ3RoIC0gMSkpICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9PSAnU3RyaW5nJykpKTtcbn07XG4iLCIvKiBlc2xpbnQgbm8tY29uc29sZTowICovXG4vKipcbiAqIFRoaXMgaXMgdGhlIG1haW4gZW50cnkgcG9pbnQgZm9yIEthVGVYLiBIZXJlLCB3ZSBleHBvc2UgZnVuY3Rpb25zIGZvclxuICogcmVuZGVyaW5nIGV4cHJlc3Npb25zIGVpdGhlciB0byBET00gbm9kZXMgb3IgdG8gbWFya3VwIHN0cmluZ3MuXG4gKlxuICogV2UgYWxzbyBleHBvc2UgdGhlIFBhcnNlRXJyb3IgY2xhc3MgdG8gY2hlY2sgaWYgZXJyb3JzIHRocm93biBmcm9tIEthVGVYIGFyZVxuICogZXJyb3JzIGluIHRoZSBleHByZXNzaW9uLCBvciBlcnJvcnMgaW4gamF2YXNjcmlwdCBoYW5kbGluZy5cbiAqL1xuXG52YXIgUGFyc2VFcnJvciA9IHJlcXVpcmUoXCIuL3NyYy9QYXJzZUVycm9yXCIpO1xudmFyIFNldHRpbmdzID0gcmVxdWlyZShcIi4vc3JjL1NldHRpbmdzXCIpO1xuXG52YXIgYnVpbGRUcmVlID0gcmVxdWlyZShcIi4vc3JjL2J1aWxkVHJlZVwiKTtcbnZhciBwYXJzZVRyZWUgPSByZXF1aXJlKFwiLi9zcmMvcGFyc2VUcmVlXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vc3JjL3V0aWxzXCIpO1xuXG4vKipcbiAqIFBhcnNlIGFuZCBidWlsZCBhbiBleHByZXNzaW9uLCBhbmQgcGxhY2UgdGhhdCBleHByZXNzaW9uIGluIHRoZSBET00gbm9kZVxuICogZ2l2ZW4uXG4gKi9cbnZhciByZW5kZXIgPSBmdW5jdGlvbihleHByZXNzaW9uLCBiYXNlTm9kZSwgb3B0aW9ucykge1xuICAgIHV0aWxzLmNsZWFyTm9kZShiYXNlTm9kZSk7XG5cbiAgICB2YXIgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3Mob3B0aW9ucyk7XG5cbiAgICB2YXIgdHJlZSA9IHBhcnNlVHJlZShleHByZXNzaW9uLCBzZXR0aW5ncyk7XG4gICAgdmFyIG5vZGUgPSBidWlsZFRyZWUodHJlZSwgZXhwcmVzc2lvbiwgc2V0dGluZ3MpLnRvTm9kZSgpO1xuXG4gICAgYmFzZU5vZGUuYXBwZW5kQ2hpbGQobm9kZSk7XG59O1xuXG4vLyBLYVRlWCdzIHN0eWxlcyBkb24ndCB3b3JrIHByb3Blcmx5IGluIHF1aXJrcyBtb2RlLiBQcmludCBvdXQgYW4gZXJyb3IsIGFuZFxuLy8gZGlzYWJsZSByZW5kZXJpbmcuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKGRvY3VtZW50LmNvbXBhdE1vZGUgIT09IFwiQ1NTMUNvbXBhdFwiKSB7XG4gICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIFwiV2FybmluZzogS2FUZVggZG9lc24ndCB3b3JrIGluIHF1aXJrcyBtb2RlLiBNYWtlIHN1cmUgeW91ciBcIiArXG4gICAgICAgICAgICAgICAgXCJ3ZWJzaXRlIGhhcyBhIHN1aXRhYmxlIGRvY3R5cGUuXCIpO1xuXG4gICAgICAgIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJLYVRlWCBkb2Vzbid0IHdvcmsgaW4gcXVpcmtzIG1vZGUuXCIpO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbmQgYnVpbGQgYW4gZXhwcmVzc2lvbiwgYW5kIHJldHVybiB0aGUgbWFya3VwIGZvciB0aGF0LlxuICovXG52YXIgcmVuZGVyVG9TdHJpbmcgPSBmdW5jdGlvbihleHByZXNzaW9uLCBvcHRpb25zKSB7XG4gICAgdmFyIHNldHRpbmdzID0gbmV3IFNldHRpbmdzKG9wdGlvbnMpO1xuXG4gICAgdmFyIHRyZWUgPSBwYXJzZVRyZWUoZXhwcmVzc2lvbiwgc2V0dGluZ3MpO1xuICAgIHJldHVybiBidWlsZFRyZWUodHJlZSwgZXhwcmVzc2lvbiwgc2V0dGluZ3MpLnRvTWFya3VwKCk7XG59O1xuXG4vKipcbiAqIFBhcnNlIGFuIGV4cHJlc3Npb24gYW5kIHJldHVybiB0aGUgcGFyc2UgdHJlZS5cbiAqL1xudmFyIGdlbmVyYXRlUGFyc2VUcmVlID0gZnVuY3Rpb24oZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICAgIHZhciBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncyhvcHRpb25zKTtcbiAgICByZXR1cm4gcGFyc2VUcmVlKGV4cHJlc3Npb24sIHNldHRpbmdzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHJlbmRlcjogcmVuZGVyLFxuICAgIHJlbmRlclRvU3RyaW5nOiByZW5kZXJUb1N0cmluZyxcbiAgICAvKipcbiAgICAgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBub3QgY3VycmVudGx5IHJlY29tbWVuZGVkIGZvciBwdWJsaWMgdXNlLlxuICAgICAqIFRoZSBpbnRlcm5hbCB0cmVlIHJlcHJlc2VudGF0aW9uIGlzIHVuc3RhYmxlIGFuZCBpcyB2ZXJ5IGxpa2VseVxuICAgICAqIHRvIGNoYW5nZS4gVXNlIGF0IHlvdXIgb3duIHJpc2suXG4gICAgICovXG4gICAgX19wYXJzZTogZ2VuZXJhdGVQYXJzZVRyZWUsXG4gICAgUGFyc2VFcnJvcjogUGFyc2VFcnJvclxufTtcbiIsIi8qKlxuICogVGhlIExleGVyIGNsYXNzIGhhbmRsZXMgdG9rZW5pemluZyB0aGUgaW5wdXQgaW4gdmFyaW91cyB3YXlzLiBTaW5jZSBvdXJcbiAqIHBhcnNlciBleHBlY3RzIHVzIHRvIGJlIGFibGUgdG8gYmFja3RyYWNrLCB0aGUgbGV4ZXIgYWxsb3dzIGxleGluZyBmcm9tIGFueVxuICogZ2l2ZW4gc3RhcnRpbmcgcG9pbnQuXG4gKlxuICogSXRzIG1haW4gZXhwb3NlZCBmdW5jdGlvbiBpcyB0aGUgYGxleGAgZnVuY3Rpb24sIHdoaWNoIHRha2VzIGEgcG9zaXRpb24gdG9cbiAqIGxleCBmcm9tIGFuZCBhIHR5cGUgb2YgdG9rZW4gdG8gbGV4LiBJdCBkZWZlcnMgdG8gdGhlIGFwcHJvcHJpYXRlIGBfaW5uZXJMZXhgXG4gKiBmdW5jdGlvbi5cbiAqXG4gKiBUaGUgdmFyaW91cyBgX2lubmVyTGV4YCBmdW5jdGlvbnMgcGVyZm9ybSB0aGUgYWN0dWFsIGxleGluZyBvZiBkaWZmZXJlbnRcbiAqIGtpbmRzLlxuICovXG5cbnZhciBtYXRjaEF0ID0gcmVxdWlyZShcIm1hdGNoLWF0XCIpO1xuXG52YXIgUGFyc2VFcnJvciA9IHJlcXVpcmUoXCIuL1BhcnNlRXJyb3JcIik7XG5cbi8vIFRoZSBtYWluIGxleGVyIGNsYXNzXG5mdW5jdGlvbiBMZXhlcihpbnB1dCkge1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICB0aGlzLnBvcyA9IDA7XG59XG5cbi8qKlxuICogVGhlIHJlc3VsdGluZyB0b2tlbiByZXR1cm5lZCBmcm9tIGBsZXhgLlxuICpcbiAqIEl0IGNvbnNpc3RzIG9mIHRoZSB0b2tlbiB0ZXh0IHBsdXMgc29tZSBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAqIFRoZSBwb3NpdGlvbiBpbmZvcm1hdGlvbiBpcyBlc3NlbnRpYWxseSBhIHJhbmdlIGluIGFuIGlucHV0IHN0cmluZyxcbiAqIGJ1dCBpbnN0ZWFkIG9mIHJlZmVyZW5jaW5nIHRoZSBiYXJlIGlucHV0IHN0cmluZywgd2UgcmVmZXIgdG8gdGhlIGxleGVyLlxuICogVGhhdCB3YXkgaXQgaXMgcG9zc2libGUgdG8gYXR0YWNoIGV4dHJhIG1ldGFkYXRhIHRvIHRoZSBpbnB1dCBzdHJpbmcsXG4gKiBsaWtlIGZvciBleGFtcGxlIGEgZmlsZSBuYW1lIG9yIHNpbWlsYXIuXG4gKlxuICogVGhlIHBvc2l0aW9uIGluZm9ybWF0aW9uIChhbGwgdGhyZWUgcGFyYW1ldGVycykgaXMgb3B0aW9uYWwsXG4gKiBzbyBpdCBpcyBPSyB0byBjb25zdHJ1Y3Qgc3ludGhldGljIHRva2VucyBpZiBhcHByb3ByaWF0ZS5cbiAqIE5vdCBwcm92aWRpbmcgYXZhaWxhYmxlIHBvc2l0aW9uIGluZm9ybWF0aW9uIG1heSBsZWFkIHRvXG4gKiBkZWdyYWRlZCBlcnJvciByZXBvcnRpbmcsIHRob3VnaC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gIHRleHQgICB0aGUgdGV4dCBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0ge251bWJlcj19IHN0YXJ0ICB0aGUgc3RhcnQgb2Zmc2V0LCB6ZXJvLWJhc2VkIGluY2x1c2l2ZVxuICogQHBhcmFtIHtudW1iZXI9fSBlbmQgICAgdGhlIGVuZCBvZmZzZXQsIHplcm8tYmFzZWQgZXhjbHVzaXZlXG4gKiBAcGFyYW0ge0xleGVyPX0gIGxleGVyICB0aGUgbGV4ZXIgd2hpY2ggaW4gdHVybiBob2xkcyB0aGUgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIFRva2VuKHRleHQsIHN0YXJ0LCBlbmQsIGxleGVyKSB7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgdGhpcy5sZXhlciA9IGxleGVyO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgcGFpciBvZiB0b2tlbnMgKHRoaXMgYW5kIGVuZFRva2VuKSwgY29tcHV0ZSBhIOKAnFRva2Vu4oCdIGVuY29tcGFzc2luZ1xuICogdGhlIHdob2xlIGlucHV0IHJhbmdlIGVuY2xvc2VkIGJ5IHRoZXNlIHR3by5cbiAqXG4gKiBAcGFyYW0ge1Rva2VufSAgZW5kVG9rZW4gIGxhc3QgdG9rZW4gb2YgdGhlIHJhbmdlLCBpbmNsdXNpdmVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0ICAgICAgdGhlIHRleHQgb2YgdGhlIG5ld2x5IGNvbnN0cnVjdGVkIHRva2VuXG4gKi9cblRva2VuLnByb3RvdHlwZS5yYW5nZSA9IGZ1bmN0aW9uKGVuZFRva2VuLCB0ZXh0KSB7XG4gICAgaWYgKGVuZFRva2VuLmxleGVyICE9PSB0aGlzLmxleGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgVG9rZW4odGV4dCk7IC8vIHNvcnJ5LCBubyBwb3NpdGlvbiBpbmZvcm1hdGlvbiBhdmFpbGFibGVcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUb2tlbih0ZXh0LCB0aGlzLnN0YXJ0LCBlbmRUb2tlbi5lbmQsIHRoaXMubGV4ZXIpO1xufTtcblxuLyogVGhlIGZvbGxvd2luZyB0b2tlblJlZ2V4XG4gKiAtIG1hdGNoZXMgdHlwaWNhbCB3aGl0ZXNwYWNlIChidXQgbm90IE5CU1AgZXRjLikgdXNpbmcgaXRzIGZpcnN0IGdyb3VwXG4gKiAtIGRvZXMgbm90IG1hdGNoIGFueSBjb250cm9sIGNoYXJhY3RlciBcXHgwMC1cXHgxZiBleGNlcHQgd2hpdGVzcGFjZVxuICogLSBkb2VzIG5vdCBtYXRjaCBhIGJhcmUgYmFja3NsYXNoXG4gKiAtIG1hdGNoZXMgYW55IEFTQ0lJIGNoYXJhY3RlciBleGNlcHQgdGhvc2UganVzdCBtZW50aW9uZWRcbiAqIC0gZG9lcyBub3QgbWF0Y2ggdGhlIEJNUCBwcml2YXRlIHVzZSBhcmVhIFxcdUUwMDAtXFx1RjhGRlxuICogLSBkb2VzIG5vdCBtYXRjaCBiYXJlIHN1cnJvZ2F0ZSBjb2RlIHVuaXRzXG4gKiAtIG1hdGNoZXMgYW55IEJNUCBjaGFyYWN0ZXIgZXhjZXB0IGZvciB0aG9zZSBqdXN0IGRlc2NyaWJlZFxuICogLSBtYXRjaGVzIGFueSB2YWxpZCBVbmljb2RlIHN1cnJvZ2F0ZSBwYWlyXG4gKiAtIG1hdGNoZXMgYSBiYWNrc2xhc2ggZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgbGV0dGVyc1xuICogLSBtYXRjaGVzIGEgYmFja3NsYXNoIGZvbGxvd2VkIGJ5IGFueSBCTVAgY2hhcmFjdGVyLCBpbmNsdWRpbmcgbmV3bGluZVxuICogSnVzdCBiZWNhdXNlIHRoZSBMZXhlciBtYXRjaGVzIHNvbWV0aGluZyBkb2Vzbid0IG1lYW4gaXQncyB2YWxpZCBpbnB1dDpcbiAqIElmIHRoZXJlIGlzIG5vIG1hdGNoaW5nIGZ1bmN0aW9uIG9yIHN5bWJvbCBkZWZpbml0aW9uLCB0aGUgUGFyc2VyIHdpbGxcbiAqIHN0aWxsIHJlamVjdCB0aGUgaW5wdXQuXG4gKi9cbnZhciB0b2tlblJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICBcIihbIFxcclxcblxcdF0rKXxcIiArICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpdGVzcGFjZVxuICAgIFwiKFshLVxcXFxbXFxcXF0tXFx1MjAyN1xcdTIwMkEtXFx1RDdGRlxcdUY5MDAtXFx1RkZGRl1cIiArICAvLyBzaW5nbGUgY29kZXBvaW50XG4gICAgXCJ8W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXVwiICsgICAgICAgICAgICAgICAvLyBzdXJyb2dhdGUgcGFpclxuICAgIFwifFxcXFxcXFxcKD86W2EtekEtWl0rfFteXFx1RDgwMC1cXHVERkZGXSlcIiArICAgICAgICAgICAvLyBmdW5jdGlvbiBuYW1lXG4gICAgXCIpXCJcbik7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBsZXhlcyBhIHNpbmdsZSB0b2tlbi5cbiAqL1xuTGV4ZXIucHJvdG90eXBlLmxleCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXQ7XG4gICAgdmFyIHBvcyA9IHRoaXMucG9zO1xuICAgIGlmIChwb3MgPT09IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IFRva2VuKFwiRU9GXCIsIHBvcywgcG9zLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIG1hdGNoID0gbWF0Y2hBdCh0b2tlblJlZ2V4LCBpbnB1dCwgcG9zKTtcbiAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgICAgICBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyOiAnXCIgKyBpbnB1dFtwb3NdICsgXCInXCIsXG4gICAgICAgICAgICBuZXcgVG9rZW4oaW5wdXRbcG9zXSwgcG9zLCBwb3MgKyAxLCB0aGlzKSk7XG4gICAgfVxuICAgIHZhciB0ZXh0ID0gbWF0Y2hbMl0gfHwgXCIgXCI7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgdGhpcy5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIHZhciBlbmQgPSB0aGlzLnBvcztcbiAgICByZXR1cm4gbmV3IFRva2VuKHRleHQsIHN0YXJ0LCBlbmQsIHRoaXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMZXhlcjtcbiIsIi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSDigJxndWxsZXTigJ0gd2hlcmUgbWFjcm9zIGFyZSBleHBhbmRlZFxuICogdW50aWwgb25seSBub24tbWFjcm8gdG9rZW5zIHJlbWFpbi5cbiAqL1xuXG52YXIgTGV4ZXIgPSByZXF1aXJlKFwiLi9MZXhlclwiKTtcblxuZnVuY3Rpb24gTWFjcm9FeHBhbmRlcihpbnB1dCwgbWFjcm9zKSB7XG4gICAgdGhpcy5sZXhlciA9IG5ldyBMZXhlcihpbnB1dCk7XG4gICAgdGhpcy5tYWNyb3MgPSBtYWNyb3M7XG4gICAgdGhpcy5zdGFjayA9IFtdOyAvLyBjb250YWlucyB0b2tlbnMgaW4gUkVWRVJTRSBvcmRlclxuICAgIHRoaXMuZGlzY2FyZGVkV2hpdGVTcGFjZSA9IFtdO1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGV4cGFuZCBmaXJzdCB0b2tlbiwgdGhlbiByZXR1cm4gZmlyc3Qgbm9uLWV4cGFuZGFibGUgdG9rZW4uXG4gKi9cbk1hY3JvRXhwYW5kZXIucHJvdG90eXBlLm5leHRUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5sZXhlci5sZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvcFRva2VuID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIG5hbWUgPSB0b3BUb2tlbi50ZXh0O1xuICAgICAgICBpZiAoIShuYW1lLmNoYXJBdCgwKSA9PT0gXCJcXFxcXCIgJiYgdGhpcy5tYWNyb3MuaGFzT3duUHJvcGVydHkobmFtZSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9wVG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV4cGFuc2lvbiA9IHRoaXMubWFjcm9zW25hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIGV4cGFuc2lvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdmFyIGJvZHlMZXhlciA9IG5ldyBMZXhlcihleHBhbnNpb24pO1xuICAgICAgICAgICAgZXhwYW5zaW9uID0gW107XG4gICAgICAgICAgICB2YXIgdG9rID0gYm9keUxleGVyLmxleCgpO1xuICAgICAgICAgICAgd2hpbGUgKHRvay50ZXh0ICE9PSBcIkVPRlwiKSB7XG4gICAgICAgICAgICAgICAgZXhwYW5zaW9uLnB1c2godG9rKTtcbiAgICAgICAgICAgICAgICB0b2sgPSBib2R5TGV4ZXIubGV4KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBhbnNpb24ucmV2ZXJzZSgpOyAvLyB0byBmaXQgaW4gd2l0aCBzdGFjayB1c2luZyBwdXNoIGFuZCBwb3BcbiAgICAgICAgICAgIHRoaXMubWFjcm9zW25hbWVdID0gZXhwYW5zaW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhY2sgPSB0aGlzLnN0YWNrLmNvbmNhdChleHBhbnNpb24pO1xuICAgIH1cbn07XG5cbk1hY3JvRXhwYW5kZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGlnbm9yZVNwYWNlKSB7XG4gICAgdGhpcy5kaXNjYXJkZWRXaGl0ZVNwYWNlID0gW107XG4gICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcbiAgICBpZiAoaWdub3JlU3BhY2UpIHtcbiAgICAgICAgd2hpbGUgKHRva2VuLnRleHQgPT09IFwiIFwiKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2NhcmRlZFdoaXRlU3BhY2UucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRva2VuO1xufTtcblxuLyoqXG4gKiBVbmRvIHRoZSBlZmZlY3Qgb2YgdGhlIHByZWNlZGluZyBjYWxsIHRvIHRoZSBnZXQgbWV0aG9kLlxuICogQSBjYWxsIHRvIHRoaXMgbWV0aG9kIE1VU1QgYmUgaW1tZWRpYXRlbHkgcHJlY2VkZWQgYW5kIGltbWVkaWF0ZWx5IGZvbGxvd2VkXG4gKiBieSBhIGNhbGwgdG8gZ2V0LiAgT25seSB1c2VkIGR1cmluZyBtb2RlIHN3aXRjaGluZywgaS5lLiBhZnRlciBvbmUgdG9rZW5cbiAqIHdhcyBnb3QgaW4gdGhlIG9sZCBtb2RlIGJ1dCBzaG91bGQgZ2V0IGdvdCBhZ2FpbiBpbiBhIG5ldyBtb2RlXG4gKiB3aXRoIHBvc3NpYmx5IGRpZmZlcmVudCB3aGl0ZXNwYWNlIGhhbmRsaW5nLlxuICovXG5NYWNyb0V4cGFuZGVyLnByb3RvdHlwZS51bmdldCA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgdGhpcy5zdGFjay5wdXNoKHRva2VuKTtcbiAgICB3aGlsZSAodGhpcy5kaXNjYXJkZWRXaGl0ZVNwYWNlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5kaXNjYXJkZWRXaGl0ZVNwYWNlLnBvcCgpKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hY3JvRXhwYW5kZXI7XG4iLCIvKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3B0aW9ucyB0aGF0IHRoZSBQYXJzZXIgY2Fycmllc1xuICogYXJvdW5kIHdpdGggaXQgd2hpbGUgcGFyc2luZy4gRGF0YSBpcyBoZWxkIGluIGFuIGBPcHRpb25zYCBvYmplY3QsIGFuZCB3aGVuXG4gKiByZWN1cnNpbmcsIGEgbmV3IGBPcHRpb25zYCBvYmplY3QgY2FuIGJlIGNyZWF0ZWQgd2l0aCB0aGUgYC53aXRoKmAgYW5kXG4gKiBgLnJlc2V0YCBmdW5jdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBtYWluIG9wdGlvbnMgY2xhc3MuIEl0IGNvbnRhaW5zIHRoZSBzdHlsZSwgc2l6ZSwgY29sb3IsIGFuZCBmb250XG4gKiBvZiB0aGUgY3VycmVudCBwYXJzZSBsZXZlbC4gSXQgYWxzbyBjb250YWlucyB0aGUgc3R5bGUgYW5kIHNpemUgb2YgdGhlIHBhcmVudFxuICogcGFyc2UgbGV2ZWwsIHNvIHNpemUgY2hhbmdlcyBjYW4gYmUgaGFuZGxlZCBlZmZpY2llbnRseS5cbiAqXG4gKiBFYWNoIG9mIHRoZSBgLndpdGgqYCBhbmQgYC5yZXNldGAgZnVuY3Rpb25zIHBhc3NlcyBpdHMgY3VycmVudCBzdHlsZSBhbmQgc2l6ZVxuICogYXMgdGhlIHBhcmVudFN0eWxlIGFuZCBwYXJlbnRTaXplIG9mIHRoZSBuZXcgb3B0aW9ucyBjbGFzcywgc28gcGFyZW50XG4gKiBoYW5kbGluZyBpcyB0YWtlbiBjYXJlIG9mIGF1dG9tYXRpY2FsbHkuXG4gKi9cbmZ1bmN0aW9uIE9wdGlvbnMoZGF0YSkge1xuICAgIHRoaXMuc3R5bGUgPSBkYXRhLnN0eWxlO1xuICAgIHRoaXMuY29sb3IgPSBkYXRhLmNvbG9yO1xuICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICB0aGlzLnBoYW50b20gPSBkYXRhLnBoYW50b207XG4gICAgdGhpcy5mb250ID0gZGF0YS5mb250O1xuXG4gICAgaWYgKGRhdGEucGFyZW50U3R5bGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnBhcmVudFN0eWxlID0gZGF0YS5zdHlsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcmVudFN0eWxlID0gZGF0YS5wYXJlbnRTdHlsZTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5wYXJlbnRTaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnRTaXplID0gZGF0YS5zaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyZW50U2l6ZSA9IGRhdGEucGFyZW50U2l6ZTtcbiAgICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBvcHRpb25zIG9iamVjdCB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgYXMgXCJ0aGlzXCIuICBQcm9wZXJ0aWVzXG4gKiBmcm9tIFwiZXh0ZW5zaW9uXCIgd2lsbCBiZSBjb3BpZWQgdG8gdGhlIG5ldyBvcHRpb25zIG9iamVjdC5cbiAqL1xuT3B0aW9ucy5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24oZXh0ZW5zaW9uKSB7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICAgIHN0eWxlOiB0aGlzLnN0eWxlLFxuICAgICAgICBzaXplOiB0aGlzLnNpemUsXG4gICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICBwYXJlbnRTdHlsZTogdGhpcy5zdHlsZSxcbiAgICAgICAgcGFyZW50U2l6ZTogdGhpcy5zaXplLFxuICAgICAgICBwaGFudG9tOiB0aGlzLnBoYW50b20sXG4gICAgICAgIGZvbnQ6IHRoaXMuZm9udFxuICAgIH07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gZXh0ZW5zaW9uKSB7XG4gICAgICAgIGlmIChleHRlbnNpb24uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgZGF0YVtrZXldID0gZXh0ZW5zaW9uW2tleV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE9wdGlvbnMoZGF0YSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBvcHRpb25zIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBzdHlsZS5cbiAqL1xuT3B0aW9ucy5wcm90b3R5cGUud2l0aFN0eWxlID0gZnVuY3Rpb24oc3R5bGUpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgICBzdHlsZTogc3R5bGVcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG9wdGlvbnMgb2JqZWN0IHdpdGggdGhlIGdpdmVuIHNpemUuXG4gKi9cbk9wdGlvbnMucHJvdG90eXBlLndpdGhTaXplID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICAgIHNpemU6IHNpemVcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG9wdGlvbnMgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGNvbG9yLlxuICovXG5PcHRpb25zLnByb3RvdHlwZS53aXRoQ29sb3IgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICAgIGNvbG9yOiBjb2xvclxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgb3B0aW9ucyBvYmplY3Qgd2l0aCBcInBoYW50b21cIiBzZXQgdG8gdHJ1ZS5cbiAqL1xuT3B0aW9ucy5wcm90b3R5cGUud2l0aFBoYW50b20gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgICBwaGFudG9tOiB0cnVlXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBvcHRpb25zIG9iamVjdHMgd2l0aCB0aGUgZ2l2ZSBmb250LlxuICovXG5PcHRpb25zLnByb3RvdHlwZS53aXRoRm9udCA9IGZ1bmN0aW9uKGZvbnQpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgICBmb250OiBmb250IHx8IHRoaXMuZm9udFxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgb3B0aW9ucyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzdHlsZSwgc2l6ZSwgYW5kIGNvbG9yLiBUaGlzIGlzXG4gKiB1c2VkIHNvIHRoYXQgcGFyZW50IHN0eWxlIGFuZCBzaXplIGNoYW5nZXMgYXJlIGhhbmRsZWQgY29ycmVjdGx5LlxuICovXG5PcHRpb25zLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7fSk7XG59O1xuXG4vKipcbiAqIEEgbWFwIG9mIGNvbG9yIG5hbWVzIHRvIENTUyBjb2xvcnMuXG4gKiBUT0RPKGVtaWx5KTogUmVtb3ZlIHRoaXMgd2hlbiB3ZSBoYXZlIHJlYWwgbWFjcm9zXG4gKi9cbnZhciBjb2xvck1hcCA9IHtcbiAgICBcImthdGV4LWJsdWVcIjogXCIjNjQ5NWVkXCIsXG4gICAgXCJrYXRleC1vcmFuZ2VcIjogXCIjZmZhNTAwXCIsXG4gICAgXCJrYXRleC1waW5rXCI6IFwiI2ZmMDBhZlwiLFxuICAgIFwia2F0ZXgtcmVkXCI6IFwiI2RmMDAzMFwiLFxuICAgIFwia2F0ZXgtZ3JlZW5cIjogXCIjMjhhZTdiXCIsXG4gICAgXCJrYXRleC1ncmF5XCI6IFwiZ3JheVwiLFxuICAgIFwia2F0ZXgtcHVycGxlXCI6IFwiIzlkMzhiZFwiLFxuICAgIFwia2F0ZXgtYmx1ZUFcIjogXCIjY2NmYWZmXCIsXG4gICAgXCJrYXRleC1ibHVlQlwiOiBcIiM4MGY2ZmZcIixcbiAgICBcImthdGV4LWJsdWVDXCI6IFwiIzYzZDllYVwiLFxuICAgIFwia2F0ZXgtYmx1ZURcIjogXCIjMTFhY2NkXCIsXG4gICAgXCJrYXRleC1ibHVlRVwiOiBcIiMwYzdmOTlcIixcbiAgICBcImthdGV4LXRlYWxBXCI6IFwiIzk0ZmZmNVwiLFxuICAgIFwia2F0ZXgtdGVhbEJcIjogXCIjMjZlZGQ1XCIsXG4gICAgXCJrYXRleC10ZWFsQ1wiOiBcIiMwMWQxYzFcIixcbiAgICBcImthdGV4LXRlYWxEXCI6IFwiIzAxYTk5NVwiLFxuICAgIFwia2F0ZXgtdGVhbEVcIjogXCIjMjA4MTcwXCIsXG4gICAgXCJrYXRleC1ncmVlbkFcIjogXCIjYjZmZmIwXCIsXG4gICAgXCJrYXRleC1ncmVlbkJcIjogXCIjOGFmMjgxXCIsXG4gICAgXCJrYXRleC1ncmVlbkNcIjogXCIjNzRjZjcwXCIsXG4gICAgXCJrYXRleC1ncmVlbkRcIjogXCIjMWZhYjU0XCIsXG4gICAgXCJrYXRleC1ncmVlbkVcIjogXCIjMGQ5MjNmXCIsXG4gICAgXCJrYXRleC1nb2xkQVwiOiBcIiNmZmQwYTlcIixcbiAgICBcImthdGV4LWdvbGRCXCI6IFwiI2ZmYmI3MVwiLFxuICAgIFwia2F0ZXgtZ29sZENcIjogXCIjZmY5YzM5XCIsXG4gICAgXCJrYXRleC1nb2xkRFwiOiBcIiNlMDdkMTBcIixcbiAgICBcImthdGV4LWdvbGRFXCI6IFwiI2E3NWEwNVwiLFxuICAgIFwia2F0ZXgtcmVkQVwiOiBcIiNmY2E5YTlcIixcbiAgICBcImthdGV4LXJlZEJcIjogXCIjZmY4NDgyXCIsXG4gICAgXCJrYXRleC1yZWRDXCI6IFwiI2Y5Njg1ZFwiLFxuICAgIFwia2F0ZXgtcmVkRFwiOiBcIiNlODRkMzlcIixcbiAgICBcImthdGV4LXJlZEVcIjogXCIjYmMyNjEyXCIsXG4gICAgXCJrYXRleC1tYXJvb25BXCI6IFwiI2ZmYmRlMFwiLFxuICAgIFwia2F0ZXgtbWFyb29uQlwiOiBcIiNmZjkyYzZcIixcbiAgICBcImthdGV4LW1hcm9vbkNcIjogXCIjZWQ1ZmE2XCIsXG4gICAgXCJrYXRleC1tYXJvb25EXCI6IFwiI2NhMzM3Y1wiLFxuICAgIFwia2F0ZXgtbWFyb29uRVwiOiBcIiM5ZTAzNGVcIixcbiAgICBcImthdGV4LXB1cnBsZUFcIjogXCIjZGRkN2ZmXCIsXG4gICAgXCJrYXRleC1wdXJwbGVCXCI6IFwiI2M2YjlmY1wiLFxuICAgIFwia2F0ZXgtcHVycGxlQ1wiOiBcIiNhYTg3ZmZcIixcbiAgICBcImthdGV4LXB1cnBsZURcIjogXCIjNzg1NGFiXCIsXG4gICAgXCJrYXRleC1wdXJwbGVFXCI6IFwiIzU0M2I3OFwiLFxuICAgIFwia2F0ZXgtbWludEFcIjogXCIjZjVmOWU4XCIsXG4gICAgXCJrYXRleC1taW50QlwiOiBcIiNlZGYyZGZcIixcbiAgICBcImthdGV4LW1pbnRDXCI6IFwiI2UwZTVjY1wiLFxuICAgIFwia2F0ZXgtZ3JheUFcIjogXCIjZjZmN2Y3XCIsXG4gICAgXCJrYXRleC1ncmF5QlwiOiBcIiNmMGYxZjJcIixcbiAgICBcImthdGV4LWdyYXlDXCI6IFwiI2UzZTVlNlwiLFxuICAgIFwia2F0ZXgtZ3JheURcIjogXCIjZDZkOGRhXCIsXG4gICAgXCJrYXRleC1ncmF5RVwiOiBcIiNiYWJlYzJcIixcbiAgICBcImthdGV4LWdyYXlGXCI6IFwiIzg4OGQ5M1wiLFxuICAgIFwia2F0ZXgtZ3JheUdcIjogXCIjNjI2NTY5XCIsXG4gICAgXCJrYXRleC1ncmF5SFwiOiBcIiMzYjNlNDBcIixcbiAgICBcImthdGV4LWdyYXlJXCI6IFwiIzIxMjQyY1wiLFxuICAgIFwia2F0ZXgta2FCbHVlXCI6IFwiIzMxNDQ1M1wiLFxuICAgIFwia2F0ZXgta2FHcmVlblwiOiBcIiM3MUIzMDdcIlxufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBDU1MgY29sb3Igb2YgdGhlIGN1cnJlbnQgb3B0aW9ucyBvYmplY3QsIGFjY291bnRpbmcgZm9yIHRoZVxuICogYGNvbG9yTWFwYC5cbiAqL1xuT3B0aW9ucy5wcm90b3R5cGUuZ2V0Q29sb3IgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5waGFudG9tKSB7XG4gICAgICAgIHJldHVybiBcInRyYW5zcGFyZW50XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yTWFwW3RoaXMuY29sb3JdIHx8IHRoaXMuY29sb3I7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPcHRpb25zO1xuIiwiLyoqXG4gKiBUaGlzIGlzIHRoZSBQYXJzZUVycm9yIGNsYXNzLCB3aGljaCBpcyB0aGUgbWFpbiBlcnJvciB0aHJvd24gYnkgS2FUZVhcbiAqIGZ1bmN0aW9ucyB3aGVuIHNvbWV0aGluZyBoYXMgZ29uZSB3cm9uZy4gVGhpcyBpcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIGludGVybmFsXG4gKiBlcnJvcnMgZnJvbSBlcnJvcnMgaW4gdGhlIGV4cHJlc3Npb24gdGhhdCB0aGUgdXNlciBwcm92aWRlZC5cbiAqXG4gKiBJZiBwb3NzaWJsZSwgYSBjYWxsZXIgc2hvdWxkIHByb3ZpZGUgYSBUb2tlbiBvciBQYXJzZU5vZGUgd2l0aCBpbmZvcm1hdGlvblxuICogYWJvdXQgd2hlcmUgaW4gdGhlIHNvdXJjZSBzdHJpbmcgdGhlIHByb2JsZW0gb2NjdXJyZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgIFRoZSBlcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0geyhUb2tlbnxQYXJzZU5vZGUpPX0gdG9rZW4gIEFuIG9iamVjdCBwcm92aWRpbmcgcG9zaXRpb24gaW5mb3JtYXRpb25cbiAqL1xuZnVuY3Rpb24gUGFyc2VFcnJvcihtZXNzYWdlLCB0b2tlbikge1xuICAgIHZhciBlcnJvciA9IFwiS2FUZVggcGFyc2UgZXJyb3I6IFwiICsgbWVzc2FnZTtcbiAgICB2YXIgc3RhcnQ7XG4gICAgdmFyIGVuZDtcblxuICAgIGlmICh0b2tlbiAmJiB0b2tlbi5sZXhlciAmJiB0b2tlbi5zdGFydCA8PSB0b2tlbi5lbmQpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSB0aGUgaW5wdXQgYW5kIGEgcG9zaXRpb24sIG1ha2UgdGhlIGVycm9yIGEgYml0IGZhbmNpZXJcblxuICAgICAgICAvLyBHZXQgdGhlIGlucHV0XG4gICAgICAgIHZhciBpbnB1dCA9IHRva2VuLmxleGVyLmlucHV0O1xuXG4gICAgICAgIC8vIFByZXBlbmQgc29tZSBpbmZvcm1hdGlvblxuICAgICAgICBzdGFydCA9IHRva2VuLnN0YXJ0O1xuICAgICAgICBlbmQgPSB0b2tlbi5lbmQ7XG4gICAgICAgIGlmIChzdGFydCA9PT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICBlcnJvciArPSBcIiBhdCBlbmQgb2YgaW5wdXQ6IFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IgKz0gXCIgYXQgcG9zaXRpb24gXCIgKyAoc3RhcnQgKyAxKSArIFwiOiBcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVuZGVybGluZSB0b2tlbiBpbiBxdWVzdGlvbiB1c2luZyBjb21iaW5pbmcgdW5kZXJzY29yZXNcbiAgICAgICAgdmFyIHVuZGVybGluZWQgPSBpbnB1dC5zbGljZShzdGFydCwgZW5kKS5yZXBsYWNlKC9bXl0vZywgXCIkJlxcdTAzMzJcIik7XG5cbiAgICAgICAgLy8gRXh0cmFjdCBzb21lIGNvbnRleHQgZnJvbSB0aGUgaW5wdXQgYW5kIGFkZCBpdCB0byB0aGUgZXJyb3JcbiAgICAgICAgdmFyIGxlZnQ7XG4gICAgICAgIGlmIChzdGFydCA+IDE1KSB7XG4gICAgICAgICAgICBsZWZ0ID0gXCLigKZcIiArIGlucHV0LnNsaWNlKHN0YXJ0IC0gMTUsIHN0YXJ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlZnQgPSBpbnB1dC5zbGljZSgwLCBzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJpZ2h0O1xuICAgICAgICBpZiAoZW5kICsgMTUgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJpZ2h0ID0gaW5wdXQuc2xpY2UoZW5kLCBlbmQgKyAxNSkgKyBcIuKAplwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmlnaHQgPSBpbnB1dC5zbGljZShlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yICs9IGxlZnQgKyB1bmRlcmxpbmVkICsgcmlnaHQ7XG4gICAgfVxuXG4gICAgLy8gU29tZSBoYWNrZXJ5IHRvIG1ha2UgUGFyc2VFcnJvciBhIHByb3RvdHlwZSBvZiBFcnJvclxuICAgIC8vIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84NDYwNzUzXG4gICAgdmFyIHNlbGYgPSBuZXcgRXJyb3IoZXJyb3IpO1xuICAgIHNlbGYubmFtZSA9IFwiUGFyc2VFcnJvclwiO1xuICAgIHNlbGYuX19wcm90b19fID0gUGFyc2VFcnJvci5wcm90b3R5cGU7XG5cbiAgICBzZWxmLnBvc2l0aW9uID0gc3RhcnQ7XG4gICAgcmV0dXJuIHNlbGY7XG59XG5cbi8vIE1vcmUgaGFja2VyeVxuUGFyc2VFcnJvci5wcm90b3R5cGUuX19wcm90b19fID0gRXJyb3IucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlRXJyb3I7XG4iLCIvKiBlc2xpbnQgbm8tY29uc3RhbnQtY29uZGl0aW9uOjAgKi9cbnZhciBmdW5jdGlvbnMgPSByZXF1aXJlKFwiLi9mdW5jdGlvbnNcIik7XG52YXIgZW52aXJvbm1lbnRzID0gcmVxdWlyZShcIi4vZW52aXJvbm1lbnRzXCIpO1xudmFyIE1hY3JvRXhwYW5kZXIgPSByZXF1aXJlKFwiLi9NYWNyb0V4cGFuZGVyXCIpO1xudmFyIHN5bWJvbHMgPSByZXF1aXJlKFwiLi9zeW1ib2xzXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgY2prUmVnZXggPSByZXF1aXJlKFwiLi91bmljb2RlUmVnZXhlc1wiKS5jamtSZWdleDtcblxudmFyIHBhcnNlRGF0YSA9IHJlcXVpcmUoXCIuL3BhcnNlRGF0YVwiKTtcbnZhciBQYXJzZUVycm9yID0gcmVxdWlyZShcIi4vUGFyc2VFcnJvclwiKTtcblxuLyoqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlIHBhcnNlciB1c2VkIHRvIHBhcnNlIG91dCBhIFRlWCBleHByZXNzaW9uIGZyb20gdGhlXG4gKiBpbnB1dC4gU2luY2UgVGVYIGlzbid0IGNvbnRleHQtZnJlZSwgc3RhbmRhcmQgcGFyc2VycyBkb24ndCB3b3JrIHBhcnRpY3VsYXJseVxuICogd2VsbC5cbiAqXG4gKiBUaGUgc3RyYXRlZ3kgb2YgdGhpcyBwYXJzZXIgaXMgYXMgc3VjaDpcbiAqXG4gKiBUaGUgbWFpbiBmdW5jdGlvbnMgKHRoZSBgLnBhcnNlLi4uYCBvbmVzKSB0YWtlIGEgcG9zaXRpb24gaW4gdGhlIGN1cnJlbnRcbiAqIHBhcnNlIHN0cmluZyB0byBwYXJzZSB0b2tlbnMgZnJvbS4gVGhlIGxleGVyIChmb3VuZCBpbiBMZXhlci5qcywgc3RvcmVkIGF0XG4gKiB0aGlzLmxleGVyKSBhbHNvIHN1cHBvcnRzIHB1bGxpbmcgb3V0IHRva2VucyBhdCBhcmJpdHJhcnkgcGxhY2VzLiBXaGVuXG4gKiBpbmRpdmlkdWFsIHRva2VucyBhcmUgbmVlZGVkIGF0IGEgcG9zaXRpb24sIHRoZSBsZXhlciBpcyBjYWxsZWQgdG8gcHVsbCBvdXQgYVxuICogdG9rZW4sIHdoaWNoIGlzIHRoZW4gdXNlZC5cbiAqXG4gKiBUaGUgcGFyc2VyIGhhcyBhIHByb3BlcnR5IGNhbGxlZCBcIm1vZGVcIiBpbmRpY2F0aW5nIHRoZSBtb2RlIHRoYXRcbiAqIHRoZSBwYXJzZXIgaXMgY3VycmVudGx5IGluLiBDdXJyZW50bHkgaXQgaGFzIHRvIGJlIG9uZSBvZiBcIm1hdGhcIiBvclxuICogXCJ0ZXh0XCIsIHdoaWNoIGRlbm90ZXMgd2hldGhlciB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBpcyBhIG1hdGgteVxuICogb25lIG9yIGEgdGV4dC15IG9uZSAoZS5nLiBpbnNpZGUgXFx0ZXh0KS4gQ3VycmVudGx5LCB0aGlzIHNlcnZlcyB0b1xuICogbGltaXQgdGhlIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgdXNlZCBpbiB0ZXh0IG1vZGUuXG4gKlxuICogVGhlIG1haW4gZnVuY3Rpb25zIHRoZW4gcmV0dXJuIGFuIG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgdXNlZnVsIGRhdGEgdGhhdFxuICogd2FzIHBhcnNlZCBhdCBpdHMgZ2l2ZW4gcG9pbnQsIGFuZCBhIG5ldyBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBwYXJzZWRcbiAqIGRhdGEuIFRoZSBtYWluIGZ1bmN0aW9ucyBjYW4gY2FsbCBlYWNoIG90aGVyIGFuZCBjb250aW51ZSB0aGUgcGFyc2luZyBieVxuICogdXNpbmcgdGhlIHJldHVybmVkIHBvc2l0aW9uIGFzIGEgbmV3IHN0YXJ0aW5nIHBvaW50LlxuICpcbiAqIFRoZXJlIGFyZSBhbHNvIGV4dHJhIGAuaGFuZGxlLi4uYCBmdW5jdGlvbnMsIHdoaWNoIHB1bGwgb3V0IHNvbWUgcmV1c2VkXG4gKiBmdW5jdGlvbmFsaXR5IGludG8gc2VsZi1jb250YWluZWQgZnVuY3Rpb25zLlxuICpcbiAqIFRoZSBlYXJsaWVyIGZ1bmN0aW9ucyByZXR1cm4gUGFyc2VOb2Rlcy5cbiAqIFRoZSBsYXRlciBmdW5jdGlvbnMgKHdoaWNoIGFyZSBjYWxsZWQgZGVlcGVyIGluIHRoZSBwYXJzZSkgc29tZXRpbWVzIHJldHVyblxuICogUGFyc2VGdW5jT3JBcmd1bWVudCwgd2hpY2ggY29udGFpbiBhIFBhcnNlTm9kZSBhcyB3ZWxsIGFzIHNvbWUgZGF0YSBhYm91dFxuICogd2hldGhlciB0aGUgcGFyc2VkIG9iamVjdCBpcyBhIGZ1bmN0aW9uIHdoaWNoIGlzIG1pc3Npbmcgc29tZSBhcmd1bWVudHMsIG9yIGFcbiAqIHN0YW5kYWxvbmUgb2JqZWN0IHdoaWNoIGNhbiBiZSB1c2VkIGFzIGFuIGFyZ3VtZW50IHRvIGFub3RoZXIgZnVuY3Rpb24uXG4gKi9cblxuLyoqXG4gKiBNYWluIFBhcnNlciBjbGFzc1xuICovXG5mdW5jdGlvbiBQYXJzZXIoaW5wdXQsIHNldHRpbmdzKSB7XG4gICAgLy8gQ3JlYXRlIGEgbmV3IG1hY3JvIGV4cGFuZGVyIChndWxsZXQpIGFuZCAoaW5kaXJlY3RseSB2aWEgdGhhdCkgYWxzbyBhXG4gICAgLy8gbmV3IGxleGVyIChtb3V0aCkgZm9yIHRoaXMgcGFyc2VyIChzdG9tYWNoLCBpbiB0aGUgbGFuZ3VhZ2Ugb2YgVGVYKVxuICAgIHRoaXMuZ3VsbGV0ID0gbmV3IE1hY3JvRXhwYW5kZXIoaW5wdXQsIHNldHRpbmdzLm1hY3Jvcyk7XG4gICAgLy8gU3RvcmUgdGhlIHNldHRpbmdzIGZvciB1c2UgaW4gcGFyc2luZ1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAvLyBDb3VudCBsZWZ0cmlnaHQgZGVwdGggKGZvciBcXG1pZGRsZSBlcnJvcnMpXG4gICAgdGhpcy5sZWZ0cmlnaHREZXB0aCA9IDA7XG59XG5cbnZhciBQYXJzZU5vZGUgPSBwYXJzZURhdGEuUGFyc2VOb2RlO1xuXG4vKipcbiAqIEFuIGluaXRpYWwgZnVuY3Rpb24gKHdpdGhvdXQgaXRzIGFyZ3VtZW50cyksIG9yIGFuIGFyZ3VtZW50IHRvIGEgZnVuY3Rpb24uXG4gKiBUaGUgYHJlc3VsdGAgYXJndW1lbnQgc2hvdWxkIGJlIGEgUGFyc2VOb2RlLlxuICovXG5mdW5jdGlvbiBQYXJzZUZ1bmNPckFyZ3VtZW50KHJlc3VsdCwgaXNGdW5jdGlvbiwgdG9rZW4pIHtcbiAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAvLyBJcyB0aGlzIGEgZnVuY3Rpb24gKGkuZS4gaXMgaXQgc29tZXRoaW5nIGRlZmluZWQgaW4gZnVuY3Rpb25zLmpzKT9cbiAgICB0aGlzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSByZXN1bHQgdG8gbWFrZSBzdXJlIGl0IGhhcyB0aGUgcmlnaHQgdHlwZSwgYW5kIHRocm93cyBhblxuICogYXBwcm9wcmlhdGUgZXJyb3Igb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGNvbnN1bWUgd2hldGhlciB0byBjb25zdW1lIHRoZSBleHBlY3RlZCB0b2tlbixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdHMgdG8gdHJ1ZVxuICovXG5QYXJzZXIucHJvdG90eXBlLmV4cGVjdCA9IGZ1bmN0aW9uKHRleHQsIGNvbnN1bWUpIHtcbiAgICBpZiAodGhpcy5uZXh0VG9rZW4udGV4dCAhPT0gdGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgJ1wiICsgdGV4dCArIFwiJywgZ290ICdcIiArIHRoaXMubmV4dFRva2VuLnRleHQgKyBcIidcIixcbiAgICAgICAgICAgIHRoaXMubmV4dFRva2VuXG4gICAgICAgICk7XG4gICAgfVxuICAgIGlmIChjb25zdW1lICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENvbnNpZGVycyB0aGUgY3VycmVudCBsb29rIGFoZWFkIHRva2VuIGFzIGNvbnN1bWVkLFxuICogYW5kIGZldGNoZXMgdGhlIG9uZSBhZnRlciB0aGF0IGFzIHRoZSBuZXcgbG9vayBhaGVhZC5cbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5jb25zdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5uZXh0VG9rZW4gPSB0aGlzLmd1bGxldC5nZXQodGhpcy5tb2RlID09PSBcIm1hdGhcIik7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnN3aXRjaE1vZGUgPSBmdW5jdGlvbihuZXdNb2RlKSB7XG4gICAgdGhpcy5ndWxsZXQudW5nZXQodGhpcy5uZXh0VG9rZW4pO1xuICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gICAgdGhpcy5jb25zdW1lKCk7XG59O1xuXG4vKipcbiAqIE1haW4gcGFyc2luZyBmdW5jdGlvbiwgd2hpY2ggcGFyc2VzIGFuIGVudGlyZSBpbnB1dC5cbiAqXG4gKiBAcmV0dXJuIHs/QXJyYXkuPFBhcnNlTm9kZT59XG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBUcnkgdG8gcGFyc2UgdGhlIGlucHV0XG4gICAgdGhpcy5tb2RlID0gXCJtYXRoXCI7XG4gICAgdGhpcy5jb25zdW1lKCk7XG4gICAgdmFyIHBhcnNlID0gdGhpcy5wYXJzZUlucHV0KCk7XG4gICAgcmV0dXJuIHBhcnNlO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYW4gZW50aXJlIGlucHV0IHRyZWUuXG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VJbnB1dCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFBhcnNlIGFuIGV4cHJlc3Npb25cbiAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uKGZhbHNlKTtcbiAgICAvLyBJZiB3ZSBzdWNjZWVkZWQsIG1ha2Ugc3VyZSB0aGVyZSdzIGFuIEVPRiBhdCB0aGUgZW5kXG4gICAgdGhpcy5leHBlY3QoXCJFT0ZcIiwgZmFsc2UpO1xuICAgIHJldHVybiBleHByZXNzaW9uO1xufTtcblxudmFyIGVuZE9mRXhwcmVzc2lvbiA9IFtcIn1cIiwgXCJcXFxcZW5kXCIsIFwiXFxcXHJpZ2h0XCIsIFwiJlwiLCBcIlxcXFxcXFxcXCIsIFwiXFxcXGNyXCJdO1xuXG4vKipcbiAqIFBhcnNlcyBhbiBcImV4cHJlc3Npb25cIiwgd2hpY2ggaXMgYSBsaXN0IG9mIGF0b21zLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYnJlYWtPbkluZml4ICBTaG91bGQgdGhlIHBhcnNpbmcgc3RvcCB3aGVuIHdlIGhpdCBpbmZpeFxuICogICAgICAgICAgICAgICAgICBub2Rlcz8gVGhpcyBoYXBwZW5zIHdoZW4gZnVuY3Rpb25zIGhhdmUgaGlnaGVyIHByZWNlbmRlbmNlXG4gKiAgICAgICAgICAgICAgICAgIHRoYW4gaW5maXggbm9kZXMgaW4gaW1wbGljaXQgcGFyc2VzLlxuICpcbiAqIEBwYXJhbSB7P3N0cmluZ30gYnJlYWtPblRva2VuVGV4dCAgVGhlIHRleHQgb2YgdGhlIHRva2VuIHRoYXQgdGhlIGV4cHJlc3Npb25cbiAqICAgICAgICAgICAgICAgICAgc2hvdWxkIGVuZCB3aXRoLCBvciBgbnVsbGAgaWYgc29tZXRoaW5nIGVsc2Ugc2hvdWxkIGVuZCB0aGVcbiAqICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5cbiAqXG4gKiBAcmV0dXJuIHtQYXJzZU5vZGV9XG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VFeHByZXNzaW9uID0gZnVuY3Rpb24oYnJlYWtPbkluZml4LCBicmVha09uVG9rZW5UZXh0KSB7XG4gICAgdmFyIGJvZHkgPSBbXTtcbiAgICAvLyBLZWVwIGFkZGluZyBhdG9tcyB0byB0aGUgYm9keSB1bnRpbCB3ZSBjYW4ndCBwYXJzZSBhbnkgbW9yZSBhdG9tcyAoZWl0aGVyXG4gICAgLy8gd2UgcmVhY2hlZCB0aGUgZW5kLCBhIH0sIG9yIGEgXFxyaWdodClcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgbGV4ID0gdGhpcy5uZXh0VG9rZW47XG4gICAgICAgIGlmIChlbmRPZkV4cHJlc3Npb24uaW5kZXhPZihsZXgudGV4dCkgIT09IC0xKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnJlYWtPblRva2VuVGV4dCAmJiBsZXgudGV4dCA9PT0gYnJlYWtPblRva2VuVGV4dCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJyZWFrT25JbmZpeCAmJiBmdW5jdGlvbnNbbGV4LnRleHRdICYmIGZ1bmN0aW9uc1tsZXgudGV4dF0uaW5maXgpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdG9tID0gdGhpcy5wYXJzZUF0b20oKTtcbiAgICAgICAgaWYgKCFhdG9tKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MudGhyb3dPbkVycm9yICYmIGxleC50ZXh0WzBdID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvck5vZGUgPSB0aGlzLmhhbmRsZVVuc3VwcG9ydGVkQ21kKCk7XG4gICAgICAgICAgICAgICAgYm9keS5wdXNoKGVycm9yTm9kZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJvZHkucHVzaChhdG9tKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlSW5maXhOb2Rlcyhib2R5KTtcbn07XG5cbi8qKlxuICogUmV3cml0ZXMgaW5maXggb3BlcmF0b3JzIHN1Y2ggYXMgXFxvdmVyIHdpdGggY29ycmVzcG9uZGluZyBjb21tYW5kcyBzdWNoXG4gKiBhcyBcXGZyYWMuXG4gKlxuICogVGhlcmUgY2FuIG9ubHkgYmUgb25lIGluZml4IG9wZXJhdG9yIHBlciBncm91cC4gIElmIHRoZXJlJ3MgbW9yZSB0aGFuIG9uZVxuICogdGhlbiB0aGUgZXhwcmVzc2lvbiBpcyBhbWJpZ3VvdXMuICBUaGlzIGNhbiBiZSByZXNvbHZlZCBieSBhZGRpbmcge30uXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICovXG5QYXJzZXIucHJvdG90eXBlLmhhbmRsZUluZml4Tm9kZXMgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgdmFyIG92ZXJJbmRleCA9IC0xO1xuICAgIHZhciBmdW5jTmFtZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IGJvZHlbaV07XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiaW5maXhcIikge1xuICAgICAgICAgICAgaWYgKG92ZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJvbmx5IG9uZSBpbmZpeCBvcGVyYXRvciBwZXIgZ3JvdXBcIixcbiAgICAgICAgICAgICAgICAgICAgbm9kZS52YWx1ZS50b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdmVySW5kZXggPSBpO1xuICAgICAgICAgICAgZnVuY05hbWUgPSBub2RlLnZhbHVlLnJlcGxhY2VXaXRoO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG92ZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdmFyIG51bWVyTm9kZTtcbiAgICAgICAgdmFyIGRlbm9tTm9kZTtcblxuICAgICAgICB2YXIgbnVtZXJCb2R5ID0gYm9keS5zbGljZSgwLCBvdmVySW5kZXgpO1xuICAgICAgICB2YXIgZGVub21Cb2R5ID0gYm9keS5zbGljZShvdmVySW5kZXggKyAxKTtcblxuICAgICAgICBpZiAobnVtZXJCb2R5Lmxlbmd0aCA9PT0gMSAmJiBudW1lckJvZHlbMF0udHlwZSA9PT0gXCJvcmRncm91cFwiKSB7XG4gICAgICAgICAgICBudW1lck5vZGUgPSBudW1lckJvZHlbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBudW1lck5vZGUgPSBuZXcgUGFyc2VOb2RlKFwib3JkZ3JvdXBcIiwgbnVtZXJCb2R5LCB0aGlzLm1vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlbm9tQm9keS5sZW5ndGggPT09IDEgJiYgZGVub21Cb2R5WzBdLnR5cGUgPT09IFwib3JkZ3JvdXBcIikge1xuICAgICAgICAgICAgZGVub21Ob2RlID0gZGVub21Cb2R5WzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVub21Ob2RlID0gbmV3IFBhcnNlTm9kZShcIm9yZGdyb3VwXCIsIGRlbm9tQm9keSwgdGhpcy5tb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuY2FsbEZ1bmN0aW9uKFxuICAgICAgICAgICAgZnVuY05hbWUsIFtudW1lck5vZGUsIGRlbm9tTm9kZV0sIG51bGwpO1xuICAgICAgICByZXR1cm4gW25ldyBQYXJzZU5vZGUodmFsdWUudHlwZSwgdmFsdWUsIHRoaXMubW9kZSldO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBib2R5O1xuICAgIH1cbn07XG5cbi8vIFRoZSBncmVlZGluZXNzIG9mIGEgc3VwZXJzY3JpcHQgb3Igc3Vic2NyaXB0XG52YXIgU1VQU1VCX0dSRUVESU5FU1MgPSAxO1xuXG4vKipcbiAqIEhhbmRsZSBhIHN1YnNjcmlwdCBvciBzdXBlcnNjcmlwdCB3aXRoIG5pY2UgZXJyb3JzLlxuICovXG5QYXJzZXIucHJvdG90eXBlLmhhbmRsZVN1cFN1YnNjcmlwdCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgc3ltYm9sVG9rZW4gPSB0aGlzLm5leHRUb2tlbjtcbiAgICB2YXIgc3ltYm9sID0gc3ltYm9sVG9rZW4udGV4dDtcbiAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLnBhcnNlR3JvdXAoKTtcblxuICAgIGlmICghZ3JvdXApIHtcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLnRocm93T25FcnJvciAmJiB0aGlzLm5leHRUb2tlbi50ZXh0WzBdID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlVW5zdXBwb3J0ZWRDbWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgZ3JvdXAgYWZ0ZXIgJ1wiICsgc3ltYm9sICsgXCInXCIsXG4gICAgICAgICAgICAgICAgc3ltYm9sVG9rZW5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGdyb3VwLmlzRnVuY3Rpb24pIHtcbiAgICAgICAgLy8gXiBhbmQgXyBoYXZlIGEgZ3JlZWRpbmVzcywgc28gaGFuZGxlIGludGVyYWN0aW9ucyB3aXRoIGZ1bmN0aW9ucydcbiAgICAgICAgLy8gZ3JlZWRpbmVzc1xuICAgICAgICB2YXIgZnVuY0dyZWVkaW5lc3MgPSBmdW5jdGlvbnNbZ3JvdXAucmVzdWx0XS5ncmVlZGluZXNzO1xuICAgICAgICBpZiAoZnVuY0dyZWVkaW5lc3MgPiBTVVBTVUJfR1JFRURJTkVTUykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihncm91cCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgICAgICBcIkdvdCBmdW5jdGlvbiAnXCIgKyBncm91cC5yZXN1bHQgKyBcIicgd2l0aCBubyBhcmd1bWVudHMgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImFzIFwiICsgbmFtZSwgc3ltYm9sVG9rZW4pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdyb3VwLnJlc3VsdDtcbiAgICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSB0ZXh0dWFsIGlucHV0IG9mIGFuIHVuc3VwcG9ydGVkIGNvbW1hbmQgaW50byBhIHRleHQgbm9kZVxuICogY29udGFpbmVkIHdpdGhpbiBhIGNvbG9yIG5vZGUgd2hvc2UgY29sb3IgaXMgZGV0ZXJtaW5lZCBieSBlcnJvckNvbG9yXG4gKi9cblBhcnNlci5wcm90b3R5cGUuaGFuZGxlVW5zdXBwb3J0ZWRDbWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGV4dCA9IHRoaXMubmV4dFRva2VuLnRleHQ7XG4gICAgdmFyIHRleHRvcmRBcnJheSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRleHRvcmRBcnJheS5wdXNoKG5ldyBQYXJzZU5vZGUoXCJ0ZXh0b3JkXCIsIHRleHRbaV0sIFwidGV4dFwiKSk7XG4gICAgfVxuXG4gICAgdmFyIHRleHROb2RlID0gbmV3IFBhcnNlTm9kZShcbiAgICAgICAgXCJ0ZXh0XCIsXG4gICAgICAgIHtcbiAgICAgICAgICAgIGJvZHk6IHRleHRvcmRBcnJheSxcbiAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiXG4gICAgICAgIH0sXG4gICAgICAgIHRoaXMubW9kZSk7XG5cbiAgICB2YXIgY29sb3JOb2RlID0gbmV3IFBhcnNlTm9kZShcbiAgICAgICAgXCJjb2xvclwiLFxuICAgICAgICB7XG4gICAgICAgICAgICBjb2xvcjogdGhpcy5zZXR0aW5ncy5lcnJvckNvbG9yLFxuICAgICAgICAgICAgdmFsdWU6IFt0ZXh0Tm9kZV0sXG4gICAgICAgICAgICB0eXBlOiBcImNvbG9yXCJcbiAgICAgICAgfSxcbiAgICAgICAgdGhpcy5tb2RlKTtcblxuICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIHJldHVybiBjb2xvck5vZGU7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIGdyb3VwIHdpdGggb3B0aW9uYWwgc3VwZXIvc3Vic2NyaXB0cy5cbiAqXG4gKiBAcmV0dXJuIHs/UGFyc2VOb2RlfVxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQXRvbSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFRoZSBib2R5IG9mIGFuIGF0b20gaXMgYW4gaW1wbGljaXQgZ3JvdXAsIHNvIHRoYXQgdGhpbmdzIGxpa2VcbiAgICAvLyBcXGxlZnQoeFxccmlnaHQpXjIgd29yayBjb3JyZWN0bHkuXG4gICAgdmFyIGJhc2UgPSB0aGlzLnBhcnNlSW1wbGljaXRHcm91cCgpO1xuXG4gICAgLy8gSW4gdGV4dCBtb2RlLCB3ZSBkb24ndCBoYXZlIHN1cGVyc2NyaXB0cyBvciBzdWJzY3JpcHRzXG4gICAgaWYgKHRoaXMubW9kZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuXG4gICAgLy8gTm90ZSB0aGF0IGJhc2UgbWF5IGJlIGVtcHR5IChpLmUuIG51bGwpIGF0IHRoaXMgcG9pbnQuXG5cbiAgICB2YXIgc3VwZXJzY3JpcHQ7XG4gICAgdmFyIHN1YnNjcmlwdDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAvLyBMZXggdGhlIGZpcnN0IHRva2VuXG4gICAgICAgIHZhciBsZXggPSB0aGlzLm5leHRUb2tlbjtcblxuICAgICAgICBpZiAobGV4LnRleHQgPT09IFwiXFxcXGxpbWl0c1wiIHx8IGxleC50ZXh0ID09PSBcIlxcXFxub2xpbWl0c1wiKSB7XG4gICAgICAgICAgICAvLyBXZSBnb3QgYSBsaW1pdCBjb250cm9sXG4gICAgICAgICAgICBpZiAoIWJhc2UgfHwgYmFzZS50eXBlICE9PSBcIm9wXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJMaW1pdCBjb250cm9scyBtdXN0IGZvbGxvdyBhIG1hdGggb3BlcmF0b3JcIixcbiAgICAgICAgICAgICAgICAgICAgbGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbWl0cyA9IGxleC50ZXh0ID09PSBcIlxcXFxsaW1pdHNcIjtcbiAgICAgICAgICAgICAgICBiYXNlLnZhbHVlLmxpbWl0cyA9IGxpbWl0cztcbiAgICAgICAgICAgICAgICBiYXNlLnZhbHVlLmFsd2F5c0hhbmRsZVN1cFN1YiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChsZXgudGV4dCA9PT0gXCJeXCIpIHtcbiAgICAgICAgICAgIC8vIFdlIGdvdCBhIHN1cGVyc2NyaXB0IHN0YXJ0XG4gICAgICAgICAgICBpZiAoc3VwZXJzY3JpcHQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkRvdWJsZSBzdXBlcnNjcmlwdFwiLCBsZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VwZXJzY3JpcHQgPSB0aGlzLmhhbmRsZVN1cFN1YnNjcmlwdChcInN1cGVyc2NyaXB0XCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGxleC50ZXh0ID09PSBcIl9cIikge1xuICAgICAgICAgICAgLy8gV2UgZ290IGEgc3Vic2NyaXB0IHN0YXJ0XG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJEb3VibGUgc3Vic2NyaXB0XCIsIGxleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJzY3JpcHQgPSB0aGlzLmhhbmRsZVN1cFN1YnNjcmlwdChcInN1YnNjcmlwdFwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChsZXgudGV4dCA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgIC8vIFdlIGdvdCBhIHByaW1lXG4gICAgICAgICAgICB2YXIgcHJpbWUgPSBuZXcgUGFyc2VOb2RlKFwidGV4dG9yZFwiLCBcIlxcXFxwcmltZVwiLCB0aGlzLm1vZGUpO1xuXG4gICAgICAgICAgICAvLyBNYW55IHByaW1lcyBjYW4gYmUgZ3JvdXBlZCB0b2dldGhlciwgc28gd2UgaGFuZGxlIHRoaXMgaGVyZVxuICAgICAgICAgICAgdmFyIHByaW1lcyA9IFtwcmltZV07XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICAgIC8vIEtlZXAgbGV4aW5nIHRva2VucyB1bnRpbCB3ZSBnZXQgc29tZXRoaW5nIHRoYXQncyBub3QgYSBwcmltZVxuICAgICAgICAgICAgd2hpbGUgKHRoaXMubmV4dFRva2VuLnRleHQgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIGVhY2ggb25lLCBhZGQgYW5vdGhlciBwcmltZSB0byB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIHByaW1lcy5wdXNoKHByaW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFB1dCB0aGVtIGludG8gYW4gb3JkZ3JvdXAgYXMgdGhlIHN1cGVyc2NyaXB0XG4gICAgICAgICAgICBzdXBlcnNjcmlwdCA9IG5ldyBQYXJzZU5vZGUoXCJvcmRncm91cFwiLCBwcmltZXMsIHRoaXMubW9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBpdCB3YXNuJ3QgXiwgXywgb3IgJywgc3RvcCBwYXJzaW5nIHN1cGVyL3N1YnNjcmlwdHNcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cGVyc2NyaXB0IHx8IHN1YnNjcmlwdCkge1xuICAgICAgICAvLyBJZiB3ZSBnb3QgZWl0aGVyIGEgc3VwZXJzY3JpcHQgb3Igc3Vic2NyaXB0LCBjcmVhdGUgYSBzdXBzdWJcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZU5vZGUoXCJzdXBzdWJcIiwge1xuICAgICAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgICAgIHN1cDogc3VwZXJzY3JpcHQsXG4gICAgICAgICAgICBzdWI6IHN1YnNjcmlwdFxuICAgICAgICB9LCB0aGlzLm1vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSByZXR1cm4gdGhlIG9yaWdpbmFsIGJvZHlcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxufTtcblxuLy8gQSBsaXN0IG9mIHRoZSBzaXplLWNoYW5naW5nIGZ1bmN0aW9ucywgZm9yIHVzZSBpbiBwYXJzZUltcGxpY2l0R3JvdXBcbnZhciBzaXplRnVuY3MgPSBbXG4gICAgXCJcXFxcdGlueVwiLCBcIlxcXFxzY3JpcHRzaXplXCIsIFwiXFxcXGZvb3Rub3Rlc2l6ZVwiLCBcIlxcXFxzbWFsbFwiLCBcIlxcXFxub3JtYWxzaXplXCIsXG4gICAgXCJcXFxcbGFyZ2VcIiwgXCJcXFxcTGFyZ2VcIiwgXCJcXFxcTEFSR0VcIiwgXCJcXFxcaHVnZVwiLCBcIlxcXFxIdWdlXCJcbl07XG5cbi8vIEEgbGlzdCBvZiB0aGUgc3R5bGUtY2hhbmdpbmcgZnVuY3Rpb25zLCBmb3IgdXNlIGluIHBhcnNlSW1wbGljaXRHcm91cFxudmFyIHN0eWxlRnVuY3MgPSBbXG4gICAgXCJcXFxcZGlzcGxheXN0eWxlXCIsIFwiXFxcXHRleHRzdHlsZVwiLCBcIlxcXFxzY3JpcHRzdHlsZVwiLCBcIlxcXFxzY3JpcHRzY3JpcHRzdHlsZVwiXG5dO1xuXG4vKipcbiAqIFBhcnNlcyBhbiBpbXBsaWNpdCBncm91cCwgd2hpY2ggaXMgYSBncm91cCB0aGF0IHN0YXJ0cyBhdCB0aGUgZW5kIG9mIGFcbiAqIHNwZWNpZmllZCwgYW5kIGVuZHMgcmlnaHQgYmVmb3JlIGEgaGlnaGVyIGV4cGxpY2l0IGdyb3VwIGVuZHMsIG9yIGF0IEVPTC4gSXRcbiAqIGlzIHVzZWQgZm9yIGZ1bmN0aW9ucyB0aGF0IGFwcGVhciB0byBhZmZlY3QgdGhlIGN1cnJlbnQgc3R5bGUsIGxpa2UgXFxMYXJnZSBvclxuICogXFx0ZXh0cm0sIHdoZXJlIGluc3RlYWQgb2Yga2VlcGluZyBhIHN0eWxlIHdlIGp1c3QgcHJldGVuZCB0aGF0IHRoZXJlIGlzIGFuXG4gKiBpbXBsaWNpdCBncm91cGluZyBhZnRlciBpdCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBncm91cC4gRS5nLlxuICogICBzbWFsbCB0ZXh0IHtcXExhcmdlIGxhcmdlIHRleHR9IHNtYWxsIHRleHQgYWdhaW5cbiAqIEl0IGlzIGFsc28gdXNlZCBmb3IgXFxsZWZ0IGFuZCBcXHJpZ2h0IHRvIGdldCB0aGUgY29ycmVjdCBncm91cGluZy5cbiAqXG4gKiBAcmV0dXJuIHs/UGFyc2VOb2RlfVxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlSW1wbGljaXRHcm91cCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMucGFyc2VTeW1ib2woKTtcblxuICAgIGlmIChzdGFydCA9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHdlIGRpZG4ndCBnZXQgYW55dGhpbmcgd2UgaGFuZGxlLCBmYWxsIGJhY2sgdG8gcGFyc2VGdW5jdGlvblxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKCk7XG4gICAgfVxuXG4gICAgdmFyIGZ1bmMgPSBzdGFydC5yZXN1bHQ7XG4gICAgdmFyIGJvZHk7XG5cbiAgICBpZiAoZnVuYyA9PT0gXCJcXFxcbGVmdFwiKSB7XG4gICAgICAgIC8vIElmIHdlIHNlZSBhIGxlZnQ6XG4gICAgICAgIC8vIFBhcnNlIHRoZSBlbnRpcmUgbGVmdCBmdW5jdGlvbiAoaW5jbHVkaW5nIHRoZSBkZWxpbWl0ZXIpXG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5wYXJzZUZ1bmN0aW9uKHN0YXJ0KTtcbiAgICAgICAgLy8gUGFyc2Ugb3V0IHRoZSBpbXBsaWNpdCBib2R5XG4gICAgICAgICsrdGhpcy5sZWZ0cmlnaHREZXB0aDtcbiAgICAgICAgYm9keSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKGZhbHNlKTtcbiAgICAgICAgLS10aGlzLmxlZnRyaWdodERlcHRoO1xuICAgICAgICAvLyBDaGVjayB0aGUgbmV4dCB0b2tlblxuICAgICAgICB0aGlzLmV4cGVjdChcIlxcXFxyaWdodFwiLCBmYWxzZSk7XG4gICAgICAgIHZhciByaWdodCA9IHRoaXMucGFyc2VGdW5jdGlvbigpO1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlTm9kZShcImxlZnRyaWdodFwiLCB7XG4gICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgbGVmdDogbGVmdC52YWx1ZS52YWx1ZSxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodC52YWx1ZS52YWx1ZVxuICAgICAgICB9LCB0aGlzLm1vZGUpO1xuICAgIH0gZWxzZSBpZiAoZnVuYyA9PT0gXCJcXFxcYmVnaW5cIikge1xuICAgICAgICAvLyBiZWdpbi4uLmVuZCBpcyBzaW1pbGFyIHRvIGxlZnQuLi5yaWdodFxuICAgICAgICB2YXIgYmVnaW4gPSB0aGlzLnBhcnNlRnVuY3Rpb24oc3RhcnQpO1xuICAgICAgICB2YXIgZW52TmFtZSA9IGJlZ2luLnZhbHVlLm5hbWU7XG4gICAgICAgIGlmICghZW52aXJvbm1lbnRzLmhhc093blByb3BlcnR5KGVudk5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgICAgICBcIk5vIHN1Y2ggZW52aXJvbm1lbnQ6IFwiICsgZW52TmFtZSwgYmVnaW4udmFsdWUubmFtZUdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWlsZCB0aGUgZW52aXJvbm1lbnQgb2JqZWN0LiBBcmd1bWVudHMgYW5kIG90aGVyIGluZm9ybWF0aW9uIHdpbGxcbiAgICAgICAgLy8gYmUgbWFkZSBhdmFpbGFibGUgdG8gdGhlIGJlZ2luIGFuZCBlbmQgbWV0aG9kcyB1c2luZyBwcm9wZXJ0aWVzLlxuICAgICAgICB2YXIgZW52ID0gZW52aXJvbm1lbnRzW2Vudk5hbWVdO1xuICAgICAgICB2YXIgYXJncyA9IHRoaXMucGFyc2VBcmd1bWVudHMoXCJcXFxcYmVnaW57XCIgKyBlbnZOYW1lICsgXCJ9XCIsIGVudik7XG4gICAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgICAgZW52TmFtZTogZW52TmFtZSxcbiAgICAgICAgICAgIHBhcnNlcjogdGhpcyxcbiAgICAgICAgICAgIHBvc2l0aW9uczogYXJncy5wb3AoKVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVzdWx0ID0gZW52LmhhbmRsZXIoY29udGV4dCwgYXJncyk7XG4gICAgICAgIHRoaXMuZXhwZWN0KFwiXFxcXGVuZFwiLCBmYWxzZSk7XG4gICAgICAgIHZhciBlbmROYW1lVG9rZW4gPSB0aGlzLm5leHRUb2tlbjtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucGFyc2VGdW5jdGlvbigpO1xuICAgICAgICBpZiAoZW5kLnZhbHVlLm5hbWUgIT09IGVudk5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgICAgIFwiTWlzbWF0Y2g6IFxcXFxiZWdpbntcIiArIGVudk5hbWUgKyBcIn0gbWF0Y2hlZCBcIiArXG4gICAgICAgICAgICAgICAgXCJieSBcXFxcZW5ke1wiICsgZW5kLnZhbHVlLm5hbWUgKyBcIn1cIixcbiAgICAgICAgICAgICAgICBlbmROYW1lVG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wb3NpdGlvbiA9IGVuZC5wb3NpdGlvbjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmNvbnRhaW5zKHNpemVGdW5jcywgZnVuYykpIHtcbiAgICAgICAgLy8gSWYgd2Ugc2VlIGEgc2l6aW5nIGZ1bmN0aW9uLCBwYXJzZSBvdXQgdGhlIGltcGxpY3QgYm9keVxuICAgICAgICBib2R5ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oZmFsc2UpO1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlTm9kZShcInNpemluZ1wiLCB7XG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHdoYXQgc2l6ZSB0byB1c2UgYmFzZWQgb24gdGhlIGxpc3Qgb2YgZnVuY3Rpb25zIGFib3ZlXG4gICAgICAgICAgICBzaXplOiBcInNpemVcIiArICh1dGlscy5pbmRleE9mKHNpemVGdW5jcywgZnVuYykgKyAxKSxcbiAgICAgICAgICAgIHZhbHVlOiBib2R5XG4gICAgICAgIH0sIHRoaXMubW9kZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5jb250YWlucyhzdHlsZUZ1bmNzLCBmdW5jKSkge1xuICAgICAgICAvLyBJZiB3ZSBzZWUgYSBzdHlsaW5nIGZ1bmN0aW9uLCBwYXJzZSBvdXQgdGhlIGltcGxpY3QgYm9keVxuICAgICAgICBib2R5ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VOb2RlKFwic3R5bGluZ1wiLCB7XG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHdoYXQgc3R5bGUgdG8gdXNlIGJ5IHB1bGxpbmcgb3V0IHRoZSBzdHlsZSBmcm9tXG4gICAgICAgICAgICAvLyB0aGUgZnVuY3Rpb24gbmFtZVxuICAgICAgICAgICAgc3R5bGU6IGZ1bmMuc2xpY2UoMSwgZnVuYy5sZW5ndGggLSA1KSxcbiAgICAgICAgICAgIHZhbHVlOiBib2R5XG4gICAgICAgIH0sIHRoaXMubW9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRGVmZXIgdG8gcGFyc2VGdW5jdGlvbiBpZiBpdCdzIG5vdCBhIGZ1bmN0aW9uIHdlIGhhbmRsZVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKHN0YXJ0KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhbiBlbnRpcmUgZnVuY3Rpb24sIGluY2x1ZGluZyBpdHMgYmFzZSBhbmQgYWxsIG9mIGl0cyBhcmd1bWVudHMuXG4gKiBUaGUgYmFzZSBtaWdodCBlaXRoZXIgaGF2ZSBiZWVuIHBhcnNlZCBhbHJlYWR5LCBpbiB3aGljaCBjYXNlXG4gKiBpdCBpcyBwcm92aWRlZCBhcyBhbiBhcmd1bWVudCwgb3IgaXQncyB0aGUgbmV4dCBncm91cCBpbiB0aGUgaW5wdXQuXG4gKlxuICogQHBhcmFtIHtQYXJzZUZ1bmNPckFyZ3VtZW50PX0gYmFzZUdyb3VwIG9wdGlvbmFsIGFzIGRlc2NyaWJlZCBhYm92ZVxuICogQHJldHVybiB7P1BhcnNlTm9kZX1cbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZ1bmN0aW9uID0gZnVuY3Rpb24oYmFzZUdyb3VwKSB7XG4gICAgaWYgKCFiYXNlR3JvdXApIHtcbiAgICAgICAgYmFzZUdyb3VwID0gdGhpcy5wYXJzZUdyb3VwKCk7XG4gICAgfVxuXG4gICAgaWYgKGJhc2VHcm91cCkge1xuICAgICAgICBpZiAoYmFzZUdyb3VwLmlzRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBmdW5jID0gYmFzZUdyb3VwLnJlc3VsdDtcbiAgICAgICAgICAgIHZhciBmdW5jRGF0YSA9IGZ1bmN0aW9uc1tmdW5jXTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGUgPT09IFwidGV4dFwiICYmICFmdW5jRGF0YS5hbGxvd2VkSW5UZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiQ2FuJ3QgdXNlIGZ1bmN0aW9uICdcIiArIGZ1bmMgKyBcIicgaW4gdGV4dCBtb2RlXCIsXG4gICAgICAgICAgICAgICAgICAgIGJhc2VHcm91cC50b2tlbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhcmdzID0gdGhpcy5wYXJzZUFyZ3VtZW50cyhmdW5jLCBmdW5jRGF0YSk7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSBiYXNlR3JvdXAudG9rZW47XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jYWxsRnVuY3Rpb24oZnVuYywgYXJncywgYXJncy5wb3AoKSwgdG9rZW4pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZU5vZGUocmVzdWx0LnR5cGUsIHJlc3VsdCwgdGhpcy5tb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlR3JvdXAucmVzdWx0O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gaGFuZGxlciB3aXRoIGEgc3VpdGFibGUgY29udGV4dCBhbmQgYXJndW1lbnRzLlxuICovXG5QYXJzZXIucHJvdG90eXBlLmNhbGxGdW5jdGlvbiA9IGZ1bmN0aW9uKG5hbWUsIGFyZ3MsIHBvc2l0aW9ucywgdG9rZW4pIHtcbiAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgZnVuY05hbWU6IG5hbWUsXG4gICAgICAgIHBhcnNlcjogdGhpcyxcbiAgICAgICAgcG9zaXRpb25zOiBwb3NpdGlvbnMsXG4gICAgICAgIHRva2VuOiB0b2tlblxuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uc1tuYW1lXS5oYW5kbGVyKGNvbnRleHQsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgdGhlIGFyZ3VtZW50cyBvZiBhIGZ1bmN0aW9uIG9yIGVudmlyb25tZW50XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZ1bmMgIFwiXFxuYW1lXCIgb3IgXCJcXGJlZ2lue25hbWV9XCJcbiAqIEBwYXJhbSB7e251bUFyZ3M6bnVtYmVyLG51bU9wdGlvbmFsQXJnczpudW1iZXJ8dW5kZWZpbmVkfX0gZnVuY0RhdGFcbiAqIEByZXR1cm4gdGhlIGFycmF5IG9mIGFyZ3VtZW50cywgd2l0aCB0aGUgbGlzdCBvZiBwb3NpdGlvbnMgYXMgbGFzdCBlbGVtZW50XG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VBcmd1bWVudHMgPSBmdW5jdGlvbihmdW5jLCBmdW5jRGF0YSkge1xuICAgIHZhciB0b3RhbEFyZ3MgPSBmdW5jRGF0YS5udW1BcmdzICsgZnVuY0RhdGEubnVtT3B0aW9uYWxBcmdzO1xuICAgIGlmICh0b3RhbEFyZ3MgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtbdGhpcy5wb3NdXTtcbiAgICB9XG5cbiAgICB2YXIgYmFzZUdyZWVkaW5lc3MgPSBmdW5jRGF0YS5ncmVlZGluZXNzO1xuICAgIHZhciBwb3NpdGlvbnMgPSBbdGhpcy5wb3NdO1xuICAgIHZhciBhcmdzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsQXJnczsgaSsrKSB7XG4gICAgICAgIHZhciBuZXh0VG9rZW4gPSB0aGlzLm5leHRUb2tlbjtcbiAgICAgICAgdmFyIGFyZ1R5cGUgPSBmdW5jRGF0YS5hcmdUeXBlcyAmJiBmdW5jRGF0YS5hcmdUeXBlc1tpXTtcbiAgICAgICAgdmFyIGFyZztcbiAgICAgICAgaWYgKGkgPCBmdW5jRGF0YS5udW1PcHRpb25hbEFyZ3MpIHtcbiAgICAgICAgICAgIGlmIChhcmdUeXBlKSB7XG4gICAgICAgICAgICAgICAgYXJnID0gdGhpcy5wYXJzZUdyb3VwT2ZUeXBlKGFyZ1R5cGUsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmcgPSB0aGlzLnBhcnNlR3JvdXAodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFyZykge1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnMucHVzaCh0aGlzLnBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYXJnVHlwZSkge1xuICAgICAgICAgICAgICAgIGFyZyA9IHRoaXMucGFyc2VHcm91cE9mVHlwZShhcmdUeXBlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJnID0gdGhpcy5wYXJzZUdyb3VwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFyZykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy50aHJvd09uRXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4udGV4dFswXSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gbmV3IFBhcnNlRnVuY09yQXJndW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVVuc3VwcG9ydGVkQ21kKHRoaXMubmV4dFRva2VuLnRleHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJFeHBlY3RlZCBncm91cCBhZnRlciAnXCIgKyBmdW5jICsgXCInXCIsIG5leHRUb2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBhcmdOb2RlO1xuICAgICAgICBpZiAoYXJnLmlzRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBhcmdHcmVlZGluZXNzID1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbnNbYXJnLnJlc3VsdF0uZ3JlZWRpbmVzcztcbiAgICAgICAgICAgIGlmIChhcmdHcmVlZGluZXNzID4gYmFzZUdyZWVkaW5lc3MpIHtcbiAgICAgICAgICAgICAgICBhcmdOb2RlID0gdGhpcy5wYXJzZUZ1bmN0aW9uKGFyZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkdvdCBmdW5jdGlvbiAnXCIgKyBhcmcucmVzdWx0ICsgXCInIGFzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJhcmd1bWVudCB0byAnXCIgKyBmdW5jICsgXCInXCIsIG5leHRUb2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcmdOb2RlID0gYXJnLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBhcmdzLnB1c2goYXJnTm9kZSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHRoaXMucG9zKTtcbiAgICB9XG5cbiAgICBhcmdzLnB1c2gocG9zaXRpb25zKTtcblxuICAgIHJldHVybiBhcmdzO1xufTtcblxuXG4vKipcbiAqIFBhcnNlcyBhIGdyb3VwIHdoZW4gdGhlIG1vZGUgaXMgY2hhbmdpbmcuXG4gKlxuICogQHJldHVybiB7P1BhcnNlRnVuY09yQXJndW1lbnR9XG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VHcm91cE9mVHlwZSA9IGZ1bmN0aW9uKGlubmVyTW9kZSwgb3B0aW9uYWwpIHtcbiAgICB2YXIgb3V0ZXJNb2RlID0gdGhpcy5tb2RlO1xuICAgIC8vIEhhbmRsZSBgb3JpZ2luYWxgIGFyZ1R5cGVzXG4gICAgaWYgKGlubmVyTW9kZSA9PT0gXCJvcmlnaW5hbFwiKSB7XG4gICAgICAgIGlubmVyTW9kZSA9IG91dGVyTW9kZTtcbiAgICB9XG5cbiAgICBpZiAoaW5uZXJNb2RlID09PSBcImNvbG9yXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDb2xvckdyb3VwKG9wdGlvbmFsKTtcbiAgICB9XG4gICAgaWYgKGlubmVyTW9kZSA9PT0gXCJzaXplXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTaXplR3JvdXAob3B0aW9uYWwpO1xuICAgIH1cblxuICAgIHRoaXMuc3dpdGNoTW9kZShpbm5lck1vZGUpO1xuICAgIGlmIChpbm5lck1vZGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgIC8vIHRleHQgbW9kZSBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgc2hvdWxkIGlnbm9yZSB0aGUgd2hpdGVzcGFjZSBiZWZvcmVcbiAgICAgICAgLy8gaXRcbiAgICAgICAgd2hpbGUgKHRoaXMubmV4dFRva2VuLnRleHQgPT09IFwiIFwiKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBCeSB0aGUgdGltZSB3ZSBnZXQgaGVyZSwgaW5uZXJNb2RlIGlzIG9uZSBvZiBcInRleHRcIiBvciBcIm1hdGhcIi5cbiAgICAvLyBXZSBzd2l0Y2ggdGhlIG1vZGUgb2YgdGhlIHBhcnNlciwgcmVjdXJzZSwgdGhlbiByZXN0b3JlIHRoZSBvbGQgbW9kZS5cbiAgICB2YXIgcmVzID0gdGhpcy5wYXJzZUdyb3VwKG9wdGlvbmFsKTtcbiAgICB0aGlzLnN3aXRjaE1vZGUob3V0ZXJNb2RlKTtcbiAgICByZXR1cm4gcmVzO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYSBncm91cCwgZXNzZW50aWFsbHkgcmV0dXJuaW5nIHRoZSBzdHJpbmcgZm9ybWVkIGJ5IHRoZVxuICogYnJhY2UtZW5jbG9zZWQgdG9rZW5zIHBsdXMgc29tZSBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kZU5hbWUgIFVzZWQgdG8gZGVzY3JpYmUgdGhlIG1vZGUgaW4gZXJyb3IgbWVzc2FnZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdGlvbmFsICBXaGV0aGVyIHRoZSBncm91cCBpcyBvcHRpb25hbCBvciByZXF1aXJlZFxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU3RyaW5nR3JvdXAgPSBmdW5jdGlvbihtb2RlTmFtZSwgb3B0aW9uYWwpIHtcbiAgICBpZiAob3B0aW9uYWwgJiYgdGhpcy5uZXh0VG9rZW4udGV4dCAhPT0gXCJbXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBvdXRlck1vZGUgPSB0aGlzLm1vZGU7XG4gICAgdGhpcy5tb2RlID0gXCJ0ZXh0XCI7XG4gICAgdGhpcy5leHBlY3Qob3B0aW9uYWwgPyBcIltcIiA6IFwie1wiKTtcbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB2YXIgZmlyc3RUb2tlbiA9IHRoaXMubmV4dFRva2VuO1xuICAgIHZhciBsYXN0VG9rZW4gPSBmaXJzdFRva2VuO1xuICAgIHdoaWxlICh0aGlzLm5leHRUb2tlbi50ZXh0ICE9PSAob3B0aW9uYWwgPyBcIl1cIiA6IFwifVwiKSkge1xuICAgICAgICBpZiAodGhpcy5uZXh0VG9rZW4udGV4dCA9PT0gXCJFT0ZcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCBpbiBcIiArIG1vZGVOYW1lLFxuICAgICAgICAgICAgICAgIGZpcnN0VG9rZW4ucmFuZ2UodGhpcy5uZXh0VG9rZW4sIHN0cikpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RUb2tlbiA9IHRoaXMubmV4dFRva2VuO1xuICAgICAgICBzdHIgKz0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIH1cbiAgICB0aGlzLm1vZGUgPSBvdXRlck1vZGU7XG4gICAgdGhpcy5leHBlY3Qob3B0aW9uYWwgPyBcIl1cIiA6IFwifVwiKTtcbiAgICByZXR1cm4gZmlyc3RUb2tlbi5yYW5nZShsYXN0VG9rZW4sIHN0cik7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIHJlZ2V4LWRlbGltaXRlZCBncm91cDogdGhlIGxhcmdlc3Qgc2VxdWVuY2Ugb2YgdG9rZW5zXG4gKiB3aG9zZSBjb25jYXRlbmF0ZWQgc3RyaW5ncyBtYXRjaCBgcmVnZXhgLiBSZXR1cm5zIHRoZSBzdHJpbmdcbiAqIGZvcm1lZCBieSB0aGUgdG9rZW5zIHBsdXMgc29tZSBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlTmFtZSAgVXNlZCB0byBkZXNjcmliZSB0aGUgbW9kZSBpbiBlcnJvciBtZXNzYWdlc1xuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlUmVnZXhHcm91cCA9IGZ1bmN0aW9uKHJlZ2V4LCBtb2RlTmFtZSkge1xuICAgIHZhciBvdXRlck1vZGUgPSB0aGlzLm1vZGU7XG4gICAgdGhpcy5tb2RlID0gXCJ0ZXh0XCI7XG4gICAgdmFyIGZpcnN0VG9rZW4gPSB0aGlzLm5leHRUb2tlbjtcbiAgICB2YXIgbGFzdFRva2VuID0gZmlyc3RUb2tlbjtcbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB3aGlsZSAodGhpcy5uZXh0VG9rZW4udGV4dCAhPT0gXCJFT0ZcIlxuICAgICAgICAgICAmJiByZWdleC50ZXN0KHN0ciArIHRoaXMubmV4dFRva2VuLnRleHQpKSB7XG4gICAgICAgIGxhc3RUb2tlbiA9IHRoaXMubmV4dFRva2VuO1xuICAgICAgICBzdHIgKz0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIH1cbiAgICBpZiAoc3RyID09PSBcIlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgXCJJbnZhbGlkIFwiICsgbW9kZU5hbWUgKyBcIjogJ1wiICsgZmlyc3RUb2tlbi50ZXh0ICsgXCInXCIsXG4gICAgICAgICAgICBmaXJzdFRva2VuKTtcbiAgICB9XG4gICAgdGhpcy5tb2RlID0gb3V0ZXJNb2RlO1xuICAgIHJldHVybiBmaXJzdFRva2VuLnJhbmdlKGxhc3RUb2tlbiwgc3RyKTtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgY29sb3IgZGVzY3JpcHRpb24uXG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VDb2xvckdyb3VwID0gZnVuY3Rpb24ob3B0aW9uYWwpIHtcbiAgICB2YXIgcmVzID0gdGhpcy5wYXJzZVN0cmluZ0dyb3VwKFwiY29sb3JcIiwgb3B0aW9uYWwpO1xuICAgIGlmICghcmVzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgbWF0Y2ggPSAoL14oI1thLXowLTldK3xbYS16XSspJC9pKS5leGVjKHJlcy50ZXh0KTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCBjb2xvcjogJ1wiICsgcmVzLnRleHQgKyBcIidcIiwgcmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQYXJzZUZ1bmNPckFyZ3VtZW50KFxuICAgICAgICBuZXcgUGFyc2VOb2RlKFwiY29sb3JcIiwgbWF0Y2hbMF0sIHRoaXMubW9kZSksXG4gICAgICAgIGZhbHNlKTtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgc2l6ZSBzcGVjaWZpY2F0aW9uLCBjb25zaXN0aW5nIG9mIG1hZ25pdHVkZSBhbmQgdW5pdC5cbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNpemVHcm91cCA9IGZ1bmN0aW9uKG9wdGlvbmFsKSB7XG4gICAgdmFyIHJlcztcbiAgICBpZiAoIW9wdGlvbmFsICYmIHRoaXMubmV4dFRva2VuLnRleHQgIT09IFwie1wiKSB7XG4gICAgICAgIHJlcyA9IHRoaXMucGFyc2VSZWdleEdyb3VwKFxuICAgICAgICAgICAgL15bLStdPyAqKD86JHxcXGQrfFxcZCtcXC5cXGQqfFxcLlxcZCopICpbYS16XXswLDJ9JC8sIFwic2l6ZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXMgPSB0aGlzLnBhcnNlU3RyaW5nR3JvdXAoXCJzaXplXCIsIG9wdGlvbmFsKTtcbiAgICB9XG4gICAgaWYgKCFyZXMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBtYXRjaCA9ICgvKFstK10/KSAqKFxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykgKihbYS16XXsyfSkvKS5leGVjKHJlcy50ZXh0KTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCBzaXplOiAnXCIgKyByZXMudGV4dCArIFwiJ1wiLCByZXMpO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgbnVtYmVyOiArKG1hdGNoWzFdICsgbWF0Y2hbMl0pLCAvLyBzaWduICsgbWFnbml0dWRlLCBjYXN0IHRvIG51bWJlclxuICAgICAgICB1bml0OiBtYXRjaFszXVxuICAgIH07XG4gICAgaWYgKGRhdGEudW5pdCAhPT0gXCJlbVwiICYmIGRhdGEudW5pdCAhPT0gXCJleFwiICYmIGRhdGEudW5pdCAhPT0gXCJtdVwiKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCB1bml0OiAnXCIgKyBkYXRhLnVuaXQgKyBcIidcIiwgcmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQYXJzZUZ1bmNPckFyZ3VtZW50KFxuICAgICAgICBuZXcgUGFyc2VOb2RlKFwiY29sb3JcIiwgZGF0YSwgdGhpcy5tb2RlKSxcbiAgICAgICAgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgZmFsc2Ugb3IgYWJzZW50LCB0aGlzIHBhcnNlcyBhbiBvcmRpbmFyeSBncm91cCxcbiAqIHdoaWNoIGlzIGVpdGhlciBhIHNpbmdsZSBudWNsZXVzIChsaWtlIFwieFwiKSBvciBhbiBleHByZXNzaW9uXG4gKiBpbiBicmFjZXMgKGxpa2UgXCJ7eCt5fVwiKS5cbiAqIElmIHRoZSBhcmd1bWVudCBpcyB0cnVlLCBpdCBwYXJzZXMgZWl0aGVyIGEgYnJhY2tldC1kZWxpbWl0ZWQgZXhwcmVzc2lvblxuICogKGxpa2UgXCJbeCt5XVwiKSBvciByZXR1cm5zIG51bGwgdG8gaW5kaWNhdGUgdGhlIGFic2VuY2Ugb2YgYVxuICogYnJhY2tldC1lbmNsb3NlZCBncm91cC5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRpb25hbCAgV2hldGhlciB0aGUgZ3JvdXAgaXMgb3B0aW9uYWwgb3IgcmVxdWlyZWRcbiAqIEByZXR1cm4gez9QYXJzZUZ1bmNPckFyZ3VtZW50fVxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlR3JvdXAgPSBmdW5jdGlvbihvcHRpb25hbCkge1xuICAgIHZhciBmaXJzdFRva2VuID0gdGhpcy5uZXh0VG9rZW47XG4gICAgLy8gVHJ5IHRvIHBhcnNlIGFuIG9wZW4gYnJhY2VcbiAgICBpZiAodGhpcy5uZXh0VG9rZW4udGV4dCA9PT0gKG9wdGlvbmFsID8gXCJbXCIgOiBcIntcIikpIHtcbiAgICAgICAgLy8gSWYgd2UgZ2V0IGEgYnJhY2UsIHBhcnNlIGFuIGV4cHJlc3Npb25cbiAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIG9wdGlvbmFsID8gXCJdXCIgOiBudWxsKTtcbiAgICAgICAgdmFyIGxhc3RUb2tlbiA9IHRoaXMubmV4dFRva2VuO1xuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgZ2V0IGEgY2xvc2UgYnJhY2VcbiAgICAgICAgdGhpcy5leHBlY3Qob3B0aW9uYWwgPyBcIl1cIiA6IFwifVwiKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUxpZ2F0dXJlcyhleHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlRnVuY09yQXJndW1lbnQoXG4gICAgICAgICAgICBuZXcgUGFyc2VOb2RlKFwib3JkZ3JvdXBcIiwgZXhwcmVzc2lvbiwgdGhpcy5tb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFRva2VuLCBsYXN0VG9rZW4pLFxuICAgICAgICAgICAgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwganVzdCByZXR1cm4gYSBudWNsZXVzLCBvciBub3RoaW5nIGZvciBhbiBvcHRpb25hbCBncm91cFxuICAgICAgICByZXR1cm4gb3B0aW9uYWwgPyBudWxsIDogdGhpcy5wYXJzZVN5bWJvbCgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogRm9ybSBsaWdhdHVyZS1saWtlIGNvbWJpbmF0aW9ucyBvZiBjaGFyYWN0ZXJzIGZvciB0ZXh0IG1vZGUuXG4gKiBUaGlzIGluY2x1ZGVzIGlucHV0cyBsaWtlIFwiLS1cIiwgXCItLS1cIiwgXCJgYFwiIGFuZCBcIicnXCIuXG4gKiBUaGUgcmVzdWx0IHdpbGwgc2ltcGx5IHJlcGxhY2UgbXVsdGlwbGUgdGV4dG9yZCBub2RlcyB3aXRoIGEgc2luZ2xlXG4gKiBjaGFyYWN0ZXIgaW4gZWFjaCB2YWx1ZSBieSBhIHNpbmdsZSB0ZXh0b3JkIG5vZGUgaGF2aW5nIG11bHRpcGxlXG4gKiBjaGFyYWN0ZXJzIGluIGl0cyB2YWx1ZS4gIFRoZSByZXByZXNlbnRhdGlvbiBpcyBzdGlsbCBBU0NJSSBzb3VyY2UuXG4gKlxuICogQHBhcmFtIHtBcnJheS48UGFyc2VOb2RlPn0gZ3JvdXAgIHRoZSBub2RlcyBvZiB0aGlzIGdyb3VwLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3Qgd2lsbCBiZSBtb2lmaWVkIGluIHBsYWNlXG4gKi9cblBhcnNlci5wcm90b3R5cGUuZm9ybUxpZ2F0dXJlcyA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIG4gPSBncm91cC5sZW5ndGggLSAxO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgdmFyIGEgPSBncm91cFtpXTtcbiAgICAgICAgdmFyIHYgPSBhLnZhbHVlO1xuICAgICAgICBpZiAodiA9PT0gXCItXCIgJiYgZ3JvdXBbaSArIDFdLnZhbHVlID09PSBcIi1cIikge1xuICAgICAgICAgICAgaWYgKGkgKyAxIDwgbiAmJiBncm91cFtpICsgMl0udmFsdWUgPT09IFwiLVwiKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAuc3BsaWNlKGksIDMsIG5ldyBQYXJzZU5vZGUoXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dG9yZFwiLCBcIi0tLVwiLCBcInRleHRcIiwgYSwgZ3JvdXBbaSArIDJdKSk7XG4gICAgICAgICAgICAgICAgbiAtPSAyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBncm91cC5zcGxpY2UoaSwgMiwgbmV3IFBhcnNlTm9kZShcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0b3JkXCIsIFwiLS1cIiwgXCJ0ZXh0XCIsIGEsIGdyb3VwW2kgKyAxXSkpO1xuICAgICAgICAgICAgICAgIG4gLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKHYgPT09IFwiJ1wiIHx8IHYgPT09IFwiYFwiKSAmJiBncm91cFtpICsgMV0udmFsdWUgPT09IHYpIHtcbiAgICAgICAgICAgIGdyb3VwLnNwbGljZShpLCAyLCBuZXcgUGFyc2VOb2RlKFxuICAgICAgICAgICAgICAgIFwidGV4dG9yZFwiLCB2ICsgdiwgXCJ0ZXh0XCIsIGEsIGdyb3VwW2kgKyAxXSkpO1xuICAgICAgICAgICAgbiAtPSAxO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBQYXJzZSBhIHNpbmdsZSBzeW1ib2wgb3V0IG9mIHRoZSBzdHJpbmcuIEhlcmUsIHdlIGhhbmRsZSBib3RoIHRoZSBmdW5jdGlvbnNcbiAqIHdlIGhhdmUgZGVmaW5lZCwgYXMgd2VsbCBhcyB0aGUgc2luZ2xlIGNoYXJhY3RlciBzeW1ib2xzXG4gKlxuICogQHJldHVybiB7P1BhcnNlRnVuY09yQXJndW1lbnR9XG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VTeW1ib2wgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbnVjbGV1cyA9IHRoaXMubmV4dFRva2VuO1xuXG4gICAgaWYgKGZ1bmN0aW9uc1tudWNsZXVzLnRleHRdKSB7XG4gICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICAvLyBJZiB0aGVyZSBleGlzdHMgYSBmdW5jdGlvbiB3aXRoIHRoaXMgbmFtZSwgd2UgcmV0dXJuIHRoZSBmdW5jdGlvbiBhbmRcbiAgICAgICAgLy8gc2F5IHRoYXQgaXQgaXMgYSBmdW5jdGlvbi5cbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUZ1bmNPckFyZ3VtZW50KFxuICAgICAgICAgICAgbnVjbGV1cy50ZXh0LFxuICAgICAgICAgICAgdHJ1ZSwgbnVjbGV1cyk7XG4gICAgfSBlbHNlIGlmIChzeW1ib2xzW3RoaXMubW9kZV1bbnVjbGV1cy50ZXh0XSkge1xuICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGlmIHRoaXMgaXMgYSBuby1hcmd1bWVudCBmdW5jdGlvbiwgZmluZCB0aGUgdHlwZSBpdFxuICAgICAgICAvLyBjb3JyZXNwb25kcyB0byBpbiB0aGUgc3ltYm9scyBtYXBcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUZ1bmNPckFyZ3VtZW50KFxuICAgICAgICAgICAgbmV3IFBhcnNlTm9kZShzeW1ib2xzW3RoaXMubW9kZV1bbnVjbGV1cy50ZXh0XS5ncm91cCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbnVjbGV1cy50ZXh0LCB0aGlzLm1vZGUsIG51Y2xldXMpLFxuICAgICAgICAgICAgZmFsc2UsIG51Y2xldXMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSBcInRleHRcIiAmJiBjamtSZWdleC50ZXN0KG51Y2xldXMudGV4dCkpIHtcbiAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VGdW5jT3JBcmd1bWVudChcbiAgICAgICAgICAgIG5ldyBQYXJzZU5vZGUoXCJ0ZXh0b3JkXCIsIG51Y2xldXMudGV4dCwgdGhpcy5tb2RlLCBudWNsZXVzKSxcbiAgICAgICAgICAgIGZhbHNlLCBudWNsZXVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLlBhcnNlTm9kZSA9IFBhcnNlTm9kZTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXI7XG4iLCIvKipcbiAqIFRoaXMgaXMgYSBtb2R1bGUgZm9yIHN0b3Jpbmcgc2V0dGluZ3MgcGFzc2VkIGludG8gS2FUZVguIEl0IGNvcnJlY3RseSBoYW5kbGVzXG4gKiBkZWZhdWx0IHNldHRpbmdzLlxuICovXG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIGZvciBnZXR0aW5nIGEgZGVmYXVsdCB2YWx1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGdldChvcHRpb24sIGRlZmF1bHRWYWx1ZSkge1xuICAgIHJldHVybiBvcHRpb24gPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IG9wdGlvbjtcbn1cblxuLyoqXG4gKiBUaGUgbWFpbiBTZXR0aW5ncyBvYmplY3RcbiAqXG4gKiBUaGUgY3VycmVudCBvcHRpb25zIHN0b3JlZCBhcmU6XG4gKiAgLSBkaXNwbGF5TW9kZTogV2hldGhlciB0aGUgZXhwcmVzc2lvbiBzaG91bGQgYmUgdHlwZXNldCBieSBkZWZhdWx0IGluXG4gKiAgICAgICAgICAgICAgICAgdGV4dHN0eWxlIG9yIGRpc3BsYXlzdHlsZSAoZGVmYXVsdCBmYWxzZSlcbiAqL1xuZnVuY3Rpb24gU2V0dGluZ3Mob3B0aW9ucykge1xuICAgIC8vIGFsbG93IG51bGwgb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuZGlzcGxheU1vZGUgPSBnZXQob3B0aW9ucy5kaXNwbGF5TW9kZSwgZmFsc2UpO1xuICAgIHRoaXMudGhyb3dPbkVycm9yID0gZ2V0KG9wdGlvbnMudGhyb3dPbkVycm9yLCB0cnVlKTtcbiAgICB0aGlzLmVycm9yQ29sb3IgPSBnZXQob3B0aW9ucy5lcnJvckNvbG9yLCBcIiNjYzAwMDBcIik7XG4gICAgdGhpcy5tYWNyb3MgPSBvcHRpb25zLm1hY3JvcyB8fCB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZXR0aW5ncztcbiIsIi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFuZCBjbGFzc2VzIGZvciB0aGUgdmFyaW91cyBraW5kcyBvZiBzdHlsZXNcbiAqIHVzZWQgaW4gVGVYLiBJdCBwcm92aWRlcyBhIGdlbmVyaWMgYFN0eWxlYCBjbGFzcywgd2hpY2ggaG9sZHMgaW5mb3JtYXRpb25cbiAqIGFib3V0IGEgc3BlY2lmaWMgc3R5bGUuIEl0IHRoZW4gcHJvdmlkZXMgaW5zdGFuY2VzIG9mIGFsbCB0aGUgZGlmZmVyZW50IGtpbmRzXG4gKiBvZiBzdHlsZXMgcG9zc2libGUsIGFuZCBwcm92aWRlcyBmdW5jdGlvbnMgdG8gbW92ZSBiZXR3ZWVuIHRoZW0gYW5kIGdldFxuICogaW5mb3JtYXRpb24gYWJvdXQgdGhlbS5cbiAqL1xuXG52YXIgc2lnbWFzID0gcmVxdWlyZShcIi4vZm9udE1ldHJpY3MuanNcIikuc2lnbWFzO1xuXG52YXIgbWV0cmljcyA9IFt7fSwge30sIHt9XTtcbnZhciBpO1xuZm9yICh2YXIga2V5IGluIHNpZ21hcykge1xuICAgIGlmIChzaWdtYXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICBtZXRyaWNzW2ldW2tleV0gPSBzaWdtYXNba2V5XVtpXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICBtZXRyaWNzW2ldLmVtUGVyRXggPSBzaWdtYXMueEhlaWdodFtpXSAvIHNpZ21hcy5xdWFkW2ldO1xufVxuXG4vKipcbiAqIFRoZSBtYWluIHN0eWxlIGNsYXNzLiBDb250YWlucyBhIHVuaXF1ZSBpZCBmb3IgdGhlIHN0eWxlLCBhIHNpemUgKHdoaWNoIGlzXG4gKiB0aGUgc2FtZSBmb3IgY3JhbXBlZCBhbmQgdW5jcmFtcGVkIHZlcnNpb24gb2YgYSBzdHlsZSksIGEgY3JhbXBlZCBmbGFnLCBhbmQgYVxuICogc2l6ZSBtdWx0aXBsaWVyLCB3aGljaCBnaXZlcyB0aGUgc2l6ZSBkaWZmZXJlbmNlIGJldHdlZW4gYSBzdHlsZSBhbmRcbiAqIHRleHRzdHlsZS5cbiAqL1xuZnVuY3Rpb24gU3R5bGUoaWQsIHNpemUsIG11bHRpcGxpZXIsIGNyYW1wZWQpIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLmNyYW1wZWQgPSBjcmFtcGVkO1xuICAgIHRoaXMuc2l6ZU11bHRpcGxpZXIgPSBtdWx0aXBsaWVyO1xuICAgIHRoaXMubWV0cmljcyA9IG1ldHJpY3Nbc2l6ZSA+IDAgPyBzaXplIC0gMSA6IDBdO1xufVxuXG4vKipcbiAqIEdldCB0aGUgc3R5bGUgb2YgYSBzdXBlcnNjcmlwdCBnaXZlbiBhIGJhc2UgaW4gdGhlIGN1cnJlbnQgc3R5bGUuXG4gKi9cblN0eWxlLnByb3RvdHlwZS5zdXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc3R5bGVzW3N1cFt0aGlzLmlkXV07XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc3R5bGUgb2YgYSBzdWJzY3JpcHQgZ2l2ZW4gYSBiYXNlIGluIHRoZSBjdXJyZW50IHN0eWxlLlxuICovXG5TdHlsZS5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHN0eWxlc1tzdWJbdGhpcy5pZF1dO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHN0eWxlIG9mIGEgZnJhY3Rpb24gbnVtZXJhdG9yIGdpdmVuIHRoZSBmcmFjdGlvbiBpbiB0aGUgY3VycmVudFxuICogc3R5bGUuXG4gKi9cblN0eWxlLnByb3RvdHlwZS5mcmFjTnVtID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHN0eWxlc1tmcmFjTnVtW3RoaXMuaWRdXTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBzdHlsZSBvZiBhIGZyYWN0aW9uIGRlbm9taW5hdG9yIGdpdmVuIHRoZSBmcmFjdGlvbiBpbiB0aGUgY3VycmVudFxuICogc3R5bGUuXG4gKi9cblN0eWxlLnByb3RvdHlwZS5mcmFjRGVuID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHN0eWxlc1tmcmFjRGVuW3RoaXMuaWRdXTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjcmFtcGVkIHZlcnNpb24gb2YgYSBzdHlsZSAoaW4gcGFydGljdWxhciwgY3JhbXBpbmcgYSBjcmFtcGVkIHN0eWxlXG4gKiBkb2Vzbid0IGNoYW5nZSB0aGUgc3R5bGUpLlxuICovXG5TdHlsZS5wcm90b3R5cGUuY3JhbXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc3R5bGVzW2NyYW1wW3RoaXMuaWRdXTtcbn07XG5cbi8qKlxuICogSFRNTCBjbGFzcyBuYW1lLCBsaWtlIFwiZGlzcGxheXN0eWxlIGNyYW1wZWRcIlxuICovXG5TdHlsZS5wcm90b3R5cGUuY2xzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNpemVOYW1lc1t0aGlzLnNpemVdICsgKHRoaXMuY3JhbXBlZCA/IFwiIGNyYW1wZWRcIiA6IFwiIHVuY3JhbXBlZFwiKTtcbn07XG5cbi8qKlxuICogSFRNTCBSZXNldCBjbGFzcyBuYW1lLCBsaWtlIFwicmVzZXQtdGV4dHN0eWxlXCJcbiAqL1xuU3R5bGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHJlc2V0TmFtZXNbdGhpcy5zaXplXTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGlmIHRoaXMgc3R5bGUgaXMgdGlnaHRseSBzcGFjZWQgKHNjcmlwdHN0eWxlL3NjcmlwdHNjcmlwdHN0eWxlKVxuICovXG5TdHlsZS5wcm90b3R5cGUuaXNUaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNpemUgPj0gMjtcbn07XG5cbi8vIElEcyBvZiB0aGUgZGlmZmVyZW50IHN0eWxlc1xudmFyIEQgPSAwO1xudmFyIERjID0gMTtcbnZhciBUID0gMjtcbnZhciBUYyA9IDM7XG52YXIgUyA9IDQ7XG52YXIgU2MgPSA1O1xudmFyIFNTID0gNjtcbnZhciBTU2MgPSA3O1xuXG4vLyBTdHJpbmcgbmFtZXMgZm9yIHRoZSBkaWZmZXJlbnQgc2l6ZXNcbnZhciBzaXplTmFtZXMgPSBbXG4gICAgXCJkaXNwbGF5c3R5bGUgdGV4dHN0eWxlXCIsXG4gICAgXCJ0ZXh0c3R5bGVcIixcbiAgICBcInNjcmlwdHN0eWxlXCIsXG4gICAgXCJzY3JpcHRzY3JpcHRzdHlsZVwiXG5dO1xuXG4vLyBSZXNldCBuYW1lcyBmb3IgdGhlIGRpZmZlcmVudCBzaXplc1xudmFyIHJlc2V0TmFtZXMgPSBbXG4gICAgXCJyZXNldC10ZXh0c3R5bGVcIixcbiAgICBcInJlc2V0LXRleHRzdHlsZVwiLFxuICAgIFwicmVzZXQtc2NyaXB0c3R5bGVcIixcbiAgICBcInJlc2V0LXNjcmlwdHNjcmlwdHN0eWxlXCJcbl07XG5cbi8vIEluc3RhbmNlcyBvZiB0aGUgZGlmZmVyZW50IHN0eWxlc1xudmFyIHN0eWxlcyA9IFtcbiAgICBuZXcgU3R5bGUoRCwgMCwgMS4wLCBmYWxzZSksXG4gICAgbmV3IFN0eWxlKERjLCAwLCAxLjAsIHRydWUpLFxuICAgIG5ldyBTdHlsZShULCAxLCAxLjAsIGZhbHNlKSxcbiAgICBuZXcgU3R5bGUoVGMsIDEsIDEuMCwgdHJ1ZSksXG4gICAgbmV3IFN0eWxlKFMsIDIsIDAuNywgZmFsc2UpLFxuICAgIG5ldyBTdHlsZShTYywgMiwgMC43LCB0cnVlKSxcbiAgICBuZXcgU3R5bGUoU1MsIDMsIDAuNSwgZmFsc2UpLFxuICAgIG5ldyBTdHlsZShTU2MsIDMsIDAuNSwgdHJ1ZSlcbl07XG5cbi8vIExvb2t1cCB0YWJsZXMgZm9yIHN3aXRjaGluZyBmcm9tIG9uZSBzdHlsZSB0byBhbm90aGVyXG52YXIgc3VwID0gW1MsIFNjLCBTLCBTYywgU1MsIFNTYywgU1MsIFNTY107XG52YXIgc3ViID0gW1NjLCBTYywgU2MsIFNjLCBTU2MsIFNTYywgU1NjLCBTU2NdO1xudmFyIGZyYWNOdW0gPSBbVCwgVGMsIFMsIFNjLCBTUywgU1NjLCBTUywgU1NjXTtcbnZhciBmcmFjRGVuID0gW1RjLCBUYywgU2MsIFNjLCBTU2MsIFNTYywgU1NjLCBTU2NdO1xudmFyIGNyYW1wID0gW0RjLCBEYywgVGMsIFRjLCBTYywgU2MsIFNTYywgU1NjXTtcblxuLy8gV2Ugb25seSBleHBvcnQgc29tZSBvZiB0aGUgc3R5bGVzLiBBbHNvLCB3ZSBkb24ndCBleHBvcnQgdGhlIGBTdHlsZWAgY2xhc3Mgc29cbi8vIG5vIG1vcmUgc3R5bGVzIGNhbiBiZSBnZW5lcmF0ZWQuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBESVNQTEFZOiBzdHlsZXNbRF0sXG4gICAgVEVYVDogc3R5bGVzW1RdLFxuICAgIFNDUklQVDogc3R5bGVzW1NdLFxuICAgIFNDUklQVFNDUklQVDogc3R5bGVzW1NTXVxufTtcbiIsIi8qIGVzbGludCBuby1jb25zb2xlOjAgKi9cbi8qKlxuICogVGhpcyBtb2R1bGUgY29udGFpbnMgZ2VuZXJhbCBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgYnVpbGRpbmdcbiAqIGRpZmZlcmVudCBraW5kcyBvZiBkb21UcmVlIG5vZGVzIGluIGEgY29uc2lzdGVudCBtYW5uZXIuXG4gKi9cblxudmFyIGRvbVRyZWUgPSByZXF1aXJlKFwiLi9kb21UcmVlXCIpO1xudmFyIGZvbnRNZXRyaWNzID0gcmVxdWlyZShcIi4vZm9udE1ldHJpY3NcIik7XG52YXIgc3ltYm9scyA9IHJlcXVpcmUoXCIuL3N5bWJvbHNcIik7XG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcblxudmFyIGdyZWVrQ2FwaXRhbHMgPSBbXG4gICAgXCJcXFxcR2FtbWFcIixcbiAgICBcIlxcXFxEZWx0YVwiLFxuICAgIFwiXFxcXFRoZXRhXCIsXG4gICAgXCJcXFxcTGFtYmRhXCIsXG4gICAgXCJcXFxcWGlcIixcbiAgICBcIlxcXFxQaVwiLFxuICAgIFwiXFxcXFNpZ21hXCIsXG4gICAgXCJcXFxcVXBzaWxvblwiLFxuICAgIFwiXFxcXFBoaVwiLFxuICAgIFwiXFxcXFBzaVwiLFxuICAgIFwiXFxcXE9tZWdhXCJcbl07XG5cbi8vIFRoZSBmb2xsb3dpbmcgaGF2ZSB0byBiZSBsb2FkZWQgZnJvbSBNYWluLUl0YWxpYyBmb250LCB1c2luZyBjbGFzcyBtYWluaXRcbnZhciBtYWluaXRMZXR0ZXJzID0gW1xuICAgIFwiXFx1MDEzMVwiLCAgIC8vIGRvdGxlc3MgaSwgXFxpbWF0aFxuICAgIFwiXFx1MDIzN1wiLCAgIC8vIGRvdGxlc3MgaiwgXFxqbWF0aFxuICAgIFwiXFx1MDBhM1wiICAgLy8gXFxwb3VuZHNcbl07XG5cbi8qKlxuICogTWFrZXMgYSBzeW1ib2xOb2RlIGFmdGVyIHRyYW5zbGF0aW9uIHZpYSB0aGUgbGlzdCBvZiBzeW1ib2xzIGluIHN5bWJvbHMuanMuXG4gKiBDb3JyZWN0bHkgcHVsbHMgb3V0IG1ldHJpY3MgZm9yIHRoZSBjaGFyYWN0ZXIsIGFuZCBvcHRpb25hbGx5IHRha2VzIGEgbGlzdCBvZlxuICogY2xhc3NlcyB0byBiZSBhdHRhY2hlZCB0byB0aGUgbm9kZS5cbiAqXG4gKiBUT0RPOiBtYWtlIGFyZ3VtZW50IG9yZGVyIGNsb3NlciB0byBtYWtlU3BhblxuICogVE9ETzogYWRkIGEgc2VwYXJhdGUgYXJndW1lbnQgZm9yIG1hdGggY2xhc3MgKGUuZy4gYG1vcGAsIGBtYmluYCksIHdoaWNoXG4gKiBzaG91bGQgaWYgcHJlc2VudCBjb21lIGZpcnN0IGluIGBjbGFzc2VzYC5cbiAqL1xudmFyIG1ha2VTeW1ib2wgPSBmdW5jdGlvbih2YWx1ZSwgZm9udEZhbWlseSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcykge1xuICAgIC8vIFJlcGxhY2UgdGhlIHZhbHVlIHdpdGggaXRzIHJlcGxhY2VkIHZhbHVlIGZyb20gc3ltYm9sLmpzXG4gICAgaWYgKHN5bWJvbHNbbW9kZV1bdmFsdWVdICYmIHN5bWJvbHNbbW9kZV1bdmFsdWVdLnJlcGxhY2UpIHtcbiAgICAgICAgdmFsdWUgPSBzeW1ib2xzW21vZGVdW3ZhbHVlXS5yZXBsYWNlO1xuICAgIH1cblxuICAgIHZhciBtZXRyaWNzID0gZm9udE1ldHJpY3MuZ2V0Q2hhcmFjdGVyTWV0cmljcyh2YWx1ZSwgZm9udEZhbWlseSk7XG5cbiAgICB2YXIgc3ltYm9sTm9kZTtcbiAgICBpZiAobWV0cmljcykge1xuICAgICAgICB2YXIgaXRhbGljID0gbWV0cmljcy5pdGFsaWM7XG4gICAgICAgIGlmIChtb2RlID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgaXRhbGljID0gMDtcbiAgICAgICAgfVxuICAgICAgICBzeW1ib2xOb2RlID0gbmV3IGRvbVRyZWUuc3ltYm9sTm9kZShcbiAgICAgICAgICAgIHZhbHVlLCBtZXRyaWNzLmhlaWdodCwgbWV0cmljcy5kZXB0aCwgaXRhbGljLCBtZXRyaWNzLnNrZXcsXG4gICAgICAgICAgICBjbGFzc2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPKGVtaWx5KTogRmlndXJlIG91dCBhIGdvb2Qgd2F5IHRvIG9ubHkgcHJpbnQgdGhpcyBpbiBkZXZlbG9wbWVudFxuICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBcIk5vIGNoYXJhY3RlciBtZXRyaWNzIGZvciAnXCIgKyB2YWx1ZSArIFwiJyBpbiBzdHlsZSAnXCIgK1xuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHkgKyBcIidcIik7XG4gICAgICAgIHN5bWJvbE5vZGUgPSBuZXcgZG9tVHJlZS5zeW1ib2xOb2RlKHZhbHVlLCAwLCAwLCAwLCAwLCBjbGFzc2VzKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5zdHlsZS5pc1RpZ2h0KCkpIHtcbiAgICAgICAgICAgIHN5bWJvbE5vZGUuY2xhc3Nlcy5wdXNoKFwibXRpZ2h0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmdldENvbG9yKCkpIHtcbiAgICAgICAgICAgIHN5bWJvbE5vZGUuc3R5bGUuY29sb3IgPSBvcHRpb25zLmdldENvbG9yKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3ltYm9sTm9kZTtcbn07XG5cbi8qKlxuICogTWFrZXMgYSBzeW1ib2wgaW4gTWFpbi1SZWd1bGFyIG9yIEFNUy1SZWd1bGFyLlxuICogVXNlZCBmb3IgcmVsLCBiaW4sIG9wZW4sIGNsb3NlLCBpbm5lciwgYW5kIHB1bmN0LlxuICovXG52YXIgbWF0aHN5bSA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzKSB7XG4gICAgLy8gRGVjaWRlIHdoYXQgZm9udCB0byByZW5kZXIgdGhlIHN5bWJvbCBpbiBieSBpdHMgZW50cnkgaW4gdGhlIHN5bWJvbHNcbiAgICAvLyB0YWJsZS5cbiAgICAvLyBIYXZlIGEgc3BlY2lhbCBjYXNlIGZvciB3aGVuIHRoZSB2YWx1ZSA9IFxcIGJlY2F1c2UgdGhlIFxcIGlzIHVzZWQgYXMgYVxuICAgIC8vIHRleHRvcmQgaW4gdW5zdXBwb3J0ZWQgY29tbWFuZCBlcnJvcnMgYnV0IGNhbm5vdCBiZSBwYXJzZWQgYXMgYSByZWd1bGFyXG4gICAgLy8gdGV4dCBvcmRpbmFsIGFuZCBpcyB0aGVyZWZvcmUgbm90IHByZXNlbnQgYXMgYSBzeW1ib2wgaW4gdGhlIHN5bWJvbHNcbiAgICAvLyB0YWJsZSBmb3IgdGV4dFxuICAgIGlmICh2YWx1ZSA9PT0gXCJcXFxcXCIgfHwgc3ltYm9sc1ttb2RlXVt2YWx1ZV0uZm9udCA9PT0gXCJtYWluXCIpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VTeW1ib2wodmFsdWUsIFwiTWFpbi1SZWd1bGFyXCIsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtYWtlU3ltYm9sKFxuICAgICAgICAgICAgdmFsdWUsIFwiQU1TLVJlZ3VsYXJcIiwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcy5jb25jYXQoW1wiYW1zcm1cIl0pKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIE1ha2VzIGEgc3ltYm9sIGluIHRoZSBkZWZhdWx0IGZvbnQgZm9yIG1hdGhvcmRzIGFuZCB0ZXh0b3Jkcy5cbiAqL1xudmFyIG1hdGhEZWZhdWx0ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMsIHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gXCJtYXRob3JkXCIpIHtcbiAgICAgICAgcmV0dXJuIG1hdGhpdCh2YWx1ZSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcInRleHRvcmRcIikge1xuICAgICAgICByZXR1cm4gbWFrZVN5bWJvbChcbiAgICAgICAgICAgIHZhbHVlLCBcIk1haW4tUmVndWxhclwiLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdChbXCJtYXRocm1cIl0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIHR5cGU6IFwiICsgdHlwZSArIFwiIGluIG1hdGhEZWZhdWx0XCIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogTWFrZXMgYSBzeW1ib2wgaW4gdGhlIGl0YWxpYyBtYXRoIGZvbnQuXG4gKi9cbnZhciBtYXRoaXQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcykge1xuICAgIGlmICgvWzAtOV0vLnRlc3QodmFsdWUuY2hhckF0KDApKSB8fFxuICAgICAgICAgICAgLy8gZ2x5cGhzIGZvciBcXGltYXRoIGFuZCBcXGptYXRoIGRvIG5vdCBleGlzdCBpbiBNYXRoLUl0YWxpYyBzbyB3ZVxuICAgICAgICAgICAgLy8gbmVlZCB0byB1c2UgTWFpbi1JdGFsaWMgaW5zdGVhZFxuICAgICAgICAgICAgdXRpbHMuY29udGFpbnMobWFpbml0TGV0dGVycywgdmFsdWUpIHx8XG4gICAgICAgICAgICB1dGlscy5jb250YWlucyhncmVla0NhcGl0YWxzLCB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VTeW1ib2woXG4gICAgICAgICAgICB2YWx1ZSwgXCJNYWluLUl0YWxpY1wiLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdChbXCJtYWluaXRcIl0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWFrZVN5bWJvbChcbiAgICAgICAgICAgIHZhbHVlLCBcIk1hdGgtSXRhbGljXCIsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMuY29uY2F0KFtcIm1hdGhpdFwiXSkpO1xuICAgIH1cbn07XG5cbi8qKlxuICogTWFrZXMgZWl0aGVyIGEgbWF0aG9yZCBvciB0ZXh0b3JkIGluIHRoZSBjb3JyZWN0IGZvbnQgYW5kIGNvbG9yLlxuICovXG52YXIgbWFrZU9yZCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zLCB0eXBlKSB7XG4gICAgdmFyIG1vZGUgPSBncm91cC5tb2RlO1xuICAgIHZhciB2YWx1ZSA9IGdyb3VwLnZhbHVlO1xuICAgIGlmIChzeW1ib2xzW21vZGVdW3ZhbHVlXSAmJiBzeW1ib2xzW21vZGVdW3ZhbHVlXS5yZXBsYWNlKSB7XG4gICAgICAgIHZhbHVlID0gc3ltYm9sc1ttb2RlXVt2YWx1ZV0ucmVwbGFjZTtcbiAgICB9XG5cbiAgICB2YXIgY2xhc3NlcyA9IFtcIm1vcmRcIl07XG5cbiAgICB2YXIgZm9udCA9IG9wdGlvbnMuZm9udDtcbiAgICBpZiAoZm9udCkge1xuICAgICAgICBpZiAoZm9udCA9PT0gXCJtYXRoaXRcIiB8fCB1dGlscy5jb250YWlucyhtYWluaXRMZXR0ZXJzLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRoaXQodmFsdWUsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZvbnROYW1lID0gZm9udE1hcFtmb250XS5mb250TmFtZTtcbiAgICAgICAgICAgIGlmIChmb250TWV0cmljcy5nZXRDaGFyYWN0ZXJNZXRyaWNzKHZhbHVlLCBmb250TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZVN5bWJvbChcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsIGZvbnROYW1lLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdChbZm9udF0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGhEZWZhdWx0KHZhbHVlLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtYXRoRGVmYXVsdCh2YWx1ZSwgbW9kZSwgb3B0aW9ucywgY2xhc3NlcywgdHlwZSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGhlaWdodCwgZGVwdGgsIGFuZCBtYXhGb250U2l6ZSBvZiBhbiBlbGVtZW50IGJhc2VkIG9uIGl0c1xuICogY2hpbGRyZW4uXG4gKi9cbnZhciBzaXplRWxlbWVudEZyb21DaGlsZHJlbiA9IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICB2YXIgaGVpZ2h0ID0gMDtcbiAgICB2YXIgZGVwdGggPSAwO1xuICAgIHZhciBtYXhGb250U2l6ZSA9IDA7XG5cbiAgICBpZiAoZWxlbS5jaGlsZHJlbikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW0uY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlbGVtLmNoaWxkcmVuW2ldLmhlaWdodCA+IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IGVsZW0uY2hpbGRyZW5baV0uaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsZW0uY2hpbGRyZW5baV0uZGVwdGggPiBkZXB0aCkge1xuICAgICAgICAgICAgICAgIGRlcHRoID0gZWxlbS5jaGlsZHJlbltpXS5kZXB0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbGVtLmNoaWxkcmVuW2ldLm1heEZvbnRTaXplID4gbWF4Rm9udFNpemUpIHtcbiAgICAgICAgICAgICAgICBtYXhGb250U2l6ZSA9IGVsZW0uY2hpbGRyZW5baV0ubWF4Rm9udFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlbGVtLmhlaWdodCA9IGhlaWdodDtcbiAgICBlbGVtLmRlcHRoID0gZGVwdGg7XG4gICAgZWxlbS5tYXhGb250U2l6ZSA9IG1heEZvbnRTaXplO1xufTtcblxuLyoqXG4gKiBNYWtlcyBhIHNwYW4gd2l0aCB0aGUgZ2l2ZW4gbGlzdCBvZiBjbGFzc2VzLCBsaXN0IG9mIGNoaWxkcmVuLCBhbmQgb3B0aW9ucy5cbiAqXG4gKiBUT0RPOiBFbnN1cmUgdGhhdCBgb3B0aW9uc2AgaXMgYWx3YXlzIHByb3ZpZGVkIChjdXJyZW50bHkgc29tZSBjYWxsIHNpdGVzXG4gKiBkb24ndCBwYXNzIGl0KS5cbiAqIFRPRE86IGFkZCBhIHNlcGFyYXRlIGFyZ3VtZW50IGZvciBtYXRoIGNsYXNzIChlLmcuIGBtb3BgLCBgbWJpbmApLCB3aGljaFxuICogc2hvdWxkIGlmIHByZXNlbnQgY29tZSBmaXJzdCBpbiBgY2xhc3Nlc2AuXG4gKi9cbnZhciBtYWtlU3BhbiA9IGZ1bmN0aW9uKGNsYXNzZXMsIGNoaWxkcmVuLCBvcHRpb25zKSB7XG4gICAgdmFyIHNwYW4gPSBuZXcgZG9tVHJlZS5zcGFuKGNsYXNzZXMsIGNoaWxkcmVuLCBvcHRpb25zKTtcblxuICAgIHNpemVFbGVtZW50RnJvbUNoaWxkcmVuKHNwYW4pO1xuXG4gICAgcmV0dXJuIHNwYW47XG59O1xuXG4vKipcbiAqIFByZXBlbmRzIHRoZSBnaXZlbiBjaGlsZHJlbiB0byB0aGUgZ2l2ZW4gc3BhbiwgdXBkYXRpbmcgaGVpZ2h0LCBkZXB0aCwgYW5kXG4gKiBtYXhGb250U2l6ZS5cbiAqL1xudmFyIHByZXBlbmRDaGlsZHJlbiA9IGZ1bmN0aW9uKHNwYW4sIGNoaWxkcmVuKSB7XG4gICAgc3Bhbi5jaGlsZHJlbiA9IGNoaWxkcmVuLmNvbmNhdChzcGFuLmNoaWxkcmVuKTtcblxuICAgIHNpemVFbGVtZW50RnJvbUNoaWxkcmVuKHNwYW4pO1xufTtcblxuLyoqXG4gKiBNYWtlcyBhIGRvY3VtZW50IGZyYWdtZW50IHdpdGggdGhlIGdpdmVuIGxpc3Qgb2YgY2hpbGRyZW4uXG4gKi9cbnZhciBtYWtlRnJhZ21lbnQgPSBmdW5jdGlvbihjaGlsZHJlbikge1xuICAgIHZhciBmcmFnbWVudCA9IG5ldyBkb21UcmVlLmRvY3VtZW50RnJhZ21lbnQoY2hpbGRyZW4pO1xuXG4gICAgc2l6ZUVsZW1lbnRGcm9tQ2hpbGRyZW4oZnJhZ21lbnQpO1xuXG4gICAgcmV0dXJuIGZyYWdtZW50O1xufTtcblxuLyoqXG4gKiBNYWtlcyBhbiBlbGVtZW50IHBsYWNlZCBpbiBlYWNoIG9mIHRoZSB2bGlzdCBlbGVtZW50cyB0byBlbnN1cmUgdGhhdCBlYWNoXG4gKiBlbGVtZW50IGhhcyB0aGUgc2FtZSBtYXggZm9udCBzaXplLiBUbyBkbyB0aGlzLCB3ZSBjcmVhdGUgYSB6ZXJvLXdpZHRoIHNwYWNlXG4gKiB3aXRoIHRoZSBjb3JyZWN0IGZvbnQgc2l6ZS5cbiAqL1xudmFyIG1ha2VGb250U2l6ZXIgPSBmdW5jdGlvbihvcHRpb25zLCBmb250U2l6ZSkge1xuICAgIHZhciBmb250U2l6ZUlubmVyID0gbWFrZVNwYW4oW10sIFtuZXcgZG9tVHJlZS5zeW1ib2xOb2RlKFwiXFx1MjAwYlwiKV0pO1xuICAgIGZvbnRTaXplSW5uZXIuc3R5bGUuZm9udFNpemUgPVxuICAgICAgICAoZm9udFNpemUgLyBvcHRpb25zLnN0eWxlLnNpemVNdWx0aXBsaWVyKSArIFwiZW1cIjtcblxuICAgIHZhciBmb250U2l6ZXIgPSBtYWtlU3BhbihcbiAgICAgICAgW1wiZm9udHNpemUtZW5zdXJlclwiLCBcInJlc2V0LVwiICsgb3B0aW9ucy5zaXplLCBcInNpemU1XCJdLFxuICAgICAgICBbZm9udFNpemVJbm5lcl0pO1xuXG4gICAgcmV0dXJuIGZvbnRTaXplcjtcbn07XG5cbi8qKlxuICogTWFrZXMgYSB2ZXJ0aWNhbCBsaXN0IGJ5IHN0YWNraW5nIGVsZW1lbnRzIGFuZCBrZXJucyBvbiB0b3Agb2YgZWFjaCBvdGhlci5cbiAqIEFsbG93cyBmb3IgbWFueSBkaWZmZXJlbnQgd2F5cyBvZiBzcGVjaWZ5aW5nIHRoZSBwb3NpdGlvbmluZyBtZXRob2QuXG4gKlxuICogQXJndW1lbnRzOlxuICogIC0gY2hpbGRyZW46IEEgbGlzdCBvZiBjaGlsZCBvciBrZXJuIG5vZGVzIHRvIGJlIHN0YWNrZWQgb24gdG9wIG9mIGVhY2ggb3RoZXJcbiAqICAgICAgICAgICAgICAoaS5lLiB0aGUgZmlyc3QgZWxlbWVudCB3aWxsIGJlIGF0IHRoZSBib3R0b20sIGFuZCB0aGUgbGFzdCBhdFxuICogICAgICAgICAgICAgIHRoZSB0b3ApLiBFbGVtZW50IG5vZGVzIGFyZSBzcGVjaWZpZWQgYXNcbiAqICAgICAgICAgICAgICAgIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogbm9kZX1cbiAqICAgICAgICAgICAgICB3aGlsZSBrZXJuIG5vZGVzIGFyZSBzcGVjaWZpZWQgYXNcbiAqICAgICAgICAgICAgICAgIHt0eXBlOiBcImtlcm5cIiwgc2l6ZTogc2l6ZX1cbiAqICAtIHBvc2l0aW9uVHlwZTogVGhlIG1ldGhvZCBieSB3aGljaCB0aGUgdmxpc3Qgc2hvdWxkIGJlIHBvc2l0aW9uZWQuIFZhbGlkXG4gKiAgICAgICAgICAgICAgICAgIHZhbHVlcyBhcmU6XG4gKiAgICAgICAgICAgICAgICAgICAtIFwiaW5kaXZpZHVhbFNoaWZ0XCI6IFRoZSBjaGlsZHJlbiBsaXN0IG9ubHkgY29udGFpbnMgZWxlbVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMsIGFuZCBlYWNoIG5vZGUgY29udGFpbnMgYW4gZXh0cmFcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic2hpZnRcIiB2YWx1ZSBvZiBob3cgbXVjaCBpdCBzaG91bGQgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0ZWQgKG5vdGUgdGhhdCBzaGlmdGluZyBpcyBhbHdheXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdmluZyBkb3dud2FyZHMpLiBwb3NpdGlvbkRhdGEgaXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZWQuXG4gKiAgICAgICAgICAgICAgICAgICAtIFwidG9wXCI6IFRoZSBwb3NpdGlvbkRhdGEgc3BlY2lmaWVzIHRoZSB0b3Btb3N0IHBvaW50IG9mXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgdmxpc3QgKG5vdGUgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhIGhlaWdodCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvIHBvc2l0aXZlIHZhbHVlcyBtb3ZlIHVwKVxuICogICAgICAgICAgICAgICAgICAgLSBcImJvdHRvbVwiOiBUaGUgcG9zaXRpb25EYXRhIHNwZWNpZmllcyB0aGUgYm90dG9tbW9zdCBwb2ludFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIHZsaXN0IChub3RlIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGgsIHNvIHBvc2l0aXZlIHZhbHVlcyBtb3ZlIGRvd25cbiAqICAgICAgICAgICAgICAgICAgIC0gXCJzaGlmdFwiOiBUaGUgdmxpc3Qgd2lsbCBiZSBwb3NpdGlvbmVkIHN1Y2ggdGhhdCBpdHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZWxpbmUgaXMgcG9zaXRpb25EYXRhIGF3YXkgZnJvbSB0aGUgYmFzZWxpbmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIGZpcnN0IGNoaWxkLiBQb3NpdGl2ZSB2YWx1ZXMgbW92ZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3dud2FyZHMuXG4gKiAgICAgICAgICAgICAgICAgICAtIFwiZmlyc3RCYXNlbGluZVwiOiBUaGUgdmxpc3Qgd2lsbCBiZSBwb3NpdGlvbmVkIHN1Y2ggdGhhdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0cyBiYXNlbGluZSBpcyBhbGlnbmVkIHdpdGggdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZWxpbmUgb2YgdGhlIGZpcnN0IGNoaWxkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uRGF0YSBpcyBpZ25vcmVkLiAodGhpcyBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVxdWl2YWxlbnQgdG8gXCJzaGlmdFwiIHdpdGhcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkRhdGE9MClcbiAqICAtIHBvc2l0aW9uRGF0YTogRGF0YSB1c2VkIGluIGRpZmZlcmVudCB3YXlzIGRlcGVuZGluZyBvbiBwb3NpdGlvblR5cGVcbiAqICAtIG9wdGlvbnM6IEFuIE9wdGlvbnMgb2JqZWN0XG4gKlxuICovXG52YXIgbWFrZVZMaXN0ID0gZnVuY3Rpb24oY2hpbGRyZW4sIHBvc2l0aW9uVHlwZSwgcG9zaXRpb25EYXRhLCBvcHRpb25zKSB7XG4gICAgdmFyIGRlcHRoO1xuICAgIHZhciBjdXJyUG9zO1xuICAgIHZhciBpO1xuICAgIGlmIChwb3NpdGlvblR5cGUgPT09IFwiaW5kaXZpZHVhbFNoaWZ0XCIpIHtcbiAgICAgICAgdmFyIG9sZENoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIGNoaWxkcmVuID0gW29sZENoaWxkcmVuWzBdXTtcblxuICAgICAgICAvLyBBZGQgaW4ga2VybnMgdG8gdGhlIGxpc3Qgb2YgY2hpbGRyZW4gdG8gZ2V0IGVhY2ggZWxlbWVudCB0byBiZVxuICAgICAgICAvLyBzaGlmdGVkIHRvIHRoZSBjb3JyZWN0IHNwZWNpZmllZCBzaGlmdFxuICAgICAgICBkZXB0aCA9IC1vbGRDaGlsZHJlblswXS5zaGlmdCAtIG9sZENoaWxkcmVuWzBdLmVsZW0uZGVwdGg7XG4gICAgICAgIGN1cnJQb3MgPSBkZXB0aDtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG9sZENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IC1vbGRDaGlsZHJlbltpXS5zaGlmdCAtIGN1cnJQb3MgLVxuICAgICAgICAgICAgICAgIG9sZENoaWxkcmVuW2ldLmVsZW0uZGVwdGg7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IGRpZmYgLVxuICAgICAgICAgICAgICAgIChvbGRDaGlsZHJlbltpIC0gMV0uZWxlbS5oZWlnaHQgK1xuICAgICAgICAgICAgICAgICBvbGRDaGlsZHJlbltpIC0gMV0uZWxlbS5kZXB0aCk7XG5cbiAgICAgICAgICAgIGN1cnJQb3MgPSBjdXJyUG9zICsgZGlmZjtcblxuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh7dHlwZTogXCJrZXJuXCIsIHNpemU6IHNpemV9KTtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gob2xkQ2hpbGRyZW5baV0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvblR5cGUgPT09IFwidG9wXCIpIHtcbiAgICAgICAgLy8gV2UgYWx3YXlzIHN0YXJ0IGF0IHRoZSBib3R0b20sIHNvIGNhbGN1bGF0ZSB0aGUgYm90dG9tIGJ5IGFkZGluZyB1cFxuICAgICAgICAvLyBhbGwgdGhlIHNpemVzXG4gICAgICAgIHZhciBib3R0b20gPSBwb3NpdGlvbkRhdGE7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IFwia2VyblwiKSB7XG4gICAgICAgICAgICAgICAgYm90dG9tIC09IGNoaWxkcmVuW2ldLnNpemU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJvdHRvbSAtPSBjaGlsZHJlbltpXS5lbGVtLmhlaWdodCArIGNoaWxkcmVuW2ldLmVsZW0uZGVwdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVwdGggPSBib3R0b207XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvblR5cGUgPT09IFwiYm90dG9tXCIpIHtcbiAgICAgICAgZGVwdGggPSAtcG9zaXRpb25EYXRhO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb25UeXBlID09PSBcInNoaWZ0XCIpIHtcbiAgICAgICAgZGVwdGggPSAtY2hpbGRyZW5bMF0uZWxlbS5kZXB0aCAtIHBvc2l0aW9uRGF0YTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uVHlwZSA9PT0gXCJmaXJzdEJhc2VsaW5lXCIpIHtcbiAgICAgICAgZGVwdGggPSAtY2hpbGRyZW5bMF0uZWxlbS5kZXB0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkZXB0aCA9IDA7XG4gICAgfVxuXG4gICAgLy8gTWFrZSB0aGUgZm9udFNpemVyXG4gICAgdmFyIG1heEZvbnRTaXplID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IFwiZWxlbVwiKSB7XG4gICAgICAgICAgICBtYXhGb250U2l6ZSA9IE1hdGgubWF4KG1heEZvbnRTaXplLCBjaGlsZHJlbltpXS5lbGVtLm1heEZvbnRTaXplKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgZm9udFNpemVyID0gbWFrZUZvbnRTaXplcihvcHRpb25zLCBtYXhGb250U2l6ZSk7XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgbGlzdCBvZiBhY3R1YWwgY2hpbGRyZW4gYXQgdGhlIGNvcnJlY3Qgb2Zmc2V0c1xuICAgIHZhciByZWFsQ2hpbGRyZW4gPSBbXTtcbiAgICBjdXJyUG9zID0gZGVwdGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSBcImtlcm5cIikge1xuICAgICAgICAgICAgY3VyclBvcyArPSBjaGlsZHJlbltpXS5zaXplO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV0uZWxlbTtcblxuICAgICAgICAgICAgdmFyIHNoaWZ0ID0gLWNoaWxkLmRlcHRoIC0gY3VyclBvcztcbiAgICAgICAgICAgIGN1cnJQb3MgKz0gY2hpbGQuaGVpZ2h0ICsgY2hpbGQuZGVwdGg7XG5cbiAgICAgICAgICAgIHZhciBjaGlsZFdyYXAgPSBtYWtlU3BhbihbXSwgW2ZvbnRTaXplciwgY2hpbGRdKTtcbiAgICAgICAgICAgIGNoaWxkV3JhcC5oZWlnaHQgLT0gc2hpZnQ7XG4gICAgICAgICAgICBjaGlsZFdyYXAuZGVwdGggKz0gc2hpZnQ7XG4gICAgICAgICAgICBjaGlsZFdyYXAuc3R5bGUudG9wID0gc2hpZnQgKyBcImVtXCI7XG5cbiAgICAgICAgICAgIHJlYWxDaGlsZHJlbi5wdXNoKGNoaWxkV3JhcCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaW4gYW4gZWxlbWVudCBhdCB0aGUgZW5kIHdpdGggbm8gb2Zmc2V0IHRvIGZpeCB0aGUgY2FsY3VsYXRpb24gb2ZcbiAgICAvLyBiYXNlbGluZXMgaW4gc29tZSBicm93c2VycyAobmFtZWx5IElFLCBzb21ldGltZXMgc2FmYXJpKVxuICAgIHZhciBiYXNlbGluZUZpeCA9IG1ha2VTcGFuKFxuICAgICAgICBbXCJiYXNlbGluZS1maXhcIl0sIFtmb250U2l6ZXIsIG5ldyBkb21UcmVlLnN5bWJvbE5vZGUoXCJcXHUyMDBiXCIpXSk7XG4gICAgcmVhbENoaWxkcmVuLnB1c2goYmFzZWxpbmVGaXgpO1xuXG4gICAgdmFyIHZsaXN0ID0gbWFrZVNwYW4oW1widmxpc3RcIl0sIHJlYWxDaGlsZHJlbik7XG4gICAgLy8gRml4IHRoZSBmaW5hbCBoZWlnaHQgYW5kIGRlcHRoLCBpbiBjYXNlIHRoZXJlIHdlcmUga2VybnMgYXQgdGhlIGVuZHNcbiAgICAvLyBzaW5jZSB0aGUgbWFrZVNwYW4gY2FsY3VsYXRpb24gd29uJ3QgdGFrZSB0aGF0IGluIHRvIGFjY291bnQuXG4gICAgdmxpc3QuaGVpZ2h0ID0gTWF0aC5tYXgoY3VyclBvcywgdmxpc3QuaGVpZ2h0KTtcbiAgICB2bGlzdC5kZXB0aCA9IE1hdGgubWF4KC1kZXB0aCwgdmxpc3QuZGVwdGgpO1xuICAgIHJldHVybiB2bGlzdDtcbn07XG5cbi8vIEEgdGFibGUgb2Ygc2l6ZSAtPiBmb250IHNpemUgZm9yIHRoZSBkaWZmZXJlbnQgc2l6aW5nIGZ1bmN0aW9uc1xudmFyIHNpemluZ011bHRpcGxpZXIgPSB7XG4gICAgc2l6ZTE6IDAuNSxcbiAgICBzaXplMjogMC43LFxuICAgIHNpemUzOiAwLjgsXG4gICAgc2l6ZTQ6IDAuOSxcbiAgICBzaXplNTogMS4wLFxuICAgIHNpemU2OiAxLjIsXG4gICAgc2l6ZTc6IDEuNDQsXG4gICAgc2l6ZTg6IDEuNzMsXG4gICAgc2l6ZTk6IDIuMDcsXG4gICAgc2l6ZTEwOiAyLjQ5XG59O1xuXG4vLyBBIG1hcCBvZiBzcGFjaW5nIGZ1bmN0aW9ucyB0byB0aGVpciBhdHRyaWJ1dGVzLCBsaWtlIHNpemUgYW5kIGNvcnJlc3BvbmRpbmdcbi8vIENTUyBjbGFzc1xudmFyIHNwYWNpbmdGdW5jdGlvbnMgPSB7XG4gICAgXCJcXFxccXF1YWRcIjoge1xuICAgICAgICBzaXplOiBcIjJlbVwiLFxuICAgICAgICBjbGFzc05hbWU6IFwicXF1YWRcIlxuICAgIH0sXG4gICAgXCJcXFxccXVhZFwiOiB7XG4gICAgICAgIHNpemU6IFwiMWVtXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJxdWFkXCJcbiAgICB9LFxuICAgIFwiXFxcXGVuc3BhY2VcIjoge1xuICAgICAgICBzaXplOiBcIjAuNWVtXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJlbnNwYWNlXCJcbiAgICB9LFxuICAgIFwiXFxcXDtcIjoge1xuICAgICAgICBzaXplOiBcIjAuMjc3Nzc4ZW1cIixcbiAgICAgICAgY2xhc3NOYW1lOiBcInRoaWNrc3BhY2VcIlxuICAgIH0sXG4gICAgXCJcXFxcOlwiOiB7XG4gICAgICAgIHNpemU6IFwiMC4yMjIyMmVtXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJtZWRpdW1zcGFjZVwiXG4gICAgfSxcbiAgICBcIlxcXFwsXCI6IHtcbiAgICAgICAgc2l6ZTogXCIwLjE2NjY3ZW1cIixcbiAgICAgICAgY2xhc3NOYW1lOiBcInRoaW5zcGFjZVwiXG4gICAgfSxcbiAgICBcIlxcXFwhXCI6IHtcbiAgICAgICAgc2l6ZTogXCItMC4xNjY2N2VtXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJuZWdhdGl2ZXRoaW5zcGFjZVwiXG4gICAgfVxufTtcblxuLyoqXG4gKiBNYXBzIFRlWCBmb250IGNvbW1hbmRzIHRvIG9iamVjdHMgY29udGFpbmluZzpcbiAqIC0gdmFyaWFudDogc3RyaW5nIHVzZWQgZm9yIFwibWF0aHZhcmlhbnRcIiBhdHRyaWJ1dGUgaW4gYnVpbGRNYXRoTUwuanNcbiAqIC0gZm9udE5hbWU6IHRoZSBcInN0eWxlXCIgcGFyYW1ldGVyIHRvIGZvbnRNZXRyaWNzLmdldENoYXJhY3Rlck1ldHJpY3NcbiAqL1xuLy8gQSBtYXAgYmV0d2VlbiB0ZXggZm9udCBjb21tYW5kcyBhbiBNYXRoTUwgbWF0aHZhcmlhbnQgYXR0cmlidXRlIHZhbHVlc1xudmFyIGZvbnRNYXAgPSB7XG4gICAgLy8gc3R5bGVzXG4gICAgXCJtYXRoYmZcIjoge1xuICAgICAgICB2YXJpYW50OiBcImJvbGRcIixcbiAgICAgICAgZm9udE5hbWU6IFwiTWFpbi1Cb2xkXCJcbiAgICB9LFxuICAgIFwibWF0aHJtXCI6IHtcbiAgICAgICAgdmFyaWFudDogXCJub3JtYWxcIixcbiAgICAgICAgZm9udE5hbWU6IFwiTWFpbi1SZWd1bGFyXCJcbiAgICB9LFxuICAgIFwidGV4dGl0XCI6IHtcbiAgICAgICAgdmFyaWFudDogXCJpdGFsaWNcIixcbiAgICAgICAgZm9udE5hbWU6IFwiTWFpbi1JdGFsaWNcIlxuICAgIH0sXG5cbiAgICAvLyBcIm1hdGhpdFwiIGlzIG1pc3NpbmcgYmVjYXVzZSBpdCByZXF1aXJlcyB0aGUgdXNlIG9mIHR3byBmb250czogTWFpbi1JdGFsaWNcbiAgICAvLyBhbmQgTWF0aC1JdGFsaWMuICBUaGlzIGlzIGhhbmRsZWQgYnkgYSBzcGVjaWFsIGNhc2UgaW4gbWFrZU9yZCB3aGljaCBlbmRzXG4gICAgLy8gdXAgY2FsbGluZyBtYXRoaXQuXG5cbiAgICAvLyBmYW1pbGllc1xuICAgIFwibWF0aGJiXCI6IHtcbiAgICAgICAgdmFyaWFudDogXCJkb3VibGUtc3RydWNrXCIsXG4gICAgICAgIGZvbnROYW1lOiBcIkFNUy1SZWd1bGFyXCJcbiAgICB9LFxuICAgIFwibWF0aGNhbFwiOiB7XG4gICAgICAgIHZhcmlhbnQ6IFwic2NyaXB0XCIsXG4gICAgICAgIGZvbnROYW1lOiBcIkNhbGlncmFwaGljLVJlZ3VsYXJcIlxuICAgIH0sXG4gICAgXCJtYXRoZnJha1wiOiB7XG4gICAgICAgIHZhcmlhbnQ6IFwiZnJha3R1clwiLFxuICAgICAgICBmb250TmFtZTogXCJGcmFrdHVyLVJlZ3VsYXJcIlxuICAgIH0sXG4gICAgXCJtYXRoc2NyXCI6IHtcbiAgICAgICAgdmFyaWFudDogXCJzY3JpcHRcIixcbiAgICAgICAgZm9udE5hbWU6IFwiU2NyaXB0LVJlZ3VsYXJcIlxuICAgIH0sXG4gICAgXCJtYXRoc2ZcIjoge1xuICAgICAgICB2YXJpYW50OiBcInNhbnMtc2VyaWZcIixcbiAgICAgICAgZm9udE5hbWU6IFwiU2Fuc1NlcmlmLVJlZ3VsYXJcIlxuICAgIH0sXG4gICAgXCJtYXRodHRcIjoge1xuICAgICAgICB2YXJpYW50OiBcIm1vbm9zcGFjZVwiLFxuICAgICAgICBmb250TmFtZTogXCJUeXBld3JpdGVyLVJlZ3VsYXJcIlxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGZvbnRNYXA6IGZvbnRNYXAsXG4gICAgbWFrZVN5bWJvbDogbWFrZVN5bWJvbCxcbiAgICBtYXRoc3ltOiBtYXRoc3ltLFxuICAgIG1ha2VTcGFuOiBtYWtlU3BhbixcbiAgICBtYWtlRnJhZ21lbnQ6IG1ha2VGcmFnbWVudCxcbiAgICBtYWtlVkxpc3Q6IG1ha2VWTGlzdCxcbiAgICBtYWtlT3JkOiBtYWtlT3JkLFxuICAgIHByZXBlbmRDaGlsZHJlbjogcHJlcGVuZENoaWxkcmVuLFxuICAgIHNpemluZ011bHRpcGxpZXI6IHNpemluZ011bHRpcGxpZXIsXG4gICAgc3BhY2luZ0Z1bmN0aW9uczogc3BhY2luZ0Z1bmN0aW9uc1xufTtcbiIsIi8qIGVzbGludCBuby1jb25zb2xlOjAgKi9cbi8qKlxuICogVGhpcyBmaWxlIGRvZXMgdGhlIG1haW4gd29yayBvZiBidWlsZGluZyBhIGRvbVRyZWUgc3RydWN0dXJlIGZyb20gYSBwYXJzZVxuICogdHJlZS4gVGhlIGVudHJ5IHBvaW50IGlzIHRoZSBgYnVpbGRIVE1MYCBmdW5jdGlvbiwgd2hpY2ggdGFrZXMgYSBwYXJzZSB0cmVlLlxuICogVGhlbiwgdGhlIGJ1aWxkRXhwcmVzc2lvbiwgYnVpbGRHcm91cCwgYW5kIHZhcmlvdXMgZ3JvdXBUeXBlcyBmdW5jdGlvbnMgYXJlXG4gKiBjYWxsZWQsIHRvIHByb2R1Y2UgYSBmaW5hbCBIVE1MIHRyZWUuXG4gKi9cblxudmFyIFBhcnNlRXJyb3IgPSByZXF1aXJlKFwiLi9QYXJzZUVycm9yXCIpO1xudmFyIFN0eWxlID0gcmVxdWlyZShcIi4vU3R5bGVcIik7XG5cbnZhciBidWlsZENvbW1vbiA9IHJlcXVpcmUoXCIuL2J1aWxkQ29tbW9uXCIpO1xudmFyIGRlbGltaXRlciA9IHJlcXVpcmUoXCIuL2RlbGltaXRlclwiKTtcbnZhciBkb21UcmVlID0gcmVxdWlyZShcIi4vZG9tVHJlZVwiKTtcbnZhciBmb250TWV0cmljcyA9IHJlcXVpcmUoXCIuL2ZvbnRNZXRyaWNzXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5cbnZhciBtYWtlU3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuO1xuXG52YXIgaXNTcGFjZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIGRvbVRyZWUuc3BhbiAmJiBub2RlLmNsYXNzZXNbMF0gPT09IFwibXNwYWNlXCI7XG59O1xuXG4vLyBCaW5hcnkgYXRvbXMgKGZpcnN0IGNsYXNzIGBtYmluYCkgY2hhbmdlIGludG8gb3JkaW5hcnkgYXRvbXMgKGBtb3JkYClcbi8vIGRlcGVuZGluZyBvbiB0aGVpciBzdXJyb3VuZGluZ3MuIFNlZSBUZVhib29rIHBnLiA0NDItNDQ2LCBSdWxlcyA1IGFuZCA2LFxuLy8gYW5kIHRoZSB0ZXh0IGJlZm9yZSBSdWxlIDE5LlxuXG52YXIgaXNCaW4gPSBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5jbGFzc2VzWzBdID09PSBcIm1iaW5cIjtcbn07XG5cbnZhciBpc0JpbkxlZnRDYW5jZWxsZXIgPSBmdW5jdGlvbihub2RlLCBpc1JlYWxHcm91cCkge1xuICAgIC8vIFRPRE86IFRoaXMgY29kZSBhc3N1bWVzIHRoYXQgYSBub2RlJ3MgbWF0aCBjbGFzcyBpcyB0aGUgZmlyc3QgZWxlbWVudFxuICAgIC8vIG9mIGl0cyBgY2xhc3Nlc2AgYXJyYXkuIEEgbGF0ZXIgY2xlYW51cCBzaG91bGQgZW5zdXJlIHRoaXMsIGZvclxuICAgIC8vIGluc3RhbmNlIGJ5IGNoYW5naW5nIHRoZSBzaWduYXR1cmUgb2YgYG1ha2VTcGFuYC5cbiAgICBpZiAobm9kZSkge1xuICAgICAgICByZXR1cm4gdXRpbHMuY29udGFpbnMoW1wibWJpblwiLCBcIm1vcGVuXCIsIFwibXJlbFwiLCBcIm1vcFwiLCBcIm1wdW5jdFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY2xhc3Nlc1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzUmVhbEdyb3VwO1xuICAgIH1cbn07XG5cbnZhciBpc0JpblJpZ2h0Q2FuY2VsbGVyID0gZnVuY3Rpb24obm9kZSwgaXNSZWFsR3JvdXApIHtcbiAgICBpZiAobm9kZSkge1xuICAgICAgICByZXR1cm4gdXRpbHMuY29udGFpbnMoW1wibXJlbFwiLCBcIm1jbG9zZVwiLCBcIm1wdW5jdFwiXSwgbm9kZS5jbGFzc2VzWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaXNSZWFsR3JvdXA7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUYWtlIGEgbGlzdCBvZiBub2RlcywgYnVpbGQgdGhlbSBpbiBvcmRlciwgYW5kIHJldHVybiBhIGxpc3Qgb2YgdGhlIGJ1aWx0XG4gKiBub2Rlcy4gZG9jdW1lbnRGcmFnbWVudHMgYXJlIGZsYXR0ZW5lZCBpbnRvIHRoZWlyIGNvbnRlbnRzLCBzbyB0aGVcbiAqIHJldHVybmVkIGxpc3QgY29udGFpbnMgbm8gZnJhZ21lbnRzLiBgaXNSZWFsR3JvdXBgIGlzIHRydWUgaWYgYGV4cHJlc3Npb25gXG4gKiBpcyBhIHJlYWwgZ3JvdXAgKG5vIGF0b21zIHdpbGwgYmUgYWRkZWQgb24gZWl0aGVyIHNpZGUpLCBhcyBvcHBvc2VkIHRvXG4gKiBhIHBhcnRpYWwgZ3JvdXAgKGUuZy4gb25lIGNyZWF0ZWQgYnkgXFxjb2xvcikuXG4gKi9cbnZhciBidWlsZEV4cHJlc3Npb24gPSBmdW5jdGlvbihleHByZXNzaW9uLCBvcHRpb25zLCBpc1JlYWxHcm91cCkge1xuICAgIC8vIFBhcnNlIGV4cHJlc3Npb25zIGludG8gYGdyb3Vwc2AuXG4gICAgdmFyIGdyb3VwcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZ3JvdXAgPSBleHByZXNzaW9uW2ldO1xuICAgICAgICB2YXIgb3V0cHV0ID0gYnVpbGRHcm91cChncm91cCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChvdXRwdXQgaW5zdGFuY2VvZiBkb21UcmVlLmRvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGdyb3Vwcywgb3V0cHV0LmNoaWxkcmVuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyb3Vwcy5wdXNoKG91dHB1dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXQgdGhpcyBwb2ludCBgZ3JvdXBzYCBjb25zaXN0cyBlbnRpcmVseSBvZiBgc3ltYm9sTm9kZWBzIGFuZCBgc3BhbmBzLlxuXG4gICAgLy8gRXhwbGljaXQgc3BhY2VzIChlLmcuLCBcXDssIFxcLCkgc2hvdWxkIGJlIGlnbm9yZWQgd2l0aCByZXNwZWN0IHRvIGF0b21cbiAgICAvLyBzcGFjaW5nIChlLmcuLCBcImFkZCB0aGljayBzcGFjZSBiZXR3ZWVuIG1vcmQgYW5kIG1yZWxcIikuIFNpbmNlIENTU1xuICAgIC8vIGFkamFjZW5jeSBydWxlcyBpbXBsZW1lbnQgYXRvbSBzcGFjaW5nLCBzcGFjZXMgc2hvdWxkIGJlIGludmlzaWJsZSB0b1xuICAgIC8vIENTUy4gU28gd2Ugc3BsaWNlIHRoZW0gb3V0IG9mIGBncm91cHNgIGFuZCBpbnRvIHRoZSBhdG9tcyB0aGVtc2VsdmVzLlxuICAgIHZhciBzcGFjZXMgPSBudWxsO1xuICAgIGZvciAoaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzU3BhY2UoZ3JvdXBzW2ldKSkge1xuICAgICAgICAgICAgc3BhY2VzID0gc3BhY2VzIHx8IFtdO1xuICAgICAgICAgICAgc3BhY2VzLnB1c2goZ3JvdXBzW2ldKTtcbiAgICAgICAgICAgIGdyb3Vwcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH0gZWxzZSBpZiAoc3BhY2VzKSB7XG4gICAgICAgICAgICBpZiAoZ3JvdXBzW2ldIGluc3RhbmNlb2YgZG9tVHJlZS5zeW1ib2xOb2RlKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBzW2ldID0gbWFrZVNwYW4oW10uY29uY2F0KGdyb3Vwc1tpXS5jbGFzc2VzKSwgW2dyb3Vwc1tpXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVpbGRDb21tb24ucHJlcGVuZENoaWxkcmVuKGdyb3Vwc1tpXSwgc3BhY2VzKTtcbiAgICAgICAgICAgIHNwYWNlcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNwYWNlcykge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShncm91cHMsIHNwYWNlcyk7XG4gICAgfVxuXG4gICAgLy8gQmluYXJ5IG9wZXJhdG9ycyBjaGFuZ2UgdG8gb3JkaW5hcnkgc3ltYm9scyBpbiBzb21lIGNvbnRleHRzLlxuICAgIGZvciAoaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzQmluKGdyb3Vwc1tpXSlcbiAgICAgICAgICAgICYmIChpc0JpbkxlZnRDYW5jZWxsZXIoZ3JvdXBzW2kgLSAxXSwgaXNSZWFsR3JvdXApXG4gICAgICAgICAgICAgICAgfHwgaXNCaW5SaWdodENhbmNlbGxlcihncm91cHNbaSArIDFdLCBpc1JlYWxHcm91cCkpKSB7XG4gICAgICAgICAgICBncm91cHNbaV0uY2xhc3Nlc1swXSA9IFwibW9yZFwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyb3Vwcztcbn07XG5cbi8vIFJldHVybiBtYXRoIGF0b20gY2xhc3MgKG1jbGFzcykgb2YgYSBkb21UcmVlLlxudmFyIGdldFR5cGVPZkRvbVRyZWUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBkb21UcmVlLmRvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VHlwZU9mRG9tVHJlZShcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuW25vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMV0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHV0aWxzLmNvbnRhaW5zKFtcIm1vcmRcIiwgXCJtb3BcIiwgXCJtYmluXCIsIFwibXJlbFwiLCBcIm1vcGVuXCIsIFwibWNsb3NlXCIsXG4gICAgICAgICAgICBcIm1wdW5jdFwiLCBcIm1pbm5lclwiXSwgbm9kZS5jbGFzc2VzWzBdKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2xhc3Nlc1swXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogU29tZXRpbWVzLCBncm91cHMgcGVyZm9ybSBzcGVjaWFsIHJ1bGVzIHdoZW4gdGhleSBoYXZlIHN1cGVyc2NyaXB0cyBvclxuICogc3Vic2NyaXB0cyBhdHRhY2hlZCB0byB0aGVtLiBUaGlzIGZ1bmN0aW9uIGxldHMgdGhlIGBzdXBzdWJgIGdyb3VwIGtub3cgdGhhdFxuICogaXRzIGlubmVyIGVsZW1lbnQgc2hvdWxkIGhhbmRsZSB0aGUgc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzIGluc3RlYWQgb2ZcbiAqIGhhbmRsaW5nIHRoZW0gaXRzZWxmLlxuICovXG52YXIgc2hvdWxkSGFuZGxlU3VwU3ViID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBpZiAoIWdyb3VwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09IFwib3BcIikge1xuICAgICAgICAvLyBPcGVyYXRvcnMgaGFuZGxlIHN1cHN1YnMgZGlmZmVyZW50bHkgd2hlbiB0aGV5IGhhdmUgbGltaXRzXG4gICAgICAgIC8vIChlLmcuIGBcXGRpc3BsYXlzdHlsZVxcc3VtXzJeM2ApXG4gICAgICAgIHJldHVybiBncm91cC52YWx1ZS5saW1pdHMgJiZcbiAgICAgICAgICAgIChvcHRpb25zLnN0eWxlLnNpemUgPT09IFN0eWxlLkRJU1BMQVkuc2l6ZSB8fFxuICAgICAgICAgICAgZ3JvdXAudmFsdWUuYWx3YXlzSGFuZGxlU3VwU3ViKTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09IFwiYWNjZW50XCIpIHtcbiAgICAgICAgcmV0dXJuIGlzQ2hhcmFjdGVyQm94KGdyb3VwLnZhbHVlLmJhc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogU29tZXRpbWVzIHdlIHdhbnQgdG8gcHVsbCBvdXQgdGhlIGlubmVybW9zdCBlbGVtZW50IG9mIGEgZ3JvdXAuIEluIG1vc3RcbiAqIGNhc2VzLCB0aGlzIHdpbGwganVzdCBiZSB0aGUgZ3JvdXAgaXRzZWxmLCBidXQgd2hlbiBvcmRncm91cHMgYW5kIGNvbG9ycyBoYXZlXG4gKiBhIHNpbmdsZSBlbGVtZW50LCB3ZSB3YW50IHRvIHB1bGwgdGhhdCBvdXQuXG4gKi9cbnZhciBnZXRCYXNlRWxlbSA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgaWYgKCFncm91cCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChncm91cC50eXBlID09PSBcIm9yZGdyb3VwXCIpIHtcbiAgICAgICAgaWYgKGdyb3VwLnZhbHVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJhc2VFbGVtKGdyb3VwLnZhbHVlWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBncm91cDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gXCJjb2xvclwiKSB7XG4gICAgICAgIGlmIChncm91cC52YWx1ZS52YWx1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRCYXNlRWxlbShncm91cC52YWx1ZS52YWx1ZVswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09IFwiZm9udFwiKSB7XG4gICAgICAgIHJldHVybiBnZXRCYXNlRWxlbShncm91cC52YWx1ZS5ib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUZVhib29rIGFsZ29yaXRobXMgb2Z0ZW4gcmVmZXJlbmNlIFwiY2hhcmFjdGVyIGJveGVzXCIsIHdoaWNoIGFyZSBzaW1wbHkgZ3JvdXBzXG4gKiB3aXRoIGEgc2luZ2xlIGNoYXJhY3RlciBpbiB0aGVtLiBUbyBkZWNpZGUgaWYgc29tZXRoaW5nIGlzIGEgY2hhcmFjdGVyIGJveCxcbiAqIHdlIGZpbmQgaXRzIGlubmVybW9zdCBncm91cCwgYW5kIHNlZSBpZiBpdCBpcyBhIHNpbmdsZSBjaGFyYWN0ZXIuXG4gKi9cbnZhciBpc0NoYXJhY3RlckJveCA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgdmFyIGJhc2VFbGVtID0gZ2V0QmFzZUVsZW0oZ3JvdXApO1xuXG4gICAgLy8gVGhlc2UgYXJlIGFsbCB0aGV5IHR5cGVzIG9mIGdyb3VwcyB3aGljaCBob2xkIHNpbmdsZSBjaGFyYWN0ZXJzXG4gICAgcmV0dXJuIGJhc2VFbGVtLnR5cGUgPT09IFwibWF0aG9yZFwiIHx8XG4gICAgICAgIGJhc2VFbGVtLnR5cGUgPT09IFwidGV4dG9yZFwiIHx8XG4gICAgICAgIGJhc2VFbGVtLnR5cGUgPT09IFwiYmluXCIgfHxcbiAgICAgICAgYmFzZUVsZW0udHlwZSA9PT0gXCJyZWxcIiB8fFxuICAgICAgICBiYXNlRWxlbS50eXBlID09PSBcImlubmVyXCIgfHxcbiAgICAgICAgYmFzZUVsZW0udHlwZSA9PT0gXCJvcGVuXCIgfHxcbiAgICAgICAgYmFzZUVsZW0udHlwZSA9PT0gXCJjbG9zZVwiIHx8XG4gICAgICAgIGJhc2VFbGVtLnR5cGUgPT09IFwicHVuY3RcIjtcbn07XG5cbnZhciBtYWtlTnVsbERlbGltaXRlciA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNsYXNzZXMpIHtcbiAgICByZXR1cm4gbWFrZVNwYW4oY2xhc3Nlcy5jb25jYXQoW1xuICAgICAgICBcInNpemluZ1wiLCBcInJlc2V0LVwiICsgb3B0aW9ucy5zaXplLCBcInNpemU1XCIsXG4gICAgICAgIG9wdGlvbnMuc3R5bGUucmVzZXQoKSwgU3R5bGUuVEVYVC5jbHMoKSxcbiAgICAgICAgXCJudWxsZGVsaW1pdGVyXCJdKSk7XG59O1xuXG4vKipcbiAqIFRoaXMgaXMgYSBtYXAgb2YgZ3JvdXAgdHlwZXMgdG8gdGhlIGZ1bmN0aW9uIHVzZWQgdG8gaGFuZGxlIHRoYXQgdHlwZS5cbiAqIFNpbXBsZXIgdHlwZXMgY29tZSBhdCB0aGUgYmVnaW5uaW5nLCB3aGlsZSBjb21wbGljYXRlZCB0eXBlcyBjb21lIGFmdGVyd2FyZHMuXG4gKi9cbnZhciBncm91cFR5cGVzID0ge307XG5cbmdyb3VwVHlwZXMubWF0aG9yZCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VPcmQoZ3JvdXAsIG9wdGlvbnMsIFwibWF0aG9yZFwiKTtcbn07XG5cbmdyb3VwVHlwZXMudGV4dG9yZCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VPcmQoZ3JvdXAsIG9wdGlvbnMsIFwidGV4dG9yZFwiKTtcbn07XG5cbmdyb3VwVHlwZXMuYmluID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWF0aHN5bShcbiAgICAgICAgZ3JvdXAudmFsdWUsIGdyb3VwLm1vZGUsIG9wdGlvbnMsIFtcIm1iaW5cIl0pO1xufTtcblxuZ3JvdXBUeXBlcy5yZWwgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYXRoc3ltKFxuICAgICAgICBncm91cC52YWx1ZSwgZ3JvdXAubW9kZSwgb3B0aW9ucywgW1wibXJlbFwiXSk7XG59O1xuXG5ncm91cFR5cGVzLm9wZW4gPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYXRoc3ltKFxuICAgICAgICBncm91cC52YWx1ZSwgZ3JvdXAubW9kZSwgb3B0aW9ucywgW1wibW9wZW5cIl0pO1xufTtcblxuZ3JvdXBUeXBlcy5jbG9zZSA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1hdGhzeW0oXG4gICAgICAgIGdyb3VwLnZhbHVlLCBncm91cC5tb2RlLCBvcHRpb25zLCBbXCJtY2xvc2VcIl0pO1xufTtcblxuZ3JvdXBUeXBlcy5pbm5lciA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1hdGhzeW0oXG4gICAgICAgIGdyb3VwLnZhbHVlLCBncm91cC5tb2RlLCBvcHRpb25zLCBbXCJtaW5uZXJcIl0pO1xufTtcblxuZ3JvdXBUeXBlcy5wdW5jdCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1hdGhzeW0oXG4gICAgICAgIGdyb3VwLnZhbHVlLCBncm91cC5tb2RlLCBvcHRpb25zLCBbXCJtcHVuY3RcIl0pO1xufTtcblxuZ3JvdXBUeXBlcy5vcmRncm91cCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG1ha2VTcGFuKFxuICAgICAgICBbXCJtb3JkXCIsIG9wdGlvbnMuc3R5bGUuY2xzKCldLFxuICAgICAgICBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUsIG9wdGlvbnMucmVzZXQoKSwgdHJ1ZSksXG4gICAgICAgIG9wdGlvbnNcbiAgICApO1xufTtcblxuZ3JvdXBUeXBlcy50ZXh0ID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnMud2l0aEZvbnQoZ3JvdXAudmFsdWUuc3R5bGUpO1xuICAgIHZhciBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC52YWx1ZS5ib2R5LCBuZXdPcHRpb25zLCB0cnVlKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlubmVyLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAoaW5uZXJbaV0udHJ5Q29tYmluZShpbm5lcltpICsgMV0pKSB7XG4gICAgICAgICAgICBpbm5lci5zcGxpY2UoaSArIDEsIDEpO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYWtlU3BhbihbXCJtb3JkXCIsIFwidGV4dFwiLCBuZXdPcHRpb25zLnN0eWxlLmNscygpXSxcbiAgICAgICAgaW5uZXIsIG5ld09wdGlvbnMpO1xufTtcblxuZ3JvdXBUeXBlcy5jb2xvciA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gYnVpbGRFeHByZXNzaW9uKFxuICAgICAgICBncm91cC52YWx1ZS52YWx1ZSxcbiAgICAgICAgb3B0aW9ucy53aXRoQ29sb3IoZ3JvdXAudmFsdWUuY29sb3IpLFxuICAgICAgICBmYWxzZVxuICAgICk7XG5cbiAgICAvLyBcXGNvbG9yIGlzbid0IHN1cHBvc2VkIHRvIGFmZmVjdCB0aGUgdHlwZSBvZiB0aGUgZWxlbWVudHMgaXQgY29udGFpbnMuXG4gICAgLy8gVG8gYWNjb21wbGlzaCB0aGlzLCB3ZSB3cmFwIHRoZSByZXN1bHRzIGluIGEgZnJhZ21lbnQsIHNvIHRoZSBpbm5lclxuICAgIC8vIGVsZW1lbnRzIHdpbGwgYmUgYWJsZSB0byBkaXJlY3RseSBpbnRlcmFjdCB3aXRoIHRoZWlyIG5laWdoYm9ycy4gRm9yXG4gICAgLy8gZXhhbXBsZSwgYFxcY29sb3J7cmVkfXsyICt9IDNgIGhhcyB0aGUgc2FtZSBzcGFjaW5nIGFzIGAyICsgM2BcbiAgICByZXR1cm4gbmV3IGJ1aWxkQ29tbW9uLm1ha2VGcmFnbWVudChlbGVtZW50cyk7XG59O1xuXG5ncm91cFR5cGVzLnN1cHN1YiA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gU3VwZXJzY3JpcHQgYW5kIHN1YnNjcmlwdHMgYXJlIGhhbmRsZWQgaW4gdGhlIFRlWGJvb2sgb24gcGFnZVxuICAgIC8vIDQ0NS00NDYsIHJ1bGVzIDE4KGEtZikuXG5cbiAgICAvLyBIZXJlIGlzIHdoZXJlIHdlIGRlZmVyIHRvIHRoZSBpbm5lciBncm91cCBpZiBpdCBzaG91bGQgaGFuZGxlXG4gICAgLy8gc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzIGl0c2VsZi5cbiAgICBpZiAoc2hvdWxkSGFuZGxlU3VwU3ViKGdyb3VwLnZhbHVlLmJhc2UsIG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBncm91cFR5cGVzW2dyb3VwLnZhbHVlLmJhc2UudHlwZV0oZ3JvdXAsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciBiYXNlID0gYnVpbGRHcm91cChncm91cC52YWx1ZS5iYXNlLCBvcHRpb25zLnJlc2V0KCkpO1xuICAgIHZhciBzdXBtaWQ7XG4gICAgdmFyIHN1Ym1pZDtcbiAgICB2YXIgc3VwO1xuICAgIHZhciBzdWI7XG5cbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIHZhciBuZXdPcHRpb25zO1xuXG4gICAgaWYgKGdyb3VwLnZhbHVlLnN1cCkge1xuICAgICAgICBuZXdPcHRpb25zID0gb3B0aW9ucy53aXRoU3R5bGUoc3R5bGUuc3VwKCkpO1xuICAgICAgICBzdXAgPSBidWlsZEdyb3VwKGdyb3VwLnZhbHVlLnN1cCwgbmV3T3B0aW9ucyk7XG4gICAgICAgIHN1cG1pZCA9IG1ha2VTcGFuKFtzdHlsZS5yZXNldCgpLCBzdHlsZS5zdXAoKS5jbHMoKV0sXG4gICAgICAgICAgICBbc3VwXSwgbmV3T3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnZhbHVlLnN1Yikge1xuICAgICAgICBuZXdPcHRpb25zID0gb3B0aW9ucy53aXRoU3R5bGUoc3R5bGUuc3ViKCkpO1xuICAgICAgICBzdWIgPSBidWlsZEdyb3VwKGdyb3VwLnZhbHVlLnN1YiwgbmV3T3B0aW9ucyk7XG4gICAgICAgIHN1Ym1pZCA9IG1ha2VTcGFuKFtzdHlsZS5yZXNldCgpLCBzdHlsZS5zdWIoKS5jbHMoKV0sXG4gICAgICAgICAgICBbc3ViXSwgbmV3T3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gUnVsZSAxOGFcbiAgICB2YXIgc3VwU2hpZnQ7XG4gICAgdmFyIHN1YlNoaWZ0O1xuICAgIGlmIChpc0NoYXJhY3RlckJveChncm91cC52YWx1ZS5iYXNlKSkge1xuICAgICAgICBzdXBTaGlmdCA9IDA7XG4gICAgICAgIHN1YlNoaWZ0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdXBTaGlmdCA9IGJhc2UuaGVpZ2h0IC0gc3R5bGUubWV0cmljcy5zdXBEcm9wO1xuICAgICAgICBzdWJTaGlmdCA9IGJhc2UuZGVwdGggKyBzdHlsZS5tZXRyaWNzLnN1YkRyb3A7XG4gICAgfVxuXG4gICAgLy8gUnVsZSAxOGNcbiAgICB2YXIgbWluU3VwU2hpZnQ7XG4gICAgaWYgKHN0eWxlID09PSBTdHlsZS5ESVNQTEFZKSB7XG4gICAgICAgIG1pblN1cFNoaWZ0ID0gc3R5bGUubWV0cmljcy5zdXAxO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUuY3JhbXBlZCkge1xuICAgICAgICBtaW5TdXBTaGlmdCA9IHN0eWxlLm1ldHJpY3Muc3VwMztcbiAgICB9IGVsc2Uge1xuICAgICAgICBtaW5TdXBTaGlmdCA9IHN0eWxlLm1ldHJpY3Muc3VwMjtcbiAgICB9XG5cbiAgICAvLyBzY3JpcHRzcGFjZSBpcyBhIGZvbnQtc2l6ZS1pbmRlcGVuZGVudCBzaXplLCBzbyBzY2FsZSBpdFxuICAgIC8vIGFwcHJvcHJpYXRlbHlcbiAgICB2YXIgbXVsdGlwbGllciA9IFN0eWxlLlRFWFQuc2l6ZU11bHRpcGxpZXIgKlxuICAgICAgICAgICAgc3R5bGUuc2l6ZU11bHRpcGxpZXI7XG4gICAgdmFyIHNjcmlwdHNwYWNlID1cbiAgICAgICAgKDAuNSAvIGZvbnRNZXRyaWNzLm1ldHJpY3MucHRQZXJFbSkgLyBtdWx0aXBsaWVyICsgXCJlbVwiO1xuXG4gICAgdmFyIHN1cHN1YjtcbiAgICBpZiAoIWdyb3VwLnZhbHVlLnN1cCkge1xuICAgICAgICAvLyBSdWxlIDE4YlxuICAgICAgICBzdWJTaGlmdCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgc3ViU2hpZnQsIHN0eWxlLm1ldHJpY3Muc3ViMSxcbiAgICAgICAgICAgIHN1Yi5oZWlnaHQgLSAwLjggKiBzdHlsZS5tZXRyaWNzLnhIZWlnaHQpO1xuXG4gICAgICAgIHN1cHN1YiA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdChbXG4gICAgICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IHN1Ym1pZH1cbiAgICAgICAgXSwgXCJzaGlmdFwiLCBzdWJTaGlmdCwgb3B0aW9ucyk7XG5cbiAgICAgICAgc3Vwc3ViLmNoaWxkcmVuWzBdLnN0eWxlLm1hcmdpblJpZ2h0ID0gc2NyaXB0c3BhY2U7XG5cbiAgICAgICAgLy8gU3Vic2NyaXB0cyBzaG91bGRuJ3QgYmUgc2hpZnRlZCBieSB0aGUgYmFzZSdzIGl0YWxpYyBjb3JyZWN0aW9uLlxuICAgICAgICAvLyBBY2NvdW50IGZvciB0aGF0IGJ5IHNoaWZ0aW5nIHRoZSBzdWJzY3JpcHQgYmFjayB0aGUgYXBwcm9wcmlhdGVcbiAgICAgICAgLy8gYW1vdW50LiBOb3RlIHdlIG9ubHkgZG8gdGhpcyB3aGVuIHRoZSBiYXNlIGlzIGEgc2luZ2xlIHN5bWJvbC5cbiAgICAgICAgaWYgKGJhc2UgaW5zdGFuY2VvZiBkb21UcmVlLnN5bWJvbE5vZGUpIHtcbiAgICAgICAgICAgIHN1cHN1Yi5jaGlsZHJlblswXS5zdHlsZS5tYXJnaW5MZWZ0ID0gLWJhc2UuaXRhbGljICsgXCJlbVwiO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICghZ3JvdXAudmFsdWUuc3ViKSB7XG4gICAgICAgIC8vIFJ1bGUgMThjLCBkXG4gICAgICAgIHN1cFNoaWZ0ID0gTWF0aC5tYXgoc3VwU2hpZnQsIG1pblN1cFNoaWZ0LFxuICAgICAgICAgICAgc3VwLmRlcHRoICsgMC4yNSAqIHN0eWxlLm1ldHJpY3MueEhlaWdodCk7XG5cbiAgICAgICAgc3Vwc3ViID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KFtcbiAgICAgICAgICAgIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogc3VwbWlkfVxuICAgICAgICBdLCBcInNoaWZ0XCIsIC1zdXBTaGlmdCwgb3B0aW9ucyk7XG5cbiAgICAgICAgc3Vwc3ViLmNoaWxkcmVuWzBdLnN0eWxlLm1hcmdpblJpZ2h0ID0gc2NyaXB0c3BhY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3VwU2hpZnQgPSBNYXRoLm1heChcbiAgICAgICAgICAgIHN1cFNoaWZ0LCBtaW5TdXBTaGlmdCwgc3VwLmRlcHRoICsgMC4yNSAqIHN0eWxlLm1ldHJpY3MueEhlaWdodCk7XG4gICAgICAgIHN1YlNoaWZ0ID0gTWF0aC5tYXgoc3ViU2hpZnQsIHN0eWxlLm1ldHJpY3Muc3ViMik7XG5cbiAgICAgICAgdmFyIHJ1bGVXaWR0aCA9IGZvbnRNZXRyaWNzLm1ldHJpY3MuZGVmYXVsdFJ1bGVUaGlja25lc3M7XG5cbiAgICAgICAgLy8gUnVsZSAxOGVcbiAgICAgICAgaWYgKChzdXBTaGlmdCAtIHN1cC5kZXB0aCkgLSAoc3ViLmhlaWdodCAtIHN1YlNoaWZ0KSA8XG4gICAgICAgICAgICAgICAgNCAqIHJ1bGVXaWR0aCkge1xuICAgICAgICAgICAgc3ViU2hpZnQgPSA0ICogcnVsZVdpZHRoIC0gKHN1cFNoaWZ0IC0gc3VwLmRlcHRoKSArIHN1Yi5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgcHNpID0gMC44ICogc3R5bGUubWV0cmljcy54SGVpZ2h0IC0gKHN1cFNoaWZ0IC0gc3VwLmRlcHRoKTtcbiAgICAgICAgICAgIGlmIChwc2kgPiAwKSB7XG4gICAgICAgICAgICAgICAgc3VwU2hpZnQgKz0gcHNpO1xuICAgICAgICAgICAgICAgIHN1YlNoaWZ0IC09IHBzaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN1cHN1YiA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdChbXG4gICAgICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IHN1Ym1pZCwgc2hpZnQ6IHN1YlNoaWZ0fSxcbiAgICAgICAgICAgIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogc3VwbWlkLCBzaGlmdDogLXN1cFNoaWZ0fVxuICAgICAgICBdLCBcImluZGl2aWR1YWxTaGlmdFwiLCBudWxsLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBTZWUgY29tbWVudCBhYm92ZSBhYm91dCBzdWJzY3JpcHRzIG5vdCBiZWluZyBzaGlmdGVkXG4gICAgICAgIGlmIChiYXNlIGluc3RhbmNlb2YgZG9tVHJlZS5zeW1ib2xOb2RlKSB7XG4gICAgICAgICAgICBzdXBzdWIuY2hpbGRyZW5bMF0uc3R5bGUubWFyZ2luTGVmdCA9IC1iYXNlLml0YWxpYyArIFwiZW1cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1cHN1Yi5jaGlsZHJlblswXS5zdHlsZS5tYXJnaW5SaWdodCA9IHNjcmlwdHNwYWNlO1xuICAgICAgICBzdXBzdWIuY2hpbGRyZW5bMV0uc3R5bGUubWFyZ2luUmlnaHQgPSBzY3JpcHRzcGFjZTtcbiAgICB9XG5cbiAgICAvLyBXZSBlbnN1cmUgdG8gd3JhcCB0aGUgc3Vwc3ViIHZsaXN0IGluIGEgc3Bhbi5tc3Vwc3ViIHRvIHJlc2V0IHRleHQtYWxpZ25cbiAgICB2YXIgbWNsYXNzID0gZ2V0VHlwZU9mRG9tVHJlZShiYXNlKSB8fCBcIm1vcmRcIjtcbiAgICByZXR1cm4gbWFrZVNwYW4oW21jbGFzc10sXG4gICAgICAgIFtiYXNlLCBtYWtlU3BhbihbXCJtc3Vwc3ViXCJdLCBbc3Vwc3ViXSldLFxuICAgICAgICBvcHRpb25zKTtcbn07XG5cbmdyb3VwVHlwZXMuZ2VuZnJhYyA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gRnJhY3Rpb25zIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIG9uIHBhZ2VzIDQ0NC00NDUsIHJ1bGVzIDE1KGEtZSkuXG4gICAgLy8gRmlndXJlIG91dCB3aGF0IHN0eWxlIHRoaXMgZnJhY3Rpb24gc2hvdWxkIGJlIGluIGJhc2VkIG9uIHRoZVxuICAgIC8vIGZ1bmN0aW9uIHVzZWRcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIGlmIChncm91cC52YWx1ZS5zaXplID09PSBcImRpc3BsYXlcIikge1xuICAgICAgICBzdHlsZSA9IFN0eWxlLkRJU1BMQVk7XG4gICAgfSBlbHNlIGlmIChncm91cC52YWx1ZS5zaXplID09PSBcInRleHRcIikge1xuICAgICAgICBzdHlsZSA9IFN0eWxlLlRFWFQ7XG4gICAgfVxuXG4gICAgdmFyIG5zdHlsZSA9IHN0eWxlLmZyYWNOdW0oKTtcbiAgICB2YXIgZHN0eWxlID0gc3R5bGUuZnJhY0RlbigpO1xuICAgIHZhciBuZXdPcHRpb25zO1xuXG4gICAgbmV3T3B0aW9ucyA9IG9wdGlvbnMud2l0aFN0eWxlKG5zdHlsZSk7XG4gICAgdmFyIG51bWVyID0gYnVpbGRHcm91cChncm91cC52YWx1ZS5udW1lciwgbmV3T3B0aW9ucyk7XG4gICAgdmFyIG51bWVycmVzZXQgPSBtYWtlU3Bhbihbc3R5bGUucmVzZXQoKSwgbnN0eWxlLmNscygpXSxcbiAgICAgICAgW251bWVyXSwgbmV3T3B0aW9ucyk7XG5cbiAgICBuZXdPcHRpb25zID0gb3B0aW9ucy53aXRoU3R5bGUoZHN0eWxlKTtcbiAgICB2YXIgZGVub20gPSBidWlsZEdyb3VwKGdyb3VwLnZhbHVlLmRlbm9tLCBuZXdPcHRpb25zKTtcbiAgICB2YXIgZGVub21yZXNldCA9IG1ha2VTcGFuKFtzdHlsZS5yZXNldCgpLCBkc3R5bGUuY2xzKCldLFxuICAgICAgICBbZGVub21dLCBuZXdPcHRpb25zKTtcblxuICAgIHZhciBydWxlV2lkdGg7XG4gICAgaWYgKGdyb3VwLnZhbHVlLmhhc0JhckxpbmUpIHtcbiAgICAgICAgcnVsZVdpZHRoID0gZm9udE1ldHJpY3MubWV0cmljcy5kZWZhdWx0UnVsZVRoaWNrbmVzcyAvXG4gICAgICAgICAgICBvcHRpb25zLnN0eWxlLnNpemVNdWx0aXBsaWVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJ1bGVXaWR0aCA9IDA7XG4gICAgfVxuXG4gICAgLy8gUnVsZSAxNWJcbiAgICB2YXIgbnVtU2hpZnQ7XG4gICAgdmFyIGNsZWFyYW5jZTtcbiAgICB2YXIgZGVub21TaGlmdDtcbiAgICBpZiAoc3R5bGUuc2l6ZSA9PT0gU3R5bGUuRElTUExBWS5zaXplKSB7XG4gICAgICAgIG51bVNoaWZ0ID0gc3R5bGUubWV0cmljcy5udW0xO1xuICAgICAgICBpZiAocnVsZVdpZHRoID4gMCkge1xuICAgICAgICAgICAgY2xlYXJhbmNlID0gMyAqIHJ1bGVXaWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsZWFyYW5jZSA9IDcgKiBmb250TWV0cmljcy5tZXRyaWNzLmRlZmF1bHRSdWxlVGhpY2tuZXNzO1xuICAgICAgICB9XG4gICAgICAgIGRlbm9tU2hpZnQgPSBzdHlsZS5tZXRyaWNzLmRlbm9tMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocnVsZVdpZHRoID4gMCkge1xuICAgICAgICAgICAgbnVtU2hpZnQgPSBzdHlsZS5tZXRyaWNzLm51bTI7XG4gICAgICAgICAgICBjbGVhcmFuY2UgPSBydWxlV2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBudW1TaGlmdCA9IHN0eWxlLm1ldHJpY3MubnVtMztcbiAgICAgICAgICAgIGNsZWFyYW5jZSA9IDMgKiBmb250TWV0cmljcy5tZXRyaWNzLmRlZmF1bHRSdWxlVGhpY2tuZXNzO1xuICAgICAgICB9XG4gICAgICAgIGRlbm9tU2hpZnQgPSBzdHlsZS5tZXRyaWNzLmRlbm9tMjtcbiAgICB9XG5cbiAgICB2YXIgZnJhYztcbiAgICBpZiAocnVsZVdpZHRoID09PSAwKSB7XG4gICAgICAgIC8vIFJ1bGUgMTVjXG4gICAgICAgIHZhciBjYW5kaWRhdGVDbGVhcmFuY2UgPVxuICAgICAgICAgICAgKG51bVNoaWZ0IC0gbnVtZXIuZGVwdGgpIC0gKGRlbm9tLmhlaWdodCAtIGRlbm9tU2hpZnQpO1xuICAgICAgICBpZiAoY2FuZGlkYXRlQ2xlYXJhbmNlIDwgY2xlYXJhbmNlKSB7XG4gICAgICAgICAgICBudW1TaGlmdCArPSAwLjUgKiAoY2xlYXJhbmNlIC0gY2FuZGlkYXRlQ2xlYXJhbmNlKTtcbiAgICAgICAgICAgIGRlbm9tU2hpZnQgKz0gMC41ICogKGNsZWFyYW5jZSAtIGNhbmRpZGF0ZUNsZWFyYW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmcmFjID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KFtcbiAgICAgICAgICAgIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogZGVub21yZXNldCwgc2hpZnQ6IGRlbm9tU2hpZnR9LFxuICAgICAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBudW1lcnJlc2V0LCBzaGlmdDogLW51bVNoaWZ0fVxuICAgICAgICBdLCBcImluZGl2aWR1YWxTaGlmdFwiLCBudWxsLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSdWxlIDE1ZFxuICAgICAgICB2YXIgYXhpc0hlaWdodCA9IHN0eWxlLm1ldHJpY3MuYXhpc0hlaWdodDtcblxuICAgICAgICBpZiAoKG51bVNoaWZ0IC0gbnVtZXIuZGVwdGgpIC0gKGF4aXNIZWlnaHQgKyAwLjUgKiBydWxlV2lkdGgpIDxcbiAgICAgICAgICAgICAgICBjbGVhcmFuY2UpIHtcbiAgICAgICAgICAgIG51bVNoaWZ0ICs9XG4gICAgICAgICAgICAgICAgY2xlYXJhbmNlIC0gKChudW1TaGlmdCAtIG51bWVyLmRlcHRoKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIChheGlzSGVpZ2h0ICsgMC41ICogcnVsZVdpZHRoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGF4aXNIZWlnaHQgLSAwLjUgKiBydWxlV2lkdGgpIC0gKGRlbm9tLmhlaWdodCAtIGRlbm9tU2hpZnQpIDxcbiAgICAgICAgICAgICAgICBjbGVhcmFuY2UpIHtcbiAgICAgICAgICAgIGRlbm9tU2hpZnQgKz1cbiAgICAgICAgICAgICAgICBjbGVhcmFuY2UgLSAoKGF4aXNIZWlnaHQgLSAwLjUgKiBydWxlV2lkdGgpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRlbm9tLmhlaWdodCAtIGRlbm9tU2hpZnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaWQgPSBtYWtlU3BhbihcbiAgICAgICAgICAgIFtvcHRpb25zLnN0eWxlLnJlc2V0KCksIFN0eWxlLlRFWFQuY2xzKCksIFwiZnJhYy1saW5lXCJdKTtcbiAgICAgICAgLy8gTWFudWFsbHkgc2V0IHRoZSBoZWlnaHQgb2YgdGhlIGxpbmUgYmVjYXVzZSBpdHMgaGVpZ2h0IGlzXG4gICAgICAgIC8vIGNyZWF0ZWQgaW4gQ1NTXG4gICAgICAgIG1pZC5oZWlnaHQgPSBydWxlV2lkdGg7XG5cbiAgICAgICAgdmFyIG1pZFNoaWZ0ID0gLShheGlzSGVpZ2h0IC0gMC41ICogcnVsZVdpZHRoKTtcblxuICAgICAgICBmcmFjID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KFtcbiAgICAgICAgICAgIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogZGVub21yZXNldCwgc2hpZnQ6IGRlbm9tU2hpZnR9LFxuICAgICAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBtaWQsICAgICAgICBzaGlmdDogbWlkU2hpZnR9LFxuICAgICAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBudW1lcnJlc2V0LCBzaGlmdDogLW51bVNoaWZ0fVxuICAgICAgICBdLCBcImluZGl2aWR1YWxTaGlmdFwiLCBudWxsLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvLyBTaW5jZSB3ZSBtYW51YWxseSBjaGFuZ2UgdGhlIHN0eWxlIHNvbWV0aW1lcyAod2l0aCBcXGRmcmFjIG9yIFxcdGZyYWMpLFxuICAgIC8vIGFjY291bnQgZm9yIHRoZSBwb3NzaWJsZSBzaXplIGNoYW5nZSBoZXJlLlxuICAgIGZyYWMuaGVpZ2h0ICo9IHN0eWxlLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zdHlsZS5zaXplTXVsdGlwbGllcjtcbiAgICBmcmFjLmRlcHRoICo9IHN0eWxlLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zdHlsZS5zaXplTXVsdGlwbGllcjtcblxuICAgIC8vIFJ1bGUgMTVlXG4gICAgdmFyIGRlbGltU2l6ZTtcbiAgICBpZiAoc3R5bGUuc2l6ZSA9PT0gU3R5bGUuRElTUExBWS5zaXplKSB7XG4gICAgICAgIGRlbGltU2l6ZSA9IHN0eWxlLm1ldHJpY3MuZGVsaW0xO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGltU2l6ZSA9IHN0eWxlLm1ldHJpY3MuZGVsaW0yO1xuICAgIH1cblxuICAgIHZhciBsZWZ0RGVsaW07XG4gICAgdmFyIHJpZ2h0RGVsaW07XG4gICAgaWYgKGdyb3VwLnZhbHVlLmxlZnREZWxpbSA9PSBudWxsKSB7XG4gICAgICAgIGxlZnREZWxpbSA9IG1ha2VOdWxsRGVsaW1pdGVyKG9wdGlvbnMsIFtcIm1vcGVuXCJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZWZ0RGVsaW0gPSBkZWxpbWl0ZXIuY3VzdG9tU2l6ZWREZWxpbShcbiAgICAgICAgICAgIGdyb3VwLnZhbHVlLmxlZnREZWxpbSwgZGVsaW1TaXplLCB0cnVlLFxuICAgICAgICAgICAgb3B0aW9ucy53aXRoU3R5bGUoc3R5bGUpLCBncm91cC5tb2RlLCBbXCJtb3BlblwiXSk7XG4gICAgfVxuICAgIGlmIChncm91cC52YWx1ZS5yaWdodERlbGltID09IG51bGwpIHtcbiAgICAgICAgcmlnaHREZWxpbSA9IG1ha2VOdWxsRGVsaW1pdGVyKG9wdGlvbnMsIFtcIm1jbG9zZVwiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmlnaHREZWxpbSA9IGRlbGltaXRlci5jdXN0b21TaXplZERlbGltKFxuICAgICAgICAgICAgZ3JvdXAudmFsdWUucmlnaHREZWxpbSwgZGVsaW1TaXplLCB0cnVlLFxuICAgICAgICAgICAgb3B0aW9ucy53aXRoU3R5bGUoc3R5bGUpLCBncm91cC5tb2RlLCBbXCJtY2xvc2VcIl0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYWtlU3BhbihcbiAgICAgICAgW1wibW9yZFwiLCBvcHRpb25zLnN0eWxlLnJlc2V0KCksIHN0eWxlLmNscygpXSxcbiAgICAgICAgW2xlZnREZWxpbSwgbWFrZVNwYW4oW1wibWZyYWNcIl0sIFtmcmFjXSksIHJpZ2h0RGVsaW1dLFxuICAgICAgICBvcHRpb25zKTtcbn07XG5cbnZhciBjYWxjdWxhdGVTaXplID0gZnVuY3Rpb24oc2l6ZVZhbHVlLCBzdHlsZSkge1xuICAgIHZhciB4ID0gc2l6ZVZhbHVlLm51bWJlcjtcbiAgICBpZiAoc2l6ZVZhbHVlLnVuaXQgPT09IFwiZXhcIikge1xuICAgICAgICB4ICo9IHN0eWxlLm1ldHJpY3MuZW1QZXJFeDtcbiAgICB9IGVsc2UgaWYgKHNpemVWYWx1ZS51bml0ID09PSBcIm11XCIpIHtcbiAgICAgICAgeCAvPSAxODtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG59O1xuXG5ncm91cFR5cGVzLmFycmF5ID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgcjtcbiAgICB2YXIgYztcbiAgICB2YXIgbnIgPSBncm91cC52YWx1ZS5ib2R5Lmxlbmd0aDtcbiAgICB2YXIgbmMgPSAwO1xuICAgIHZhciBib2R5ID0gbmV3IEFycmF5KG5yKTtcblxuICAgIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG5cbiAgICAvLyBIb3Jpem9udGFsIHNwYWNpbmdcbiAgICB2YXIgcHQgPSAxIC8gZm9udE1ldHJpY3MubWV0cmljcy5wdFBlckVtO1xuICAgIHZhciBhcnJheWNvbHNlcCA9IDUgKiBwdDsgLy8gXFxhcnJheWNvbHNlcCBpbiBhcnRpY2xlLmNsc1xuXG4gICAgLy8gVmVydGljYWwgc3BhY2luZ1xuICAgIHZhciBiYXNlbGluZXNraXAgPSAxMiAqIHB0OyAvLyBzZWUgc2l6ZTEwLmNsb1xuICAgIC8vIERlZmF1bHQgXFxhcnJheXN0cmV0Y2ggZnJvbSBsdHRhYi5kdHhcbiAgICAvLyBUT0RPKGdhZ2Vybik6IG1heSBnZXQgcmVkZWZpbmVkIG9uY2Ugd2UgaGF2ZSB1c2VyLWRlZmluZWQgbWFjcm9zXG4gICAgdmFyIGFycmF5c3RyZXRjaCA9IHV0aWxzLmRlZmx0KGdyb3VwLnZhbHVlLmFycmF5c3RyZXRjaCwgMSk7XG4gICAgdmFyIGFycmF5c2tpcCA9IGFycmF5c3RyZXRjaCAqIGJhc2VsaW5lc2tpcDtcbiAgICB2YXIgYXJzdHJ1dEhlaWdodCA9IDAuNyAqIGFycmF5c2tpcDsgLy8gXFxzdHJ1dGJveCBpbiBsdGZzc3RyYy5kdHggYW5kXG4gICAgdmFyIGFyc3RydXREZXB0aCA9IDAuMyAqIGFycmF5c2tpcDsgIC8vIFxcQGFyc3RydXRib3ggaW4gbHR0YWIuZHR4XG5cbiAgICB2YXIgdG90YWxIZWlnaHQgPSAwO1xuICAgIGZvciAociA9IDA7IHIgPCBncm91cC52YWx1ZS5ib2R5Lmxlbmd0aDsgKytyKSB7XG4gICAgICAgIHZhciBpbnJvdyA9IGdyb3VwLnZhbHVlLmJvZHlbcl07XG4gICAgICAgIHZhciBoZWlnaHQgPSBhcnN0cnV0SGVpZ2h0OyAvLyBcXEBhcnJheSBhZGRzIGFuIFxcQGFyc3RydXRcbiAgICAgICAgdmFyIGRlcHRoID0gYXJzdHJ1dERlcHRoOyAgIC8vIHRvIGVhY2ggdG93ICh2aWEgdGhlIHRlbXBsYXRlKVxuXG4gICAgICAgIGlmIChuYyA8IGlucm93Lmxlbmd0aCkge1xuICAgICAgICAgICAgbmMgPSBpbnJvdy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3V0cm93ID0gbmV3IEFycmF5KGlucm93Lmxlbmd0aCk7XG4gICAgICAgIGZvciAoYyA9IDA7IGMgPCBpbnJvdy5sZW5ndGg7ICsrYykge1xuICAgICAgICAgICAgdmFyIGVsdCA9IGJ1aWxkR3JvdXAoaW5yb3dbY10sIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGRlcHRoIDwgZWx0LmRlcHRoKSB7XG4gICAgICAgICAgICAgICAgZGVwdGggPSBlbHQuZGVwdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGVpZ2h0IDwgZWx0LmhlaWdodCkge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IGVsdC5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRyb3dbY10gPSBlbHQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ2FwID0gMDtcbiAgICAgICAgaWYgKGdyb3VwLnZhbHVlLnJvd0dhcHNbcl0pIHtcbiAgICAgICAgICAgIGdhcCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAudmFsdWUucm93R2Fwc1tyXS52YWx1ZSwgc3R5bGUpO1xuICAgICAgICAgICAgaWYgKGdhcCA+IDApIHsgLy8gXFxAYXJnYXJyYXljclxuICAgICAgICAgICAgICAgIGdhcCArPSBhcnN0cnV0RGVwdGg7XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoIDwgZ2FwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoID0gZ2FwOyAvLyBcXEB4YXJnYXJyYXljclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnYXAgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb3V0cm93LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgb3V0cm93LmRlcHRoID0gZGVwdGg7XG4gICAgICAgIHRvdGFsSGVpZ2h0ICs9IGhlaWdodDtcbiAgICAgICAgb3V0cm93LnBvcyA9IHRvdGFsSGVpZ2h0O1xuICAgICAgICB0b3RhbEhlaWdodCArPSBkZXB0aCArIGdhcDsgLy8gXFxAeWFyZ2FycmF5Y3JcbiAgICAgICAgYm9keVtyXSA9IG91dHJvdztcbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0ID0gdG90YWxIZWlnaHQgLyAyICsgc3R5bGUubWV0cmljcy5heGlzSGVpZ2h0O1xuICAgIHZhciBjb2xEZXNjcmlwdGlvbnMgPSBncm91cC52YWx1ZS5jb2xzIHx8IFtdO1xuICAgIHZhciBjb2xzID0gW107XG4gICAgdmFyIGNvbFNlcDtcbiAgICB2YXIgY29sRGVzY3JOdW07XG4gICAgZm9yIChjID0gMCwgY29sRGVzY3JOdW0gPSAwO1xuICAgICAgICAgLy8gQ29udGludWUgd2hpbGUgZWl0aGVyIHRoZXJlIGFyZSBtb3JlIGNvbHVtbnMgb3IgbW9yZSBjb2x1bW5cbiAgICAgICAgIC8vIGRlc2NyaXB0aW9ucywgc28gdHJhaWxpbmcgc2VwYXJhdG9ycyBkb24ndCBnZXQgbG9zdC5cbiAgICAgICAgIGMgPCBuYyB8fCBjb2xEZXNjck51bSA8IGNvbERlc2NyaXB0aW9ucy5sZW5ndGg7XG4gICAgICAgICArK2MsICsrY29sRGVzY3JOdW0pIHtcblxuICAgICAgICB2YXIgY29sRGVzY3IgPSBjb2xEZXNjcmlwdGlvbnNbY29sRGVzY3JOdW1dIHx8IHt9O1xuXG4gICAgICAgIHZhciBmaXJzdFNlcGFyYXRvciA9IHRydWU7XG4gICAgICAgIHdoaWxlIChjb2xEZXNjci50eXBlID09PSBcInNlcGFyYXRvclwiKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIHNlcGFyYXRvciBpbiBhIHJvdywgYWRkIGEgc3BhY2VcbiAgICAgICAgICAgIC8vIGJldHdlZW4gdGhlbS5cbiAgICAgICAgICAgIGlmICghZmlyc3RTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBjb2xTZXAgPSBtYWtlU3BhbihbXCJhcnJheWNvbHNlcFwiXSwgW10pO1xuICAgICAgICAgICAgICAgIGNvbFNlcC5zdHlsZS53aWR0aCA9XG4gICAgICAgICAgICAgICAgICAgIGZvbnRNZXRyaWNzLm1ldHJpY3MuZG91YmxlUnVsZVNlcCArIFwiZW1cIjtcbiAgICAgICAgICAgICAgICBjb2xzLnB1c2goY29sU2VwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbERlc2NyLnNlcGFyYXRvciA9PT0gXCJ8XCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VwYXJhdG9yID0gbWFrZVNwYW4oXG4gICAgICAgICAgICAgICAgICAgIFtcInZlcnRpY2FsLXNlcGFyYXRvclwiXSxcbiAgICAgICAgICAgICAgICAgICAgW10pO1xuICAgICAgICAgICAgICAgIHNlcGFyYXRvci5zdHlsZS5oZWlnaHQgPSB0b3RhbEhlaWdodCArIFwiZW1cIjtcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3Iuc3R5bGUudmVydGljYWxBbGlnbiA9XG4gICAgICAgICAgICAgICAgICAgIC0odG90YWxIZWlnaHQgLSBvZmZzZXQpICsgXCJlbVwiO1xuXG4gICAgICAgICAgICAgICAgY29scy5wdXNoKHNlcGFyYXRvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkludmFsaWQgc2VwYXJhdG9yIHR5cGU6IFwiICsgY29sRGVzY3Iuc2VwYXJhdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29sRGVzY3JOdW0rKztcbiAgICAgICAgICAgIGNvbERlc2NyID0gY29sRGVzY3JpcHRpb25zW2NvbERlc2NyTnVtXSB8fCB7fTtcbiAgICAgICAgICAgIGZpcnN0U2VwYXJhdG9yID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA+PSBuYykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2Vwd2lkdGg7XG4gICAgICAgIGlmIChjID4gMCB8fCBncm91cC52YWx1ZS5oc2tpcEJlZm9yZUFuZEFmdGVyKSB7XG4gICAgICAgICAgICBzZXB3aWR0aCA9IHV0aWxzLmRlZmx0KGNvbERlc2NyLnByZWdhcCwgYXJyYXljb2xzZXApO1xuICAgICAgICAgICAgaWYgKHNlcHdpZHRoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29sU2VwID0gbWFrZVNwYW4oW1wiYXJyYXljb2xzZXBcIl0sIFtdKTtcbiAgICAgICAgICAgICAgICBjb2xTZXAuc3R5bGUud2lkdGggPSBzZXB3aWR0aCArIFwiZW1cIjtcbiAgICAgICAgICAgICAgICBjb2xzLnB1c2goY29sU2VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2wgPSBbXTtcbiAgICAgICAgZm9yIChyID0gMDsgciA8IG5yOyArK3IpIHtcbiAgICAgICAgICAgIHZhciByb3cgPSBib2R5W3JdO1xuICAgICAgICAgICAgdmFyIGVsZW0gPSByb3dbY107XG4gICAgICAgICAgICBpZiAoIWVsZW0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzaGlmdCA9IHJvdy5wb3MgLSBvZmZzZXQ7XG4gICAgICAgICAgICBlbGVtLmRlcHRoID0gcm93LmRlcHRoO1xuICAgICAgICAgICAgZWxlbS5oZWlnaHQgPSByb3cuaGVpZ2h0O1xuICAgICAgICAgICAgY29sLnB1c2goe3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBlbGVtLCBzaGlmdDogc2hpZnR9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdChjb2wsIFwiaW5kaXZpZHVhbFNoaWZ0XCIsIG51bGwsIG9wdGlvbnMpO1xuICAgICAgICBjb2wgPSBtYWtlU3BhbihcbiAgICAgICAgICAgIFtcImNvbC1hbGlnbi1cIiArIChjb2xEZXNjci5hbGlnbiB8fCBcImNcIildLFxuICAgICAgICAgICAgW2NvbF0pO1xuICAgICAgICBjb2xzLnB1c2goY29sKTtcblxuICAgICAgICBpZiAoYyA8IG5jIC0gMSB8fCBncm91cC52YWx1ZS5oc2tpcEJlZm9yZUFuZEFmdGVyKSB7XG4gICAgICAgICAgICBzZXB3aWR0aCA9IHV0aWxzLmRlZmx0KGNvbERlc2NyLnBvc3RnYXAsIGFycmF5Y29sc2VwKTtcbiAgICAgICAgICAgIGlmIChzZXB3aWR0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbFNlcCA9IG1ha2VTcGFuKFtcImFycmF5Y29sc2VwXCJdLCBbXSk7XG4gICAgICAgICAgICAgICAgY29sU2VwLnN0eWxlLndpZHRoID0gc2Vwd2lkdGggKyBcImVtXCI7XG4gICAgICAgICAgICAgICAgY29scy5wdXNoKGNvbFNlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYm9keSA9IG1ha2VTcGFuKFtcIm10YWJsZVwiXSwgY29scyk7XG4gICAgcmV0dXJuIG1ha2VTcGFuKFtcIm1vcmRcIl0sIFtib2R5XSwgb3B0aW9ucyk7XG59O1xuXG5ncm91cFR5cGVzLnNwYWNpbmcgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIGlmIChncm91cC52YWx1ZSA9PT0gXCJcXFxcIFwiIHx8IGdyb3VwLnZhbHVlID09PSBcIlxcXFxzcGFjZVwiIHx8XG4gICAgICAgIGdyb3VwLnZhbHVlID09PSBcIiBcIiB8fCBncm91cC52YWx1ZSA9PT0gXCJ+XCIpIHtcbiAgICAgICAgLy8gU3BhY2VzIGFyZSBnZW5lcmF0ZWQgYnkgYWRkaW5nIGFuIGFjdHVhbCBzcGFjZS4gRWFjaCBvZiB0aGVzZVxuICAgICAgICAvLyB0aGluZ3MgaGFzIGFuIGVudHJ5IGluIHRoZSBzeW1ib2xzIHRhYmxlLCBzbyB0aGVzZSB3aWxsIGJlIHR1cm5lZFxuICAgICAgICAvLyBpbnRvIGFwcHJvcHJpYXRlIG91dHB1dHMuXG4gICAgICAgIGlmIChncm91cC5tb2RlID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VPcmQoZ3JvdXAsIG9wdGlvbnMsIFwidGV4dG9yZFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlU3BhbihbXCJtc3BhY2VcIl0sXG4gICAgICAgICAgICAgICAgW2J1aWxkQ29tbW9uLm1hdGhzeW0oZ3JvdXAudmFsdWUsIGdyb3VwLm1vZGUsIG9wdGlvbnMpXSxcbiAgICAgICAgICAgICAgICBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyIGtpbmRzIG9mIHNwYWNlcyBhcmUgb2YgYXJiaXRyYXJ5IHdpZHRoLiBXZSB1c2UgQ1NTIHRvXG4gICAgICAgIC8vIGdlbmVyYXRlIHRoZXNlLlxuICAgICAgICByZXR1cm4gbWFrZVNwYW4oXG4gICAgICAgICAgICBbXCJtc3BhY2VcIixcbiAgICAgICAgICAgICAgICBidWlsZENvbW1vbi5zcGFjaW5nRnVuY3Rpb25zW2dyb3VwLnZhbHVlXS5jbGFzc05hbWVdLFxuICAgICAgICAgICAgW10sIG9wdGlvbnMpO1xuICAgIH1cbn07XG5cbmdyb3VwVHlwZXMubGxhcCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGlubmVyID0gbWFrZVNwYW4oXG4gICAgICAgIFtcImlubmVyXCJdLCBbYnVpbGRHcm91cChncm91cC52YWx1ZS5ib2R5LCBvcHRpb25zLnJlc2V0KCkpXSk7XG4gICAgdmFyIGZpeCA9IG1ha2VTcGFuKFtcImZpeFwiXSwgW10pO1xuICAgIHJldHVybiBtYWtlU3BhbihcbiAgICAgICAgW1wibW9yZFwiLCBcImxsYXBcIiwgb3B0aW9ucy5zdHlsZS5jbHMoKV0sIFtpbm5lciwgZml4XSwgb3B0aW9ucyk7XG59O1xuXG5ncm91cFR5cGVzLnJsYXAgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBpbm5lciA9IG1ha2VTcGFuKFxuICAgICAgICBbXCJpbm5lclwiXSwgW2J1aWxkR3JvdXAoZ3JvdXAudmFsdWUuYm9keSwgb3B0aW9ucy5yZXNldCgpKV0pO1xuICAgIHZhciBmaXggPSBtYWtlU3BhbihbXCJmaXhcIl0sIFtdKTtcbiAgICByZXR1cm4gbWFrZVNwYW4oXG4gICAgICAgIFtcIm1vcmRcIiwgXCJybGFwXCIsIG9wdGlvbnMuc3R5bGUuY2xzKCldLCBbaW5uZXIsIGZpeF0sIG9wdGlvbnMpO1xufTtcblxuZ3JvdXBUeXBlcy5vcCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gT3BlcmF0b3JzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnLiA0NDMtNDQ0LCBydWxlIDEzKGEpLlxuICAgIHZhciBzdXBHcm91cDtcbiAgICB2YXIgc3ViR3JvdXA7XG4gICAgdmFyIGhhc0xpbWl0cyA9IGZhbHNlO1xuICAgIGlmIChncm91cC50eXBlID09PSBcInN1cHN1YlwiKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgbGltaXRzLCBzdXBzdWIgd2lsbCBwYXNzIHVzIGl0cyBncm91cCB0byBoYW5kbGUuIFB1bGxcbiAgICAgICAgLy8gb3V0IHRoZSBzdXBlcnNjcmlwdCBhbmQgc3Vic2NyaXB0IGFuZCBzZXQgdGhlIGdyb3VwIHRvIHRoZSBvcCBpblxuICAgICAgICAvLyBpdHMgYmFzZS5cbiAgICAgICAgc3VwR3JvdXAgPSBncm91cC52YWx1ZS5zdXA7XG4gICAgICAgIHN1Ykdyb3VwID0gZ3JvdXAudmFsdWUuc3ViO1xuICAgICAgICBncm91cCA9IGdyb3VwLnZhbHVlLmJhc2U7XG4gICAgICAgIGhhc0xpbWl0cyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcblxuICAgIC8vIE1vc3Qgb3BlcmF0b3JzIGhhdmUgYSBsYXJnZSBzdWNjZXNzb3Igc3ltYm9sLCBidXQgdGhlc2UgZG9uJ3QuXG4gICAgdmFyIG5vU3VjY2Vzc29yID0gW1xuICAgICAgICBcIlxcXFxzbWFsbGludFwiXG4gICAgXTtcblxuICAgIHZhciBsYXJnZSA9IGZhbHNlO1xuICAgIGlmIChzdHlsZS5zaXplID09PSBTdHlsZS5ESVNQTEFZLnNpemUgJiZcbiAgICAgICAgZ3JvdXAudmFsdWUuc3ltYm9sICYmXG4gICAgICAgICF1dGlscy5jb250YWlucyhub1N1Y2Nlc3NvciwgZ3JvdXAudmFsdWUuYm9keSkpIHtcblxuICAgICAgICAvLyBNb3N0IHN5bWJvbCBvcGVyYXRvcnMgZ2V0IGxhcmdlciBpbiBkaXNwbGF5c3R5bGUgKHJ1bGUgMTMpXG4gICAgICAgIGxhcmdlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgYmFzZTtcbiAgICB2YXIgYmFzZVNoaWZ0ID0gMDtcbiAgICB2YXIgc2xhbnQgPSAwO1xuICAgIGlmIChncm91cC52YWx1ZS5zeW1ib2wpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHN5bWJvbCwgY3JlYXRlIHRoZSBzeW1ib2wuXG4gICAgICAgIHZhciBmb250TmFtZSA9IGxhcmdlID8gXCJTaXplMi1SZWd1bGFyXCIgOiBcIlNpemUxLVJlZ3VsYXJcIjtcbiAgICAgICAgYmFzZSA9IGJ1aWxkQ29tbW9uLm1ha2VTeW1ib2woXG4gICAgICAgICAgICBncm91cC52YWx1ZS5ib2R5LCBmb250TmFtZSwgXCJtYXRoXCIsIG9wdGlvbnMsXG4gICAgICAgICAgICBbXCJtb3BcIiwgXCJvcC1zeW1ib2xcIiwgbGFyZ2UgPyBcImxhcmdlLW9wXCIgOiBcInNtYWxsLW9wXCJdKTtcblxuICAgICAgICAvLyBTaGlmdCB0aGUgc3ltYm9sIHNvIGl0cyBjZW50ZXIgbGllcyBvbiB0aGUgYXhpcyAocnVsZSAxMykuIEl0XG4gICAgICAgIC8vIGFwcGVhcnMgdGhhdCBvdXIgZm9udHMgaGF2ZSB0aGUgY2VudGVycyBvZiB0aGUgc3ltYm9scyBhbHJlYWR5XG4gICAgICAgIC8vIGFsbW9zdCBvbiB0aGUgYXhpcywgc28gdGhlc2UgbnVtYmVycyBhcmUgdmVyeSBzbWFsbC4gTm90ZSB3ZVxuICAgICAgICAvLyBkb24ndCBhY3R1YWxseSBhcHBseSB0aGlzIGhlcmUsIGJ1dCBpbnN0ZWFkIGl0IGlzIHVzZWQgZWl0aGVyIGluXG4gICAgICAgIC8vIHRoZSB2bGlzdCBjcmVhdGlvbiBvciBzZXBhcmF0ZWx5IHdoZW4gdGhlcmUgYXJlIG5vIGxpbWl0cy5cbiAgICAgICAgYmFzZVNoaWZ0ID0gKGJhc2UuaGVpZ2h0IC0gYmFzZS5kZXB0aCkgLyAyIC1cbiAgICAgICAgICAgIHN0eWxlLm1ldHJpY3MuYXhpc0hlaWdodCAqIHN0eWxlLnNpemVNdWx0aXBsaWVyO1xuXG4gICAgICAgIC8vIFRoZSBzbGFudCBvZiB0aGUgc3ltYm9sIGlzIGp1c3QgaXRzIGl0YWxpYyBjb3JyZWN0aW9uLlxuICAgICAgICBzbGFudCA9IGJhc2UuaXRhbGljO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAudmFsdWUudmFsdWUpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIGxpc3QsIGNvbXBvc2UgdGhhdCBsaXN0LlxuICAgICAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUudmFsdWUsIG9wdGlvbnMsIHRydWUpO1xuXG4gICAgICAgIGJhc2UgPSBtYWtlU3BhbihbXCJtb3BcIl0sIGlubmVyLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UsIHRoaXMgaXMgYSB0ZXh0IG9wZXJhdG9yLiBCdWlsZCB0aGUgdGV4dCBmcm9tIHRoZVxuICAgICAgICAvLyBvcGVyYXRvcidzIG5hbWUuXG4gICAgICAgIC8vIFRPRE8oZW1pbHkpOiBBZGQgYSBzcGFjZSBpbiB0aGUgbWlkZGxlIG9mIHNvbWUgb2YgdGhlc2VcbiAgICAgICAgLy8gb3BlcmF0b3JzLCBsaWtlIFxcbGltc3VwXG4gICAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBncm91cC52YWx1ZS5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChidWlsZENvbW1vbi5tYXRoc3ltKGdyb3VwLnZhbHVlLmJvZHlbaV0sIGdyb3VwLm1vZGUpKTtcbiAgICAgICAgfVxuICAgICAgICBiYXNlID0gbWFrZVNwYW4oW1wibW9wXCJdLCBvdXRwdXQsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChoYXNMaW1pdHMpIHtcbiAgICAgICAgLy8gSUUgOCBjbGlwcyBcXGludCBpZiBpdCBpcyBpbiBhIGRpc3BsYXk6IGlubGluZS1ibG9jay4gV2Ugd3JhcCBpdFxuICAgICAgICAvLyBpbiBhIG5ldyBzcGFuIHNvIGl0IGlzIGFuIGlubGluZSwgYW5kIHdvcmtzLlxuICAgICAgICBiYXNlID0gbWFrZVNwYW4oW10sIFtiYXNlXSk7XG5cbiAgICAgICAgdmFyIHN1cG1pZDtcbiAgICAgICAgdmFyIHN1cEtlcm47XG4gICAgICAgIHZhciBzdWJtaWQ7XG4gICAgICAgIHZhciBzdWJLZXJuO1xuICAgICAgICB2YXIgbmV3T3B0aW9ucztcbiAgICAgICAgLy8gV2UgbWFudWFsbHkgaGF2ZSB0byBoYW5kbGUgdGhlIHN1cGVyc2NyaXB0cyBhbmQgc3Vic2NyaXB0cy4gVGhpcyxcbiAgICAgICAgLy8gYXNpZGUgZnJvbSB0aGUga2VybiBjYWxjdWxhdGlvbnMsIGlzIGNvcGllZCBmcm9tIHN1cHN1Yi5cbiAgICAgICAgaWYgKHN1cEdyb3VwKSB7XG4gICAgICAgICAgICBuZXdPcHRpb25zID0gb3B0aW9ucy53aXRoU3R5bGUoc3R5bGUuc3VwKCkpO1xuICAgICAgICAgICAgdmFyIHN1cCA9IGJ1aWxkR3JvdXAoc3VwR3JvdXAsIG5ld09wdGlvbnMpO1xuICAgICAgICAgICAgc3VwbWlkID0gbWFrZVNwYW4oW3N0eWxlLnJlc2V0KCksIHN0eWxlLnN1cCgpLmNscygpXSxcbiAgICAgICAgICAgICAgICBbc3VwXSwgbmV3T3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHN1cEtlcm4gPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgICBmb250TWV0cmljcy5tZXRyaWNzLmJpZ09wU3BhY2luZzEsXG4gICAgICAgICAgICAgICAgZm9udE1ldHJpY3MubWV0cmljcy5iaWdPcFNwYWNpbmczIC0gc3VwLmRlcHRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdWJHcm91cCkge1xuICAgICAgICAgICAgbmV3T3B0aW9ucyA9IG9wdGlvbnMud2l0aFN0eWxlKHN0eWxlLnN1YigpKTtcbiAgICAgICAgICAgIHZhciBzdWIgPSBidWlsZEdyb3VwKHN1Ykdyb3VwLCBuZXdPcHRpb25zKTtcbiAgICAgICAgICAgIHN1Ym1pZCA9IG1ha2VTcGFuKFtzdHlsZS5yZXNldCgpLCBzdHlsZS5zdWIoKS5jbHMoKV0sXG4gICAgICAgICAgICAgICAgW3N1Yl0sIG5ld09wdGlvbnMpO1xuXG4gICAgICAgICAgICBzdWJLZXJuID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgZm9udE1ldHJpY3MubWV0cmljcy5iaWdPcFNwYWNpbmcyLFxuICAgICAgICAgICAgICAgIGZvbnRNZXRyaWNzLm1ldHJpY3MuYmlnT3BTcGFjaW5nNCAtIHN1Yi5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQnVpbGQgdGhlIGZpbmFsIGdyb3VwIGFzIGEgdmxpc3Qgb2YgdGhlIHBvc3NpYmxlIHN1YnNjcmlwdCwgYmFzZSxcbiAgICAgICAgLy8gYW5kIHBvc3NpYmxlIHN1cGVyc2NyaXB0LlxuICAgICAgICB2YXIgZmluYWxHcm91cDtcbiAgICAgICAgdmFyIHRvcDtcbiAgICAgICAgdmFyIGJvdHRvbTtcbiAgICAgICAgaWYgKCFzdXBHcm91cCkge1xuICAgICAgICAgICAgdG9wID0gYmFzZS5oZWlnaHQgLSBiYXNlU2hpZnQ7XG5cbiAgICAgICAgICAgIGZpbmFsR3JvdXAgPSBidWlsZENvbW1vbi5tYWtlVkxpc3QoW1xuICAgICAgICAgICAgICAgIHt0eXBlOiBcImtlcm5cIiwgc2l6ZTogZm9udE1ldHJpY3MubWV0cmljcy5iaWdPcFNwYWNpbmc1fSxcbiAgICAgICAgICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IHN1Ym1pZH0sXG4gICAgICAgICAgICAgICAge3R5cGU6IFwia2VyblwiLCBzaXplOiBzdWJLZXJufSxcbiAgICAgICAgICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IGJhc2V9XG4gICAgICAgICAgICBdLCBcInRvcFwiLCB0b3AsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAvLyBIZXJlLCB3ZSBzaGlmdCB0aGUgbGltaXRzIGJ5IHRoZSBzbGFudCBvZiB0aGUgc3ltYm9sLiBOb3RlXG4gICAgICAgICAgICAvLyB0aGF0IHdlIGFyZSBzdXBwb3NlZCB0byBzaGlmdCB0aGUgbGltaXRzIGJ5IDEvMiBvZiB0aGUgc2xhbnQsXG4gICAgICAgICAgICAvLyBidXQgc2luY2Ugd2UgYXJlIGNlbnRlcmluZyB0aGUgbGltaXRzIGFkZGluZyBhIGZ1bGwgc2xhbnQgb2ZcbiAgICAgICAgICAgIC8vIG1hcmdpbiB3aWxsIHNoaWZ0IGJ5IDEvMiB0aGF0LlxuICAgICAgICAgICAgZmluYWxHcm91cC5jaGlsZHJlblswXS5zdHlsZS5tYXJnaW5MZWZ0ID0gLXNsYW50ICsgXCJlbVwiO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdWJHcm91cCkge1xuICAgICAgICAgICAgYm90dG9tID0gYmFzZS5kZXB0aCArIGJhc2VTaGlmdDtcblxuICAgICAgICAgICAgZmluYWxHcm91cCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdChbXG4gICAgICAgICAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBiYXNlfSxcbiAgICAgICAgICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IHN1cEtlcm59LFxuICAgICAgICAgICAgICAgIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogc3VwbWlkfSxcbiAgICAgICAgICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IGZvbnRNZXRyaWNzLm1ldHJpY3MuYmlnT3BTcGFjaW5nNX1cbiAgICAgICAgICAgIF0sIFwiYm90dG9tXCIsIGJvdHRvbSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIFNlZSBjb21tZW50IGFib3ZlIGFib3V0IHNsYW50c1xuICAgICAgICAgICAgZmluYWxHcm91cC5jaGlsZHJlblsxXS5zdHlsZS5tYXJnaW5MZWZ0ID0gc2xhbnQgKyBcImVtXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN1cEdyb3VwICYmICFzdWJHcm91cCkge1xuICAgICAgICAgICAgLy8gVGhpcyBjYXNlIHByb2JhYmx5IHNob3VsZG4ndCBvY2N1ciAodGhpcyB3b3VsZCBtZWFuIHRoZVxuICAgICAgICAgICAgLy8gc3Vwc3ViIHdhcyBzZW5kaW5nIHVzIGEgZ3JvdXAgd2l0aCBubyBzdXBlcnNjcmlwdCBvclxuICAgICAgICAgICAgLy8gc3Vic2NyaXB0KSBidXQgYmUgc2FmZS5cbiAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm90dG9tID0gZm9udE1ldHJpY3MubWV0cmljcy5iaWdPcFNwYWNpbmc1ICtcbiAgICAgICAgICAgICAgICBzdWJtaWQuaGVpZ2h0ICsgc3VibWlkLmRlcHRoICtcbiAgICAgICAgICAgICAgICBzdWJLZXJuICtcbiAgICAgICAgICAgICAgICBiYXNlLmRlcHRoICsgYmFzZVNoaWZ0O1xuXG4gICAgICAgICAgICBmaW5hbEdyb3VwID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KFtcbiAgICAgICAgICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IGZvbnRNZXRyaWNzLm1ldHJpY3MuYmlnT3BTcGFjaW5nNX0sXG4gICAgICAgICAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBzdWJtaWR9LFxuICAgICAgICAgICAgICAgIHt0eXBlOiBcImtlcm5cIiwgc2l6ZTogc3ViS2Vybn0sXG4gICAgICAgICAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBiYXNlfSxcbiAgICAgICAgICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IHN1cEtlcm59LFxuICAgICAgICAgICAgICAgIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogc3VwbWlkfSxcbiAgICAgICAgICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IGZvbnRNZXRyaWNzLm1ldHJpY3MuYmlnT3BTcGFjaW5nNX1cbiAgICAgICAgICAgIF0sIFwiYm90dG9tXCIsIGJvdHRvbSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIFNlZSBjb21tZW50IGFib3ZlIGFib3V0IHNsYW50c1xuICAgICAgICAgICAgZmluYWxHcm91cC5jaGlsZHJlblswXS5zdHlsZS5tYXJnaW5MZWZ0ID0gLXNsYW50ICsgXCJlbVwiO1xuICAgICAgICAgICAgZmluYWxHcm91cC5jaGlsZHJlblsyXS5zdHlsZS5tYXJnaW5MZWZ0ID0gc2xhbnQgKyBcImVtXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFrZVNwYW4oW1wibW9wXCIsIFwib3AtbGltaXRzXCJdLCBbZmluYWxHcm91cF0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChncm91cC52YWx1ZS5zeW1ib2wpIHtcbiAgICAgICAgICAgIGJhc2Uuc3R5bGUudG9wID0gYmFzZVNoaWZ0ICsgXCJlbVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxufTtcblxuZ3JvdXBUeXBlcy5tb2QgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBpbm5lciA9IFtdO1xuXG4gICAgaWYgKGdyb3VwLnZhbHVlLm1vZFR5cGUgPT09IFwiYm1vZFwiKSB7XG4gICAgICAgIC8vIOKAnFxcbm9uc2NyaXB0XFxtc2tpcC1cXG1lZG11c2tpcFxcbWtlcm41bXXigJ1cbiAgICAgICAgaWYgKCFvcHRpb25zLnN0eWxlLmlzVGlnaHQoKSkge1xuICAgICAgICAgICAgaW5uZXIucHVzaChtYWtlU3BhbihcbiAgICAgICAgICAgICAgICBbXCJtc3BhY2VcIiwgXCJuZWdhdGl2ZW1lZGl1bXNwYWNlXCJdLCBbXSwgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIGlubmVyLnB1c2gobWFrZVNwYW4oW1wibXNwYWNlXCIsIFwidGhpY2tzcGFjZVwiXSwgW10sIG9wdGlvbnMpKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc3R5bGUuc2l6ZSA9PT0gU3R5bGUuRElTUExBWS5zaXplKSB7XG4gICAgICAgIGlubmVyLnB1c2gobWFrZVNwYW4oW1wibXNwYWNlXCIsIFwicXVhZFwiXSwgW10sIG9wdGlvbnMpKTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLnZhbHVlLm1vZFR5cGUgPT09IFwibW9kXCIpIHtcbiAgICAgICAgaW5uZXIucHVzaChtYWtlU3BhbihbXCJtc3BhY2VcIiwgXCJ0d2VsdmVtdXNwYWNlXCJdLCBbXSwgb3B0aW9ucykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlubmVyLnB1c2gobWFrZVNwYW4oW1wibXNwYWNlXCIsIFwiZWlnaHRtdXNwYWNlXCJdLCBbXSwgb3B0aW9ucykpO1xuICAgIH1cblxuICAgIGlmIChncm91cC52YWx1ZS5tb2RUeXBlID09PSBcInBvZFwiIHx8IGdyb3VwLnZhbHVlLm1vZFR5cGUgPT09IFwicG1vZFwiKSB7XG4gICAgICAgIGlubmVyLnB1c2goYnVpbGRDb21tb24ubWF0aHN5bShcIihcIiwgZ3JvdXAubW9kZSkpO1xuICAgIH1cblxuICAgIGlmIChncm91cC52YWx1ZS5tb2RUeXBlICE9PSBcInBvZFwiKSB7XG4gICAgICAgIHZhciBtb2RJbm5lciA9IFtcbiAgICAgICAgICAgIGJ1aWxkQ29tbW9uLm1hdGhzeW0oXCJtXCIsIGdyb3VwLm1vZGUpLFxuICAgICAgICAgICAgYnVpbGRDb21tb24ubWF0aHN5bShcIm9cIiwgZ3JvdXAubW9kZSksXG4gICAgICAgICAgICBidWlsZENvbW1vbi5tYXRoc3ltKFwiZFwiLCBncm91cC5tb2RlKV07XG4gICAgICAgIGlmIChncm91cC52YWx1ZS5tb2RUeXBlID09PSBcImJtb2RcIikge1xuICAgICAgICAgICAgaW5uZXIucHVzaChtYWtlU3BhbihbXCJtYmluXCJdLCBtb2RJbm5lciwgb3B0aW9ucykpO1xuICAgICAgICAgICAgLy8g4oCcXFxta2VybjVtdVxcbm9uc2NyaXB0XFxtc2tpcC1cXG1lZG11c2tpcOKAnVxuICAgICAgICAgICAgaW5uZXIucHVzaChtYWtlU3BhbihbXCJtc3BhY2VcIiwgXCJ0aGlja3NwYWNlXCJdLCBbXSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnN0eWxlLmlzVGlnaHQoKSkge1xuICAgICAgICAgICAgICAgIGlubmVyLnB1c2gobWFrZVNwYW4oXG4gICAgICAgICAgICAgICAgICAgIFtcIm1zcGFjZVwiLCBcIm5lZ2F0aXZlbWVkaXVtc3BhY2VcIl0sIFtdLCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShpbm5lciwgbW9kSW5uZXIpO1xuICAgICAgICAgICAgaW5uZXIucHVzaChtYWtlU3BhbihbXCJtc3BhY2VcIiwgXCJzaXhtdXNwYWNlXCJdLCBbXSwgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnZhbHVlLnZhbHVlKSB7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGlubmVyLFxuICAgICAgICAgICAgYnVpbGRFeHByZXNzaW9uKGdyb3VwLnZhbHVlLnZhbHVlLCBvcHRpb25zLCBmYWxzZSkpO1xuICAgIH1cblxuICAgIGlmIChncm91cC52YWx1ZS5tb2RUeXBlID09PSBcInBvZFwiIHx8IGdyb3VwLnZhbHVlLm1vZFR5cGUgPT09IFwicG1vZFwiKSB7XG4gICAgICAgIGlubmVyLnB1c2goYnVpbGRDb21tb24ubWF0aHN5bShcIilcIiwgZ3JvdXAubW9kZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlRnJhZ21lbnQoaW5uZXIpO1xufTtcblxuZ3JvdXBUeXBlcy5rYXRleCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gVGhlIEthVGVYIGxvZ28uIFRoZSBvZmZzZXRzIGZvciB0aGUgSyBhbmQgYSB3ZXJlIGNob3NlbiB0byBsb29rXG4gICAgLy8gZ29vZCwgYnV0IHRoZSBvZmZzZXRzIGZvciB0aGUgVCwgRSwgYW5kIFggd2VyZSB0YWtlbiBmcm9tIHRoZVxuICAgIC8vIGRlZmluaXRpb24gb2YgXFxUZVggaW4gVGVYIChzZWUgVGVYYm9vayBwZy4gMzU2KVxuICAgIHZhciBrID0gbWFrZVNwYW4oXG4gICAgICAgIFtcImtcIl0sIFtidWlsZENvbW1vbi5tYXRoc3ltKFwiS1wiLCBncm91cC5tb2RlKV0sIG9wdGlvbnMpO1xuICAgIHZhciBhID0gbWFrZVNwYW4oXG4gICAgICAgIFtcImFcIl0sIFtidWlsZENvbW1vbi5tYXRoc3ltKFwiQVwiLCBncm91cC5tb2RlKV0sIG9wdGlvbnMpO1xuXG4gICAgYS5oZWlnaHQgPSAoYS5oZWlnaHQgKyAwLjIpICogMC43NTtcbiAgICBhLmRlcHRoID0gKGEuaGVpZ2h0IC0gMC4yKSAqIDAuNzU7XG5cbiAgICB2YXIgdCA9IG1ha2VTcGFuKFxuICAgICAgICBbXCJ0XCJdLCBbYnVpbGRDb21tb24ubWF0aHN5bShcIlRcIiwgZ3JvdXAubW9kZSldLCBvcHRpb25zKTtcbiAgICB2YXIgZSA9IG1ha2VTcGFuKFxuICAgICAgICBbXCJlXCJdLCBbYnVpbGRDb21tb24ubWF0aHN5bShcIkVcIiwgZ3JvdXAubW9kZSldLCBvcHRpb25zKTtcblxuICAgIGUuaGVpZ2h0ID0gKGUuaGVpZ2h0IC0gMC4yMTU1KTtcbiAgICBlLmRlcHRoID0gKGUuZGVwdGggKyAwLjIxNTUpO1xuXG4gICAgdmFyIHggPSBtYWtlU3BhbihcbiAgICAgICAgW1wieFwiXSwgW2J1aWxkQ29tbW9uLm1hdGhzeW0oXCJYXCIsIGdyb3VwLm1vZGUpXSwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gbWFrZVNwYW4oXG4gICAgICAgIFtcIm1vcmRcIiwgXCJrYXRleC1sb2dvXCJdLCBbaywgYSwgdCwgZSwgeF0sIG9wdGlvbnMpO1xufTtcblxuZ3JvdXBUeXBlcy5vdmVybGluZSA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gT3ZlcmxpbmVzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnIDQ0MywgUnVsZSA5LlxuICAgIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG5cbiAgICAvLyBCdWlsZCB0aGUgaW5uZXIgZ3JvdXAgaW4gdGhlIGNyYW1wZWQgc3R5bGUuXG4gICAgdmFyIGlubmVyR3JvdXAgPSBidWlsZEdyb3VwKGdyb3VwLnZhbHVlLmJvZHksXG4gICAgICAgICAgICBvcHRpb25zLndpdGhTdHlsZShzdHlsZS5jcmFtcCgpKSk7XG5cbiAgICB2YXIgcnVsZVdpZHRoID0gZm9udE1ldHJpY3MubWV0cmljcy5kZWZhdWx0UnVsZVRoaWNrbmVzcyAvXG4gICAgICAgIHN0eWxlLnNpemVNdWx0aXBsaWVyO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBsaW5lIGFib3ZlIHRoZSBib2R5XG4gICAgdmFyIGxpbmUgPSBtYWtlU3BhbihcbiAgICAgICAgW3N0eWxlLnJlc2V0KCksIFN0eWxlLlRFWFQuY2xzKCksIFwib3ZlcmxpbmUtbGluZVwiXSk7XG4gICAgbGluZS5oZWlnaHQgPSBydWxlV2lkdGg7XG4gICAgbGluZS5tYXhGb250U2l6ZSA9IDEuMDtcblxuICAgIC8vIEdlbmVyYXRlIHRoZSB2bGlzdCwgd2l0aCB0aGUgYXBwcm9wcmlhdGUga2VybnNcbiAgICB2YXIgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3QoW1xuICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IGlubmVyR3JvdXB9LFxuICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IDMgKiBydWxlV2lkdGh9LFxuICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IGxpbmV9LFxuICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IHJ1bGVXaWR0aH1cbiAgICBdLCBcImZpcnN0QmFzZWxpbmVcIiwgbnVsbCwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gbWFrZVNwYW4oW1wibW9yZFwiLCBcIm92ZXJsaW5lXCJdLCBbdmxpc3RdLCBvcHRpb25zKTtcbn07XG5cbmdyb3VwVHlwZXMudW5kZXJsaW5lID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICAvLyBVbmRlcmxpbmVzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnIDQ0MywgUnVsZSAxMC5cbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuXG4gICAgLy8gQnVpbGQgdGhlIGlubmVyIGdyb3VwLlxuICAgIHZhciBpbm5lckdyb3VwID0gYnVpbGRHcm91cChncm91cC52YWx1ZS5ib2R5LCBvcHRpb25zKTtcblxuICAgIHZhciBydWxlV2lkdGggPSBmb250TWV0cmljcy5tZXRyaWNzLmRlZmF1bHRSdWxlVGhpY2tuZXNzIC9cbiAgICAgICAgc3R5bGUuc2l6ZU11bHRpcGxpZXI7XG5cbiAgICAvLyBDcmVhdGUgdGhlIGxpbmUgYWJvdmUgdGhlIGJvZHlcbiAgICB2YXIgbGluZSA9IG1ha2VTcGFuKFtzdHlsZS5yZXNldCgpLCBTdHlsZS5URVhULmNscygpLCBcInVuZGVybGluZS1saW5lXCJdKTtcbiAgICBsaW5lLmhlaWdodCA9IHJ1bGVXaWR0aDtcbiAgICBsaW5lLm1heEZvbnRTaXplID0gMS4wO1xuXG4gICAgLy8gR2VuZXJhdGUgdGhlIHZsaXN0LCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBrZXJuc1xuICAgIHZhciB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdChbXG4gICAgICAgIHt0eXBlOiBcImtlcm5cIiwgc2l6ZTogcnVsZVdpZHRofSxcbiAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBsaW5lfSxcbiAgICAgICAge3R5cGU6IFwia2VyblwiLCBzaXplOiAzICogcnVsZVdpZHRofSxcbiAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBpbm5lckdyb3VwfVxuICAgIF0sIFwidG9wXCIsIGlubmVyR3JvdXAuaGVpZ2h0LCBvcHRpb25zKTtcblxuICAgIHJldHVybiBtYWtlU3BhbihbXCJtb3JkXCIsIFwidW5kZXJsaW5lXCJdLCBbdmxpc3RdLCBvcHRpb25zKTtcbn07XG5cbmdyb3VwVHlwZXMuc3FydCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gU3F1YXJlIHJvb3RzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnLiA0NDMsIFJ1bGUgMTEuXG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcblxuICAgIC8vIEZpcnN0LCB3ZSBkbyB0aGUgc2FtZSBzdGVwcyBhcyBpbiBvdmVybGluZSB0byBidWlsZCB0aGUgaW5uZXIgZ3JvdXBcbiAgICAvLyBhbmQgbGluZVxuICAgIHZhciBpbm5lciA9IGJ1aWxkR3JvdXAoZ3JvdXAudmFsdWUuYm9keSwgb3B0aW9ucy53aXRoU3R5bGUoc3R5bGUuY3JhbXAoKSkpO1xuXG4gICAgdmFyIHJ1bGVXaWR0aCA9IGZvbnRNZXRyaWNzLm1ldHJpY3MuZGVmYXVsdFJ1bGVUaGlja25lc3MgL1xuICAgICAgICBzdHlsZS5zaXplTXVsdGlwbGllcjtcblxuICAgIHZhciBsaW5lID0gbWFrZVNwYW4oXG4gICAgICAgIFtzdHlsZS5yZXNldCgpLCBTdHlsZS5URVhULmNscygpLCBcInNxcnQtbGluZVwiXSwgW10sXG4gICAgICAgIG9wdGlvbnMpO1xuICAgIGxpbmUuaGVpZ2h0ID0gcnVsZVdpZHRoO1xuICAgIGxpbmUubWF4Rm9udFNpemUgPSAxLjA7XG5cbiAgICB2YXIgcGhpID0gcnVsZVdpZHRoO1xuICAgIGlmIChzdHlsZS5pZCA8IFN0eWxlLlRFWFQuaWQpIHtcbiAgICAgICAgcGhpID0gc3R5bGUubWV0cmljcy54SGVpZ2h0O1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgY2xlYXJhbmNlIGJldHdlZW4gdGhlIGJvZHkgYW5kIGxpbmVcbiAgICB2YXIgbGluZUNsZWFyYW5jZSA9IHJ1bGVXaWR0aCArIHBoaSAvIDQ7XG5cbiAgICB2YXIgaW5uZXJIZWlnaHQgPSAoaW5uZXIuaGVpZ2h0ICsgaW5uZXIuZGVwdGgpICogc3R5bGUuc2l6ZU11bHRpcGxpZXI7XG4gICAgdmFyIG1pbkRlbGltaXRlckhlaWdodCA9IGlubmVySGVpZ2h0ICsgbGluZUNsZWFyYW5jZSArIHJ1bGVXaWR0aDtcblxuICAgIC8vIENyZWF0ZSBhIFxcc3VyZCBkZWxpbWl0ZXIgb2YgdGhlIHJlcXVpcmVkIG1pbmltdW0gc2l6ZVxuICAgIHZhciBkZWxpbSA9IG1ha2VTcGFuKFtcInNxcnQtc2lnblwiXSwgW1xuICAgICAgICBkZWxpbWl0ZXIuY3VzdG9tU2l6ZWREZWxpbShcIlxcXFxzdXJkXCIsIG1pbkRlbGltaXRlckhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsIG9wdGlvbnMsIGdyb3VwLm1vZGUpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zKTtcblxuICAgIHZhciBkZWxpbURlcHRoID0gKGRlbGltLmhlaWdodCArIGRlbGltLmRlcHRoKSAtIHJ1bGVXaWR0aDtcblxuICAgIC8vIEFkanVzdCB0aGUgY2xlYXJhbmNlIGJhc2VkIG9uIHRoZSBkZWxpbWl0ZXIgc2l6ZVxuICAgIGlmIChkZWxpbURlcHRoID4gaW5uZXIuaGVpZ2h0ICsgaW5uZXIuZGVwdGggKyBsaW5lQ2xlYXJhbmNlKSB7XG4gICAgICAgIGxpbmVDbGVhcmFuY2UgPVxuICAgICAgICAgICAgKGxpbmVDbGVhcmFuY2UgKyBkZWxpbURlcHRoIC0gaW5uZXIuaGVpZ2h0IC0gaW5uZXIuZGVwdGgpIC8gMjtcbiAgICB9XG5cbiAgICAvLyBTaGlmdCB0aGUgZGVsaW1pdGVyIHNvIHRoYXQgaXRzIHRvcCBsaW5lcyB1cCB3aXRoIHRoZSB0b3Agb2YgdGhlIGxpbmVcbiAgICB2YXIgZGVsaW1TaGlmdCA9IC0oaW5uZXIuaGVpZ2h0ICsgbGluZUNsZWFyYW5jZSArIHJ1bGVXaWR0aCkgKyBkZWxpbS5oZWlnaHQ7XG4gICAgZGVsaW0uc3R5bGUudG9wID0gZGVsaW1TaGlmdCArIFwiZW1cIjtcbiAgICBkZWxpbS5oZWlnaHQgLT0gZGVsaW1TaGlmdDtcbiAgICBkZWxpbS5kZXB0aCArPSBkZWxpbVNoaWZ0O1xuXG4gICAgLy8gV2UgYWRkIGEgc3BlY2lhbCBjYXNlIGhlcmUsIGJlY2F1c2UgZXZlbiB3aGVuIGBpbm5lcmAgaXMgZW1wdHksIHdlXG4gICAgLy8gc3RpbGwgZ2V0IGEgbGluZS4gU28sIHdlIHVzZSBhIHNpbXBsZSBoZXVyaXN0aWMgdG8gZGVjaWRlIGlmIHdlXG4gICAgLy8gc2hvdWxkIG9taXQgdGhlIGJvZHkgZW50aXJlbHkuIChub3RlIHRoaXMgZG9lc24ndCB3b3JrIGZvciBzb21ldGhpbmdcbiAgICAvLyBsaWtlIGBcXHNxcnR7XFxybGFwe3h9fWAsIGJ1dCBpZiBzb21lb25lIGlzIGRvaW5nIHRoYXQgdGhleSBkZXNlcnZlIGZvclxuICAgIC8vIGl0IG5vdCB0byB3b3JrLlxuICAgIHZhciBib2R5O1xuICAgIGlmIChpbm5lci5oZWlnaHQgPT09IDAgJiYgaW5uZXIuZGVwdGggPT09IDApIHtcbiAgICAgICAgYm9keSA9IG1ha2VTcGFuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYm9keSA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdChbXG4gICAgICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IGlubmVyfSxcbiAgICAgICAgICAgIHt0eXBlOiBcImtlcm5cIiwgc2l6ZTogbGluZUNsZWFyYW5jZX0sXG4gICAgICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IGxpbmV9LFxuICAgICAgICAgICAge3R5cGU6IFwia2VyblwiLCBzaXplOiBydWxlV2lkdGh9XG4gICAgICAgIF0sIFwiZmlyc3RCYXNlbGluZVwiLCBudWxsLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoIWdyb3VwLnZhbHVlLmluZGV4KSB7XG4gICAgICAgIHJldHVybiBtYWtlU3BhbihbXCJtb3JkXCIsIFwic3FydFwiXSwgW2RlbGltLCBib2R5XSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSGFuZGxlIHRoZSBvcHRpb25hbCByb290IGluZGV4XG5cbiAgICAgICAgLy8gVGhlIGluZGV4IGlzIGFsd2F5cyBpbiBzY3JpcHRzY3JpcHQgc3R5bGVcbiAgICAgICAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLndpdGhTdHlsZShTdHlsZS5TQ1JJUFRTQ1JJUFQpO1xuICAgICAgICB2YXIgcm9vdCA9IGJ1aWxkR3JvdXAoZ3JvdXAudmFsdWUuaW5kZXgsIG5ld09wdGlvbnMpO1xuICAgICAgICB2YXIgcm9vdFdyYXAgPSBtYWtlU3BhbihcbiAgICAgICAgICAgIFtzdHlsZS5yZXNldCgpLCBTdHlsZS5TQ1JJUFRTQ1JJUFQuY2xzKCldLFxuICAgICAgICAgICAgW3Jvb3RdLFxuICAgICAgICAgICAgbmV3T3B0aW9ucyk7XG5cbiAgICAgICAgLy8gRmlndXJlIG91dCB0aGUgaGVpZ2h0IGFuZCBkZXB0aCBvZiB0aGUgaW5uZXIgcGFydFxuICAgICAgICB2YXIgaW5uZXJSb290SGVpZ2h0ID0gTWF0aC5tYXgoZGVsaW0uaGVpZ2h0LCBib2R5LmhlaWdodCk7XG4gICAgICAgIHZhciBpbm5lclJvb3REZXB0aCA9IE1hdGgubWF4KGRlbGltLmRlcHRoLCBib2R5LmRlcHRoKTtcblxuICAgICAgICAvLyBUaGUgYW1vdW50IHRoZSBpbmRleCBpcyBzaGlmdGVkIGJ5LiBUaGlzIGlzIHRha2VuIGZyb20gdGhlIFRlWFxuICAgICAgICAvLyBzb3VyY2UsIGluIHRoZSBkZWZpbml0aW9uIG9mIGBcXHJAQHRgLlxuICAgICAgICB2YXIgdG9TaGlmdCA9IDAuNiAqIChpbm5lclJvb3RIZWlnaHQgLSBpbm5lclJvb3REZXB0aCk7XG5cbiAgICAgICAgLy8gQnVpbGQgYSBWTGlzdCB3aXRoIHRoZSBzdXBlcnNjcmlwdCBzaGlmdGVkIHVwIGNvcnJlY3RseVxuICAgICAgICB2YXIgcm9vdFZMaXN0ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KFxuICAgICAgICAgICAgW3t0eXBlOiBcImVsZW1cIiwgZWxlbTogcm9vdFdyYXB9XSxcbiAgICAgICAgICAgIFwic2hpZnRcIiwgLXRvU2hpZnQsIG9wdGlvbnMpO1xuICAgICAgICAvLyBBZGQgYSBjbGFzcyBzdXJyb3VuZGluZyBpdCBzbyB3ZSBjYW4gYWRkIG9uIHRoZSBhcHByb3ByaWF0ZVxuICAgICAgICAvLyBrZXJuaW5nXG4gICAgICAgIHZhciByb290Vkxpc3RXcmFwID0gbWFrZVNwYW4oW1wicm9vdFwiXSwgW3Jvb3RWTGlzdF0pO1xuXG4gICAgICAgIHJldHVybiBtYWtlU3BhbihbXCJtb3JkXCIsIFwic3FydFwiXSxcbiAgICAgICAgICAgIFtyb290Vkxpc3RXcmFwLCBkZWxpbSwgYm9keV0sIG9wdGlvbnMpO1xuICAgIH1cbn07XG5cbmdyb3VwVHlwZXMuc2l6aW5nID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICAvLyBIYW5kbGUgc2l6aW5nIG9wZXJhdG9ycyBsaWtlIFxcSHVnZS4gUmVhbCBUZVggZG9lc24ndCBhY3R1YWxseSBhbGxvd1xuICAgIC8vIHRoZXNlIGZ1bmN0aW9ucyBpbnNpZGUgb2YgbWF0aCBleHByZXNzaW9ucywgc28gd2UgZG8gc29tZSBzcGVjaWFsXG4gICAgLy8gaGFuZGxpbmcuXG4gICAgdmFyIGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLnZhbHVlLnZhbHVlLFxuICAgICAgICAgICAgb3B0aW9ucy53aXRoU2l6ZShncm91cC52YWx1ZS5zaXplKSwgZmFsc2UpO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgY29ycmVjdCBtYXhGb250U2l6ZS5cbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIHZhciBmb250U2l6ZSA9IGJ1aWxkQ29tbW9uLnNpemluZ011bHRpcGxpZXJbZ3JvdXAudmFsdWUuc2l6ZV07XG4gICAgZm9udFNpemUgPSBmb250U2l6ZSAqIHN0eWxlLnNpemVNdWx0aXBsaWVyO1xuXG4gICAgLy8gQWRkIHNpemUtcmVzZXR0aW5nIGNsYXNzZXMgdG8gdGhlIGlubmVyIGxpc3QgYW5kIHNldCBtYXhGb250U2l6ZVxuICAgIC8vIG1hbnVhbGx5LiBIYW5kbGUgbmVzdGVkIHNpemUgY2hhbmdlcy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlubmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwb3MgPSB1dGlscy5pbmRleE9mKGlubmVyW2ldLmNsYXNzZXMsIFwic2l6aW5nXCIpO1xuICAgICAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICAgICAgaW5uZXJbaV0uY2xhc3Nlcy5wdXNoKFwic2l6aW5nXCIsIFwicmVzZXQtXCIgKyBvcHRpb25zLnNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXAudmFsdWUuc2l6ZSwgc3R5bGUuY2xzKCkpO1xuICAgICAgICAgICAgaW5uZXJbaV0ubWF4Rm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpbm5lcltpXS5jbGFzc2VzW3BvcyArIDFdID09PSBcInJlc2V0LVwiICsgZ3JvdXAudmFsdWUuc2l6ZSkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG5lc3RlZCBzaXplIGNoYW5nZTogZS5nLiwgaW5uZXJbaV0gaXMgdGhlIFwiYlwiIGluXG4gICAgICAgICAgICAvLyBgXFxIdWdlIGEgXFxzbWFsbCBiYC4gT3ZlcnJpZGUgdGhlIG9sZCBzaXplICh0aGUgYHJlc2V0LWAgY2xhc3MpXG4gICAgICAgICAgICAvLyBidXQgbm90IHRoZSBuZXcgc2l6ZS5cbiAgICAgICAgICAgIGlubmVyW2ldLmNsYXNzZXNbcG9zICsgMV0gPSBcInJlc2V0LVwiICsgb3B0aW9ucy5zaXplO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VGcmFnbWVudChpbm5lcik7XG59O1xuXG5ncm91cFR5cGVzLnN0eWxpbmcgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIFN0eWxlIGNoYW5nZXMgYXJlIGhhbmRsZWQgaW4gdGhlIFRlWGJvb2sgb24gcGcuIDQ0MiwgUnVsZSAzLlxuXG4gICAgLy8gRmlndXJlIG91dCB3aGF0IHN0eWxlIHdlJ3JlIGNoYW5naW5nIHRvLlxuICAgIHZhciBzdHlsZU1hcCA9IHtcbiAgICAgICAgXCJkaXNwbGF5XCI6IFN0eWxlLkRJU1BMQVksXG4gICAgICAgIFwidGV4dFwiOiBTdHlsZS5URVhULFxuICAgICAgICBcInNjcmlwdFwiOiBTdHlsZS5TQ1JJUFQsXG4gICAgICAgIFwic2NyaXB0c2NyaXB0XCI6IFN0eWxlLlNDUklQVFNDUklQVFxuICAgIH07XG5cbiAgICB2YXIgbmV3U3R5bGUgPSBzdHlsZU1hcFtncm91cC52YWx1ZS5zdHlsZV07XG4gICAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLndpdGhTdHlsZShuZXdTdHlsZSk7XG5cbiAgICAvLyBCdWlsZCB0aGUgaW5uZXIgZXhwcmVzc2lvbiBpbiB0aGUgbmV3IHN0eWxlLlxuICAgIHZhciBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihcbiAgICAgICAgZ3JvdXAudmFsdWUudmFsdWUsIG5ld09wdGlvbnMsIGZhbHNlKTtcblxuICAgIC8vIEFkZCBzdHlsZS1yZXNldHRpbmcgY2xhc3NlcyB0byB0aGUgaW5uZXIgbGlzdC4gSGFuZGxlIG5lc3RlZCBjaGFuZ2VzLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5uZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBvcyA9IHV0aWxzLmluZGV4T2YoaW5uZXJbaV0uY2xhc3NlcywgbmV3U3R5bGUucmVzZXQoKSk7XG4gICAgICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgICAgICBpbm5lcltpXS5jbGFzc2VzLnB1c2gob3B0aW9ucy5zdHlsZS5yZXNldCgpLCBuZXdTdHlsZS5jbHMoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgbmVzdGVkIHN0eWxlIGNoYW5nZSwgYXMgYFxcdGV4dHN0eWxlIGFcXHNjcmlwdHN0eWxlIGJgLlxuICAgICAgICAgICAgLy8gT25seSBvdmVycmlkZSB0aGUgb2xkIHN0eWxlICh0aGUgcmVzZXQgY2xhc3MpLlxuICAgICAgICAgICAgaW5uZXJbaV0uY2xhc3Nlc1twb3NdID0gb3B0aW9ucy5zdHlsZS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBidWlsZENvbW1vbi5tYWtlRnJhZ21lbnQoaW5uZXIpO1xufTtcblxuZ3JvdXBUeXBlcy5mb250ID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgZm9udCA9IGdyb3VwLnZhbHVlLmZvbnQ7XG4gICAgcmV0dXJuIGJ1aWxkR3JvdXAoZ3JvdXAudmFsdWUuYm9keSwgb3B0aW9ucy53aXRoRm9udChmb250KSk7XG59O1xuXG5ncm91cFR5cGVzLmRlbGltc2l6aW5nID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgZGVsaW0gPSBncm91cC52YWx1ZS52YWx1ZTtcblxuICAgIGlmIChkZWxpbSA9PT0gXCIuXCIpIHtcbiAgICAgICAgLy8gRW1wdHkgZGVsaW1pdGVycyBzdGlsbCBjb3VudCBhcyBlbGVtZW50cywgZXZlbiB0aG91Z2ggdGhleSBkb24ndFxuICAgICAgICAvLyBzaG93IGFueXRoaW5nLlxuICAgICAgICByZXR1cm4gbWFrZVNwYW4oW2dyb3VwLnZhbHVlLm1jbGFzc10pO1xuICAgIH1cblxuICAgIC8vIFVzZSBkZWxpbWl0ZXIuc2l6ZWREZWxpbSB0byBnZW5lcmF0ZSB0aGUgZGVsaW1pdGVyLlxuICAgIHJldHVybiBkZWxpbWl0ZXIuc2l6ZWREZWxpbShcbiAgICAgICAgICAgIGRlbGltLCBncm91cC52YWx1ZS5zaXplLCBvcHRpb25zLCBncm91cC5tb2RlLFxuICAgICAgICAgICAgW2dyb3VwLnZhbHVlLm1jbGFzc10pO1xufTtcblxuZ3JvdXBUeXBlcy5sZWZ0cmlnaHQgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIEJ1aWxkIHRoZSBpbm5lciBleHByZXNzaW9uXG4gICAgdmFyIGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLnZhbHVlLmJvZHksIG9wdGlvbnMucmVzZXQoKSwgdHJ1ZSk7XG5cbiAgICB2YXIgaW5uZXJIZWlnaHQgPSAwO1xuICAgIHZhciBpbm5lckRlcHRoID0gMDtcbiAgICB2YXIgaGFkTWlkZGxlID0gZmFsc2U7XG5cbiAgICAvLyBDYWxjdWxhdGUgaXRzIGhlaWdodCBhbmQgZGVwdGhcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlubmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpbm5lcltpXS5pc01pZGRsZSkge1xuICAgICAgICAgICAgaGFkTWlkZGxlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlubmVySGVpZ2h0ID0gTWF0aC5tYXgoaW5uZXJbaV0uaGVpZ2h0LCBpbm5lckhlaWdodCk7XG4gICAgICAgICAgICBpbm5lckRlcHRoID0gTWF0aC5tYXgoaW5uZXJbaV0uZGVwdGgsIGlubmVyRGVwdGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcblxuICAgIC8vIFRoZSBzaXplIG9mIGRlbGltaXRlcnMgaXMgdGhlIHNhbWUsIHJlZ2FyZGxlc3Mgb2Ygd2hhdCBzdHlsZSB3ZSBhcmVcbiAgICAvLyBpbi4gVGh1cywgdG8gY29ycmVjdGx5IGNhbGN1bGF0ZSB0aGUgc2l6ZSBvZiBkZWxpbWl0ZXIgd2UgbmVlZCBhcm91bmRcbiAgICAvLyBhIGdyb3VwLCB3ZSBzY2FsZSBkb3duIHRoZSBpbm5lciBzaXplIGJhc2VkIG9uIHRoZSBzaXplLlxuICAgIGlubmVySGVpZ2h0ICo9IHN0eWxlLnNpemVNdWx0aXBsaWVyO1xuICAgIGlubmVyRGVwdGggKj0gc3R5bGUuc2l6ZU11bHRpcGxpZXI7XG5cbiAgICB2YXIgbGVmdERlbGltO1xuICAgIGlmIChncm91cC52YWx1ZS5sZWZ0ID09PSBcIi5cIikge1xuICAgICAgICAvLyBFbXB0eSBkZWxpbWl0ZXJzIGluIFxcbGVmdCBhbmQgXFxyaWdodCBtYWtlIG51bGwgZGVsaW1pdGVyIHNwYWNlcy5cbiAgICAgICAgbGVmdERlbGltID0gbWFrZU51bGxEZWxpbWl0ZXIob3B0aW9ucywgW1wibW9wZW5cIl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgdXNlIGxlZnRSaWdodERlbGltIHRvIGdlbmVyYXRlIHRoZSBjb3JyZWN0IHNpemVkXG4gICAgICAgIC8vIGRlbGltaXRlci5cbiAgICAgICAgbGVmdERlbGltID0gZGVsaW1pdGVyLmxlZnRSaWdodERlbGltKFxuICAgICAgICAgICAgZ3JvdXAudmFsdWUubGVmdCwgaW5uZXJIZWlnaHQsIGlubmVyRGVwdGgsIG9wdGlvbnMsXG4gICAgICAgICAgICBncm91cC5tb2RlLCBbXCJtb3BlblwiXSk7XG4gICAgfVxuICAgIC8vIEFkZCBpdCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBleHByZXNzaW9uXG4gICAgaW5uZXIudW5zaGlmdChsZWZ0RGVsaW0pO1xuXG4gICAgLy8gSGFuZGxlIG1pZGRsZSBkZWxpbWl0ZXJzXG4gICAgaWYgKGhhZE1pZGRsZSkge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgaW5uZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpbm5lcltpXS5pc01pZGRsZSkge1xuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBvcHRpb25zIHRoYXQgd2VyZSBhY3RpdmUgd2hlbiBcXG1pZGRsZSB3YXMgY2FsbGVkXG4gICAgICAgICAgICAgICAgaW5uZXJbaV0gPSBkZWxpbWl0ZXIubGVmdFJpZ2h0RGVsaW0oXG4gICAgICAgICAgICAgICAgICAgIGlubmVyW2ldLmlzTWlkZGxlLnZhbHVlLCBpbm5lckhlaWdodCwgaW5uZXJEZXB0aCxcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJbaV0uaXNNaWRkbGUub3B0aW9ucywgZ3JvdXAubW9kZSwgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJpZ2h0RGVsaW07XG4gICAgLy8gU2FtZSBmb3IgdGhlIHJpZ2h0IGRlbGltaXRlclxuICAgIGlmIChncm91cC52YWx1ZS5yaWdodCA9PT0gXCIuXCIpIHtcbiAgICAgICAgcmlnaHREZWxpbSA9IG1ha2VOdWxsRGVsaW1pdGVyKG9wdGlvbnMsIFtcIm1jbG9zZVwiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmlnaHREZWxpbSA9IGRlbGltaXRlci5sZWZ0UmlnaHREZWxpbShcbiAgICAgICAgICAgIGdyb3VwLnZhbHVlLnJpZ2h0LCBpbm5lckhlaWdodCwgaW5uZXJEZXB0aCwgb3B0aW9ucyxcbiAgICAgICAgICAgIGdyb3VwLm1vZGUsIFtcIm1jbG9zZVwiXSk7XG4gICAgfVxuICAgIC8vIEFkZCBpdCB0byB0aGUgZW5kIG9mIHRoZSBleHByZXNzaW9uLlxuICAgIGlubmVyLnB1c2gocmlnaHREZWxpbSk7XG5cbiAgICByZXR1cm4gbWFrZVNwYW4oXG4gICAgICAgIFtcIm1pbm5lclwiLCBzdHlsZS5jbHMoKV0sIGlubmVyLCBvcHRpb25zKTtcbn07XG5cbmdyb3VwVHlwZXMubWlkZGxlID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbWlkZGxlRGVsaW07XG4gICAgaWYgKGdyb3VwLnZhbHVlLnZhbHVlID09PSBcIi5cIikge1xuICAgICAgICBtaWRkbGVEZWxpbSA9IG1ha2VOdWxsRGVsaW1pdGVyKG9wdGlvbnMsIFtdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBtaWRkbGVEZWxpbSA9IGRlbGltaXRlci5zaXplZERlbGltKFxuICAgICAgICAgICAgZ3JvdXAudmFsdWUudmFsdWUsIDEsIG9wdGlvbnMsXG4gICAgICAgICAgICBncm91cC5tb2RlLCBbXSk7XG4gICAgICAgIG1pZGRsZURlbGltLmlzTWlkZGxlID0ge3ZhbHVlOiBncm91cC52YWx1ZS52YWx1ZSwgb3B0aW9uczogb3B0aW9uc307XG4gICAgfVxuICAgIHJldHVybiBtaWRkbGVEZWxpbTtcbn07XG5cbmdyb3VwVHlwZXMucnVsZSA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gTWFrZSBhbiBlbXB0eSBzcGFuIGZvciB0aGUgcnVsZVxuICAgIHZhciBydWxlID0gbWFrZVNwYW4oW1wibW9yZFwiLCBcInJ1bGVcIl0sIFtdLCBvcHRpb25zKTtcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBzaGlmdCwgd2lkdGgsIGFuZCBoZWlnaHQgb2YgdGhlIHJ1bGUsIGFuZCBhY2NvdW50IGZvciB1bml0c1xuICAgIHZhciBzaGlmdCA9IDA7XG4gICAgaWYgKGdyb3VwLnZhbHVlLnNoaWZ0KSB7XG4gICAgICAgIHNoaWZ0ID0gY2FsY3VsYXRlU2l6ZShncm91cC52YWx1ZS5zaGlmdCwgc3R5bGUpO1xuICAgIH1cblxuICAgIHZhciB3aWR0aCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAudmFsdWUud2lkdGgsIHN0eWxlKTtcbiAgICB2YXIgaGVpZ2h0ID0gY2FsY3VsYXRlU2l6ZShncm91cC52YWx1ZS5oZWlnaHQsIHN0eWxlKTtcblxuICAgIC8vIFRoZSBzaXplcyBvZiBydWxlcyBhcmUgYWJzb2x1dGUsIHNvIG1ha2UgaXQgbGFyZ2VyIGlmIHdlIGFyZSBpbiBhXG4gICAgLy8gc21hbGxlciBzdHlsZS5cbiAgICBzaGlmdCAvPSBzdHlsZS5zaXplTXVsdGlwbGllcjtcbiAgICB3aWR0aCAvPSBzdHlsZS5zaXplTXVsdGlwbGllcjtcbiAgICBoZWlnaHQgLz0gc3R5bGUuc2l6ZU11bHRpcGxpZXI7XG5cbiAgICAvLyBTdHlsZSB0aGUgcnVsZSB0byB0aGUgcmlnaHQgc2l6ZVxuICAgIHJ1bGUuc3R5bGUuYm9yZGVyUmlnaHRXaWR0aCA9IHdpZHRoICsgXCJlbVwiO1xuICAgIHJ1bGUuc3R5bGUuYm9yZGVyVG9wV2lkdGggPSBoZWlnaHQgKyBcImVtXCI7XG4gICAgcnVsZS5zdHlsZS5ib3R0b20gPSBzaGlmdCArIFwiZW1cIjtcblxuICAgIC8vIFJlY29yZCB0aGUgaGVpZ2h0IGFuZCB3aWR0aFxuICAgIHJ1bGUud2lkdGggPSB3aWR0aDtcbiAgICBydWxlLmhlaWdodCA9IGhlaWdodCArIHNoaWZ0O1xuICAgIHJ1bGUuZGVwdGggPSAtc2hpZnQ7XG5cbiAgICByZXR1cm4gcnVsZTtcbn07XG5cbmdyb3VwVHlwZXMua2VybiA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gTWFrZSBhbiBlbXB0eSBzcGFuIGZvciB0aGUgcnVsZVxuICAgIHZhciBydWxlID0gbWFrZVNwYW4oW1wibW9yZFwiLCBcInJ1bGVcIl0sIFtdLCBvcHRpb25zKTtcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuXG4gICAgdmFyIGRpbWVuc2lvbiA9IDA7XG4gICAgaWYgKGdyb3VwLnZhbHVlLmRpbWVuc2lvbikge1xuICAgICAgICBkaW1lbnNpb24gPSBjYWxjdWxhdGVTaXplKGdyb3VwLnZhbHVlLmRpbWVuc2lvbiwgc3R5bGUpO1xuICAgIH1cblxuICAgIGRpbWVuc2lvbiAvPSBzdHlsZS5zaXplTXVsdGlwbGllcjtcblxuICAgIHJ1bGUuc3R5bGUubWFyZ2luTGVmdCA9IGRpbWVuc2lvbiArIFwiZW1cIjtcblxuICAgIHJldHVybiBydWxlO1xufTtcblxuZ3JvdXBUeXBlcy5hY2NlbnQgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIEFjY2VudHMgYXJlIGhhbmRsZWQgaW4gdGhlIFRlWGJvb2sgcGcuIDQ0MywgcnVsZSAxMi5cbiAgICB2YXIgYmFzZSA9IGdyb3VwLnZhbHVlLmJhc2U7XG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcblxuICAgIHZhciBzdXBzdWJHcm91cDtcbiAgICBpZiAoZ3JvdXAudHlwZSA9PT0gXCJzdXBzdWJcIikge1xuICAgICAgICAvLyBJZiBvdXIgYmFzZSBpcyBhIGNoYXJhY3RlciBib3gsIGFuZCB3ZSBoYXZlIHN1cGVyc2NyaXB0cyBhbmRcbiAgICAgICAgLy8gc3Vic2NyaXB0cywgdGhlIHN1cHN1YiB3aWxsIGRlZmVyIHRvIHVzLiBJbiBwYXJ0aWN1bGFyLCB3ZSB3YW50XG4gICAgICAgIC8vIHRvIGF0dGFjaCB0aGUgc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzIHRvIHRoZSBpbm5lciBib2R5IChzb1xuICAgICAgICAvLyB0aGF0IHRoZSBwb3NpdGlvbiBvZiB0aGUgc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzIHdvbid0IGJlXG4gICAgICAgIC8vIGFmZmVjdGVkIGJ5IHRoZSBoZWlnaHQgb2YgdGhlIGFjY2VudCkuIFdlIGFjY29tcGxpc2ggdGhpcyBieVxuICAgICAgICAvLyBzdGlja2luZyB0aGUgYmFzZSBvZiB0aGUgYWNjZW50IGludG8gdGhlIGJhc2Ugb2YgdGhlIHN1cHN1YiwgYW5kXG4gICAgICAgIC8vIHJlbmRlcmluZyB0aGF0LCB3aGlsZSBrZWVwaW5nIHRyYWNrIG9mIHdoZXJlIHRoZSBhY2NlbnQgaXMuXG5cbiAgICAgICAgLy8gVGhlIHN1cHN1YiBncm91cCBpcyB0aGUgZ3JvdXAgdGhhdCB3YXMgcGFzc2VkIGluXG4gICAgICAgIHZhciBzdXBzdWIgPSBncm91cDtcbiAgICAgICAgLy8gVGhlIHJlYWwgYWNjZW50IGdyb3VwIGlzIHRoZSBiYXNlIG9mIHRoZSBzdXBzdWIgZ3JvdXBcbiAgICAgICAgZ3JvdXAgPSBzdXBzdWIudmFsdWUuYmFzZTtcbiAgICAgICAgLy8gVGhlIGNoYXJhY3RlciBib3ggaXMgdGhlIGJhc2Ugb2YgdGhlIGFjY2VudCBncm91cFxuICAgICAgICBiYXNlID0gZ3JvdXAudmFsdWUuYmFzZTtcbiAgICAgICAgLy8gU3RpY2sgdGhlIGNoYXJhY3RlciBib3ggaW50byB0aGUgYmFzZSBvZiB0aGUgc3Vwc3ViIGdyb3VwXG4gICAgICAgIHN1cHN1Yi52YWx1ZS5iYXNlID0gYmFzZTtcblxuICAgICAgICAvLyBSZXJlbmRlciB0aGUgc3Vwc3ViIGdyb3VwIHdpdGggaXRzIG5ldyBiYXNlLCBhbmQgc3RvcmUgdGhhdFxuICAgICAgICAvLyByZXN1bHQuXG4gICAgICAgIHN1cHN1Ykdyb3VwID0gYnVpbGRHcm91cChcbiAgICAgICAgICAgIHN1cHN1Yiwgb3B0aW9ucy5yZXNldCgpKTtcbiAgICB9XG5cbiAgICAvLyBCdWlsZCB0aGUgYmFzZSBncm91cFxuICAgIHZhciBib2R5ID0gYnVpbGRHcm91cChcbiAgICAgICAgYmFzZSwgb3B0aW9ucy53aXRoU3R5bGUoc3R5bGUuY3JhbXAoKSkpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBza2V3IG9mIHRoZSBhY2NlbnQuIFRoaXMgaXMgYmFzZWQgb24gdGhlIGxpbmUgXCJJZiB0aGVcbiAgICAvLyBudWNsZXVzIGlzIG5vdCBhIHNpbmdsZSBjaGFyYWN0ZXIsIGxldCBzID0gMDsgb3RoZXJ3aXNlIHNldCBzIHRvIHRoZVxuICAgIC8vIGtlcm4gYW1vdW50IGZvciB0aGUgbnVjbGV1cyBmb2xsb3dlZCBieSB0aGUgXFxza2V3Y2hhciBvZiBpdHMgZm9udC5cIlxuICAgIC8vIE5vdGUgdGhhdCBvdXIgc2tldyBtZXRyaWNzIGFyZSBqdXN0IHRoZSBrZXJuIGJldHdlZW4gZWFjaCBjaGFyYWN0ZXJcbiAgICAvLyBhbmQgdGhlIHNrZXdjaGFyLlxuICAgIHZhciBza2V3O1xuICAgIGlmIChpc0NoYXJhY3RlckJveChiYXNlKSkge1xuICAgICAgICAvLyBJZiB0aGUgYmFzZSBpcyBhIGNoYXJhY3RlciBib3gsIHRoZW4gd2Ugd2FudCB0aGUgc2tldyBvZiB0aGVcbiAgICAgICAgLy8gaW5uZXJtb3N0IGNoYXJhY3Rlci4gVG8gZG8gdGhhdCwgd2UgZmluZCB0aGUgaW5uZXJtb3N0IGNoYXJhY3RlcjpcbiAgICAgICAgdmFyIGJhc2VDaGFyID0gZ2V0QmFzZUVsZW0oYmFzZSk7XG4gICAgICAgIC8vIFRoZW4sIHdlIHJlbmRlciBpdHMgZ3JvdXAgdG8gZ2V0IHRoZSBzeW1ib2wgaW5zaWRlIGl0XG4gICAgICAgIHZhciBiYXNlR3JvdXAgPSBidWlsZEdyb3VwKFxuICAgICAgICAgICAgYmFzZUNoYXIsIG9wdGlvbnMud2l0aFN0eWxlKHN0eWxlLmNyYW1wKCkpKTtcbiAgICAgICAgLy8gRmluYWxseSwgd2UgcHVsbCB0aGUgc2tldyBvZmYgb2YgdGhlIHN5bWJvbC5cbiAgICAgICAgc2tldyA9IGJhc2VHcm91cC5za2V3O1xuICAgICAgICAvLyBOb3RlIHRoYXQgd2Ugbm93IHRocm93IGF3YXkgYmFzZUdyb3VwLCBiZWNhdXNlIHRoZSBsYXllcnMgd2VcbiAgICAgICAgLy8gcmVtb3ZlZCB3aXRoIGdldEJhc2VFbGVtIG1pZ2h0IGNvbnRhaW4gdGhpbmdzIGxpa2UgXFxjb2xvciB3aGljaFxuICAgICAgICAvLyB3ZSBjYW4ndCBnZXQgcmlkIG9mLlxuICAgICAgICAvLyBUT0RPKGVtaWx5KTogRmluZCBhIGJldHRlciB3YXkgdG8gZ2V0IHRoZSBza2V3XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2tldyA9IDA7XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBhbW91bnQgb2Ygc3BhY2UgYmV0d2VlbiB0aGUgYm9keSBhbmQgdGhlIGFjY2VudFxuICAgIHZhciBjbGVhcmFuY2UgPSBNYXRoLm1pbihcbiAgICAgICAgYm9keS5oZWlnaHQsXG4gICAgICAgIHN0eWxlLm1ldHJpY3MueEhlaWdodCk7XG5cbiAgICAvLyBCdWlsZCB0aGUgYWNjZW50XG4gICAgdmFyIGFjY2VudCA9IGJ1aWxkQ29tbW9uLm1ha2VTeW1ib2woXG4gICAgICAgIGdyb3VwLnZhbHVlLmFjY2VudCwgXCJNYWluLVJlZ3VsYXJcIiwgXCJtYXRoXCIsIG9wdGlvbnMpO1xuICAgIC8vIFJlbW92ZSB0aGUgaXRhbGljIGNvcnJlY3Rpb24gb2YgdGhlIGFjY2VudCwgYmVjYXVzZSBpdCBvbmx5IHNlcnZlcyB0b1xuICAgIC8vIHNoaWZ0IHRoZSBhY2NlbnQgb3ZlciB0byBhIHBsYWNlIHdlIGRvbid0IHdhbnQuXG4gICAgYWNjZW50Lml0YWxpYyA9IDA7XG5cbiAgICAvLyBUaGUgXFx2ZWMgY2hhcmFjdGVyIHRoYXQgdGhlIGZvbnRzIHVzZSBpcyBhIGNvbWJpbmluZyBjaGFyYWN0ZXIsIGFuZFxuICAgIC8vIHRodXMgc2hvd3MgdXAgbXVjaCB0b28gZmFyIHRvIHRoZSBsZWZ0LiBUbyBhY2NvdW50IGZvciB0aGlzLCB3ZSBhZGQgYVxuICAgIC8vIHNwZWNpZmljIGNsYXNzIHdoaWNoIHNoaWZ0cyB0aGUgYWNjZW50IG92ZXIgdG8gd2hlcmUgd2Ugd2FudCBpdC5cbiAgICAvLyBUT0RPKGVtaWx5KTogRml4IHRoaXMgaW4gYSBiZXR0ZXIgd2F5LCBsaWtlIGJ5IGNoYW5naW5nIHRoZSBmb250XG4gICAgdmFyIHZlY0NsYXNzID0gZ3JvdXAudmFsdWUuYWNjZW50ID09PSBcIlxcXFx2ZWNcIiA/IFwiYWNjZW50LXZlY1wiIDogbnVsbDtcblxuICAgIHZhciBhY2NlbnRCb2R5ID0gbWFrZVNwYW4oW1wiYWNjZW50LWJvZHlcIiwgdmVjQ2xhc3NdLCBbXG4gICAgICAgIG1ha2VTcGFuKFtdLCBbYWNjZW50XSldKTtcblxuICAgIGFjY2VudEJvZHkgPSBidWlsZENvbW1vbi5tYWtlVkxpc3QoW1xuICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IGJvZHl9LFxuICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IC1jbGVhcmFuY2V9LFxuICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IGFjY2VudEJvZHl9XG4gICAgXSwgXCJmaXJzdEJhc2VsaW5lXCIsIG51bGwsIG9wdGlvbnMpO1xuXG4gICAgLy8gU2hpZnQgdGhlIGFjY2VudCBvdmVyIGJ5IHRoZSBza2V3LiBOb3RlIHdlIHNoaWZ0IGJ5IHR3aWNlIHRoZSBza2V3XG4gICAgLy8gYmVjYXVzZSB3ZSBhcmUgY2VudGVyaW5nIHRoZSBhY2NlbnQsIHNvIGJ5IGFkZGluZyAyKnNrZXcgdG8gdGhlIGxlZnQsXG4gICAgLy8gd2Ugc2hpZnQgaXQgdG8gdGhlIHJpZ2h0IGJ5IDEqc2tldy5cbiAgICBhY2NlbnRCb2R5LmNoaWxkcmVuWzFdLnN0eWxlLm1hcmdpbkxlZnQgPSAyICogc2tldyArIFwiZW1cIjtcblxuICAgIHZhciBhY2NlbnRXcmFwID0gbWFrZVNwYW4oW1wibW9yZFwiLCBcImFjY2VudFwiXSwgW2FjY2VudEJvZHldLCBvcHRpb25zKTtcblxuICAgIGlmIChzdXBzdWJHcm91cCkge1xuICAgICAgICAvLyBIZXJlLCB3ZSByZXBsYWNlIHRoZSBcImJhc2VcIiBjaGlsZCBvZiB0aGUgc3Vwc3ViIHdpdGggb3VyIG5ld2x5XG4gICAgICAgIC8vIGdlbmVyYXRlZCBhY2NlbnQuXG4gICAgICAgIHN1cHN1Ykdyb3VwLmNoaWxkcmVuWzBdID0gYWNjZW50V3JhcDtcblxuICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCByZXJ1biB0aGUgaGVpZ2h0IGNhbGN1bGF0aW9uIGFmdGVyIHJlcGxhY2luZyB0aGVcbiAgICAgICAgLy8gYWNjZW50LCB3ZSBtYW51YWxseSByZWNhbGN1bGF0ZSBoZWlnaHQuXG4gICAgICAgIHN1cHN1Ykdyb3VwLmhlaWdodCA9IE1hdGgubWF4KGFjY2VudFdyYXAuaGVpZ2h0LCBzdXBzdWJHcm91cC5oZWlnaHQpO1xuXG4gICAgICAgIC8vIEFjY2VudHMgc2hvdWxkIGFsd2F5cyBiZSBvcmRzLCBldmVuIHdoZW4gdGhlaXIgaW5uYXJkcyBhcmUgbm90LlxuICAgICAgICBzdXBzdWJHcm91cC5jbGFzc2VzWzBdID0gXCJtb3JkXCI7XG5cbiAgICAgICAgcmV0dXJuIHN1cHN1Ykdyb3VwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhY2NlbnRXcmFwO1xuICAgIH1cbn07XG5cbmdyb3VwVHlwZXMucGhhbnRvbSA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gYnVpbGRFeHByZXNzaW9uKFxuICAgICAgICBncm91cC52YWx1ZS52YWx1ZSxcbiAgICAgICAgb3B0aW9ucy53aXRoUGhhbnRvbSgpLFxuICAgICAgICBmYWxzZVxuICAgICk7XG5cbiAgICAvLyBcXHBoYW50b20gaXNuJ3Qgc3VwcG9zZWQgdG8gYWZmZWN0IHRoZSBlbGVtZW50cyBpdCBjb250YWlucy5cbiAgICAvLyBTZWUgXCJjb2xvclwiIGZvciBtb3JlIGRldGFpbHMuXG4gICAgcmV0dXJuIG5ldyBidWlsZENvbW1vbi5tYWtlRnJhZ21lbnQoZWxlbWVudHMpO1xufTtcblxuZ3JvdXBUeXBlcy5tY2xhc3MgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBlbGVtZW50cyA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC52YWx1ZS52YWx1ZSwgb3B0aW9ucywgdHJ1ZSk7XG5cbiAgICByZXR1cm4gbWFrZVNwYW4oW2dyb3VwLnZhbHVlLm1jbGFzc10sIGVsZW1lbnRzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogYnVpbGRHcm91cCBpcyB0aGUgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGdyb3VwIGFuZCBjYWxscyB0aGUgY29ycmVjdCBncm91cFR5cGVcbiAqIGZ1bmN0aW9uIGZvciBpdC4gSXQgYWxzbyBoYW5kbGVzIHRoZSBpbnRlcmFjdGlvbiBvZiBzaXplIGFuZCBzdHlsZSBjaGFuZ2VzXG4gKiBiZXR3ZWVuIHBhcmVudHMgYW5kIGNoaWxkcmVuLlxuICovXG52YXIgYnVpbGRHcm91cCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgaWYgKCFncm91cCkge1xuICAgICAgICByZXR1cm4gbWFrZVNwYW4oKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXBUeXBlc1tncm91cC50eXBlXSkge1xuICAgICAgICAvLyBDYWxsIHRoZSBncm91cFR5cGVzIGZ1bmN0aW9uXG4gICAgICAgIHZhciBncm91cE5vZGUgPSBncm91cFR5cGVzW2dyb3VwLnR5cGVdKGdyb3VwLCBvcHRpb25zKTtcbiAgICAgICAgdmFyIG11bHRpcGxpZXI7XG5cbiAgICAgICAgLy8gSWYgdGhlIHN0eWxlIGNoYW5nZWQgYmV0d2VlbiB0aGUgcGFyZW50IGFuZCB0aGUgY3VycmVudCBncm91cCxcbiAgICAgICAgLy8gYWNjb3VudCBmb3IgdGhlIHNpemUgZGlmZmVyZW5jZVxuICAgICAgICBpZiAob3B0aW9ucy5zdHlsZSAhPT0gb3B0aW9ucy5wYXJlbnRTdHlsZSkge1xuICAgICAgICAgICAgbXVsdGlwbGllciA9IG9wdGlvbnMuc3R5bGUuc2l6ZU11bHRpcGxpZXIgL1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmVudFN0eWxlLnNpemVNdWx0aXBsaWVyO1xuXG4gICAgICAgICAgICBncm91cE5vZGUuaGVpZ2h0ICo9IG11bHRpcGxpZXI7XG4gICAgICAgICAgICBncm91cE5vZGUuZGVwdGggKj0gbXVsdGlwbGllcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBzaXplIGNoYW5nZWQgYmV0d2VlbiB0aGUgcGFyZW50IGFuZCB0aGUgY3VycmVudCBncm91cCwgYWNjb3VudFxuICAgICAgICAvLyBmb3IgdGhhdCBzaXplIGRpZmZlcmVuY2UuXG4gICAgICAgIGlmIChvcHRpb25zLnNpemUgIT09IG9wdGlvbnMucGFyZW50U2l6ZSkge1xuICAgICAgICAgICAgbXVsdGlwbGllciA9IGJ1aWxkQ29tbW9uLnNpemluZ011bHRpcGxpZXJbb3B0aW9ucy5zaXplXSAvXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkQ29tbW9uLnNpemluZ011bHRpcGxpZXJbb3B0aW9ucy5wYXJlbnRTaXplXTtcblxuICAgICAgICAgICAgZ3JvdXBOb2RlLmhlaWdodCAqPSBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgZ3JvdXBOb2RlLmRlcHRoICo9IG11bHRpcGxpZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ3JvdXBOb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgXCJHb3QgZ3JvdXAgb2YgdW5rbm93biB0eXBlOiAnXCIgKyBncm91cC50eXBlICsgXCInXCIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGFrZSBhbiBlbnRpcmUgcGFyc2UgdHJlZSwgYW5kIGJ1aWxkIGl0IGludG8gYW4gYXBwcm9wcmlhdGUgc2V0IG9mIEhUTUxcbiAqIG5vZGVzLlxuICovXG52YXIgYnVpbGRIVE1MID0gZnVuY3Rpb24odHJlZSwgb3B0aW9ucykge1xuICAgIC8vIGJ1aWxkRXhwcmVzc2lvbiBpcyBkZXN0cnVjdGl2ZSwgc28gd2UgbmVlZCB0byBtYWtlIGEgY2xvbmVcbiAgICAvLyBvZiB0aGUgaW5jb21pbmcgdHJlZSBzbyB0aGF0IGl0IGlzbid0IGFjY2lkZW50YWxseSBjaGFuZ2VkXG4gICAgdHJlZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodHJlZSkpO1xuXG4gICAgLy8gQnVpbGQgdGhlIGV4cHJlc3Npb24gY29udGFpbmVkIGluIHRoZSB0cmVlXG4gICAgdmFyIGV4cHJlc3Npb24gPSBidWlsZEV4cHJlc3Npb24odHJlZSwgb3B0aW9ucywgdHJ1ZSk7XG4gICAgdmFyIGJvZHkgPSBtYWtlU3BhbihbXCJiYXNlXCIsIG9wdGlvbnMuc3R5bGUuY2xzKCldLCBleHByZXNzaW9uLCBvcHRpb25zKTtcblxuICAgIC8vIEFkZCBzdHJ1dHMsIHdoaWNoIGVuc3VyZSB0aGF0IHRoZSB0b3Agb2YgdGhlIEhUTUwgZWxlbWVudCBmYWxscyBhdCB0aGVcbiAgICAvLyBoZWlnaHQgb2YgdGhlIGV4cHJlc3Npb24sIGFuZCB0aGUgYm90dG9tIG9mIHRoZSBIVE1MIGVsZW1lbnQgZmFsbHMgYXQgdGhlXG4gICAgLy8gZGVwdGggb2YgdGhlIGV4cHJlc3Npb24uXG4gICAgdmFyIHRvcFN0cnV0ID0gbWFrZVNwYW4oW1wic3RydXRcIl0pO1xuICAgIHZhciBib3R0b21TdHJ1dCA9IG1ha2VTcGFuKFtcInN0cnV0XCIsIFwiYm90dG9tXCJdKTtcblxuICAgIHRvcFN0cnV0LnN0eWxlLmhlaWdodCA9IGJvZHkuaGVpZ2h0ICsgXCJlbVwiO1xuICAgIGJvdHRvbVN0cnV0LnN0eWxlLmhlaWdodCA9IChib2R5LmhlaWdodCArIGJvZHkuZGVwdGgpICsgXCJlbVwiO1xuICAgIC8vIFdlJ2QgbGlrZSB0byB1c2UgYHZlcnRpY2FsLWFsaWduOiB0b3BgIGJ1dCBpbiBJRSA5IHRoaXMgbG93ZXJzIHRoZVxuICAgIC8vIGJhc2VsaW5lIG9mIHRoZSBib3ggdG8gdGhlIGJvdHRvbSBvZiB0aGlzIHN0cnV0IChpbnN0ZWFkIHN0YXlpbmcgaW4gdGhlXG4gICAgLy8gbm9ybWFsIHBsYWNlKSBzbyB3ZSB1c2UgYW4gYWJzb2x1dGUgdmFsdWUgZm9yIHZlcnRpY2FsLWFsaWduIGluc3RlYWRcbiAgICBib3R0b21TdHJ1dC5zdHlsZS52ZXJ0aWNhbEFsaWduID0gLWJvZHkuZGVwdGggKyBcImVtXCI7XG5cbiAgICAvLyBXcmFwIHRoZSBzdHJ1dHMgYW5kIGJvZHkgdG9nZXRoZXJcbiAgICB2YXIgaHRtbE5vZGUgPSBtYWtlU3BhbihbXCJrYXRleC1odG1sXCJdLCBbdG9wU3RydXQsIGJvdHRvbVN0cnV0LCBib2R5XSk7XG5cbiAgICBodG1sTm9kZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG5cbiAgICByZXR1cm4gaHRtbE5vZGU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1aWxkSFRNTDtcbiIsIi8qKlxuICogVGhpcyBmaWxlIGNvbnZlcnRzIGEgcGFyc2UgdHJlZSBpbnRvIGEgY29vcmVzcG9uZGluZyBNYXRoTUwgdHJlZS4gVGhlIG1haW5cbiAqIGVudHJ5IHBvaW50IGlzIHRoZSBgYnVpbGRNYXRoTUxgIGZ1bmN0aW9uLCB3aGljaCB0YWtlcyBhIHBhcnNlIHRyZWUgZnJvbSB0aGVcbiAqIHBhcnNlci5cbiAqL1xuXG52YXIgYnVpbGRDb21tb24gPSByZXF1aXJlKFwiLi9idWlsZENvbW1vblwiKTtcbnZhciBmb250TWV0cmljcyA9IHJlcXVpcmUoXCIuL2ZvbnRNZXRyaWNzXCIpO1xudmFyIG1hdGhNTFRyZWUgPSByZXF1aXJlKFwiLi9tYXRoTUxUcmVlXCIpO1xudmFyIFBhcnNlRXJyb3IgPSByZXF1aXJlKFwiLi9QYXJzZUVycm9yXCIpO1xudmFyIHN5bWJvbHMgPSByZXF1aXJlKFwiLi9zeW1ib2xzXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5cbnZhciBtYWtlU3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuO1xudmFyIGZvbnRNYXAgPSBidWlsZENvbW1vbi5mb250TWFwO1xuXG4vKipcbiAqIFRha2VzIGEgc3ltYm9sIGFuZCBjb252ZXJ0cyBpdCBpbnRvIGEgTWF0aE1MIHRleHQgbm9kZSBhZnRlciBwZXJmb3JtaW5nXG4gKiBvcHRpb25hbCByZXBsYWNlbWVudCBmcm9tIHN5bWJvbHMuanMuXG4gKi9cbnZhciBtYWtlVGV4dCA9IGZ1bmN0aW9uKHRleHQsIG1vZGUpIHtcbiAgICBpZiAoc3ltYm9sc1ttb2RlXVt0ZXh0XSAmJiBzeW1ib2xzW21vZGVdW3RleHRdLnJlcGxhY2UpIHtcbiAgICAgICAgdGV4dCA9IHN5bWJvbHNbbW9kZV1bdGV4dF0ucmVwbGFjZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUodGV4dCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1hdGggdmFyaWFudCBhcyBhIHN0cmluZyBvciBudWxsIGlmIG5vbmUgaXMgcmVxdWlyZWQuXG4gKi9cbnZhciBnZXRWYXJpYW50ID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgZm9udCA9IG9wdGlvbnMuZm9udDtcbiAgICBpZiAoIWZvbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG1vZGUgPSBncm91cC5tb2RlO1xuICAgIGlmIChmb250ID09PSBcIm1hdGhpdFwiKSB7XG4gICAgICAgIHJldHVybiBcIml0YWxpY1wiO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IGdyb3VwLnZhbHVlO1xuICAgIGlmICh1dGlscy5jb250YWlucyhbXCJcXFxcaW1hdGhcIiwgXCJcXFxcam1hdGhcIl0sIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoc3ltYm9sc1ttb2RlXVt2YWx1ZV0gJiYgc3ltYm9sc1ttb2RlXVt2YWx1ZV0ucmVwbGFjZSkge1xuICAgICAgICB2YWx1ZSA9IHN5bWJvbHNbbW9kZV1bdmFsdWVdLnJlcGxhY2U7XG4gICAgfVxuXG4gICAgdmFyIGZvbnROYW1lID0gZm9udE1hcFtmb250XS5mb250TmFtZTtcbiAgICBpZiAoZm9udE1ldHJpY3MuZ2V0Q2hhcmFjdGVyTWV0cmljcyh2YWx1ZSwgZm9udE5hbWUpKSB7XG4gICAgICAgIHJldHVybiBmb250TWFwW29wdGlvbnMuZm9udF0udmFyaWFudDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogRnVuY3Rpb25zIGZvciBoYW5kbGluZyB0aGUgZGlmZmVyZW50IHR5cGVzIG9mIGdyb3VwcyBmb3VuZCBpbiB0aGUgcGFyc2VcbiAqIHRyZWUuIEVhY2ggZnVuY3Rpb24gc2hvdWxkIHRha2UgYSBwYXJzZSBncm91cCBhbmQgcmV0dXJuIGEgTWF0aE1MIG5vZGUuXG4gKi9cbnZhciBncm91cFR5cGVzID0ge307XG5cbmdyb3VwVHlwZXMubWF0aG9yZCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtaVwiLFxuICAgICAgICBbbWFrZVRleHQoZ3JvdXAudmFsdWUsIGdyb3VwLm1vZGUpXSk7XG5cbiAgICB2YXIgdmFyaWFudCA9IGdldFZhcmlhbnQoZ3JvdXAsIG9wdGlvbnMpO1xuICAgIGlmICh2YXJpYW50KSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWF0aHZhcmlhbnRcIiwgdmFyaWFudCk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy50ZXh0b3JkID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGV4dCA9IG1ha2VUZXh0KGdyb3VwLnZhbHVlLCBncm91cC5tb2RlKTtcblxuICAgIHZhciB2YXJpYW50ID0gZ2V0VmFyaWFudChncm91cCwgb3B0aW9ucykgfHwgXCJub3JtYWxcIjtcblxuICAgIHZhciBub2RlO1xuICAgIGlmICgvWzAtOV0vLnRlc3QoZ3JvdXAudmFsdWUpKSB7XG4gICAgICAgIC8vIFRPRE8oa2V2aW5iKSBtZXJnZSBhZGphY2VudCA8bW4+IG5vZGVzXG4gICAgICAgIC8vIGRvIGl0IGFzIGEgcG9zdCBwcm9jZXNzaW5nIHN0ZXBcbiAgICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW5cIiwgW3RleHRdKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZm9udCkge1xuICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCB2YXJpYW50KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1pXCIsIFt0ZXh0XSk7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWF0aHZhcmlhbnRcIiwgdmFyaWFudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLmJpbiA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtb1wiLCBbbWFrZVRleHQoZ3JvdXAudmFsdWUsIGdyb3VwLm1vZGUpXSk7XG5cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmdyb3VwVHlwZXMucmVsID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICBcIm1vXCIsIFttYWtlVGV4dChncm91cC52YWx1ZSwgZ3JvdXAubW9kZSldKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5vcGVuID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICBcIm1vXCIsIFttYWtlVGV4dChncm91cC52YWx1ZSwgZ3JvdXAubW9kZSldKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5jbG9zZSA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtb1wiLCBbbWFrZVRleHQoZ3JvdXAudmFsdWUsIGdyb3VwLm1vZGUpXSk7XG5cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmdyb3VwVHlwZXMuaW5uZXIgPSBmdW5jdGlvbihncm91cCkge1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibW9cIiwgW21ha2VUZXh0KGdyb3VwLnZhbHVlLCBncm91cC5tb2RlKV0pO1xuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLnB1bmN0ID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICBcIm1vXCIsIFttYWtlVGV4dChncm91cC52YWx1ZSwgZ3JvdXAubW9kZSldKTtcblxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic2VwYXJhdG9yXCIsIFwidHJ1ZVwiKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5vcmRncm91cCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLnZhbHVlLCBvcHRpb25zKTtcblxuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIGlubmVyKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy50ZXh0ID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUuYm9keSwgb3B0aW9ucyk7XG5cbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRleHRcIiwgaW5uZXIpO1xuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLmNvbG9yID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUudmFsdWUsIG9wdGlvbnMpO1xuXG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBpbm5lcik7XG5cbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGhjb2xvclwiLCBncm91cC52YWx1ZS5jb2xvcik7XG5cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmdyb3VwVHlwZXMuc3Vwc3ViID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBbYnVpbGRHcm91cChncm91cC52YWx1ZS5iYXNlLCBvcHRpb25zKV07XG5cbiAgICBpZiAoZ3JvdXAudmFsdWUuc3ViKSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goYnVpbGRHcm91cChncm91cC52YWx1ZS5zdWIsIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAudmFsdWUuc3VwKSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goYnVpbGRHcm91cChncm91cC52YWx1ZS5zdXAsIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZVR5cGU7XG4gICAgaWYgKCFncm91cC52YWx1ZS5zdWIpIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm1zdXBcIjtcbiAgICB9IGVsc2UgaWYgKCFncm91cC52YWx1ZS5zdXApIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm1zdWJcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBub2RlVHlwZSA9IFwibXN1YnN1cFwiO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUobm9kZVR5cGUsIGNoaWxkcmVuKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5nZW5mcmFjID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICBcIm1mcmFjXCIsXG4gICAgICAgIFtidWlsZEdyb3VwKGdyb3VwLnZhbHVlLm51bWVyLCBvcHRpb25zKSxcbiAgICAgICAgICAgIGJ1aWxkR3JvdXAoZ3JvdXAudmFsdWUuZGVub20sIG9wdGlvbnMpXSk7XG5cbiAgICBpZiAoIWdyb3VwLnZhbHVlLmhhc0JhckxpbmUpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsaW5ldGhpY2tuZXNzXCIsIFwiMHB4XCIpO1xuICAgIH1cblxuICAgIGlmIChncm91cC52YWx1ZS5sZWZ0RGVsaW0gIT0gbnVsbCB8fCBncm91cC52YWx1ZS5yaWdodERlbGltICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHdpdGhEZWxpbXMgPSBbXTtcblxuICAgICAgICBpZiAoZ3JvdXAudmFsdWUubGVmdERlbGltICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0T3AgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgICAgICAgICBcIm1vXCIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShncm91cC52YWx1ZS5sZWZ0RGVsaW0pXSk7XG5cbiAgICAgICAgICAgIGxlZnRPcC5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG5cbiAgICAgICAgICAgIHdpdGhEZWxpbXMucHVzaChsZWZ0T3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgd2l0aERlbGltcy5wdXNoKG5vZGUpO1xuXG4gICAgICAgIGlmIChncm91cC52YWx1ZS5yaWdodERlbGltICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciByaWdodE9wID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgICAgICAgICAgXCJtb1wiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoZ3JvdXAudmFsdWUucmlnaHREZWxpbSldKTtcblxuICAgICAgICAgICAgcmlnaHRPcC5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG5cbiAgICAgICAgICAgIHdpdGhEZWxpbXMucHVzaChyaWdodE9wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvdXRlck5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgd2l0aERlbGltcyk7XG5cbiAgICAgICAgcmV0dXJuIG91dGVyTm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmdyb3VwVHlwZXMuYXJyYXkgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtdGFibGVcIiwgZ3JvdXAudmFsdWUuYm9keS5tYXAoZnVuY3Rpb24ocm93KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgICAgICAgICAgXCJtdHJcIiwgcm93Lm1hcChmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibXRkXCIsIFtidWlsZEdyb3VwKGNlbGwsIG9wdGlvbnMpXSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KSk7XG59O1xuXG5ncm91cFR5cGVzLnNxcnQgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBub2RlO1xuICAgIGlmIChncm91cC52YWx1ZS5pbmRleCkge1xuICAgICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgICAgICBcIm1yb290XCIsIFtcbiAgICAgICAgICAgICAgICBidWlsZEdyb3VwKGdyb3VwLnZhbHVlLmJvZHksIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIGJ1aWxkR3JvdXAoZ3JvdXAudmFsdWUuaW5kZXgsIG9wdGlvbnMpXG4gICAgICAgICAgICBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgICAgICBcIm1zcXJ0XCIsIFtidWlsZEdyb3VwKGdyb3VwLnZhbHVlLmJvZHksIG9wdGlvbnMpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLmxlZnRyaWdodCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLnZhbHVlLmJvZHksIG9wdGlvbnMpO1xuXG4gICAgaWYgKGdyb3VwLnZhbHVlLmxlZnQgIT09IFwiLlwiKSB7XG4gICAgICAgIHZhciBsZWZ0Tm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICAgICAgXCJtb1wiLCBbbWFrZVRleHQoZ3JvdXAudmFsdWUubGVmdCwgZ3JvdXAubW9kZSldKTtcblxuICAgICAgICBsZWZ0Tm9kZS5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG5cbiAgICAgICAgaW5uZXIudW5zaGlmdChsZWZ0Tm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnZhbHVlLnJpZ2h0ICE9PSBcIi5cIikge1xuICAgICAgICB2YXIgcmlnaHROb2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgICAgICBcIm1vXCIsIFttYWtlVGV4dChncm91cC52YWx1ZS5yaWdodCwgZ3JvdXAubW9kZSldKTtcblxuICAgICAgICByaWdodE5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuXG4gICAgICAgIGlubmVyLnB1c2gocmlnaHROb2RlKTtcbiAgICB9XG5cbiAgICB2YXIgb3V0ZXJOb2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIGlubmVyKTtcblxuICAgIHJldHVybiBvdXRlck5vZGU7XG59O1xuXG5ncm91cFR5cGVzLm1pZGRsZSA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG1pZGRsZU5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtb1wiLCBbbWFrZVRleHQoZ3JvdXAudmFsdWUubWlkZGxlLCBncm91cC5tb2RlKV0pO1xuICAgIG1pZGRsZU5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuICAgIHJldHVybiBtaWRkbGVOb2RlO1xufTtcblxuZ3JvdXBUeXBlcy5hY2NlbnQgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBhY2NlbnROb2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibW9cIiwgW21ha2VUZXh0KGdyb3VwLnZhbHVlLmFjY2VudCwgZ3JvdXAubW9kZSldKTtcblxuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibW92ZXJcIixcbiAgICAgICAgW2J1aWxkR3JvdXAoZ3JvdXAudmFsdWUuYmFzZSwgb3B0aW9ucyksXG4gICAgICAgICAgICBhY2NlbnROb2RlXSk7XG5cbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImFjY2VudFwiLCBcInRydWVcIik7XG5cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmdyb3VwVHlwZXMuc3BhY2luZyA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgdmFyIG5vZGU7XG5cbiAgICBpZiAoZ3JvdXAudmFsdWUgPT09IFwiXFxcXCBcIiB8fCBncm91cC52YWx1ZSA9PT0gXCJcXFxcc3BhY2VcIiB8fFxuICAgICAgICBncm91cC52YWx1ZSA9PT0gXCIgXCIgfHwgZ3JvdXAudmFsdWUgPT09IFwiflwiKSB7XG4gICAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgICAgIFwibXRleHRcIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKFwiXFx1MDBhMFwiKV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zcGFjZVwiKTtcblxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgIFwid2lkdGhcIiwgYnVpbGRDb21tb24uc3BhY2luZ0Z1bmN0aW9uc1tncm91cC52YWx1ZV0uc2l6ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLm9wID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbm9kZTtcblxuICAgIC8vIFRPRE8oZW1pbHkpOiBoYW5kbGUgYmlnIG9wZXJhdG9ycyB1c2luZyB0aGUgYGxhcmdlb3BgIGF0dHJpYnV0ZVxuXG4gICAgaWYgKGdyb3VwLnZhbHVlLnN5bWJvbCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgc3ltYm9sLiBKdXN0IGFkZCB0aGUgc3ltYm9sLlxuICAgICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgICAgICBcIm1vXCIsIFttYWtlVGV4dChncm91cC52YWx1ZS5ib2R5LCBncm91cC5tb2RlKV0pO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAudmFsdWUudmFsdWUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBvcGVyYXRvciB3aXRoIGNoaWxkcmVuLiBBZGQgdGhlbS5cbiAgICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICAgICAgXCJtb1wiLCBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUudmFsdWUsIG9wdGlvbnMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGEgdGV4dCBvcGVyYXRvci4gQWRkIGFsbCBvZiB0aGUgY2hhcmFjdGVycyBmcm9tIHRoZVxuICAgICAgICAvLyBvcGVyYXRvcidzIG5hbWUuXG4gICAgICAgIC8vIFRPRE8oZW1pbHkpOiBBZGQgYSBzcGFjZSBpbiB0aGUgbWlkZGxlIG9mIHNvbWUgb2YgdGhlc2VcbiAgICAgICAgLy8gb3BlcmF0b3JzLCBsaWtlIFxcbGltc3VwLlxuICAgICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgICAgICBcIm1pXCIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShncm91cC52YWx1ZS5ib2R5LnNsaWNlKDEpKV0pO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5tb2QgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBpbm5lciA9IFtdO1xuXG4gICAgaWYgKGdyb3VwLnZhbHVlLm1vZFR5cGUgPT09IFwicG9kXCIgfHwgZ3JvdXAudmFsdWUubW9kVHlwZSA9PT0gXCJwbW9kXCIpIHtcbiAgICAgICAgaW5uZXIucHVzaChuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgICAgIFwibW9cIiwgW21ha2VUZXh0KFwiKFwiLCBncm91cC5tb2RlKV0pKTtcbiAgICB9XG4gICAgaWYgKGdyb3VwLnZhbHVlLm1vZFR5cGUgIT09IFwicG9kXCIpIHtcbiAgICAgICAgaW5uZXIucHVzaChuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgICAgIFwibW9cIiwgW21ha2VUZXh0KFwibW9kXCIsIGdyb3VwLm1vZGUpXSkpO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAudmFsdWUudmFsdWUpIHtcbiAgICAgICAgdmFyIHNwYWNlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3BhY2VcIik7XG4gICAgICAgIHNwYWNlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMC4zMzMzMzNlbVwiKTtcbiAgICAgICAgaW5uZXIucHVzaChzcGFjZSk7XG4gICAgICAgIGlubmVyID0gaW5uZXIuY29uY2F0KGJ1aWxkRXhwcmVzc2lvbihncm91cC52YWx1ZS52YWx1ZSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAudmFsdWUubW9kVHlwZSA9PT0gXCJwb2RcIiB8fCBncm91cC52YWx1ZS5tb2RUeXBlID09PSBcInBtb2RcIikge1xuICAgICAgICBpbm5lci5wdXNoKG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICAgICAgXCJtb1wiLCBbbWFrZVRleHQoXCIpXCIsIGdyb3VwLm1vZGUpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIGlubmVyKTtcbn07XG5cbmdyb3VwVHlwZXMua2F0ZXggPSBmdW5jdGlvbihncm91cCkge1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibXRleHRcIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKFwiS2FUZVhcIildKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5mb250ID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgZm9udCA9IGdyb3VwLnZhbHVlLmZvbnQ7XG4gICAgcmV0dXJuIGJ1aWxkR3JvdXAoZ3JvdXAudmFsdWUuYm9keSwgb3B0aW9ucy53aXRoRm9udChmb250KSk7XG59O1xuXG5ncm91cFR5cGVzLmRlbGltc2l6aW5nID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBbXTtcblxuICAgIGlmIChncm91cC52YWx1ZS52YWx1ZSAhPT0gXCIuXCIpIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChtYWtlVGV4dChncm91cC52YWx1ZS52YWx1ZSwgZ3JvdXAubW9kZSkpO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBjaGlsZHJlbik7XG5cbiAgICBpZiAoZ3JvdXAudmFsdWUubWNsYXNzID09PSBcIm1vcGVuXCIgfHxcbiAgICAgICAgZ3JvdXAudmFsdWUubWNsYXNzID09PSBcIm1jbG9zZVwiKSB7XG4gICAgICAgIC8vIE9ubHkgc29tZSBvZiB0aGUgZGVsaW1zaXppbmcgZnVuY3Rpb25zIGFjdCBhcyBmZW5jZXMsIGFuZCB0aGV5XG4gICAgICAgIC8vIHJldHVybiBcIm1vcGVuXCIgb3IgXCJtY2xvc2VcIiBtY2xhc3MuXG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEV4cGxpY2l0bHkgZGlzYWJsZSBmZW5jaW5nIGlmIGl0J3Mgbm90IGEgZmVuY2UsIHRvIG92ZXJyaWRlIHRoZVxuICAgICAgICAvLyBkZWZhdWx0cy5cbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcImZhbHNlXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5zdHlsaW5nID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUudmFsdWUsIG9wdGlvbnMpO1xuXG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBpbm5lcik7XG5cbiAgICB2YXIgc3R5bGVBdHRyaWJ1dGVzID0ge1xuICAgICAgICBcImRpc3BsYXlcIjogW1wiMFwiLCBcInRydWVcIl0sXG4gICAgICAgIFwidGV4dFwiOiBbXCIwXCIsIFwiZmFsc2VcIl0sXG4gICAgICAgIFwic2NyaXB0XCI6IFtcIjFcIiwgXCJmYWxzZVwiXSxcbiAgICAgICAgXCJzY3JpcHRzY3JpcHRcIjogW1wiMlwiLCBcImZhbHNlXCJdXG4gICAgfTtcblxuICAgIHZhciBhdHRyID0gc3R5bGVBdHRyaWJ1dGVzW2dyb3VwLnZhbHVlLnN0eWxlXTtcblxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic2NyaXB0bGV2ZWxcIiwgYXR0clswXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkaXNwbGF5c3R5bGVcIiwgYXR0clsxXSk7XG5cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmdyb3VwVHlwZXMuc2l6aW5nID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUudmFsdWUsIG9wdGlvbnMpO1xuXG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBpbm5lcik7XG5cbiAgICAvLyBUT0RPKGVtaWx5KTogVGhpcyBkb2Vzbid0IHByb2R1Y2UgdGhlIGNvcnJlY3Qgc2l6ZSBmb3IgbmVzdGVkIHNpemVcbiAgICAvLyBjaGFuZ2VzLCBiZWNhdXNlIHdlIGRvbid0IGtlZXAgc3RhdGUgb2Ygd2hhdCBzdHlsZSB3ZSdyZSBjdXJyZW50bHlcbiAgICAvLyBpbiwgc28gd2UgY2FuJ3QgcmVzZXQgdGhlIHNpemUgdG8gbm9ybWFsIGJlZm9yZSBjaGFuZ2luZyBpdC4gIE5vd1xuICAgIC8vIHRoYXQgd2UncmUgcGFzc2luZyBhbiBvcHRpb25zIHBhcmFtZXRlciB3ZSBzaG91bGQgYmUgYWJsZSB0byBmaXhcbiAgICAvLyB0aGlzLlxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFxuICAgICAgICBcIm1hdGhzaXplXCIsIGJ1aWxkQ29tbW9uLnNpemluZ011bHRpcGxpZXJbZ3JvdXAudmFsdWUuc2l6ZV0gKyBcImVtXCIpO1xuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLm92ZXJsaW5lID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgb3BlcmF0b3IgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtb1wiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoXCJcXHUyMDNlXCIpXSk7XG4gICAgb3BlcmF0b3Iuc2V0QXR0cmlidXRlKFwic3RyZXRjaHlcIiwgXCJ0cnVlXCIpO1xuXG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtb3ZlclwiLFxuICAgICAgICBbYnVpbGRHcm91cChncm91cC52YWx1ZS5ib2R5LCBvcHRpb25zKSxcbiAgICAgICAgICAgIG9wZXJhdG9yXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJhY2NlbnRcIiwgXCJ0cnVlXCIpO1xuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLnVuZGVybGluZSA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG9wZXJhdG9yID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibW9cIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKFwiXFx1MjAzZVwiKV0pO1xuICAgIG9wZXJhdG9yLnNldEF0dHJpYnV0ZShcInN0cmV0Y2h5XCIsIFwidHJ1ZVwiKTtcblxuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibXVuZGVyXCIsXG4gICAgICAgIFtidWlsZEdyb3VwKGdyb3VwLnZhbHVlLmJvZHksIG9wdGlvbnMpLFxuICAgICAgICAgICAgb3BlcmF0b3JdKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImFjY2VudHVuZGVyXCIsIFwidHJ1ZVwiKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5ydWxlID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAvLyBUT0RPKGVtaWx5KTogRmlndXJlIG91dCBpZiB0aGVyZSdzIGFuIGFjdHVhbCB3YXkgdG8gZHJhdyBibGFjayBib3hlc1xuICAgIC8vIGluIE1hdGhNTC5cbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5rZXJuID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAvLyBUT0RPKGtldmluKTogRmlndXJlIG91dCBpZiB0aGVyZSdzIGEgd2F5IHRvIGFkZCBzcGFjZSBpbiBNYXRoTUxcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5sbGFwID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICBcIm1wYWRkZWRcIiwgW2J1aWxkR3JvdXAoZ3JvdXAudmFsdWUuYm9keSwgb3B0aW9ucyldKTtcblxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibHNwYWNlXCIsIFwiLTF3aWR0aFwiKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMHB4XCIpO1xuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLnJsYXAgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibXBhZGRlZFwiLCBbYnVpbGRHcm91cChncm91cC52YWx1ZS5ib2R5LCBvcHRpb25zKV0pO1xuXG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjBweFwiKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5waGFudG9tID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUudmFsdWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1waGFudG9tXCIsIGlubmVyKTtcbn07XG5cbmdyb3VwVHlwZXMubWNsYXNzID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUudmFsdWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBpbm5lcik7XG59O1xuXG4vKipcbiAqIFRha2VzIGEgbGlzdCBvZiBub2RlcywgYnVpbGRzIHRoZW0sIGFuZCByZXR1cm5zIGEgbGlzdCBvZiB0aGUgZ2VuZXJhdGVkXG4gKiBNYXRoTUwgbm9kZXMuIEEgbGl0dGxlIHNpbXBsZXIgdGhhbiB0aGUgSFRNTCB2ZXJzaW9uIGJlY2F1c2Ugd2UgZG9uJ3QgZG8gYW55XG4gKiBwcmV2aW91cy1ub2RlIGhhbmRsaW5nLlxuICovXG52YXIgYnVpbGRFeHByZXNzaW9uID0gZnVuY3Rpb24oZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICAgIHZhciBncm91cHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJlc3Npb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGdyb3VwID0gZXhwcmVzc2lvbltpXTtcbiAgICAgICAgZ3JvdXBzLnB1c2goYnVpbGRHcm91cChncm91cCwgb3B0aW9ucykpO1xuICAgIH1cbiAgICByZXR1cm4gZ3JvdXBzO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhIGdyb3VwIGZyb20gdGhlIHBhcnNlciBhbmQgY2FsbHMgdGhlIGFwcHJvcHJpYXRlIGdyb3VwVHlwZXMgZnVuY3Rpb25cbiAqIG9uIGl0IHRvIHByb2R1Y2UgYSBNYXRoTUwgbm9kZS5cbiAqL1xudmFyIGJ1aWxkR3JvdXAgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIGlmICghZ3JvdXApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXBUeXBlc1tncm91cC50eXBlXSkge1xuICAgICAgICAvLyBDYWxsIHRoZSBncm91cFR5cGVzIGZ1bmN0aW9uXG4gICAgICAgIHJldHVybiBncm91cFR5cGVzW2dyb3VwLnR5cGVdKGdyb3VwLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgIFwiR290IGdyb3VwIG9mIHVua25vd24gdHlwZTogJ1wiICsgZ3JvdXAudHlwZSArIFwiJ1wiKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFRha2VzIGEgZnVsbCBwYXJzZSB0cmVlIGFuZCBzZXR0aW5ncyBhbmQgYnVpbGRzIGEgTWF0aE1MIHJlcHJlc2VudGF0aW9uIG9mXG4gKiBpdC4gSW4gcGFydGljdWxhciwgd2UgcHV0IHRoZSBlbGVtZW50cyBmcm9tIGJ1aWxkaW5nIHRoZSBwYXJzZSB0cmVlIGludG8gYVxuICogPHNlbWFudGljcz4gdGFnIHNvIHdlIGNhbiBhbHNvIGluY2x1ZGUgdGhhdCBUZVggc291cmNlIGFzIGFuIGFubm90YXRpb24uXG4gKlxuICogTm90ZSB0aGF0IHdlIGFjdHVhbGx5IHJldHVybiBhIGRvbVRyZWUgZWxlbWVudCB3aXRoIGEgYDxtYXRoPmAgaW5zaWRlIGl0IHNvXG4gKiB3ZSBjYW4gZG8gYXBwcm9wcmlhdGUgc3R5bGluZy5cbiAqL1xudmFyIGJ1aWxkTWF0aE1MID0gZnVuY3Rpb24odHJlZSwgdGV4RXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICAgIHZhciBleHByZXNzaW9uID0gYnVpbGRFeHByZXNzaW9uKHRyZWUsIG9wdGlvbnMpO1xuXG4gICAgLy8gV3JhcCB1cCB0aGUgZXhwcmVzc2lvbiBpbiBhbiBtcm93IHNvIGl0IGlzIHByZXNlbnRlZCBpbiB0aGUgc2VtYW50aWNzXG4gICAgLy8gdGFnIGNvcnJlY3RseS5cbiAgICB2YXIgd3JhcHBlciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBleHByZXNzaW9uKTtcblxuICAgIC8vIEJ1aWxkIGEgVGVYIGFubm90YXRpb24gb2YgdGhlIHNvdXJjZVxuICAgIHZhciBhbm5vdGF0aW9uID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwiYW5ub3RhdGlvblwiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUodGV4RXhwcmVzc2lvbildKTtcblxuICAgIGFubm90YXRpb24uc2V0QXR0cmlidXRlKFwiZW5jb2RpbmdcIiwgXCJhcHBsaWNhdGlvbi94LXRleFwiKTtcblxuICAgIHZhciBzZW1hbnRpY3MgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJzZW1hbnRpY3NcIiwgW3dyYXBwZXIsIGFubm90YXRpb25dKTtcblxuICAgIHZhciBtYXRoID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtYXRoXCIsIFtzZW1hbnRpY3NdKTtcblxuICAgIC8vIFlvdSBjYW4ndCBzdHlsZSA8bWF0aD4gbm9kZXMsIHNvIHdlIHdyYXAgdGhlIG5vZGUgaW4gYSBzcGFuLlxuICAgIHJldHVybiBtYWtlU3BhbihbXCJrYXRleC1tYXRobWxcIl0sIFttYXRoXSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1aWxkTWF0aE1MO1xuIiwidmFyIGJ1aWxkSFRNTCA9IHJlcXVpcmUoXCIuL2J1aWxkSFRNTFwiKTtcbnZhciBidWlsZE1hdGhNTCA9IHJlcXVpcmUoXCIuL2J1aWxkTWF0aE1MXCIpO1xudmFyIGJ1aWxkQ29tbW9uID0gcmVxdWlyZShcIi4vYnVpbGRDb21tb25cIik7XG52YXIgT3B0aW9ucyA9IHJlcXVpcmUoXCIuL09wdGlvbnNcIik7XG52YXIgU2V0dGluZ3MgPSByZXF1aXJlKFwiLi9TZXR0aW5nc1wiKTtcbnZhciBTdHlsZSA9IHJlcXVpcmUoXCIuL1N0eWxlXCIpO1xuXG52YXIgbWFrZVNwYW4gPSBidWlsZENvbW1vbi5tYWtlU3BhbjtcblxudmFyIGJ1aWxkVHJlZSA9IGZ1bmN0aW9uKHRyZWUsIGV4cHJlc3Npb24sIHNldHRpbmdzKSB7XG4gICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCBuZXcgU2V0dGluZ3Moe30pO1xuXG4gICAgdmFyIHN0YXJ0U3R5bGUgPSBTdHlsZS5URVhUO1xuICAgIGlmIChzZXR0aW5ncy5kaXNwbGF5TW9kZSkge1xuICAgICAgICBzdGFydFN0eWxlID0gU3R5bGUuRElTUExBWTtcbiAgICB9XG5cbiAgICAvLyBTZXR1cCB0aGUgZGVmYXVsdCBvcHRpb25zXG4gICAgdmFyIG9wdGlvbnMgPSBuZXcgT3B0aW9ucyh7XG4gICAgICAgIHN0eWxlOiBzdGFydFN0eWxlLFxuICAgICAgICBzaXplOiBcInNpemU1XCJcbiAgICB9KTtcblxuICAgIC8vIGBidWlsZEhUTUxgIHNvbWV0aW1lcyBtZXNzZXMgd2l0aCB0aGUgcGFyc2UgdHJlZSAobGlrZSB0dXJuaW5nIGJpbnMgLT5cbiAgICAvLyBvcmRzKSwgc28gd2UgYnVpbGQgdGhlIE1hdGhNTCB2ZXJzaW9uIGZpcnN0LlxuICAgIHZhciBtYXRoTUxOb2RlID0gYnVpbGRNYXRoTUwodHJlZSwgZXhwcmVzc2lvbiwgb3B0aW9ucyk7XG4gICAgdmFyIGh0bWxOb2RlID0gYnVpbGRIVE1MKHRyZWUsIG9wdGlvbnMpO1xuXG4gICAgdmFyIGthdGV4Tm9kZSA9IG1ha2VTcGFuKFtcImthdGV4XCJdLCBbXG4gICAgICAgIG1hdGhNTE5vZGUsIGh0bWxOb2RlXG4gICAgXSk7XG5cbiAgICBpZiAoc2V0dGluZ3MuZGlzcGxheU1vZGUpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VTcGFuKFtcImthdGV4LWRpc3BsYXlcIl0sIFtrYXRleE5vZGVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga2F0ZXhOb2RlO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYnVpbGRUcmVlO1xuIiwiLyoqXG4gKiBUaGlzIGZpbGUgZGVhbHMgd2l0aCBjcmVhdGluZyBkZWxpbWl0ZXJzIG9mIHZhcmlvdXMgc2l6ZXMuIFRoZSBUZVhib29rXG4gKiBkaXNjdXNzZXMgdGhlc2Ugcm91dGluZXMgb24gcGFnZSA0NDEtNDQyLCBpbiB0aGUgXCJBbm90aGVyIHN1YnJvdXRpbmUgc2V0cyBib3hcbiAqIHggdG8gYSBzcGVjaWZpZWQgdmFyaWFibGUgZGVsaW1pdGVyXCIgcGFyYWdyYXBoLlxuICpcbiAqIFRoZXJlIGFyZSB0aHJlZSBtYWluIHJvdXRpbmVzIGhlcmUuIGBtYWtlU21hbGxEZWxpbWAgbWFrZXMgYSBkZWxpbWl0ZXIgaW4gdGhlXG4gKiBub3JtYWwgZm9udCwgYnV0IGluIGVpdGhlciB0ZXh0LCBzY3JpcHQsIG9yIHNjcmlwdHNjcmlwdCBzdHlsZS5cbiAqIGBtYWtlTGFyZ2VEZWxpbWAgbWFrZXMgYSBkZWxpbWl0ZXIgaW4gdGV4dHN0eWxlLCBidXQgaW4gb25lIG9mIHRoZSBTaXplMSxcbiAqIFNpemUyLCBTaXplMywgb3IgU2l6ZTQgZm9udHMuIGBtYWtlU3RhY2tlZERlbGltYCBtYWtlcyBhIGRlbGltaXRlciBvdXQgb2ZcbiAqIHNtYWxsZXIgcGllY2VzIHRoYXQgYXJlIHN0YWNrZWQgb24gdG9wIG9mIG9uZSBhbm90aGVyLlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgdGFrZSBhIHBhcmFtZXRlciBgY2VudGVyYCwgd2hpY2ggZGV0ZXJtaW5lcyBpZiB0aGUgZGVsaW1pdGVyXG4gKiBzaG91bGQgYmUgY2VudGVyZWQgYXJvdW5kIHRoZSBheGlzLlxuICpcbiAqIFRoZW4sIHRoZXJlIGFyZSB0aHJlZSBleHBvc2VkIGZ1bmN0aW9ucy4gYHNpemVkRGVsaW1gIG1ha2VzIGEgZGVsaW1pdGVyIGluXG4gKiBvbmUgb2YgdGhlIGdpdmVuIHNpemVzLiBUaGlzIGlzIHVzZWQgZm9yIHRoaW5ncyBsaWtlIGBcXGJpZ2xgLlxuICogYGN1c3RvbVNpemVkRGVsaW1gIG1ha2VzIGEgZGVsaW1pdGVyIHdpdGggYSBnaXZlbiB0b3RhbCBoZWlnaHQrZGVwdGguIEl0IGlzXG4gKiBjYWxsZWQgaW4gcGxhY2VzIGxpa2UgYFxcc3FydGAuIGBsZWZ0UmlnaHREZWxpbWAgbWFrZXMgYW4gYXBwcm9wcmlhdGVcbiAqIGRlbGltaXRlciB3aGljaCBzdXJyb3VuZHMgYW4gZXhwcmVzc2lvbiBvZiBhIGdpdmVuIGhlaWdodCBhbiBkZXB0aC4gSXQgaXNcbiAqIHVzZWQgaW4gYFxcbGVmdGAgYW5kIGBcXHJpZ2h0YC5cbiAqL1xuXG52YXIgUGFyc2VFcnJvciA9IHJlcXVpcmUoXCIuL1BhcnNlRXJyb3JcIik7XG52YXIgU3R5bGUgPSByZXF1aXJlKFwiLi9TdHlsZVwiKTtcblxudmFyIGJ1aWxkQ29tbW9uID0gcmVxdWlyZShcIi4vYnVpbGRDb21tb25cIik7XG52YXIgZm9udE1ldHJpY3MgPSByZXF1aXJlKFwiLi9mb250TWV0cmljc1wiKTtcbnZhciBzeW1ib2xzID0gcmVxdWlyZShcIi4vc3ltYm9sc1wiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuXG52YXIgbWFrZVNwYW4gPSBidWlsZENvbW1vbi5tYWtlU3BhbjtcblxuLyoqXG4gKiBHZXQgdGhlIG1ldHJpY3MgZm9yIGEgZ2l2ZW4gc3ltYm9sIGFuZCBmb250LCBhZnRlciB0cmFuc2Zvcm1hdGlvbiAoaS5lLlxuICogYWZ0ZXIgZm9sbG93aW5nIHJlcGxhY2VtZW50IGZyb20gc3ltYm9scy5qcylcbiAqL1xudmFyIGdldE1ldHJpY3MgPSBmdW5jdGlvbihzeW1ib2wsIGZvbnQpIHtcbiAgICBpZiAoc3ltYm9scy5tYXRoW3N5bWJvbF0gJiYgc3ltYm9scy5tYXRoW3N5bWJvbF0ucmVwbGFjZSkge1xuICAgICAgICByZXR1cm4gZm9udE1ldHJpY3MuZ2V0Q2hhcmFjdGVyTWV0cmljcyhcbiAgICAgICAgICAgIHN5bWJvbHMubWF0aFtzeW1ib2xdLnJlcGxhY2UsIGZvbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmb250TWV0cmljcy5nZXRDaGFyYWN0ZXJNZXRyaWNzKFxuICAgICAgICAgICAgc3ltYm9sLCBmb250KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBhIHN5bWJvbCBpbiB0aGUgZ2l2ZW4gZm9udCBzaXplIChub3RlIHNpemUgaXMgYW4gaW50ZWdlcilcbiAqL1xudmFyIG1hdGhybVNpemUgPSBmdW5jdGlvbih2YWx1ZSwgc2l6ZSwgbW9kZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3ltYm9sKHZhbHVlLCBcIlNpemVcIiArIHNpemUgKyBcIi1SZWd1bGFyXCIsXG4gICAgICAgIG1vZGUsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgZGVsaW1pdGVyIHNwYW4gaW4gYSBnaXZlbiBzdHlsZSwgYW5kIGFkZHMgYXBwcm9wcmlhdGUgaGVpZ2h0LCBkZXB0aCxcbiAqIGFuZCBtYXhGb250U2l6ZXMuXG4gKi9cbnZhciBzdHlsZVdyYXAgPSBmdW5jdGlvbihkZWxpbSwgdG9TdHlsZSwgb3B0aW9ucywgY2xhc3Nlcykge1xuICAgIGNsYXNzZXMgPSBjbGFzc2VzIHx8IFtdO1xuICAgIHZhciBzcGFuID0gbWFrZVNwYW4oXG4gICAgICAgIGNsYXNzZXMuY29uY2F0KFtcInN0eWxlLXdyYXBcIiwgb3B0aW9ucy5zdHlsZS5yZXNldCgpLCB0b1N0eWxlLmNscygpXSksXG4gICAgICAgIFtkZWxpbV0sIG9wdGlvbnMpO1xuXG4gICAgdmFyIG11bHRpcGxpZXIgPSB0b1N0eWxlLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zdHlsZS5zaXplTXVsdGlwbGllcjtcblxuICAgIHNwYW4uaGVpZ2h0ICo9IG11bHRpcGxpZXI7XG4gICAgc3Bhbi5kZXB0aCAqPSBtdWx0aXBsaWVyO1xuICAgIHNwYW4ubWF4Rm9udFNpemUgPSB0b1N0eWxlLnNpemVNdWx0aXBsaWVyO1xuXG4gICAgcmV0dXJuIHNwYW47XG59O1xuXG4vKipcbiAqIE1ha2VzIGEgc21hbGwgZGVsaW1pdGVyLiBUaGlzIGlzIGEgZGVsaW1pdGVyIHRoYXQgY29tZXMgaW4gdGhlIE1haW4tUmVndWxhclxuICogZm9udCwgYnV0IGlzIHJlc3R5bGVkIHRvIGVpdGhlciBiZSBpbiB0ZXh0c3R5bGUsIHNjcmlwdHN0eWxlLCBvclxuICogc2NyaXB0c2NyaXB0c3R5bGUuXG4gKi9cbnZhciBtYWtlU21hbGxEZWxpbSA9IGZ1bmN0aW9uKGRlbGltLCBzdHlsZSwgY2VudGVyLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKSB7XG4gICAgdmFyIHRleHQgPSBidWlsZENvbW1vbi5tYWtlU3ltYm9sKGRlbGltLCBcIk1haW4tUmVndWxhclwiLCBtb2RlLCBvcHRpb25zKTtcblxuICAgIHZhciBzcGFuID0gc3R5bGVXcmFwKHRleHQsIHN0eWxlLCBvcHRpb25zLCBjbGFzc2VzKTtcblxuICAgIGlmIChjZW50ZXIpIHtcbiAgICAgICAgdmFyIHNoaWZ0ID1cbiAgICAgICAgICAgICgxIC0gb3B0aW9ucy5zdHlsZS5zaXplTXVsdGlwbGllciAvIHN0eWxlLnNpemVNdWx0aXBsaWVyKSAqXG4gICAgICAgICAgICBvcHRpb25zLnN0eWxlLm1ldHJpY3MuYXhpc0hlaWdodDtcblxuICAgICAgICBzcGFuLnN0eWxlLnRvcCA9IHNoaWZ0ICsgXCJlbVwiO1xuICAgICAgICBzcGFuLmhlaWdodCAtPSBzaGlmdDtcbiAgICAgICAgc3Bhbi5kZXB0aCArPSBzaGlmdDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3Bhbjtcbn07XG5cbi8qKlxuICogTWFrZXMgYSBsYXJnZSBkZWxpbWl0ZXIuIFRoaXMgaXMgYSBkZWxpbWl0ZXIgdGhhdCBjb21lcyBpbiB0aGUgU2l6ZTEsIFNpemUyLFxuICogU2l6ZTMsIG9yIFNpemU0IGZvbnRzLiBJdCBpcyBhbHdheXMgcmVuZGVyZWQgaW4gdGV4dHN0eWxlLlxuICovXG52YXIgbWFrZUxhcmdlRGVsaW0gPSBmdW5jdGlvbihkZWxpbSwgc2l6ZSwgY2VudGVyLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKSB7XG4gICAgdmFyIGlubmVyID0gbWF0aHJtU2l6ZShkZWxpbSwgc2l6ZSwgbW9kZSwgb3B0aW9ucyk7XG5cbiAgICB2YXIgc3BhbiA9IHN0eWxlV3JhcChcbiAgICAgICAgbWFrZVNwYW4oW1wiZGVsaW1zaXppbmdcIiwgXCJzaXplXCIgKyBzaXplXSwgW2lubmVyXSwgb3B0aW9ucyksXG4gICAgICAgIFN0eWxlLlRFWFQsIG9wdGlvbnMsIGNsYXNzZXMpO1xuXG4gICAgaWYgKGNlbnRlcikge1xuICAgICAgICB2YXIgc2hpZnQgPSAoMSAtIG9wdGlvbnMuc3R5bGUuc2l6ZU11bHRpcGxpZXIpICpcbiAgICAgICAgICAgIG9wdGlvbnMuc3R5bGUubWV0cmljcy5heGlzSGVpZ2h0O1xuXG4gICAgICAgIHNwYW4uc3R5bGUudG9wID0gc2hpZnQgKyBcImVtXCI7XG4gICAgICAgIHNwYW4uaGVpZ2h0IC09IHNoaWZ0O1xuICAgICAgICBzcGFuLmRlcHRoICs9IHNoaWZ0O1xuICAgIH1cblxuICAgIHJldHVybiBzcGFuO1xufTtcblxuLyoqXG4gKiBNYWtlIGFuIGlubmVyIHNwYW4gd2l0aCB0aGUgZ2l2ZW4gb2Zmc2V0IGFuZCBpbiB0aGUgZ2l2ZW4gZm9udC4gVGhpcyBpcyB1c2VkXG4gKiBpbiBgbWFrZVN0YWNrZWREZWxpbWAgdG8gbWFrZSB0aGUgc3RhY2tpbmcgcGllY2VzIGZvciB0aGUgZGVsaW1pdGVyLlxuICovXG52YXIgbWFrZUlubmVyID0gZnVuY3Rpb24oc3ltYm9sLCBmb250LCBtb2RlKSB7XG4gICAgdmFyIHNpemVDbGFzcztcbiAgICAvLyBBcHBseSB0aGUgY29ycmVjdCBDU1MgY2xhc3MgdG8gY2hvb3NlIHRoZSByaWdodCBmb250LlxuICAgIGlmIChmb250ID09PSBcIlNpemUxLVJlZ3VsYXJcIikge1xuICAgICAgICBzaXplQ2xhc3MgPSBcImRlbGltLXNpemUxXCI7XG4gICAgfSBlbHNlIGlmIChmb250ID09PSBcIlNpemU0LVJlZ3VsYXJcIikge1xuICAgICAgICBzaXplQ2xhc3MgPSBcImRlbGltLXNpemU0XCI7XG4gICAgfVxuXG4gICAgdmFyIGlubmVyID0gbWFrZVNwYW4oXG4gICAgICAgIFtcImRlbGltc2l6aW5naW5uZXJcIiwgc2l6ZUNsYXNzXSxcbiAgICAgICAgW21ha2VTcGFuKFtdLCBbYnVpbGRDb21tb24ubWFrZVN5bWJvbChzeW1ib2wsIGZvbnQsIG1vZGUpXSldKTtcblxuICAgIC8vIFNpbmNlIHRoaXMgd2lsbCBiZSBwYXNzZWQgaW50byBgbWFrZVZMaXN0YCBpbiB0aGUgZW5kLCB3cmFwIHRoZSBlbGVtZW50XG4gICAgLy8gaW4gdGhlIGFwcHJvcHJpYXRlIHRhZyB0aGF0IFZMaXN0IHVzZXMuXG4gICAgcmV0dXJuIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogaW5uZXJ9O1xufTtcblxuLyoqXG4gKiBNYWtlIGEgc3RhY2tlZCBkZWxpbWl0ZXIgb3V0IG9mIGEgZ2l2ZW4gZGVsaW1pdGVyLCB3aXRoIHRoZSB0b3RhbCBoZWlnaHQgYXRcbiAqIGxlYXN0IGBoZWlnaHRUb3RhbGAuIFRoaXMgcm91dGluZSBpcyBtZW50aW9uZWQgb24gcGFnZSA0NDIgb2YgdGhlIFRlWGJvb2suXG4gKi9cbnZhciBtYWtlU3RhY2tlZERlbGltID0gZnVuY3Rpb24oZGVsaW0sIGhlaWdodFRvdGFsLCBjZW50ZXIsIG9wdGlvbnMsIG1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMpIHtcbiAgICAvLyBUaGVyZSBhcmUgZm91ciBwYXJ0cywgdGhlIHRvcCwgYW4gb3B0aW9uYWwgbWlkZGxlLCBhIHJlcGVhdGVkIHBhcnQsIGFuZCBhXG4gICAgLy8gYm90dG9tLlxuICAgIHZhciB0b3A7XG4gICAgdmFyIG1pZGRsZTtcbiAgICB2YXIgcmVwZWF0O1xuICAgIHZhciBib3R0b207XG4gICAgdG9wID0gcmVwZWF0ID0gYm90dG9tID0gZGVsaW07XG4gICAgbWlkZGxlID0gbnVsbDtcbiAgICAvLyBBbHNvIGtlZXAgdHJhY2sgb2Ygd2hhdCBmb250IHRoZSBkZWxpbWl0ZXJzIGFyZSBpblxuICAgIHZhciBmb250ID0gXCJTaXplMS1SZWd1bGFyXCI7XG5cbiAgICAvLyBXZSBzZXQgdGhlIHBhcnRzIGFuZCBmb250IGJhc2VkIG9uIHRoZSBzeW1ib2wuIE5vdGUgdGhhdCB3ZSB1c2VcbiAgICAvLyAnXFx1MjNkMCcgaW5zdGVhZCBvZiAnfCcgYW5kICdcXHUyMDE2JyBpbnN0ZWFkIG9mICdcXFxcfCcgZm9yIHRoZVxuICAgIC8vIHJlcGVhdHMgb2YgdGhlIGFycm93c1xuICAgIGlmIChkZWxpbSA9PT0gXCJcXFxcdXBhcnJvd1wiKSB7XG4gICAgICAgIHJlcGVhdCA9IGJvdHRvbSA9IFwiXFx1MjNkMFwiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXFVwYXJyb3dcIikge1xuICAgICAgICByZXBlYXQgPSBib3R0b20gPSBcIlxcdTIwMTZcIjtcbiAgICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxkb3duYXJyb3dcIikge1xuICAgICAgICB0b3AgPSByZXBlYXQgPSBcIlxcdTIzZDBcIjtcbiAgICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxEb3duYXJyb3dcIikge1xuICAgICAgICB0b3AgPSByZXBlYXQgPSBcIlxcdTIwMTZcIjtcbiAgICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFx1cGRvd25hcnJvd1wiKSB7XG4gICAgICAgIHRvcCA9IFwiXFxcXHVwYXJyb3dcIjtcbiAgICAgICAgcmVwZWF0ID0gXCJcXHUyM2QwXCI7XG4gICAgICAgIGJvdHRvbSA9IFwiXFxcXGRvd25hcnJvd1wiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXFVwZG93bmFycm93XCIpIHtcbiAgICAgICAgdG9wID0gXCJcXFxcVXBhcnJvd1wiO1xuICAgICAgICByZXBlYXQgPSBcIlxcdTIwMTZcIjtcbiAgICAgICAgYm90dG9tID0gXCJcXFxcRG93bmFycm93XCI7XG4gICAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJbXCIgfHwgZGVsaW0gPT09IFwiXFxcXGxicmFja1wiKSB7XG4gICAgICAgIHRvcCA9IFwiXFx1MjNhMVwiO1xuICAgICAgICByZXBlYXQgPSBcIlxcdTIzYTJcIjtcbiAgICAgICAgYm90dG9tID0gXCJcXHUyM2EzXCI7XG4gICAgICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICB9IGVsc2UgaWYgKGRlbGltID09PSBcIl1cIiB8fCBkZWxpbSA9PT0gXCJcXFxccmJyYWNrXCIpIHtcbiAgICAgICAgdG9wID0gXCJcXHUyM2E0XCI7XG4gICAgICAgIHJlcGVhdCA9IFwiXFx1MjNhNVwiO1xuICAgICAgICBib3R0b20gPSBcIlxcdTIzYTZcIjtcbiAgICAgICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXGxmbG9vclwiKSB7XG4gICAgICAgIHJlcGVhdCA9IHRvcCA9IFwiXFx1MjNhMlwiO1xuICAgICAgICBib3R0b20gPSBcIlxcdTIzYTNcIjtcbiAgICAgICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXGxjZWlsXCIpIHtcbiAgICAgICAgdG9wID0gXCJcXHUyM2ExXCI7XG4gICAgICAgIHJlcGVhdCA9IGJvdHRvbSA9IFwiXFx1MjNhMlwiO1xuICAgICAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxccmZsb29yXCIpIHtcbiAgICAgICAgcmVwZWF0ID0gdG9wID0gXCJcXHUyM2E1XCI7XG4gICAgICAgIGJvdHRvbSA9IFwiXFx1MjNhNlwiO1xuICAgICAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxccmNlaWxcIikge1xuICAgICAgICB0b3AgPSBcIlxcdTIzYTRcIjtcbiAgICAgICAgcmVwZWF0ID0gYm90dG9tID0gXCJcXHUyM2E1XCI7XG4gICAgICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICB9IGVsc2UgaWYgKGRlbGltID09PSBcIihcIikge1xuICAgICAgICB0b3AgPSBcIlxcdTIzOWJcIjtcbiAgICAgICAgcmVwZWF0ID0gXCJcXHUyMzljXCI7XG4gICAgICAgIGJvdHRvbSA9IFwiXFx1MjM5ZFwiO1xuICAgICAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCIpXCIpIHtcbiAgICAgICAgdG9wID0gXCJcXHUyMzllXCI7XG4gICAgICAgIHJlcGVhdCA9IFwiXFx1MjM5ZlwiO1xuICAgICAgICBib3R0b20gPSBcIlxcdTIzYTBcIjtcbiAgICAgICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXHtcIiB8fCBkZWxpbSA9PT0gXCJcXFxcbGJyYWNlXCIpIHtcbiAgICAgICAgdG9wID0gXCJcXHUyM2E3XCI7XG4gICAgICAgIG1pZGRsZSA9IFwiXFx1MjNhOFwiO1xuICAgICAgICBib3R0b20gPSBcIlxcdTIzYTlcIjtcbiAgICAgICAgcmVwZWF0ID0gXCJcXHUyM2FhXCI7XG4gICAgICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFx9XCIgfHwgZGVsaW0gPT09IFwiXFxcXHJicmFjZVwiKSB7XG4gICAgICAgIHRvcCA9IFwiXFx1MjNhYlwiO1xuICAgICAgICBtaWRkbGUgPSBcIlxcdTIzYWNcIjtcbiAgICAgICAgYm90dG9tID0gXCJcXHUyM2FkXCI7XG4gICAgICAgIHJlcGVhdCA9IFwiXFx1MjNhYVwiO1xuICAgICAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxcbGdyb3VwXCIpIHtcbiAgICAgICAgdG9wID0gXCJcXHUyM2E3XCI7XG4gICAgICAgIGJvdHRvbSA9IFwiXFx1MjNhOVwiO1xuICAgICAgICByZXBlYXQgPSBcIlxcdTIzYWFcIjtcbiAgICAgICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXHJncm91cFwiKSB7XG4gICAgICAgIHRvcCA9IFwiXFx1MjNhYlwiO1xuICAgICAgICBib3R0b20gPSBcIlxcdTIzYWRcIjtcbiAgICAgICAgcmVwZWF0ID0gXCJcXHUyM2FhXCI7XG4gICAgICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxsbW91c3RhY2hlXCIpIHtcbiAgICAgICAgdG9wID0gXCJcXHUyM2E3XCI7XG4gICAgICAgIGJvdHRvbSA9IFwiXFx1MjNhZFwiO1xuICAgICAgICByZXBlYXQgPSBcIlxcdTIzYWFcIjtcbiAgICAgICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXHJtb3VzdGFjaGVcIikge1xuICAgICAgICB0b3AgPSBcIlxcdTIzYWJcIjtcbiAgICAgICAgYm90dG9tID0gXCJcXHUyM2E5XCI7XG4gICAgICAgIHJlcGVhdCA9IFwiXFx1MjNhYVwiO1xuICAgICAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxcc3VyZFwiKSB7XG4gICAgICAgIHRvcCA9IFwiXFx1ZTAwMVwiO1xuICAgICAgICBib3R0b20gPSBcIlxcdTIzYjdcIjtcbiAgICAgICAgcmVwZWF0ID0gXCJcXHVlMDAwXCI7XG4gICAgICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICB9XG5cbiAgICAvLyBHZXQgdGhlIG1ldHJpY3Mgb2YgdGhlIGZvdXIgc2VjdGlvbnNcbiAgICB2YXIgdG9wTWV0cmljcyA9IGdldE1ldHJpY3ModG9wLCBmb250KTtcbiAgICB2YXIgdG9wSGVpZ2h0VG90YWwgPSB0b3BNZXRyaWNzLmhlaWdodCArIHRvcE1ldHJpY3MuZGVwdGg7XG4gICAgdmFyIHJlcGVhdE1ldHJpY3MgPSBnZXRNZXRyaWNzKHJlcGVhdCwgZm9udCk7XG4gICAgdmFyIHJlcGVhdEhlaWdodFRvdGFsID0gcmVwZWF0TWV0cmljcy5oZWlnaHQgKyByZXBlYXRNZXRyaWNzLmRlcHRoO1xuICAgIHZhciBib3R0b21NZXRyaWNzID0gZ2V0TWV0cmljcyhib3R0b20sIGZvbnQpO1xuICAgIHZhciBib3R0b21IZWlnaHRUb3RhbCA9IGJvdHRvbU1ldHJpY3MuaGVpZ2h0ICsgYm90dG9tTWV0cmljcy5kZXB0aDtcbiAgICB2YXIgbWlkZGxlSGVpZ2h0VG90YWwgPSAwO1xuICAgIHZhciBtaWRkbGVGYWN0b3IgPSAxO1xuICAgIGlmIChtaWRkbGUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIG1pZGRsZU1ldHJpY3MgPSBnZXRNZXRyaWNzKG1pZGRsZSwgZm9udCk7XG4gICAgICAgIG1pZGRsZUhlaWdodFRvdGFsID0gbWlkZGxlTWV0cmljcy5oZWlnaHQgKyBtaWRkbGVNZXRyaWNzLmRlcHRoO1xuICAgICAgICBtaWRkbGVGYWN0b3IgPSAyOyAvLyByZXBlYXQgc3ltbWV0cmljYWxseSBhYm92ZSBhbmQgYmVsb3cgbWlkZGxlXG4gICAgfVxuXG4gICAgLy8gQ2FsY3VhdGUgdGhlIG1pbmltYWwgaGVpZ2h0IHRoYXQgdGhlIGRlbGltaXRlciBjYW4gaGF2ZS5cbiAgICAvLyBJdCBpcyBhdCBsZWFzdCB0aGUgc2l6ZSBvZiB0aGUgdG9wLCBib3R0b20sIGFuZCBvcHRpb25hbCBtaWRkbGUgY29tYmluZWQuXG4gICAgdmFyIG1pbkhlaWdodCA9IHRvcEhlaWdodFRvdGFsICsgYm90dG9tSGVpZ2h0VG90YWwgKyBtaWRkbGVIZWlnaHRUb3RhbDtcblxuICAgIC8vIENvbXB1dGUgdGhlIG51bWJlciBvZiBjb3BpZXMgb2YgdGhlIHJlcGVhdCBzeW1ib2wgd2Ugd2lsbCBuZWVkXG4gICAgdmFyIHJlcGVhdENvdW50ID0gTWF0aC5jZWlsKFxuICAgICAgICAoaGVpZ2h0VG90YWwgLSBtaW5IZWlnaHQpIC8gKG1pZGRsZUZhY3RvciAqIHJlcGVhdEhlaWdodFRvdGFsKSk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSB0b3RhbCBoZWlnaHQgb2YgdGhlIGRlbGltaXRlciBpbmNsdWRpbmcgYWxsIHRoZSBzeW1ib2xzXG4gICAgdmFyIHJlYWxIZWlnaHRUb3RhbCA9XG4gICAgICAgIG1pbkhlaWdodCArIHJlcGVhdENvdW50ICogbWlkZGxlRmFjdG9yICogcmVwZWF0SGVpZ2h0VG90YWw7XG5cbiAgICAvLyBUaGUgY2VudGVyIG9mIHRoZSBkZWxpbWl0ZXIgaXMgcGxhY2VkIGF0IHRoZSBjZW50ZXIgb2YgdGhlIGF4aXMuIE5vdGVcbiAgICAvLyB0aGF0IGluIHRoaXMgY29udGV4dCwgXCJjZW50ZXJcIiBtZWFucyB0aGF0IHRoZSBkZWxpbWl0ZXIgc2hvdWxkIGJlXG4gICAgLy8gY2VudGVyZWQgYXJvdW5kIHRoZSBheGlzIGluIHRoZSBjdXJyZW50IHN0eWxlLCB3aGlsZSBub3JtYWxseSBpdCBpc1xuICAgIC8vIGNlbnRlcmVkIGFyb3VuZCB0aGUgYXhpcyBpbiB0ZXh0c3R5bGUuXG4gICAgdmFyIGF4aXNIZWlnaHQgPSBvcHRpb25zLnN0eWxlLm1ldHJpY3MuYXhpc0hlaWdodDtcbiAgICBpZiAoY2VudGVyKSB7XG4gICAgICAgIGF4aXNIZWlnaHQgKj0gb3B0aW9ucy5zdHlsZS5zaXplTXVsdGlwbGllcjtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXB0aFxuICAgIHZhciBkZXB0aCA9IHJlYWxIZWlnaHRUb3RhbCAvIDIgLSBheGlzSGVpZ2h0O1xuXG4gICAgLy8gTm93LCB3ZSBzdGFydCBidWlsZGluZyB0aGUgcGllY2VzIHRoYXQgd2lsbCBnbyBpbnRvIHRoZSB2bGlzdFxuXG4gICAgLy8gS2VlcCBhIGxpc3Qgb2YgdGhlIGlubmVyIHBpZWNlc1xuICAgIHZhciBpbm5lcnMgPSBbXTtcblxuICAgIC8vIEFkZCB0aGUgYm90dG9tIHN5bWJvbFxuICAgIGlubmVycy5wdXNoKG1ha2VJbm5lcihib3R0b20sIGZvbnQsIG1vZGUpKTtcblxuICAgIHZhciBpO1xuICAgIGlmIChtaWRkbGUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gQWRkIHRoYXQgbWFueSBzeW1ib2xzXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZXBlYXRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBpbm5lcnMucHVzaChtYWtlSW5uZXIocmVwZWF0LCBmb250LCBtb2RlKSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXaGVuIHRoZXJlIGlzIGEgbWlkZGxlIGJpdCwgd2UgbmVlZCB0aGUgbWlkZGxlIHBhcnQgYW5kIHR3byByZXBlYXRlZFxuICAgICAgICAvLyBzZWN0aW9uc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVwZWF0Q291bnQ7IGkrKykge1xuICAgICAgICAgICAgaW5uZXJzLnB1c2gobWFrZUlubmVyKHJlcGVhdCwgZm9udCwgbW9kZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlubmVycy5wdXNoKG1ha2VJbm5lcihtaWRkbGUsIGZvbnQsIG1vZGUpKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlcGVhdENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGlubmVycy5wdXNoKG1ha2VJbm5lcihyZXBlYXQsIGZvbnQsIG1vZGUpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgdG9wIHN5bWJvbFxuICAgIGlubmVycy5wdXNoKG1ha2VJbm5lcih0b3AsIGZvbnQsIG1vZGUpKTtcblxuICAgIC8vIEZpbmFsbHksIGJ1aWxkIHRoZSB2bGlzdFxuICAgIHZhciBpbm5lciA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdChpbm5lcnMsIFwiYm90dG9tXCIsIGRlcHRoLCBvcHRpb25zKTtcblxuICAgIHJldHVybiBzdHlsZVdyYXAoXG4gICAgICAgIG1ha2VTcGFuKFtcImRlbGltc2l6aW5nXCIsIFwibXVsdFwiXSwgW2lubmVyXSwgb3B0aW9ucyksXG4gICAgICAgIFN0eWxlLlRFWFQsIG9wdGlvbnMsIGNsYXNzZXMpO1xufTtcblxuLy8gVGhlcmUgYXJlIHRocmVlIGtpbmRzIG9mIGRlbGltaXRlcnMsIGRlbGltaXRlcnMgdGhhdCBzdGFjayB3aGVuIHRoZXkgYmVjb21lXG4vLyB0b28gbGFyZ2VcbnZhciBzdGFja0xhcmdlRGVsaW1pdGVycyA9IFtcbiAgICBcIihcIiwgXCIpXCIsIFwiW1wiLCBcIlxcXFxsYnJhY2tcIiwgXCJdXCIsIFwiXFxcXHJicmFja1wiLFxuICAgIFwiXFxcXHtcIiwgXCJcXFxcbGJyYWNlXCIsIFwiXFxcXH1cIiwgXCJcXFxccmJyYWNlXCIsXG4gICAgXCJcXFxcbGZsb29yXCIsIFwiXFxcXHJmbG9vclwiLCBcIlxcXFxsY2VpbFwiLCBcIlxcXFxyY2VpbFwiLFxuICAgIFwiXFxcXHN1cmRcIlxuXTtcblxuLy8gZGVsaW1pdGVycyB0aGF0IGFsd2F5cyBzdGFja1xudmFyIHN0YWNrQWx3YXlzRGVsaW1pdGVycyA9IFtcbiAgICBcIlxcXFx1cGFycm93XCIsIFwiXFxcXGRvd25hcnJvd1wiLCBcIlxcXFx1cGRvd25hcnJvd1wiLFxuICAgIFwiXFxcXFVwYXJyb3dcIiwgXCJcXFxcRG93bmFycm93XCIsIFwiXFxcXFVwZG93bmFycm93XCIsXG4gICAgXCJ8XCIsIFwiXFxcXHxcIiwgXCJcXFxcdmVydFwiLCBcIlxcXFxWZXJ0XCIsXG4gICAgXCJcXFxcbHZlcnRcIiwgXCJcXFxccnZlcnRcIiwgXCJcXFxcbFZlcnRcIiwgXCJcXFxcclZlcnRcIixcbiAgICBcIlxcXFxsZ3JvdXBcIiwgXCJcXFxccmdyb3VwXCIsIFwiXFxcXGxtb3VzdGFjaGVcIiwgXCJcXFxccm1vdXN0YWNoZVwiXG5dO1xuXG4vLyBhbmQgZGVsaW1pdGVycyB0aGF0IG5ldmVyIHN0YWNrXG52YXIgc3RhY2tOZXZlckRlbGltaXRlcnMgPSBbXG4gICAgXCI8XCIsIFwiPlwiLCBcIlxcXFxsYW5nbGVcIiwgXCJcXFxccmFuZ2xlXCIsIFwiL1wiLCBcIlxcXFxiYWNrc2xhc2hcIiwgXCJcXFxcbHRcIiwgXCJcXFxcZ3RcIlxuXTtcblxuLy8gTWV0cmljcyBvZiB0aGUgZGlmZmVyZW50IHNpemVzLiBGb3VuZCBieSBsb29raW5nIGF0IFRlWCdzIG91dHB1dCBvZlxuLy8gJFxcYmlnbHwgLy8gXFxCaWdsfCBcXGJpZ2dsfCBcXEJpZ2dsfCBcXHNob3dsaXN0cyRcbi8vIFVzZWQgdG8gY3JlYXRlIHN0YWNrZWQgZGVsaW1pdGVycyBvZiBhcHByb3ByaWF0ZSBzaXplcyBpbiBtYWtlU2l6ZWREZWxpbS5cbnZhciBzaXplVG9NYXhIZWlnaHQgPSBbMCwgMS4yLCAxLjgsIDIuNCwgMy4wXTtcblxuLyoqXG4gKiBVc2VkIHRvIGNyZWF0ZSBhIGRlbGltaXRlciBvZiBhIHNwZWNpZmljIHNpemUsIHdoZXJlIGBzaXplYCBpcyAxLCAyLCAzLCBvciA0LlxuICovXG52YXIgbWFrZVNpemVkRGVsaW0gPSBmdW5jdGlvbihkZWxpbSwgc2l6ZSwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcykge1xuICAgIC8vIDwgYW5kID4gdHVybiBpbnRvIFxcbGFuZ2xlIGFuZCBcXHJhbmdsZSBpbiBkZWxpbWl0ZXJzXG4gICAgaWYgKGRlbGltID09PSBcIjxcIiB8fCBkZWxpbSA9PT0gXCJcXFxcbHRcIikge1xuICAgICAgICBkZWxpbSA9IFwiXFxcXGxhbmdsZVwiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiPlwiIHx8IGRlbGltID09PSBcIlxcXFxndFwiKSB7XG4gICAgICAgIGRlbGltID0gXCJcXFxccmFuZ2xlXCI7XG4gICAgfVxuXG4gICAgLy8gU2l6ZWQgZGVsaW1pdGVycyBhcmUgbmV2ZXIgY2VudGVyZWQuXG4gICAgaWYgKHV0aWxzLmNvbnRhaW5zKHN0YWNrTGFyZ2VEZWxpbWl0ZXJzLCBkZWxpbSkgfHxcbiAgICAgICAgdXRpbHMuY29udGFpbnMoc3RhY2tOZXZlckRlbGltaXRlcnMsIGRlbGltKSkge1xuICAgICAgICByZXR1cm4gbWFrZUxhcmdlRGVsaW0oZGVsaW0sIHNpemUsIGZhbHNlLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmNvbnRhaW5zKHN0YWNrQWx3YXlzRGVsaW1pdGVycywgZGVsaW0pKSB7XG4gICAgICAgIHJldHVybiBtYWtlU3RhY2tlZERlbGltKFxuICAgICAgICAgICAgZGVsaW0sIHNpemVUb01heEhlaWdodFtzaXplXSwgZmFsc2UsIG9wdGlvbnMsIG1vZGUsIGNsYXNzZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSWxsZWdhbCBkZWxpbWl0ZXI6ICdcIiArIGRlbGltICsgXCInXCIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGhlcmUgYXJlIHRocmVlIGRpZmZlcmVudCBzZXF1ZW5jZXMgb2YgZGVsaW1pdGVyIHNpemVzIHRoYXQgdGhlIGRlbGltaXRlcnNcbiAqIGZvbGxvdyBkZXBlbmRpbmcgb24gdGhlIGtpbmQgb2YgZGVsaW1pdGVyLiBUaGlzIGlzIHVzZWQgd2hlbiBjcmVhdGluZyBjdXN0b21cbiAqIHNpemVkIGRlbGltaXRlcnMgdG8gZGVjaWRlIHdoZXRoZXIgdG8gY3JlYXRlIGEgc21hbGwsIGxhcmdlLCBvciBzdGFja2VkXG4gKiBkZWxpbWl0ZXIuXG4gKlxuICogSW4gcmVhbCBUZVgsIHRoZXNlIHNlcXVlbmNlcyBhcmVuJ3QgZXhwbGljaXRseSBkZWZpbmVkLCBidXQgYXJlIGluc3RlYWRcbiAqIGRlZmluZWQgaW5zaWRlIHRoZSBmb250IG1ldHJpY3MuIFNpbmNlIHRoZXJlIGFyZSBvbmx5IHRocmVlIHNlcXVlbmNlcyB0aGF0XG4gKiBhcmUgcG9zc2libGUgZm9yIHRoZSBkZWxpbWl0ZXJzIHRoYXQgVGVYIGRlZmluZXMsIGl0IGlzIGVhc2llciB0byBqdXN0IGVuY29kZVxuICogdGhlbSBleHBsaWNpdGx5IGhlcmUuXG4gKi9cblxuLy8gRGVsaW1pdGVycyB0aGF0IG5ldmVyIHN0YWNrIHRyeSBzbWFsbCBkZWxpbWl0ZXJzIGFuZCBsYXJnZSBkZWxpbWl0ZXJzIG9ubHlcbnZhciBzdGFja05ldmVyRGVsaW1pdGVyU2VxdWVuY2UgPSBbXG4gICAge3R5cGU6IFwic21hbGxcIiwgc3R5bGU6IFN0eWxlLlNDUklQVFNDUklQVH0sXG4gICAge3R5cGU6IFwic21hbGxcIiwgc3R5bGU6IFN0eWxlLlNDUklQVH0sXG4gICAge3R5cGU6IFwic21hbGxcIiwgc3R5bGU6IFN0eWxlLlRFWFR9LFxuICAgIHt0eXBlOiBcImxhcmdlXCIsIHNpemU6IDF9LFxuICAgIHt0eXBlOiBcImxhcmdlXCIsIHNpemU6IDJ9LFxuICAgIHt0eXBlOiBcImxhcmdlXCIsIHNpemU6IDN9LFxuICAgIHt0eXBlOiBcImxhcmdlXCIsIHNpemU6IDR9XG5dO1xuXG4vLyBEZWxpbWl0ZXJzIHRoYXQgYWx3YXlzIHN0YWNrIHRyeSB0aGUgc21hbGwgZGVsaW1pdGVycyBmaXJzdCwgdGhlbiBzdGFja1xudmFyIHN0YWNrQWx3YXlzRGVsaW1pdGVyU2VxdWVuY2UgPSBbXG4gICAge3R5cGU6IFwic21hbGxcIiwgc3R5bGU6IFN0eWxlLlNDUklQVFNDUklQVH0sXG4gICAge3R5cGU6IFwic21hbGxcIiwgc3R5bGU6IFN0eWxlLlNDUklQVH0sXG4gICAge3R5cGU6IFwic21hbGxcIiwgc3R5bGU6IFN0eWxlLlRFWFR9LFxuICAgIHt0eXBlOiBcInN0YWNrXCJ9XG5dO1xuXG4vLyBEZWxpbWl0ZXJzIHRoYXQgc3RhY2sgd2hlbiBsYXJnZSB0cnkgdGhlIHNtYWxsIGFuZCB0aGVuIGxhcmdlIGRlbGltaXRlcnMsIGFuZFxuLy8gc3RhY2sgYWZ0ZXJ3YXJkc1xudmFyIHN0YWNrTGFyZ2VEZWxpbWl0ZXJTZXF1ZW5jZSA9IFtcbiAgICB7dHlwZTogXCJzbWFsbFwiLCBzdHlsZTogU3R5bGUuU0NSSVBUU0NSSVBUfSxcbiAgICB7dHlwZTogXCJzbWFsbFwiLCBzdHlsZTogU3R5bGUuU0NSSVBUfSxcbiAgICB7dHlwZTogXCJzbWFsbFwiLCBzdHlsZTogU3R5bGUuVEVYVH0sXG4gICAge3R5cGU6IFwibGFyZ2VcIiwgc2l6ZTogMX0sXG4gICAge3R5cGU6IFwibGFyZ2VcIiwgc2l6ZTogMn0sXG4gICAge3R5cGU6IFwibGFyZ2VcIiwgc2l6ZTogM30sXG4gICAge3R5cGU6IFwibGFyZ2VcIiwgc2l6ZTogNH0sXG4gICAge3R5cGU6IFwic3RhY2tcIn1cbl07XG5cbi8qKlxuICogR2V0IHRoZSBmb250IHVzZWQgaW4gYSBkZWxpbWl0ZXIgYmFzZWQgb24gd2hhdCBraW5kIG9mIGRlbGltaXRlciBpdCBpcy5cbiAqL1xudmFyIGRlbGltVHlwZVRvRm9udCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBpZiAodHlwZS50eXBlID09PSBcInNtYWxsXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiTWFpbi1SZWd1bGFyXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlLnR5cGUgPT09IFwibGFyZ2VcIikge1xuICAgICAgICByZXR1cm4gXCJTaXplXCIgKyB0eXBlLnNpemUgKyBcIi1SZWd1bGFyXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlLnR5cGUgPT09IFwic3RhY2tcIikge1xuICAgICAgICByZXR1cm4gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUcmF2ZXJzZSBhIHNlcXVlbmNlIG9mIHR5cGVzIG9mIGRlbGltaXRlcnMgdG8gZGVjaWRlIHdoYXQga2luZCBvZiBkZWxpbWl0ZXJcbiAqIHNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBhIGRlbGltaXRlciBvZiB0aGUgZ2l2ZW4gaGVpZ2h0K2RlcHRoLlxuICovXG52YXIgdHJhdmVyc2VTZXF1ZW5jZSA9IGZ1bmN0aW9uKGRlbGltLCBoZWlnaHQsIHNlcXVlbmNlLCBvcHRpb25zKSB7XG4gICAgLy8gSGVyZSwgd2UgY2hvb3NlIHRoZSBpbmRleCB3ZSBzaG91bGQgc3RhcnQgYXQgaW4gdGhlIHNlcXVlbmNlcy4gSW4gc21hbGxlclxuICAgIC8vIHNpemVzICh3aGljaCBjb3JyZXNwb25kIHRvIGxhcmdlciBudW1iZXJzIGluIHN0eWxlLnNpemUpIHdlIHN0YXJ0IGVhcmxpZXJcbiAgICAvLyBpbiB0aGUgc2VxdWVuY2UuIFRodXMsIHNjcmlwdHNjcmlwdCBzdGFydHMgYXQgaW5kZXggMy0zPTAsIHNjcmlwdCBzdGFydHNcbiAgICAvLyBhdCBpbmRleCAzLTI9MSwgdGV4dCBzdGFydHMgYXQgMy0xPTIsIGFuZCBkaXNwbGF5IHN0YXJ0cyBhdCBtaW4oMiwzLTApPTJcbiAgICB2YXIgc3RhcnQgPSBNYXRoLm1pbigyLCAzIC0gb3B0aW9ucy5zdHlsZS5zaXplKTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBzZXF1ZW5jZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VxdWVuY2VbaV0udHlwZSA9PT0gXCJzdGFja1wiKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGFsd2F5cyB0aGUgbGFzdCBkZWxpbWl0ZXIsIHNvIHdlIGp1c3QgYnJlYWsgdGhlIGxvb3Agbm93LlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWV0cmljcyA9IGdldE1ldHJpY3MoZGVsaW0sIGRlbGltVHlwZVRvRm9udChzZXF1ZW5jZVtpXSkpO1xuICAgICAgICB2YXIgaGVpZ2h0RGVwdGggPSBtZXRyaWNzLmhlaWdodCArIG1ldHJpY3MuZGVwdGg7XG5cbiAgICAgICAgLy8gU21hbGwgZGVsaW1pdGVycyBhcmUgc2NhbGVkIGRvd24gdmVyc2lvbnMgb2YgdGhlIHNhbWUgZm9udCwgc28gd2VcbiAgICAgICAgLy8gYWNjb3VudCBmb3IgdGhlIHN0eWxlIGNoYW5nZSBzaXplLlxuXG4gICAgICAgIGlmIChzZXF1ZW5jZVtpXS50eXBlID09PSBcInNtYWxsXCIpIHtcbiAgICAgICAgICAgIGhlaWdodERlcHRoICo9IHNlcXVlbmNlW2ldLnN0eWxlLnNpemVNdWx0aXBsaWVyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGRlbGltaXRlciBhdCB0aGlzIHNpemUgd29ya3MgZm9yIHRoZSBnaXZlbiBoZWlnaHQuXG4gICAgICAgIGlmIChoZWlnaHREZXB0aCA+IGhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcXVlbmNlW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZSwgcmV0dXJuIHRoZSBsYXN0IHNlcXVlbmNlIGVsZW1lbnQuXG4gICAgcmV0dXJuIHNlcXVlbmNlW3NlcXVlbmNlLmxlbmd0aCAtIDFdO1xufTtcblxuLyoqXG4gKiBNYWtlIGEgZGVsaW1pdGVyIG9mIGEgZ2l2ZW4gaGVpZ2h0K2RlcHRoLCB3aXRoIG9wdGlvbmFsIGNlbnRlcmluZy4gSGVyZSwgd2VcbiAqIHRyYXZlcnNlIHRoZSBzZXF1ZW5jZXMsIGFuZCBjcmVhdGUgYSBkZWxpbWl0ZXIgdGhhdCB0aGUgc2VxdWVuY2UgdGVsbHMgdXMgdG8uXG4gKi9cbnZhciBtYWtlQ3VzdG9tU2l6ZWREZWxpbSA9IGZ1bmN0aW9uKGRlbGltLCBoZWlnaHQsIGNlbnRlciwgb3B0aW9ucywgbW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMpIHtcbiAgICBpZiAoZGVsaW0gPT09IFwiPFwiIHx8IGRlbGltID09PSBcIlxcXFxsdFwiKSB7XG4gICAgICAgIGRlbGltID0gXCJcXFxcbGFuZ2xlXCI7XG4gICAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCI+XCIgfHwgZGVsaW0gPT09IFwiXFxcXGd0XCIpIHtcbiAgICAgICAgZGVsaW0gPSBcIlxcXFxyYW5nbGVcIjtcbiAgICB9XG5cbiAgICAvLyBEZWNpZGUgd2hhdCBzZXF1ZW5jZSB0byB1c2VcbiAgICB2YXIgc2VxdWVuY2U7XG4gICAgaWYgKHV0aWxzLmNvbnRhaW5zKHN0YWNrTmV2ZXJEZWxpbWl0ZXJzLCBkZWxpbSkpIHtcbiAgICAgICAgc2VxdWVuY2UgPSBzdGFja05ldmVyRGVsaW1pdGVyU2VxdWVuY2U7XG4gICAgfSBlbHNlIGlmICh1dGlscy5jb250YWlucyhzdGFja0xhcmdlRGVsaW1pdGVycywgZGVsaW0pKSB7XG4gICAgICAgIHNlcXVlbmNlID0gc3RhY2tMYXJnZURlbGltaXRlclNlcXVlbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcXVlbmNlID0gc3RhY2tBbHdheXNEZWxpbWl0ZXJTZXF1ZW5jZTtcbiAgICB9XG5cbiAgICAvLyBMb29rIHRocm91Z2ggdGhlIHNlcXVlbmNlXG4gICAgdmFyIGRlbGltVHlwZSA9IHRyYXZlcnNlU2VxdWVuY2UoZGVsaW0sIGhlaWdodCwgc2VxdWVuY2UsIG9wdGlvbnMpO1xuXG4gICAgLy8gRGVwZW5kaW5nIG9uIHRoZSBzZXF1ZW5jZSBlbGVtZW50IHdlIGRlY2lkZWQgb24sIGNhbGwgdGhlIGFwcHJvcHJpYXRlXG4gICAgLy8gZnVuY3Rpb24uXG4gICAgaWYgKGRlbGltVHlwZS50eXBlID09PSBcInNtYWxsXCIpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VTbWFsbERlbGltKGRlbGltLCBkZWxpbVR5cGUuc3R5bGUsIGNlbnRlciwgb3B0aW9ucywgbW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMpO1xuICAgIH0gZWxzZSBpZiAoZGVsaW1UeXBlLnR5cGUgPT09IFwibGFyZ2VcIikge1xuICAgICAgICByZXR1cm4gbWFrZUxhcmdlRGVsaW0oZGVsaW0sIGRlbGltVHlwZS5zaXplLCBjZW50ZXIsIG9wdGlvbnMsIG1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzKTtcbiAgICB9IGVsc2UgaWYgKGRlbGltVHlwZS50eXBlID09PSBcInN0YWNrXCIpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VTdGFja2VkRGVsaW0oZGVsaW0sIGhlaWdodCwgY2VudGVyLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIE1ha2UgYSBkZWxpbWl0ZXIgZm9yIHVzZSB3aXRoIGBcXGxlZnRgIGFuZCBgXFxyaWdodGAsIGdpdmVuIGEgaGVpZ2h0IGFuZCBkZXB0aFxuICogb2YgYW4gZXhwcmVzc2lvbiB0aGF0IHRoZSBkZWxpbWl0ZXJzIHN1cnJvdW5kLlxuICovXG52YXIgbWFrZUxlZnRSaWdodERlbGltID0gZnVuY3Rpb24oZGVsaW0sIGhlaWdodCwgZGVwdGgsIG9wdGlvbnMsIG1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcykge1xuICAgIC8vIFdlIGFsd2F5cyBjZW50ZXIgXFxsZWZ0L1xccmlnaHQgZGVsaW1pdGVycywgc28gdGhlIGF4aXMgaXMgYWx3YXlzIHNoaWZ0ZWRcbiAgICB2YXIgYXhpc0hlaWdodCA9XG4gICAgICAgIG9wdGlvbnMuc3R5bGUubWV0cmljcy5heGlzSGVpZ2h0ICogb3B0aW9ucy5zdHlsZS5zaXplTXVsdGlwbGllcjtcblxuICAgIC8vIFRha2VuIGZyb20gVGVYIHNvdXJjZSwgdGV4LndlYiwgZnVuY3Rpb24gbWFrZV9sZWZ0X3JpZ2h0XG4gICAgdmFyIGRlbGltaXRlckZhY3RvciA9IDkwMTtcbiAgICB2YXIgZGVsaW1pdGVyRXh0ZW5kID0gNS4wIC8gZm9udE1ldHJpY3MubWV0cmljcy5wdFBlckVtO1xuXG4gICAgdmFyIG1heERpc3RGcm9tQXhpcyA9IE1hdGgubWF4KFxuICAgICAgICBoZWlnaHQgLSBheGlzSGVpZ2h0LCBkZXB0aCArIGF4aXNIZWlnaHQpO1xuXG4gICAgdmFyIHRvdGFsSGVpZ2h0ID0gTWF0aC5tYXgoXG4gICAgICAgIC8vIEluIHJlYWwgVGVYLCBjYWxjdWxhdGlvbnMgYXJlIGRvbmUgdXNpbmcgaW50ZWdyYWwgdmFsdWVzIHdoaWNoIGFyZVxuICAgICAgICAvLyA2NTUzNiBwZXIgcHQsIG9yIDY1NTM2MCBwZXIgZW0uIFNvLCB0aGUgZGl2aXNpb24gaGVyZSB0cnVuY2F0ZXMgaW5cbiAgICAgICAgLy8gVGVYIGJ1dCBkb2Vzbid0IGhlcmUsIHByb2R1Y2luZyBkaWZmZXJlbnQgcmVzdWx0cy4gSWYgd2Ugd2FudGVkIHRvXG4gICAgICAgIC8vIGV4YWN0bHkgbWF0Y2ggVGVYJ3MgY2FsY3VsYXRpb24sIHdlIGNvdWxkIGRvXG4gICAgICAgIC8vICAgTWF0aC5mbG9vcig2NTUzNjAgKiBtYXhEaXN0RnJvbUF4aXMgLyA1MDApICpcbiAgICAgICAgLy8gICAgZGVsaW1pdGVyRmFjdG9yIC8gNjU1MzYwXG4gICAgICAgIC8vIChUbyBzZWUgdGhlIGRpZmZlcmVuY2UsIGNvbXBhcmVcbiAgICAgICAgLy8gICAgeF57eF57XFxsZWZ0KFxccnVsZXswLjFlbX17MC42OGVtfVxccmlnaHQpfX1cbiAgICAgICAgLy8gaW4gVGVYIGFuZCBLYVRlWClcbiAgICAgICAgbWF4RGlzdEZyb21BeGlzIC8gNTAwICogZGVsaW1pdGVyRmFjdG9yLFxuICAgICAgICAyICogbWF4RGlzdEZyb21BeGlzIC0gZGVsaW1pdGVyRXh0ZW5kKTtcblxuICAgIC8vIEZpbmFsbHksIHdlIGRlZmVyIHRvIGBtYWtlQ3VzdG9tU2l6ZWREZWxpbWAgd2l0aCBvdXIgY2FsY3VsYXRlZCB0b3RhbFxuICAgIC8vIGhlaWdodFxuICAgIHJldHVybiBtYWtlQ3VzdG9tU2l6ZWREZWxpbShkZWxpbSwgdG90YWxIZWlnaHQsIHRydWUsIG9wdGlvbnMsIG1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc2l6ZWREZWxpbTogbWFrZVNpemVkRGVsaW0sXG4gICAgY3VzdG9tU2l6ZWREZWxpbTogbWFrZUN1c3RvbVNpemVkRGVsaW0sXG4gICAgbGVmdFJpZ2h0RGVsaW06IG1ha2VMZWZ0UmlnaHREZWxpbVxufTtcbiIsIi8qKlxuICogVGhlc2Ugb2JqZWN0cyBzdG9yZSB0aGUgZGF0YSBhYm91dCB0aGUgRE9NIG5vZGVzIHdlIGNyZWF0ZSwgYXMgd2VsbCBhcyBzb21lXG4gKiBleHRyYSBkYXRhLiBUaGV5IGNhbiB0aGVuIGJlIHRyYW5zZm9ybWVkIGludG8gcmVhbCBET00gbm9kZXMgd2l0aCB0aGVcbiAqIGB0b05vZGVgIGZ1bmN0aW9uIG9yIEhUTUwgbWFya3VwIHVzaW5nIGB0b01hcmt1cGAuIFRoZXkgYXJlIHVzZWZ1bCBmb3IgYm90aFxuICogc3RvcmluZyBleHRyYSBwcm9wZXJ0aWVzIG9uIHRoZSBub2RlcywgYXMgd2VsbCBhcyBwcm92aWRpbmcgYSB3YXkgdG8gZWFzaWx5XG4gKiB3b3JrIHdpdGggdGhlIERPTS5cbiAqXG4gKiBTaW1pbGFyIGZ1bmN0aW9ucyBmb3Igd29ya2luZyB3aXRoIE1hdGhNTCBub2RlcyBleGlzdCBpbiBtYXRoTUxUcmVlLmpzLlxuICovXG52YXIgdW5pY29kZVJlZ2V4ZXMgPSByZXF1aXJlKFwiLi91bmljb2RlUmVnZXhlc1wiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBIVE1MIGNsYXNzTmFtZSBiYXNlZCBvbiBhIGxpc3Qgb2YgY2xhc3Nlcy4gSW4gYWRkaXRpb24gdG8gam9pbmluZ1xuICogd2l0aCBzcGFjZXMsIHdlIGFsc28gcmVtb3ZlIG51bGwgb3IgZW1wdHkgY2xhc3Nlcy5cbiAqL1xudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24oY2xhc3Nlcykge1xuICAgIGNsYXNzZXMgPSBjbGFzc2VzLnNsaWNlKCk7XG4gICAgZm9yICh2YXIgaSA9IGNsYXNzZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKCFjbGFzc2VzW2ldKSB7XG4gICAgICAgICAgICBjbGFzc2VzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbGFzc2VzLmpvaW4oXCIgXCIpO1xufTtcblxuLyoqXG4gKiBUaGlzIG5vZGUgcmVwcmVzZW50cyBhIHNwYW4gbm9kZSwgd2l0aCBhIGNsYXNzTmFtZSwgYSBsaXN0IG9mIGNoaWxkcmVuLCBhbmRcbiAqIGFuIGlubGluZSBzdHlsZS4gSXQgYWxzbyBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCBpdHMgaGVpZ2h0LCBkZXB0aCwgYW5kXG4gKiBtYXhGb250U2l6ZS5cbiAqL1xuZnVuY3Rpb24gc3BhbihjbGFzc2VzLCBjaGlsZHJlbiwgb3B0aW9ucykge1xuICAgIHRoaXMuY2xhc3NlcyA9IGNsYXNzZXMgfHwgW107XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuIHx8IFtdO1xuICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICB0aGlzLmRlcHRoID0gMDtcbiAgICB0aGlzLm1heEZvbnRTaXplID0gMDtcbiAgICB0aGlzLnN0eWxlID0ge307XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3R5bGUuaXNUaWdodCgpKSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzZXMucHVzaChcIm10aWdodFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5nZXRDb2xvcigpKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLmNvbG9yID0gb3B0aW9ucy5nZXRDb2xvcigpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFNldHMgYW4gYXJiaXRyYXJ5IGF0dHJpYnV0ZSBvbiB0aGUgc3Bhbi4gV2FybmluZzogdXNlIHRoaXMgd2lzZWx5LiBOb3QgYWxsXG4gKiBicm93c2VycyBzdXBwb3J0IGF0dHJpYnV0ZXMgdGhlIHNhbWUsIGFuZCBoYXZpbmcgdG9vIG1hbnkgY3VzdG9tIGF0dHJpYnV0ZXNcbiAqIGlzIHByb2JhYmx5IGJhZC5cbiAqL1xuc3Bhbi5wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24oYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGVdID0gdmFsdWU7XG59O1xuXG5zcGFuLnByb3RvdHlwZS50cnlDb21iaW5lID0gZnVuY3Rpb24oc2libGluZykge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgc3BhbiBpbnRvIGFuIEhUTUwgbm9kZVxuICovXG5zcGFuLnByb3RvdHlwZS50b05vZGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuXG4gICAgLy8gQXBwbHkgdGhlIGNsYXNzXG4gICAgc3Bhbi5jbGFzc05hbWUgPSBjcmVhdGVDbGFzcyh0aGlzLmNsYXNzZXMpO1xuXG4gICAgLy8gQXBwbHkgaW5saW5lIHN0eWxlc1xuICAgIGZvciAodmFyIHN0eWxlIGluIHRoaXMuc3R5bGUpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnN0eWxlLCBzdHlsZSkpIHtcbiAgICAgICAgICAgIHNwYW4uc3R5bGVbc3R5bGVdID0gdGhpcy5zdHlsZVtzdHlsZV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBcHBseSBhdHRyaWJ1dGVzXG4gICAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQXBwZW5kIHRoZSBjaGlsZHJlbiwgYWxzbyBhcyBIVE1MIG5vZGVzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQodGhpcy5jaGlsZHJlbltpXS50b05vZGUoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNwYW47XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIHNwYW4gaW50byBhbiBIVE1MIG1hcmt1cCBzdHJpbmdcbiAqL1xuc3Bhbi5wcm90b3R5cGUudG9NYXJrdXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbWFya3VwID0gXCI8c3BhblwiO1xuXG4gICAgLy8gQWRkIHRoZSBjbGFzc1xuICAgIGlmICh0aGlzLmNsYXNzZXMubGVuZ3RoKSB7XG4gICAgICAgIG1hcmt1cCArPSBcIiBjbGFzcz1cXFwiXCI7XG4gICAgICAgIG1hcmt1cCArPSB1dGlscy5lc2NhcGUoY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKSk7XG4gICAgICAgIG1hcmt1cCArPSBcIlxcXCJcIjtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGVzID0gXCJcIjtcblxuICAgIC8vIEFkZCB0aGUgc3R5bGVzLCBhZnRlciBoeXBoZW5hdGlvblxuICAgIGZvciAodmFyIHN0eWxlIGluIHRoaXMuc3R5bGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICAgICAgICBzdHlsZXMgKz0gdXRpbHMuaHlwaGVuYXRlKHN0eWxlKSArIFwiOlwiICsgdGhpcy5zdHlsZVtzdHlsZV0gKyBcIjtcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHlsZXMpIHtcbiAgICAgICAgbWFya3VwICs9IFwiIHN0eWxlPVxcXCJcIiArIHV0aWxzLmVzY2FwZShzdHlsZXMpICsgXCJcXFwiXCI7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBhdHRyaWJ1dGVzXG4gICAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgICAgICBtYXJrdXAgKz0gXCIgXCIgKyBhdHRyICsgXCI9XFxcIlwiO1xuICAgICAgICAgICAgbWFya3VwICs9IHV0aWxzLmVzY2FwZSh0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgICAgICAgbWFya3VwICs9IFwiXFxcIlwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbWFya3VwICs9IFwiPlwiO1xuXG4gICAgLy8gQWRkIHRoZSBtYXJrdXAgb2YgdGhlIGNoaWxkcmVuLCBhbHNvIGFzIG1hcmt1cFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXJrdXAgKz0gdGhpcy5jaGlsZHJlbltpXS50b01hcmt1cCgpO1xuICAgIH1cblxuICAgIG1hcmt1cCArPSBcIjwvc3Bhbj5cIjtcblxuICAgIHJldHVybiBtYXJrdXA7XG59O1xuXG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgZG9jdW1lbnQgZnJhZ21lbnQsIHdoaWNoIGNvbnRhaW5zIGVsZW1lbnRzLCBidXQgd2hlblxuICogcGxhY2VkIGludG8gdGhlIERPTSBkb2Vzbid0IGhhdmUgYW55IHJlcHJlc2VudGF0aW9uIGl0c2VsZi4gVGh1cywgaXQgb25seVxuICogY29udGFpbnMgY2hpbGRyZW4gYW5kIGRvZXNuJ3QgaGF2ZSBhbnkgSFRNTCBwcm9wZXJ0aWVzLiBJdCBhbHNvIGtlZXBzIHRyYWNrXG4gKiBvZiBhIGhlaWdodCwgZGVwdGgsIGFuZCBtYXhGb250U2l6ZS5cbiAqL1xuZnVuY3Rpb24gZG9jdW1lbnRGcmFnbWVudChjaGlsZHJlbikge1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCBbXTtcbiAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgdGhpcy5kZXB0aCA9IDA7XG4gICAgdGhpcy5tYXhGb250U2l6ZSA9IDA7XG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgZnJhZ21lbnQgaW50byBhIG5vZGVcbiAqL1xuZG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUudG9Ob2RlID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gQ3JlYXRlIGEgZnJhZ21lbnRcbiAgICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIC8vIEFwcGVuZCB0aGUgY2hpbGRyZW5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZnJhZy5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkcmVuW2ldLnRvTm9kZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnJhZztcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgZnJhZ21lbnQgaW50byBIVE1MIG1hcmt1cFxuICovXG5kb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZS50b01hcmt1cCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtYXJrdXAgPSBcIlwiO1xuXG4gICAgLy8gU2ltcGx5IGNvbmNhdGVuYXRlIHRoZSBtYXJrdXAgZm9yIHRoZSBjaGlsZHJlbiB0b2dldGhlclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXJrdXAgKz0gdGhpcy5jaGlsZHJlbltpXS50b01hcmt1cCgpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXJrdXA7XG59O1xuXG52YXIgaUNvbWJpbmF0aW9ucyA9IHtcbiAgICAnw64nOiAnXFx1MDEzMVxcdTAzMDInLFxuICAgICfDryc6ICdcXHUwMTMxXFx1MDMwOCcsXG4gICAgJ8OtJzogJ1xcdTAxMzFcXHUwMzAxJyxcbiAgICAvLyAnxKsnOiAnXFx1MDEzMVxcdTAzMDQnLCAvLyBlbmFibGUgd2hlbiB3ZSBhZGQgRXh0ZW5kZWQgTGF0aW5cbiAgICAnw6wnOiAnXFx1MDEzMVxcdTAzMDAnXG59O1xuXG4vKipcbiAqIEEgc3ltYm9sIG5vZGUgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgYSBzaW5nbGUgc3ltYm9sLiBJdCBlaXRoZXIgcmVuZGVyc1xuICogdG8gYSBzaW5nbGUgdGV4dCBub2RlLCBvciBhIHNwYW4gd2l0aCBhIHNpbmdsZSB0ZXh0IG5vZGUgaW4gaXQsIGRlcGVuZGluZyBvblxuICogd2hldGhlciBpdCBoYXMgQ1NTIGNsYXNzZXMsIHN0eWxlcywgb3IgbmVlZHMgaXRhbGljIGNvcnJlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHN5bWJvbE5vZGUodmFsdWUsIGhlaWdodCwgZGVwdGgsIGl0YWxpYywgc2tldywgY2xhc3Nlcywgc3R5bGUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWUgfHwgXCJcIjtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCAwO1xuICAgIHRoaXMuZGVwdGggPSBkZXB0aCB8fCAwO1xuICAgIHRoaXMuaXRhbGljID0gaXRhbGljIHx8IDA7XG4gICAgdGhpcy5za2V3ID0gc2tldyB8fCAwO1xuICAgIHRoaXMuY2xhc3NlcyA9IGNsYXNzZXMgfHwgW107XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlIHx8IHt9O1xuICAgIHRoaXMubWF4Rm9udFNpemUgPSAwO1xuXG4gICAgLy8gTWFyayBDSksgY2hhcmFjdGVycyB3aXRoIHNwZWNpZmljIGNsYXNzZXMgc28gdGhhdCB3ZSBjYW4gc3BlY2lmeSB3aGljaFxuICAgIC8vIGZvbnRzIHRvIHVzZS4gIFRoaXMgYWxsb3dzIHVzIHRvIHJlbmRlciB0aGVzZSBjaGFyYWN0ZXJzIHdpdGggYSBzZXJpZlxuICAgIC8vIGZvbnQgaW4gc2l0dWF0aW9ucyB3aGVyZSB0aGUgYnJvd3NlciB3b3VsZCBlaXRoZXIgZGVmYXVsdCB0byBhIHNhbnMgc2VyaWZcbiAgICAvLyBvciByZW5kZXIgYSBwbGFjZWhvbGRlciBjaGFyYWN0ZXIuXG4gICAgaWYgKHVuaWNvZGVSZWdleGVzLmNqa1JlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgIC8vIEkgY291bGRuJ3QgZmluZCBhbnkgZm9udHMgdGhhdCBjb250YWluZWQgSGFuZ3VsIGFzIHdlbGwgYXMgYWxsIG9mXG4gICAgICAgIC8vIHRoZSBvdGhlciBjaGFyYWN0ZXJzIHdlIHdhbnRlZCB0byB0ZXN0IHRoZXJlIGZvciBpdCBnZXRzIGl0cyBvd25cbiAgICAgICAgLy8gQ1NTIGNsYXNzLlxuICAgICAgICBpZiAodW5pY29kZVJlZ2V4ZXMuaGFuZ3VsUmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3Nlcy5wdXNoKCdoYW5ndWxfZmFsbGJhY2snKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3Nlcy5wdXNoKCdjamtfZmFsbGJhY2snKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICgvW8Ouw6/DrcOsXS8udGVzdCh0aGlzLnZhbHVlKSkgeyAgICAvLyBhZGQgxKsgd2hlbiB3ZSBhZGQgRXh0ZW5kZWQgTGF0aW5cbiAgICAgICAgdGhpcy52YWx1ZSA9IGlDb21iaW5hdGlvbnNbdGhpcy52YWx1ZV07XG4gICAgfVxufVxuXG5zeW1ib2xOb2RlLnByb3RvdHlwZS50cnlDb21iaW5lID0gZnVuY3Rpb24oc2libGluZykge1xuICAgIGlmICghc2libGluZ1xuICAgICAgICB8fCAhKHNpYmxpbmcgaW5zdGFuY2VvZiBzeW1ib2xOb2RlKVxuICAgICAgICB8fCB0aGlzLml0YWxpYyA+IDBcbiAgICAgICAgfHwgY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKSAhPT0gY3JlYXRlQ2xhc3Moc2libGluZy5jbGFzc2VzKVxuICAgICAgICB8fCB0aGlzLnNrZXcgIT09IHNpYmxpbmcuc2tld1xuICAgICAgICB8fCB0aGlzLm1heEZvbnRTaXplICE9PSBzaWJsaW5nLm1heEZvbnRTaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgc3R5bGUgaW4gdGhpcy5zdHlsZSkge1xuICAgICAgICBpZiAodGhpcy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSlcbiAgICAgICAgICAgICYmIHRoaXMuc3R5bGVbc3R5bGVdICE9PSBzaWJsaW5nLnN0eWxlW3N0eWxlXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoc3R5bGUgaW4gc2libGluZy5zdHlsZSkge1xuICAgICAgICBpZiAoc2libGluZy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSlcbiAgICAgICAgICAgICYmIHRoaXMuc3R5bGVbc3R5bGVdICE9PSBzaWJsaW5nLnN0eWxlW3N0eWxlXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMudmFsdWUgKz0gc2libGluZy52YWx1ZTtcbiAgICB0aGlzLmhlaWdodCA9IE1hdGgubWF4KHRoaXMuaGVpZ2h0LCBzaWJsaW5nLmhlaWdodCk7XG4gICAgdGhpcy5kZXB0aCA9IE1hdGgubWF4KHRoaXMuZGVwdGgsIHNpYmxpbmcuZGVwdGgpO1xuICAgIHRoaXMuaXRhbGljID0gc2libGluZy5pdGFsaWM7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0ZXh0IG5vZGUgb3Igc3BhbiBmcm9tIGEgc3ltYm9sIG5vZGUuIE5vdGUgdGhhdCBhIHNwYW4gaXMgb25seVxuICogY3JlYXRlZCBpZiBpdCBpcyBuZWVkZWQuXG4gKi9cbnN5bWJvbE5vZGUucHJvdG90eXBlLnRvTm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy52YWx1ZSk7XG4gICAgdmFyIHNwYW4gPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuaXRhbGljID4gMCkge1xuICAgICAgICBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHNwYW4uc3R5bGUubWFyZ2luUmlnaHQgPSB0aGlzLml0YWxpYyArIFwiZW1cIjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jbGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3BhbiA9IHNwYW4gfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHNwYW4uY2xhc3NOYW1lID0gY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlKSkge1xuICAgICAgICAgICAgc3BhbiA9IHNwYW4gfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICBzcGFuLnN0eWxlW3N0eWxlXSA9IHRoaXMuc3R5bGVbc3R5bGVdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNwYW4pIHtcbiAgICAgICAgc3Bhbi5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIG1hcmt1cCBmb3IgYSBzeW1ib2wgbm9kZS5cbiAqL1xuc3ltYm9sTm9kZS5wcm90b3R5cGUudG9NYXJrdXAgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBUT0RPKGFscGVydCk6IE1vcmUgZHVwbGljYXRpb24gdGhhbiBJJ2QgbGlrZSBmcm9tXG4gICAgLy8gc3Bhbi5wcm90b3R5cGUudG9NYXJrdXAgYW5kIHN5bWJvbE5vZGUucHJvdG90eXBlLnRvTm9kZS4uLlxuICAgIHZhciBuZWVkc1NwYW4gPSBmYWxzZTtcblxuICAgIHZhciBtYXJrdXAgPSBcIjxzcGFuXCI7XG5cbiAgICBpZiAodGhpcy5jbGFzc2VzLmxlbmd0aCkge1xuICAgICAgICBuZWVkc1NwYW4gPSB0cnVlO1xuICAgICAgICBtYXJrdXAgKz0gXCIgY2xhc3M9XFxcIlwiO1xuICAgICAgICBtYXJrdXAgKz0gdXRpbHMuZXNjYXBlKGNyZWF0ZUNsYXNzKHRoaXMuY2xhc3NlcykpO1xuICAgICAgICBtYXJrdXAgKz0gXCJcXFwiXCI7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlcyA9IFwiXCI7XG5cbiAgICBpZiAodGhpcy5pdGFsaWMgPiAwKSB7XG4gICAgICAgIHN0eWxlcyArPSBcIm1hcmdpbi1yaWdodDpcIiArIHRoaXMuaXRhbGljICsgXCJlbTtcIjtcbiAgICB9XG4gICAgZm9yICh2YXIgc3R5bGUgaW4gdGhpcy5zdHlsZSkge1xuICAgICAgICBpZiAodGhpcy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcbiAgICAgICAgICAgIHN0eWxlcyArPSB1dGlscy5oeXBoZW5hdGUoc3R5bGUpICsgXCI6XCIgKyB0aGlzLnN0eWxlW3N0eWxlXSArIFwiO1wiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlcykge1xuICAgICAgICBuZWVkc1NwYW4gPSB0cnVlO1xuICAgICAgICBtYXJrdXAgKz0gXCIgc3R5bGU9XFxcIlwiICsgdXRpbHMuZXNjYXBlKHN0eWxlcykgKyBcIlxcXCJcIjtcbiAgICB9XG5cbiAgICB2YXIgZXNjYXBlZCA9IHV0aWxzLmVzY2FwZSh0aGlzLnZhbHVlKTtcbiAgICBpZiAobmVlZHNTcGFuKSB7XG4gICAgICAgIG1hcmt1cCArPSBcIj5cIjtcbiAgICAgICAgbWFya3VwICs9IGVzY2FwZWQ7XG4gICAgICAgIG1hcmt1cCArPSBcIjwvc3Bhbj5cIjtcbiAgICAgICAgcmV0dXJuIG1hcmt1cDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZXNjYXBlZDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBzcGFuOiBzcGFuLFxuICAgIGRvY3VtZW50RnJhZ21lbnQ6IGRvY3VtZW50RnJhZ21lbnQsXG4gICAgc3ltYm9sTm9kZTogc3ltYm9sTm9kZVxufTtcbiIsIi8qIGVzbGludCBuby1jb25zdGFudC1jb25kaXRpb246MCAqL1xudmFyIHBhcnNlRGF0YSA9IHJlcXVpcmUoXCIuL3BhcnNlRGF0YVwiKTtcbnZhciBQYXJzZUVycm9yID0gcmVxdWlyZShcIi4vUGFyc2VFcnJvclwiKTtcbnZhciBTdHlsZSA9IHJlcXVpcmUoXCIuL1N0eWxlXCIpO1xuXG52YXIgUGFyc2VOb2RlID0gcGFyc2VEYXRhLlBhcnNlTm9kZTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgYm9keSBvZiB0aGUgZW52aXJvbm1lbnQsIHdpdGggcm93cyBkZWxpbWl0ZWQgYnkgXFxcXCBhbmRcbiAqIGNvbHVtbnMgZGVsaW1pdGVkIGJ5ICYsIGFuZCBjcmVhdGUgYSBuZXN0ZWQgbGlzdCBpbiByb3ctbWFqb3Igb3JkZXJcbiAqIHdpdGggb25lIGdyb3VwIHBlciBjZWxsLlxuICovXG5mdW5jdGlvbiBwYXJzZUFycmF5KHBhcnNlciwgcmVzdWx0KSB7XG4gICAgdmFyIHJvdyA9IFtdO1xuICAgIHZhciBib2R5ID0gW3Jvd107XG4gICAgdmFyIHJvd0dhcHMgPSBbXTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgY2VsbCA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIG51bGwpO1xuICAgICAgICByb3cucHVzaChuZXcgUGFyc2VOb2RlKFwib3JkZ3JvdXBcIiwgY2VsbCwgcGFyc2VyLm1vZGUpKTtcbiAgICAgICAgdmFyIG5leHQgPSBwYXJzZXIubmV4dFRva2VuLnRleHQ7XG4gICAgICAgIGlmIChuZXh0ID09PSBcIiZcIikge1xuICAgICAgICAgICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0ID09PSBcIlxcXFxlbmRcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gXCJcXFxcXFxcXFwiIHx8IG5leHQgPT09IFwiXFxcXGNyXCIpIHtcbiAgICAgICAgICAgIHZhciBjciA9IHBhcnNlci5wYXJzZUZ1bmN0aW9uKCk7XG4gICAgICAgICAgICByb3dHYXBzLnB1c2goY3IudmFsdWUuc2l6ZSk7XG4gICAgICAgICAgICByb3cgPSBbXTtcbiAgICAgICAgICAgIGJvZHkucHVzaChyb3cpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJFeHBlY3RlZCAmIG9yIFxcXFxcXFxcIG9yIFxcXFxlbmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5uZXh0VG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5ib2R5ID0gYm9keTtcbiAgICByZXN1bHQucm93R2FwcyA9IHJvd0dhcHM7XG4gICAgcmV0dXJuIG5ldyBQYXJzZU5vZGUocmVzdWx0LnR5cGUsIHJlc3VsdCwgcGFyc2VyLm1vZGUpO1xufVxuXG4vKlxuICogQW4gZW52aXJvbm1lbnQgZGVmaW5pdGlvbiBpcyB2ZXJ5IHNpbWlsYXIgdG8gYSBmdW5jdGlvbiBkZWZpbml0aW9uOlxuICogaXQgaXMgZGVjbGFyZWQgd2l0aCBhIG5hbWUgb3IgYSBsaXN0IG9mIG5hbWVzLCBhIHNldCBvZiBwcm9wZXJ0aWVzXG4gKiBhbmQgYSBoYW5kbGVyIGNvbnRhaW5pbmcgdGhlIGFjdHVhbCBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBUaGUgcHJvcGVydGllcyBpbmNsdWRlOlxuICogIC0gbnVtQXJnczogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgYWZ0ZXIgdGhlIFxcYmVnaW57bmFtZX0gZnVuY3Rpb24uXG4gKiAgLSBhcmdUeXBlczogKG9wdGlvbmFsKSBKdXN0IGxpa2UgZm9yIGEgZnVuY3Rpb25cbiAqICAtIGFsbG93ZWRJblRleHQ6IChvcHRpb25hbCkgV2hldGhlciBvciBub3QgdGhlIGVudmlyb25tZW50IGlzIGFsbG93ZWQgaW5zaWRlXG4gKiAgICAgICAgICAgICAgICAgICB0ZXh0IG1vZGUgKGRlZmF1bHQgZmFsc2UpIChub3QgZW5mb3JjZWQgeWV0KVxuICogIC0gbnVtT3B0aW9uYWxBcmdzOiAob3B0aW9uYWwpIEp1c3QgbGlrZSBmb3IgYSBmdW5jdGlvblxuICogQSBiYXJlIG51bWJlciBpbnN0ZWFkIG9mIHRoYXQgb2JqZWN0IGluZGljYXRlcyB0aGUgbnVtQXJncyB2YWx1ZS5cbiAqXG4gKiBUaGUgaGFuZGxlciBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgdHdvIGFyZ3VtZW50c1xuICogIC0gY29udGV4dDogaW5mb3JtYXRpb24gYW5kIHJlZmVyZW5jZXMgcHJvdmlkZWQgYnkgdGhlIHBhcnNlclxuICogIC0gYXJnczogYW4gYXJyYXkgb2YgYXJndW1lbnRzIHBhc3NlZCB0byBcXGJlZ2lue25hbWV9XG4gKiBUaGUgY29udGV4dCBjb250YWlucyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiAgLSBlbnZOYW1lOiB0aGUgbmFtZSBvZiB0aGUgZW52aXJvbm1lbnQsIG9uZSBvZiB0aGUgbGlzdGVkIG5hbWVzLlxuICogIC0gcGFyc2VyOiB0aGUgcGFyc2VyIG9iamVjdFxuICogIC0gbGV4ZXI6IHRoZSBsZXhlciBvYmplY3RcbiAqICAtIHBvc2l0aW9uczogdGhlIHBvc2l0aW9ucyBhc3NvY2lhdGVkIHdpdGggdGhlc2UgYXJndW1lbnRzIGZyb20gYXJncy5cbiAqIFRoZSBoYW5kbGVyIG11c3QgcmV0dXJuIGEgUGFyc2VSZXN1bHQuXG4gKi9cblxuZnVuY3Rpb24gZGVmaW5lRW52aXJvbm1lbnQobmFtZXMsIHByb3BzLCBoYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBuYW1lcyA9IFtuYW1lc107XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvcHMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcHJvcHMgPSB7IG51bUFyZ3M6IHByb3BzIH07XG4gICAgfVxuICAgIC8vIFNldCBkZWZhdWx0IHZhbHVlcyBvZiBlbnZpcm9ubWVudHNcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgbnVtQXJnczogcHJvcHMubnVtQXJncyB8fCAwLFxuICAgICAgICBhcmdUeXBlczogcHJvcHMuYXJnVHlwZXMsXG4gICAgICAgIGdyZWVkaW5lc3M6IDEsXG4gICAgICAgIGFsbG93ZWRJblRleHQ6ICEhcHJvcHMuYWxsb3dlZEluVGV4dCxcbiAgICAgICAgbnVtT3B0aW9uYWxBcmdzOiBwcm9wcy5udW1PcHRpb25hbEFyZ3MgfHwgMCxcbiAgICAgICAgaGFuZGxlcjogaGFuZGxlclxuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBtb2R1bGUuZXhwb3J0c1tuYW1lc1tpXV0gPSBkYXRhO1xuICAgIH1cbn1cblxuLy8gQXJyYXlzIGFyZSBwYXJ0IG9mIExhVGVYLCBkZWZpbmVkIGluIGx0dGFiLmR0eCBzbyBpdHMgZG9jdW1lbnRhdGlvblxuLy8gaXMgcGFydCBvZiB0aGUgc291cmNlMmUucGRmIGZpbGUgb2YgTGFUZVgyZSBzb3VyY2UgZG9jdW1lbnRhdGlvbi5cbmRlZmluZUVudmlyb25tZW50KFwiYXJyYXlcIiwge1xuICAgIG51bUFyZ3M6IDFcbn0sIGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB2YXIgY29sYWxpZ24gPSBhcmdzWzBdO1xuICAgIGNvbGFsaWduID0gY29sYWxpZ24udmFsdWUubWFwID8gY29sYWxpZ24udmFsdWUgOiBbY29sYWxpZ25dO1xuICAgIHZhciBjb2xzID0gY29sYWxpZ24ubWFwKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIGNhID0gbm9kZS52YWx1ZTtcbiAgICAgICAgaWYgKFwibGNyXCIuaW5kZXhPZihjYSkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICAgICAgICAgICAgICBhbGlnbjogY2FcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoY2EgPT09IFwifFwiKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic2VwYXJhdG9yXCIsXG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yOiBcInxcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgIFwiVW5rbm93biBjb2x1bW4gYWxpZ25tZW50OiBcIiArIG5vZGUudmFsdWUsXG4gICAgICAgICAgICBub2RlKTtcbiAgICB9KTtcbiAgICB2YXIgcmVzID0ge1xuICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgIGNvbHM6IGNvbHMsXG4gICAgICAgIGhza2lwQmVmb3JlQW5kQWZ0ZXI6IHRydWUgLy8gXFxAcHJlYW1ibGUgaW4gbHR0YWIuZHR4XG4gICAgfTtcbiAgICByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMpO1xuICAgIHJldHVybiByZXM7XG59KTtcblxuLy8gVGhlIG1hdHJpeCBlbnZpcm9ubWVudHMgb2YgYW1zbWF0aCBidWlsZHMgb24gdGhlIGFycmF5IGVudmlyb25tZW50XG4vLyBvZiBMYVRlWCwgd2hpY2ggaXMgZGlzY3Vzc2VkIGFib3ZlLlxuZGVmaW5lRW52aXJvbm1lbnQoW1xuICAgIFwibWF0cml4XCIsXG4gICAgXCJwbWF0cml4XCIsXG4gICAgXCJibWF0cml4XCIsXG4gICAgXCJCbWF0cml4XCIsXG4gICAgXCJ2bWF0cml4XCIsXG4gICAgXCJWbWF0cml4XCJcbl0sIHtcbn0sIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB2YXIgZGVsaW1pdGVycyA9IHtcbiAgICAgICAgXCJtYXRyaXhcIjogbnVsbCxcbiAgICAgICAgXCJwbWF0cml4XCI6IFtcIihcIiwgXCIpXCJdLFxuICAgICAgICBcImJtYXRyaXhcIjogW1wiW1wiLCBcIl1cIl0sXG4gICAgICAgIFwiQm1hdHJpeFwiOiBbXCJcXFxce1wiLCBcIlxcXFx9XCJdLFxuICAgICAgICBcInZtYXRyaXhcIjogW1wifFwiLCBcInxcIl0sXG4gICAgICAgIFwiVm1hdHJpeFwiOiBbXCJcXFxcVmVydFwiLCBcIlxcXFxWZXJ0XCJdXG4gICAgfVtjb250ZXh0LmVudk5hbWVdO1xuICAgIHZhciByZXMgPSB7XG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgaHNraXBCZWZvcmVBbmRBZnRlcjogZmFsc2UgLy8gXFxoc2tpcCAtXFxhcnJheWNvbHNlcCBpbiBhbXNtYXRoXG4gICAgfTtcbiAgICByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMpO1xuICAgIGlmIChkZWxpbWl0ZXJzKSB7XG4gICAgICAgIHJlcyA9IG5ldyBQYXJzZU5vZGUoXCJsZWZ0cmlnaHRcIiwge1xuICAgICAgICAgICAgYm9keTogW3Jlc10sXG4gICAgICAgICAgICBsZWZ0OiBkZWxpbWl0ZXJzWzBdLFxuICAgICAgICAgICAgcmlnaHQ6IGRlbGltaXRlcnNbMV1cbiAgICAgICAgfSwgY29udGV4dC5tb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn0pO1xuXG4vLyBBIGNhc2VzIGVudmlyb25tZW50IChpbiBhbXNtYXRoLnN0eSkgaXMgYWxtb3N0IGVxdWl2YWxlbnQgdG9cbi8vIFxcZGVmXFxhcnJheXN0cmV0Y2h7MS4yfSVcbi8vIFxcbGVmdFxce1xcYmVnaW57YXJyYXl9e0B7fWxAe1xccXVhZH1sQHt9fSDigKYgXFxlbmR7YXJyYXl9XFxyaWdodC5cbmRlZmluZUVudmlyb25tZW50KFwiY2FzZXNcIiwge1xufSwgZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHZhciByZXMgPSB7XG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgYXJyYXlzdHJldGNoOiAxLjIsXG4gICAgICAgIGNvbHM6IFt7XG4gICAgICAgICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICAgICAgICBhbGlnbjogXCJsXCIsXG4gICAgICAgICAgICBwcmVnYXA6IDAsXG4gICAgICAgICAgICAvLyBUT0RPKGtldmluYikgZ2V0IHRoZSBjdXJyZW50IHN0eWxlLlxuICAgICAgICAgICAgLy8gRm9yIG5vdyB3ZSB1c2UgdGhlIG1ldHJpY3MgZm9yIFRFWFQgc3R5bGUgd2hpY2ggaXMgd2hhdCB3ZSB3ZXJlXG4gICAgICAgICAgICAvLyBkb2luZyBiZWZvcmUuICBCZWZvcmUgYXR0ZW1wdGluZyB0byBnZXQgdGhlIGN1cnJlbnQgc3R5bGUgd2VcbiAgICAgICAgICAgIC8vIHNob3VsZCBsb29rIGF0IFRlWCdzIGJlaGF2aW9yIGVzcGVjaWFsbHkgZm9yIFxcb3ZlciBhbmQgbWF0cmljZXMuXG4gICAgICAgICAgICBwb3N0Z2FwOiBTdHlsZS5URVhULm1ldHJpY3MucXVhZFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICAgICAgICBhbGlnbjogXCJsXCIsXG4gICAgICAgICAgICBwcmVnYXA6IDAsXG4gICAgICAgICAgICBwb3N0Z2FwOiAwXG4gICAgICAgIH1dXG4gICAgfTtcbiAgICByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMpO1xuICAgIHJlcyA9IG5ldyBQYXJzZU5vZGUoXCJsZWZ0cmlnaHRcIiwge1xuICAgICAgICBib2R5OiBbcmVzXSxcbiAgICAgICAgbGVmdDogXCJcXFxce1wiLFxuICAgICAgICByaWdodDogXCIuXCJcbiAgICB9LCBjb250ZXh0Lm1vZGUpO1xuICAgIHJldHVybiByZXM7XG59KTtcblxuLy8gQW4gYWxpZ25lZCBlbnZpcm9ubWVudCBpcyBsaWtlIHRoZSBhbGlnbiogZW52aXJvbm1lbnRcbi8vIGV4Y2VwdCBpdCBvcGVyYXRlcyB3aXRoaW4gbWF0aCBtb2RlLlxuLy8gTm90ZSB0aGF0IHdlIGFzc3VtZSBcXG5vbWFsbGluZXNraXBsaW1pdCB0byBiZSB6ZXJvLFxuLy8gc28gdGhhdCBcXHN0cnV0QCBpcyB0aGUgc2FtZSBhcyBcXHN0cnV0LlxuZGVmaW5lRW52aXJvbm1lbnQoXCJhbGlnbmVkXCIsIHtcbn0sIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB2YXIgcmVzID0ge1xuICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgIGNvbHM6IFtdXG4gICAgfTtcbiAgICByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMpO1xuICAgIHZhciBlbXB0eUdyb3VwID0gbmV3IFBhcnNlTm9kZShcIm9yZGdyb3VwXCIsIFtdLCBjb250ZXh0Lm1vZGUpO1xuICAgIHZhciBudW1Db2xzID0gMDtcbiAgICByZXMudmFsdWUuYm9keS5mb3JFYWNoKGZ1bmN0aW9uKHJvdykge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHJvdy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgcm93W2ldLnZhbHVlLnVuc2hpZnQoZW1wdHlHcm91cCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bUNvbHMgPCByb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICBudW1Db2xzID0gcm93Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQ29sczsgKytpKSB7XG4gICAgICAgIHZhciBhbGlnbiA9IFwiclwiO1xuICAgICAgICB2YXIgcHJlZ2FwID0gMDtcbiAgICAgICAgaWYgKGkgJSAyID09PSAxKSB7XG4gICAgICAgICAgICBhbGlnbiA9IFwibFwiO1xuICAgICAgICB9IGVsc2UgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBwcmVnYXAgPSAyOyAvLyBvbmUgXFxxcXVhZCBiZXR3ZWVuIGNvbHVtbnNcbiAgICAgICAgfVxuICAgICAgICByZXMudmFsdWUuY29sc1tpXSA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICAgICAgICAgIGFsaWduOiBhbGlnbixcbiAgICAgICAgICAgIHByZWdhcDogcHJlZ2FwLFxuICAgICAgICAgICAgcG9zdGdhcDogMFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufSk7XG4iLCIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6MCAqL1xuXG52YXIgU3R5bGUgPSByZXF1aXJlKFwiLi9TdHlsZVwiKTtcbnZhciBjamtSZWdleCA9IHJlcXVpcmUoXCIuL3VuaWNvZGVSZWdleGVzXCIpLmNqa1JlZ2V4O1xuXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyBtZXRyaWNzIHJlZ2FyZGluZyBmb250cyBhbmQgaW5kaXZpZHVhbCBzeW1ib2xzLiBUaGUgc2lnbWFcbiAqIGFuZCB4aSB2YXJpYWJsZXMsIGFzIHdlbGwgYXMgdGhlIG1ldHJpY01hcCBtYXAgY29udGFpbiBkYXRhIGV4dHJhY3RlZCBmcm9tXG4gKiBUZVgsIFRlWCBmb250IG1ldHJpY3MsIGFuZCB0aGUgVFRGIGZpbGVzLiBUaGVzZSBkYXRhIGFyZSB0aGVuIGV4cG9zZWQgdmlhIHRoZVxuICogYG1ldHJpY3NgIHZhcmlhYmxlIGFuZCB0aGUgZ2V0Q2hhcmFjdGVyTWV0cmljcyBmdW5jdGlvbi5cbiAqL1xuXG4vLyBJbiBUZVgsIHRoZXJlIGFyZSBhY3R1YWxseSB0aHJlZSBzZXRzIG9mIGRpbWVuc2lvbnMsIG9uZSBmb3IgZWFjaCBvZlxuLy8gdGV4dHN0eWxlLCBzY3JpcHRzdHlsZSwgYW5kIHNjcmlwdHNjcmlwdHN0eWxlLiAgVGhlc2UgYXJlIHByb3ZpZGVkIGluIHRoZVxuLy8gdGhlIGFycmF5cyBiZWxvdywgaW4gdGhhdCBvcmRlci5cbi8vXG4vLyBUaGUgZm9udCBtZXRyaWNzIGFyZSBzdG9yZWQgaW4gZm9udHMgY21zeTEwLCBjbXN5NywgYW5kIGNtc3k1IHJlc3BzZWN0aXZlbHkuXG4vLyBUaGlzIHdhcyBkZXRlcm1pbmVkIGJ5IHJ1bm5pbmcgdGhlIGZvbGxsb3dpbmcgc2NyaXB0OlxuLy9cbi8vICAgICBsYXRleCAtaW50ZXJhY3Rpb249bm9uc3RvcG1vZGUgXFxcbi8vICAgICAnXFxkb2N1bWVudGNsYXNze2FydGljbGV9XFx1c2VwYWNrYWdle2Ftc21hdGh9XFxiZWdpbntkb2N1bWVudH0nIFxcXG4vLyAgICAgJyRhJCBcXGV4cGFuZGFmdGVyXFxzaG93XFx0aGVcXHRleHRmb250MicgXFxcbi8vICAgICAnXFxleHBhbmRhZnRlclxcc2hvd1xcdGhlXFxzY3JpcHRmb250MicgXFxcbi8vICAgICAnXFxleHBhbmRhZnRlclxcc2hvd1xcdGhlXFxzY3JpcHRzY3JpcHRmb250MicgXFxcbi8vICAgICAnXFxzdG9wJ1xuLy9cbi8vIFRoZSBtZXRyaWNzIHRoZW1zZWx2ZXMgd2VyZSByZXRyZWl2ZWQgdXNpbmcgdGhlIGZvbGxvd2luZyBjb21tYW5kczpcbi8vXG4vLyAgICAgdGZ0b3BsIGNtc3kxMFxuLy8gICAgIHRmdG9wbCBjbXN5N1xuLy8gICAgIHRmdG9wbCBjbXN5NVxuLy9cbi8vIFRoZSBvdXRwdXQgb2YgZWFjaCBvZiB0aGVzZSBjb21tYW5kcyBpcyBxdWl0ZSBsZW5ndGh5LiAgVGhlIG9ubHkgcGFydCB3ZVxuLy8gY2FyZSBhYm91dCBpcyB0aGUgRk9OVERJTUVOIHNlY3Rpb24uIEVhY2ggdmFsdWUgaXMgbWVhc3VyZWQgaW4gRU1zLlxudmFyIHNpZ21hcyA9IHtcbiAgICBzbGFudDogWzAuMjUwLCAwLjI1MCwgMC4yNTBdLCAgICAgICAvLyBzaWdtYTFcbiAgICBzcGFjZTogWzAuMDAwLCAwLjAwMCwgMC4wMDBdLCAgICAgICAvLyBzaWdtYTJcbiAgICBzdHJldGNoOiBbMC4wMDAsIDAuMDAwLCAwLjAwMF0sICAgICAvLyBzaWdtYTNcbiAgICBzaHJpbms6IFswLjAwMCwgMC4wMDAsIDAuMDAwXSwgICAgICAvLyBzaWdtYTRcbiAgICB4SGVpZ2h0OiBbMC40MzEsIDAuNDMxLCAwLjQzMV0sICAgICAvLyBzaWdtYTVcbiAgICBxdWFkOiBbMS4wMDAsIDEuMTcxLCAxLjQ3Ml0sICAgICAgICAvLyBzaWdtYTZcbiAgICBleHRyYVNwYWNlOiBbMC4wMDAsIDAuMDAwLCAwLjAwMF0sICAvLyBzaWdtYTdcbiAgICBudW0xOiBbMC42NzcsIDAuNzMyLCAwLjkyNV0sICAgICAgICAvLyBzaWdtYThcbiAgICBudW0yOiBbMC4zOTQsIDAuMzg0LCAwLjM4N10sICAgICAgICAvLyBzaWdtYTlcbiAgICBudW0zOiBbMC40NDQsIDAuNDcxLCAwLjUwNF0sICAgICAgICAvLyBzaWdtYTEwXG4gICAgZGVub20xOiBbMC42ODYsIDAuNzUyLCAxLjAyNV0sICAgICAgLy8gc2lnbWExMVxuICAgIGRlbm9tMjogWzAuMzQ1LCAwLjM0NCwgMC41MzJdLCAgICAgIC8vIHNpZ21hMTJcbiAgICBzdXAxOiBbMC40MTMsIDAuNTAzLCAwLjUwNF0sICAgICAgICAvLyBzaWdtYTEzXG4gICAgc3VwMjogWzAuMzYzLCAwLjQzMSwgMC40MDRdLCAgICAgICAgLy8gc2lnbWExNFxuICAgIHN1cDM6IFswLjI4OSwgMC4yODYsIDAuMjk0XSwgICAgICAgIC8vIHNpZ21hMTVcbiAgICBzdWIxOiBbMC4xNTAsIDAuMTQzLCAwLjIwMF0sICAgICAgICAvLyBzaWdtYTE2XG4gICAgc3ViMjogWzAuMjQ3LCAwLjI4NiwgMC40MDBdLCAgICAgICAgLy8gc2lnbWExN1xuICAgIHN1cERyb3A6IFswLjM4NiwgMC4zNTMsIDAuNDk0XSwgICAgIC8vIHNpZ21hMThcbiAgICBzdWJEcm9wOiBbMC4wNTAsIDAuMDcxLCAwLjEwMF0sICAgICAvLyBzaWdtYTE5XG4gICAgZGVsaW0xOiBbMi4zOTAsIDEuNzAwLCAxLjk4MF0sICAgICAgLy8gc2lnbWEyMFxuICAgIGRlbGltMjogWzEuMDEwLCAxLjE1NywgMS40MjBdLCAgICAgIC8vIHNpZ21hMjFcbiAgICBheGlzSGVpZ2h0OiBbMC4yNTAsIDAuMjUwLCAwLjI1MF0gIC8vIHNpZ21hMjJcbn07XG5cbi8vIFRoZXNlIGZvbnQgbWV0cmljcyBhcmUgZXh0cmFjdGVkIGZyb20gVGVYIGJ5IHVzaW5nXG4vLyBcXGZvbnRcXGE9Y21leDEwXG4vLyBcXHNob3d0aGVcXGZvbnRkaW1lblhcXGFcbi8vIHdoZXJlIFggaXMgdGhlIGNvcnJlc3BvbmRpbmcgdmFyaWFibGUgbnVtYmVyLiBUaGVzZSBjb3JyZXNwb25kIHRvIHRoZSBmb250XG4vLyBwYXJhbWV0ZXJzIG9mIHRoZSBleHRlbnNpb24gZm9udHMgKGZhbWlseSAzKS4gU2VlIHRoZSBUZVhib29rLCBwYWdlIDQ0MS5cbnZhciB4aTEgPSAwO1xudmFyIHhpMiA9IDA7XG52YXIgeGkzID0gMDtcbnZhciB4aTQgPSAwO1xudmFyIHhpNSA9IDAuNDMxO1xudmFyIHhpNiA9IDE7XG52YXIgeGk3ID0gMDtcbnZhciB4aTggPSAwLjA0O1xudmFyIHhpOSA9IDAuMTExO1xudmFyIHhpMTAgPSAwLjE2NjtcbnZhciB4aTExID0gMC4yO1xudmFyIHhpMTIgPSAwLjY7XG52YXIgeGkxMyA9IDAuMTtcblxuLy8gVGhpcyB2YWx1ZSBkZXRlcm1pbmVzIGhvdyBsYXJnZSBhIHB0IGlzLCBmb3IgbWV0cmljcyB3aGljaCBhcmUgZGVmaW5lZCBpblxuLy8gdGVybXMgb2YgcHRzLlxuLy8gVGhpcyB2YWx1ZSBpcyBhbHNvIHVzZWQgaW4ga2F0ZXgubGVzczsgaWYgeW91IGNoYW5nZSBpdCBtYWtlIHN1cmUgdGhlIHZhbHVlc1xuLy8gbWF0Y2guXG52YXIgcHRQZXJFbSA9IDEwLjA7XG5cbi8vIFRoZSBzcGFjZSBiZXR3ZWVuIGFkamFjZW50IGB8YCBjb2x1bW5zIGluIGFuIGFycmF5IGRlZmluaXRpb24uIEZyb21cbi8vIGBcXHNob3d0aGVcXGRvdWJsZXJ1bGVzZXBgIGluIExhVGVYLlxudmFyIGRvdWJsZVJ1bGVTZXAgPSAyLjAgLyBwdFBlckVtO1xuXG4vKipcbiAqIFRoaXMgaXMganVzdCBhIG1hcHBpbmcgZnJvbSBjb21tb24gbmFtZXMgdG8gcmVhbCBtZXRyaWNzXG4gKi9cbnZhciBtZXRyaWNzID0ge1xuICAgIGRlZmF1bHRSdWxlVGhpY2tuZXNzOiB4aTgsXG4gICAgYmlnT3BTcGFjaW5nMTogeGk5LFxuICAgIGJpZ09wU3BhY2luZzI6IHhpMTAsXG4gICAgYmlnT3BTcGFjaW5nMzogeGkxMSxcbiAgICBiaWdPcFNwYWNpbmc0OiB4aTEyLFxuICAgIGJpZ09wU3BhY2luZzU6IHhpMTMsXG4gICAgcHRQZXJFbTogcHRQZXJFbSxcbiAgICBkb3VibGVSdWxlU2VwOiBkb3VibGVSdWxlU2VwXG59O1xuXG4vLyBUaGlzIG1hcCBjb250YWlucyBhIG1hcHBpbmcgZnJvbSBmb250IG5hbWUgYW5kIGNoYXJhY3RlciBjb2RlIHRvIGNoYXJhY3RlclxuLy8gbWV0cmljcywgaW5jbHVkaW5nIGhlaWdodCwgZGVwdGgsIGl0YWxpYyBjb3JyZWN0aW9uLCBhbmQgc2tldyAoa2VybiBmcm9tIHRoZVxuLy8gY2hhcmFjdGVyIHRvIHRoZSBjb3JyZXNwb25kaW5nIFxcc2tld2NoYXIpXG4vLyBUaGlzIG1hcCBpcyBnZW5lcmF0ZWQgdmlhIGBtYWtlIG1ldHJpY3NgLiBJdCBzaG91bGQgbm90IGJlIGNoYW5nZWQgbWFudWFsbHkuXG52YXIgbWV0cmljTWFwID0gcmVxdWlyZShcIi4vZm9udE1ldHJpY3NEYXRhXCIpO1xuXG4vLyBUaGVzZSBhcmUgdmVyeSByb3VnaCBhcHByb3hpbWF0aW9ucy4gIFdlIGRlZmF1bHQgdG8gVGltZXMgTmV3IFJvbWFuIHdoaWNoXG4vLyBzaG91bGQgaGF2ZSBMYXRpbi0xIGFuZCBDeXJpbGxpYyBjaGFyYWN0ZXJzLCBidXQgbWF5IG5vdCBkZXBlbmRpbmcgb24gdGhlXG4vLyBvcGVyYXRpbmcgc3lzdGVtLiAgVGhlIG1ldHJpY3MgZG8gbm90IGFjY291bnQgZm9yIGV4dHJhIGhlaWdodCBmcm9tIHRoZVxuLy8gYWNjZW50cy4gIEluIHRoZSBjYXNlIG9mIEN5cmlsbGljIGNoYXJhY3RlcnMgd2hpY2ggaGF2ZSBib3RoIGFzY2VuZGVycyBhbmRcbi8vIGRlc2NlbmRlcnMgd2UgcHJlZmVyIGFwcHJveGltYXRpb25zIHdpdGggYXNjZW5kZXJzLCBwcmltYXJpbHkgdG8gcHJldmVudFxuLy8gdGhlIGZyYWN0aW9uIGJhciBvciByb290IGxpbmUgZnJvbSBpbnRlcnNlY3RpbmcgdGhlIGdseXBoLlxuLy8gVE9ETyhrZXZpbmIpIGFsbG93IHVuaW9uIG9mIG11bHRpcGxlIGdseXBoIG1ldHJpY3MgZm9yIGJldHRlciBhY2N1cmFjeS5cbnZhciBleHRyYUNoYXJhY3Rlck1hcCA9IHtcbiAgICAvLyBMYXRpbi0xXG4gICAgJ8OAJzogJ0EnLFxuICAgICfDgSc6ICdBJyxcbiAgICAnw4InOiAnQScsXG4gICAgJ8ODJzogJ0EnLFxuICAgICfDhCc6ICdBJyxcbiAgICAnw4UnOiAnQScsXG4gICAgJ8OGJzogJ0EnLFxuICAgICfDhyc6ICdDJyxcbiAgICAnw4gnOiAnRScsXG4gICAgJ8OJJzogJ0UnLFxuICAgICfDiic6ICdFJyxcbiAgICAnw4snOiAnRScsXG4gICAgJ8OMJzogJ0knLFxuICAgICfDjSc6ICdJJyxcbiAgICAnw44nOiAnSScsXG4gICAgJ8OPJzogJ0knLFxuICAgICfDkCc6ICdEJyxcbiAgICAnw5EnOiAnTicsXG4gICAgJ8OSJzogJ08nLFxuICAgICfDkyc6ICdPJyxcbiAgICAnw5QnOiAnTycsXG4gICAgJ8OVJzogJ08nLFxuICAgICfDlic6ICdPJyxcbiAgICAnw5gnOiAnTycsXG4gICAgJ8OZJzogJ1UnLFxuICAgICfDmic6ICdVJyxcbiAgICAnw5snOiAnVScsXG4gICAgJ8OcJzogJ1UnLFxuICAgICfDnSc6ICdZJyxcbiAgICAnw54nOiAnbycsXG4gICAgJ8OfJzogJ0InLFxuICAgICfDoCc6ICdhJyxcbiAgICAnw6EnOiAnYScsXG4gICAgJ8OiJzogJ2EnLFxuICAgICfDoyc6ICdhJyxcbiAgICAnw6QnOiAnYScsXG4gICAgJ8OlJzogJ2EnLFxuICAgICfDpic6ICdhJyxcbiAgICAnw6cnOiAnYycsXG4gICAgJ8OoJzogJ2UnLFxuICAgICfDqSc6ICdlJyxcbiAgICAnw6onOiAnZScsXG4gICAgJ8OrJzogJ2UnLFxuICAgICfDrCc6ICdpJyxcbiAgICAnw60nOiAnaScsXG4gICAgJ8OuJzogJ2knLFxuICAgICfDryc6ICdpJyxcbiAgICAnw7AnOiAnZCcsXG4gICAgJ8OxJzogJ24nLFxuICAgICfDsic6ICdvJyxcbiAgICAnw7MnOiAnbycsXG4gICAgJ8O0JzogJ28nLFxuICAgICfDtSc6ICdvJyxcbiAgICAnw7YnOiAnbycsXG4gICAgJ8O4JzogJ28nLFxuICAgICfDuSc6ICd1JyxcbiAgICAnw7onOiAndScsXG4gICAgJ8O7JzogJ3UnLFxuICAgICfDvCc6ICd1JyxcbiAgICAnw70nOiAneScsXG4gICAgJ8O+JzogJ28nLFxuICAgICfDvyc6ICd5JyxcblxuICAgIC8vIEN5cmlsbGljXG4gICAgJ9CQJzogJ0EnLFxuICAgICfQkSc6ICdCJyxcbiAgICAn0JInOiAnQicsXG4gICAgJ9CTJzogJ0YnLFxuICAgICfQlCc6ICdBJyxcbiAgICAn0JUnOiAnRScsXG4gICAgJ9CWJzogJ0snLFxuICAgICfQlyc6ICczJyxcbiAgICAn0JgnOiAnTicsXG4gICAgJ9CZJzogJ04nLFxuICAgICfQmic6ICdLJyxcbiAgICAn0JsnOiAnTicsXG4gICAgJ9CcJzogJ00nLFxuICAgICfQnSc6ICdIJyxcbiAgICAn0J4nOiAnTycsXG4gICAgJ9CfJzogJ04nLFxuICAgICfQoCc6ICdQJyxcbiAgICAn0KEnOiAnQycsXG4gICAgJ9CiJzogJ1QnLFxuICAgICfQoyc6ICd5JyxcbiAgICAn0KQnOiAnTycsXG4gICAgJ9ClJzogJ1gnLFxuICAgICfQpic6ICdVJyxcbiAgICAn0KcnOiAnaCcsXG4gICAgJ9CoJzogJ1cnLFxuICAgICfQqSc6ICdXJyxcbiAgICAn0KonOiAnQicsXG4gICAgJ9CrJzogJ1gnLFxuICAgICfQrCc6ICdCJyxcbiAgICAn0K0nOiAnMycsXG4gICAgJ9CuJzogJ1gnLFxuICAgICfQryc6ICdSJyxcbiAgICAn0LAnOiAnYScsXG4gICAgJ9CxJzogJ2InLFxuICAgICfQsic6ICdhJyxcbiAgICAn0LMnOiAncicsXG4gICAgJ9C0JzogJ3knLFxuICAgICfQtSc6ICdlJyxcbiAgICAn0LYnOiAnbScsXG4gICAgJ9C3JzogJ2UnLFxuICAgICfQuCc6ICduJyxcbiAgICAn0LknOiAnbicsXG4gICAgJ9C6JzogJ24nLFxuICAgICfQuyc6ICduJyxcbiAgICAn0LwnOiAnbScsXG4gICAgJ9C9JzogJ24nLFxuICAgICfQvic6ICdvJyxcbiAgICAn0L8nOiAnbicsXG4gICAgJ9GAJzogJ3AnLFxuICAgICfRgSc6ICdjJyxcbiAgICAn0YInOiAnbycsXG4gICAgJ9GDJzogJ3knLFxuICAgICfRhCc6ICdiJyxcbiAgICAn0YUnOiAneCcsXG4gICAgJ9GGJzogJ24nLFxuICAgICfRhyc6ICduJyxcbiAgICAn0YgnOiAndycsXG4gICAgJ9GJJzogJ3cnLFxuICAgICfRiic6ICdhJyxcbiAgICAn0YsnOiAnbScsXG4gICAgJ9GMJzogJ2EnLFxuICAgICfRjSc6ICdlJyxcbiAgICAn0Y4nOiAnbScsXG4gICAgJ9GPJzogJ3InXG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYSBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgbG9va2luZyB1cCBpbmZvcm1hdGlvbiBpbiB0aGVcbiAqIG1ldHJpY01hcCB0YWJsZS4gSXQgdGFrZXMgYSBjaGFyYWN0ZXIgYXMgYSBzdHJpbmcsIGFuZCBhIHN0eWxlLlxuICpcbiAqIE5vdGU6IHRoZSBgd2lkdGhgIHByb3BlcnR5IG1heSBiZSB1bmRlZmluZWQgaWYgZm9udE1ldHJpY3NEYXRhLmpzIHdhc24ndFxuICogYnVpbHQgdXNpbmcgYE1ha2UgZXh0ZW5kZWRfbWV0cmljc2AuXG4gKi9cbnZhciBnZXRDaGFyYWN0ZXJNZXRyaWNzID0gZnVuY3Rpb24oY2hhcmFjdGVyLCBzdHlsZSkge1xuICAgIHZhciBjaCA9IGNoYXJhY3Rlci5jaGFyQ29kZUF0KDApO1xuICAgIGlmIChjaGFyYWN0ZXJbMF0gaW4gZXh0cmFDaGFyYWN0ZXJNYXApIHtcbiAgICAgICAgY2ggPSBleHRyYUNoYXJhY3Rlck1hcFtjaGFyYWN0ZXJbMF1dLmNoYXJDb2RlQXQoMCk7XG4gICAgfSBlbHNlIGlmIChjamtSZWdleC50ZXN0KGNoYXJhY3RlclswXSkpIHtcbiAgICAgICAgY2ggPSAnTScuY2hhckNvZGVBdCgwKTtcbiAgICB9XG4gICAgdmFyIG1ldHJpY3MgPSBtZXRyaWNNYXBbc3R5bGVdW2NoXTtcbiAgICBpZiAobWV0cmljcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVwdGg6IG1ldHJpY3NbMF0sXG4gICAgICAgICAgICBoZWlnaHQ6IG1ldHJpY3NbMV0sXG4gICAgICAgICAgICBpdGFsaWM6IG1ldHJpY3NbMl0sXG4gICAgICAgICAgICBza2V3OiBtZXRyaWNzWzNdLFxuICAgICAgICAgICAgd2lkdGg6IG1ldHJpY3NbNF1cbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtZXRyaWNzOiBtZXRyaWNzLFxuICAgIHNpZ21hczogc2lnbWFzLFxuICAgIGdldENoYXJhY3Rlck1ldHJpY3M6IGdldENoYXJhY3Rlck1ldHJpY3Ncbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBcIkFNUy1SZWd1bGFyXCI6IHtcbiAgICAgICAgXCI2NVwiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiNjZcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjY3XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI2OFwiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiNjlcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjcwXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI3MVwiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiNzJcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjczXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI3NFwiOiBbMC4xNjY2NywgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiNzVcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjc2XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI3N1wiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiNzhcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjc5XCI6IFswLjE2NjY3LCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4MFwiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiODFcIjogWzAuMTY2NjcsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjgyXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4M1wiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiODRcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjg1XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NlwiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiODdcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjg4XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4OVwiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiOTBcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjEwN1wiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiMTY1XCI6IFswLCAwLjY3NSwgMC4wMjUsIDBdLFxuICAgICAgICBcIjE3NFwiOiBbMC4xNTU1OSwgMC42OTIyNCwgMCwgMF0sXG4gICAgICAgIFwiMjQwXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCIyOTVcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjcxMFwiOiBbMCwgMC44MjUsIDAsIDBdLFxuICAgICAgICBcIjczMlwiOiBbMCwgMC45LCAwLCAwXSxcbiAgICAgICAgXCI3NzBcIjogWzAsIDAuODI1LCAwLCAwXSxcbiAgICAgICAgXCI3NzFcIjogWzAsIDAuOSwgMCwgMF0sXG4gICAgICAgIFwiOTg5XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCIxMDA4XCI6IFswLCAwLjQzMDU2LCAwLjA0MDI4LCAwXSxcbiAgICAgICAgXCI4MjQ1XCI6IFswLCAwLjU0OTg2LCAwLCAwXSxcbiAgICAgICAgXCI4NDYzXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NDg3XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NDk4XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NTAyXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NTAzXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NTA0XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NTEzXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NTkyXCI6IFstMC4wMzU5OCwgMC40NjQwMiwgMCwgMF0sXG4gICAgICAgIFwiODU5NFwiOiBbLTAuMDM1OTgsIDAuNDY0MDIsIDAsIDBdLFxuICAgICAgICBcIjg2MDJcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI4NjAzXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODYwNlwiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMF0sXG4gICAgICAgIFwiODYwOFwiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMF0sXG4gICAgICAgIFwiODYxMFwiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMF0sXG4gICAgICAgIFwiODYxMVwiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMF0sXG4gICAgICAgIFwiODYxOVwiOiBbMCwgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODYyMFwiOiBbMCwgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODYyMVwiOiBbLTAuMTMzMTMsIDAuMzc3ODgsIDAsIDBdLFxuICAgICAgICBcIjg2MjJcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI4NjI0XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjI1XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjMwXCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI4NjMxXCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI4NjM0XCI6IFswLjA4MTk4LCAwLjU4MTk4LCAwLCAwXSxcbiAgICAgICAgXCI4NjM1XCI6IFswLjA4MTk4LCAwLjU4MTk4LCAwLCAwXSxcbiAgICAgICAgXCI4NjM4XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjM5XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjQyXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjQzXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjQ0XCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NjQ2XCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NjQ3XCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NjQ4XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjQ5XCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NjUwXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjUxXCI6IFswLjAxMzU0LCAwLjUyMjM5LCAwLCAwXSxcbiAgICAgICAgXCI4NjUyXCI6IFswLjAxMzU0LCAwLjUyMjM5LCAwLCAwXSxcbiAgICAgICAgXCI4NjUzXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODY1NFwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDBdLFxuICAgICAgICBcIjg2NTVcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI4NjY2XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwXSxcbiAgICAgICAgXCI4NjY3XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwXSxcbiAgICAgICAgXCI4NjY5XCI6IFstMC4xMzMxMywgMC4zNzc4OCwgMCwgMF0sXG4gICAgICAgIFwiODY3MlwiOiBbLTAuMDY0LCAwLjQzNywgMCwgMF0sXG4gICAgICAgIFwiODY3NFwiOiBbLTAuMDY0LCAwLjQzNywgMCwgMF0sXG4gICAgICAgIFwiODcwNVwiOiBbMCwgMC44MjUsIDAsIDBdLFxuICAgICAgICBcIjg3MDhcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjg3MDlcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDBdLFxuICAgICAgICBcIjg3MTdcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjg3MjJcIjogWy0wLjAzNTk4LCAwLjQ2NDAyLCAwLCAwXSxcbiAgICAgICAgXCI4NzI0XCI6IFswLjA4MTk4LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NzI2XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCI4NzMzXCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NzM2XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NzM3XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NzM4XCI6IFswLjAzNTE3LCAwLjUyMjM5LCAwLCAwXSxcbiAgICAgICAgXCI4NzM5XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCI4NzQwXCI6IFswLjI1MTQyLCAwLjc0MTExLCAwLCAwXSxcbiAgICAgICAgXCI4NzQxXCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCI4NzQyXCI6IFswLjI1MTQyLCAwLjc0MTExLCAwLCAwXSxcbiAgICAgICAgXCI4NzU2XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NzU3XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NzY0XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODc2NVwiOiBbLTAuMTMzMTMsIDAuMzc3ODgsIDAsIDBdLFxuICAgICAgICBcIjg3NjlcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI4NzcwXCI6IFstMC4wMzYyNSwgMC40NjM3NSwgMCwgMF0sXG4gICAgICAgIFwiODc3NFwiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMF0sXG4gICAgICAgIFwiODc3NlwiOiBbLTAuMDE2ODgsIDAuNDgzMTIsIDAsIDBdLFxuICAgICAgICBcIjg3NzhcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDBdLFxuICAgICAgICBcIjg3ODJcIjogWzAuMDYwNjIsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjg3ODNcIjogWzAuMDYwNjIsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjg3ODVcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDBdLFxuICAgICAgICBcIjg3ODZcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDBdLFxuICAgICAgICBcIjg3ODdcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDBdLFxuICAgICAgICBcIjg3OTBcIjogWzAsIDAuNjkyMjQsIDAsIDBdLFxuICAgICAgICBcIjg3OTFcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDBdLFxuICAgICAgICBcIjg3OTZcIjogWzAuMDgxOTgsIDAuOTE2NjcsIDAsIDBdLFxuICAgICAgICBcIjg4MDZcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDBdLFxuICAgICAgICBcIjg4MDdcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDBdLFxuICAgICAgICBcIjg4MDhcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDBdLFxuICAgICAgICBcIjg4MDlcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDBdLFxuICAgICAgICBcIjg4MTJcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDBdLFxuICAgICAgICBcIjg4MTRcIjogWzAuMjA1NzYsIDAuNzA1NzYsIDAsIDBdLFxuICAgICAgICBcIjg4MTVcIjogWzAuMjA1NzYsIDAuNzA1NzYsIDAsIDBdLFxuICAgICAgICBcIjg4MTZcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDBdLFxuICAgICAgICBcIjg4MTdcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDBdLFxuICAgICAgICBcIjg4MThcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDBdLFxuICAgICAgICBcIjg4MTlcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDBdLFxuICAgICAgICBcIjg4MjJcIjogWzAuMTgwOCwgMC42NzUsIDAsIDBdLFxuICAgICAgICBcIjg4MjNcIjogWzAuMTgwOCwgMC42NzUsIDAsIDBdLFxuICAgICAgICBcIjg4MjhcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDBdLFxuICAgICAgICBcIjg4MjlcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDBdLFxuICAgICAgICBcIjg4MzBcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDBdLFxuICAgICAgICBcIjg4MzFcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDBdLFxuICAgICAgICBcIjg4MzJcIjogWzAuMjA1NzYsIDAuNzA1NzYsIDAsIDBdLFxuICAgICAgICBcIjg4MzNcIjogWzAuMjA1NzYsIDAuNzA1NzYsIDAsIDBdLFxuICAgICAgICBcIjg4NDBcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDBdLFxuICAgICAgICBcIjg4NDFcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDBdLFxuICAgICAgICBcIjg4NDJcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDBdLFxuICAgICAgICBcIjg4NDNcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDBdLFxuICAgICAgICBcIjg4NDdcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjg4NDhcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjg4NThcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDBdLFxuICAgICAgICBcIjg4NTlcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDBdLFxuICAgICAgICBcIjg4NjFcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDBdLFxuICAgICAgICBcIjg4NjJcIjogWzAsIDAuNjc1LCAwLCAwXSxcbiAgICAgICAgXCI4ODYzXCI6IFswLCAwLjY3NSwgMCwgMF0sXG4gICAgICAgIFwiODg2NFwiOiBbMCwgMC42NzUsIDAsIDBdLFxuICAgICAgICBcIjg4NjVcIjogWzAsIDAuNjc1LCAwLCAwXSxcbiAgICAgICAgXCI4ODcyXCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4ODczXCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4ODc0XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4ODc2XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4ODc3XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4ODc4XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4ODc5XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4ODgyXCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwXSxcbiAgICAgICAgXCI4ODgzXCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwXSxcbiAgICAgICAgXCI4ODg0XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODg1XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODg4XCI6IFswLCAwLjU0OTg2LCAwLCAwXSxcbiAgICAgICAgXCI4ODkwXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODkxXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4ODkyXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4OTAxXCI6IFswLCAwLjU0OTg2LCAwLCAwXSxcbiAgICAgICAgXCI4OTAzXCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCI4OTA1XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCI4OTA2XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCI4OTA3XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4OTA4XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4OTA5XCI6IFstMC4wMzU5OCwgMC40NjQwMiwgMCwgMF0sXG4gICAgICAgIFwiODkxMFwiOiBbMCwgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODkxMVwiOiBbMCwgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODkxMlwiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODkxM1wiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODkxNFwiOiBbMCwgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODkxNVwiOiBbMCwgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODkxNlwiOiBbMCwgMC42OTIyNCwgMCwgMF0sXG4gICAgICAgIFwiODkxOFwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDBdLFxuICAgICAgICBcIjg5MTlcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwXSxcbiAgICAgICAgXCI4OTIwXCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwXSxcbiAgICAgICAgXCI4OTIxXCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwXSxcbiAgICAgICAgXCI4OTIyXCI6IFswLjM4NTY5LCAwLjg4NTY5LCAwLCAwXSxcbiAgICAgICAgXCI4OTIzXCI6IFswLjM4NTY5LCAwLjg4NTY5LCAwLCAwXSxcbiAgICAgICAgXCI4OTI2XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwXSxcbiAgICAgICAgXCI4OTI3XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwXSxcbiAgICAgICAgXCI4OTI4XCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwXSxcbiAgICAgICAgXCI4OTI5XCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwXSxcbiAgICAgICAgXCI4OTM0XCI6IFswLjIzMjIyLCAwLjc0MTExLCAwLCAwXSxcbiAgICAgICAgXCI4OTM1XCI6IFswLjIzMjIyLCAwLjc0MTExLCAwLCAwXSxcbiAgICAgICAgXCI4OTM2XCI6IFswLjIzMjIyLCAwLjc0MTExLCAwLCAwXSxcbiAgICAgICAgXCI4OTM3XCI6IFswLjIzMjIyLCAwLjc0MTExLCAwLCAwXSxcbiAgICAgICAgXCI4OTM4XCI6IFswLjIwNTc2LCAwLjcwNTc2LCAwLCAwXSxcbiAgICAgICAgXCI4OTM5XCI6IFswLjIwNTc2LCAwLjcwNTc2LCAwLCAwXSxcbiAgICAgICAgXCI4OTQwXCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwXSxcbiAgICAgICAgXCI4OTQxXCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwXSxcbiAgICAgICAgXCI4OTk0XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4OTk1XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI5NDE2XCI6IFswLjE1NTU5LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI5NDg0XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI5NDg4XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI5NDkyXCI6IFswLCAwLjM3Nzg4LCAwLCAwXSxcbiAgICAgICAgXCI5NDk2XCI6IFswLCAwLjM3Nzg4LCAwLCAwXSxcbiAgICAgICAgXCI5NTg1XCI6IFswLjE5NDQ0LCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI5NTg2XCI6IFswLjE5NDQ0LCAwLjc0MTExLCAwLCAwXSxcbiAgICAgICAgXCI5NjMyXCI6IFswLCAwLjY3NSwgMCwgMF0sXG4gICAgICAgIFwiOTYzM1wiOiBbMCwgMC42NzUsIDAsIDBdLFxuICAgICAgICBcIjk2NTBcIjogWzAsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjk2NTFcIjogWzAsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjk2NTRcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjk2NjBcIjogWzAsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjk2NjFcIjogWzAsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjk2NjRcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjk2NzRcIjogWzAuMTExMTEsIDAuNjkyMjQsIDAsIDBdLFxuICAgICAgICBcIjk3MzNcIjogWzAuMTk0NDQsIDAuNjkyMjQsIDAsIDBdLFxuICAgICAgICBcIjEwMDAzXCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCIxMDAxNlwiOiBbMCwgMC42OTIyNCwgMCwgMF0sXG4gICAgICAgIFwiMTA3MzFcIjogWzAuMTExMTEsIDAuNjkyMjQsIDAsIDBdLFxuICAgICAgICBcIjEwODQ2XCI6IFswLjE5NDQ0LCAwLjc1NTgzLCAwLCAwXSxcbiAgICAgICAgXCIxMDg3N1wiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMF0sXG4gICAgICAgIFwiMTA4NzhcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDBdLFxuICAgICAgICBcIjEwODg1XCI6IFswLjI1NTgzLCAwLjc1NTgzLCAwLCAwXSxcbiAgICAgICAgXCIxMDg4NlwiOiBbMC4yNTU4MywgMC43NTU4MywgMCwgMF0sXG4gICAgICAgIFwiMTA4ODdcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDBdLFxuICAgICAgICBcIjEwODg4XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCIxMDg4OVwiOiBbMC4yNjE2NywgMC43NTcyNiwgMCwgMF0sXG4gICAgICAgIFwiMTA4OTBcIjogWzAuMjYxNjcsIDAuNzU3MjYsIDAsIDBdLFxuICAgICAgICBcIjEwODkxXCI6IFswLjQ4MjU2LCAwLjk4MjU2LCAwLCAwXSxcbiAgICAgICAgXCIxMDg5MlwiOiBbMC40ODI1NiwgMC45ODI1NiwgMCwgMF0sXG4gICAgICAgIFwiMTA5MDFcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDBdLFxuICAgICAgICBcIjEwOTAyXCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwXSxcbiAgICAgICAgXCIxMDkzM1wiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMF0sXG4gICAgICAgIFwiMTA5MzRcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDBdLFxuICAgICAgICBcIjEwOTM1XCI6IFswLjI2MTY3LCAwLjc1NzI2LCAwLCAwXSxcbiAgICAgICAgXCIxMDkzNlwiOiBbMC4yNjE2NywgMC43NTcyNiwgMCwgMF0sXG4gICAgICAgIFwiMTA5MzdcIjogWzAuMjYxNjcsIDAuNzU3MjYsIDAsIDBdLFxuICAgICAgICBcIjEwOTM4XCI6IFswLjI2MTY3LCAwLjc1NzI2LCAwLCAwXSxcbiAgICAgICAgXCIxMDk0OVwiOiBbMC4yNTU4MywgMC43NTU4MywgMCwgMF0sXG4gICAgICAgIFwiMTA5NTBcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDBdLFxuICAgICAgICBcIjEwOTU1XCI6IFswLjI4NDgxLCAwLjc5MzgzLCAwLCAwXSxcbiAgICAgICAgXCIxMDk1NlwiOiBbMC4yODQ4MSwgMC43OTM4MywgMCwgMF0sXG4gICAgICAgIFwiNTczNTBcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDBdLFxuICAgICAgICBcIjU3MzUxXCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCI1NzM1MlwiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMF0sXG4gICAgICAgIFwiNTczNTNcIjogWzAsIDAuNDMwNTYsIDAuMDQwMjgsIDBdLFxuICAgICAgICBcIjU3MzU2XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwXSxcbiAgICAgICAgXCI1NzM1N1wiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMF0sXG4gICAgICAgIFwiNTczNThcIjogWzAuNDE5NTEsIDAuOTE5NTEsIDAsIDBdLFxuICAgICAgICBcIjU3MzU5XCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwXSxcbiAgICAgICAgXCI1NzM2MFwiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMF0sXG4gICAgICAgIFwiNTczNjFcIjogWzAuNDE5NTEsIDAuOTE5NTEsIDAsIDBdLFxuICAgICAgICBcIjU3MzY2XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwXSxcbiAgICAgICAgXCI1NzM2N1wiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMF0sXG4gICAgICAgIFwiNTczNjhcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDBdLFxuICAgICAgICBcIjU3MzY5XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwXSxcbiAgICAgICAgXCI1NzM3MFwiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMF0sXG4gICAgICAgIFwiNTczNzFcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDBdXG4gICAgfSxcbiAgICBcIkNhbGlncmFwaGljLVJlZ3VsYXJcIjoge1xuICAgICAgICBcIjQ4XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI0OVwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiNTBcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjUxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI1MlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiNTNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjU0XCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1NVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiNTZcIjogWzAsIDAuNjQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjU3XCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI2NVwiOiBbMCwgMC42ODMzMywgMCwgMC4xOTQ0NV0sXG4gICAgICAgIFwiNjZcIjogWzAsIDAuNjgzMzMsIDAuMDMwNDEsIDAuMTM4ODldLFxuICAgICAgICBcIjY3XCI6IFswLCAwLjY4MzMzLCAwLjA1ODM0LCAwLjEzODg5XSxcbiAgICAgICAgXCI2OFwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wODMzNF0sXG4gICAgICAgIFwiNjlcIjogWzAsIDAuNjgzMzMsIDAuMDg5NDQsIDAuMTExMTFdLFxuICAgICAgICBcIjcwXCI6IFswLCAwLjY4MzMzLCAwLjA5OTMxLCAwLjExMTExXSxcbiAgICAgICAgXCI3MVwiOiBbMC4wOTcyMiwgMC42ODMzMywgMC4wNTkzLCAwLjExMTExXSxcbiAgICAgICAgXCI3MlwiOiBbMCwgMC42ODMzMywgMC4wMDk2NSwgMC4xMTExMV0sXG4gICAgICAgIFwiNzNcIjogWzAsIDAuNjgzMzMsIDAuMDczODIsIDBdLFxuICAgICAgICBcIjc0XCI6IFswLjA5NzIyLCAwLjY4MzMzLCAwLjE4NDcyLCAwLjE2NjY3XSxcbiAgICAgICAgXCI3NVwiOiBbMCwgMC42ODMzMywgMC4wMTQ0NSwgMC4wNTU1Nl0sXG4gICAgICAgIFwiNzZcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTM4ODldLFxuICAgICAgICBcIjc3XCI6IFswLCAwLjY4MzMzLCAwLCAwLjEzODg5XSxcbiAgICAgICAgXCI3OFwiOiBbMCwgMC42ODMzMywgMC4xNDczNiwgMC4wODMzNF0sXG4gICAgICAgIFwiNzlcIjogWzAsIDAuNjgzMzMsIDAuMDI3NzgsIDAuMTExMTFdLFxuICAgICAgICBcIjgwXCI6IFswLCAwLjY4MzMzLCAwLjA4MjIyLCAwLjA4MzM0XSxcbiAgICAgICAgXCI4MVwiOiBbMC4wOTcyMiwgMC42ODMzMywgMCwgMC4xMTExMV0sXG4gICAgICAgIFwiODJcIjogWzAsIDAuNjgzMzMsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjgzXCI6IFswLCAwLjY4MzMzLCAwLjA3NSwgMC4xMzg4OV0sXG4gICAgICAgIFwiODRcIjogWzAsIDAuNjgzMzMsIDAuMjU0MTcsIDBdLFxuICAgICAgICBcIjg1XCI6IFswLCAwLjY4MzMzLCAwLjA5OTMxLCAwLjA4MzM0XSxcbiAgICAgICAgXCI4NlwiOiBbMCwgMC42ODMzMywgMC4wODIyMiwgMF0sXG4gICAgICAgIFwiODdcIjogWzAsIDAuNjgzMzMsIDAuMDgyMjIsIDAuMDgzMzRdLFxuICAgICAgICBcIjg4XCI6IFswLCAwLjY4MzMzLCAwLjE0NjQzLCAwLjEzODg5XSxcbiAgICAgICAgXCI4OVwiOiBbMC4wOTcyMiwgMC42ODMzMywgMC4wODIyMiwgMC4wODMzNF0sXG4gICAgICAgIFwiOTBcIjogWzAsIDAuNjgzMzMsIDAuMDc5NDQsIDAuMTM4ODldXG4gICAgfSxcbiAgICBcIkZyYWt0dXItUmVndWxhclwiOiB7XG4gICAgICAgIFwiMzNcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjM0XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCIzOFwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiMzlcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjQwXCI6IFswLjI0OTgyLCAwLjc0OTQ3LCAwLCAwXSxcbiAgICAgICAgXCI0MVwiOiBbMC4yNDk4MiwgMC43NDk0NywgMCwgMF0sXG4gICAgICAgIFwiNDJcIjogWzAsIDAuNjIxMTksIDAsIDBdLFxuICAgICAgICBcIjQzXCI6IFswLjA4MzE5LCAwLjU4MjgzLCAwLCAwXSxcbiAgICAgICAgXCI0NFwiOiBbMCwgMC4xMDgwMywgMCwgMF0sXG4gICAgICAgIFwiNDVcIjogWzAuMDgzMTksIDAuNTgyODMsIDAsIDBdLFxuICAgICAgICBcIjQ2XCI6IFswLCAwLjEwODAzLCAwLCAwXSxcbiAgICAgICAgXCI0N1wiOiBbMC4yNDk4MiwgMC43NDk0NywgMCwgMF0sXG4gICAgICAgIFwiNDhcIjogWzAsIDAuNDc1MzQsIDAsIDBdLFxuICAgICAgICBcIjQ5XCI6IFswLCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCI1MFwiOiBbMCwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiNTFcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDBdLFxuICAgICAgICBcIjUyXCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCI1M1wiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiNTRcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjU1XCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCI1NlwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNTdcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDBdLFxuICAgICAgICBcIjU4XCI6IFswLCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCI1OVwiOiBbMC4xMjYwNCwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiNjFcIjogWy0wLjEzMDk5LCAwLjM2ODY2LCAwLCAwXSxcbiAgICAgICAgXCI2M1wiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNjVcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjY2XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI2N1wiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNjhcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjY5XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI3MFwiOiBbMC4xMjYwNCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNzFcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjcyXCI6IFswLjA2MzAyLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI3M1wiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNzRcIjogWzAuMTI2MDQsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjc1XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI3NlwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNzdcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjc4XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI3OVwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiODBcIjogWzAuMTg5MDYsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjgxXCI6IFswLjAzNzgxLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI4MlwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjg0XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI4NVwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjg3XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI4OFwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiODlcIjogWzAuMTg5MDYsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjkwXCI6IFswLjEyNjA0LCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI5MVwiOiBbMC4yNDk4MiwgMC43NDk0NywgMCwgMF0sXG4gICAgICAgIFwiOTNcIjogWzAuMjQ5ODIsIDAuNzQ5NDcsIDAsIDBdLFxuICAgICAgICBcIjk0XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI5N1wiOiBbMCwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiOThcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjk5XCI6IFswLCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCIxMDBcIjogWzAsIDAuNjIxMTksIDAsIDBdLFxuICAgICAgICBcIjEwMVwiOiBbMCwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiMTAyXCI6IFswLjE4OTA2LCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCIxMDNcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDBdLFxuICAgICAgICBcIjEwNFwiOiBbMC4xODkwNiwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiMTA1XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCIxMDZcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjEwN1wiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiMTA4XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCIxMDlcIjogWzAsIDAuNDc1MzQsIDAsIDBdLFxuICAgICAgICBcIjExMFwiOiBbMCwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiMTExXCI6IFswLCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCIxMTJcIjogWzAuMTg5MDYsIDAuNTIzOTYsIDAsIDBdLFxuICAgICAgICBcIjExM1wiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiMTE0XCI6IFswLCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCIxMTVcIjogWzAsIDAuNDc1MzQsIDAsIDBdLFxuICAgICAgICBcIjExNlwiOiBbMCwgMC42MjExOSwgMCwgMF0sXG4gICAgICAgIFwiMTE3XCI6IFswLCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCIxMThcIjogWzAsIDAuNTIzOTYsIDAsIDBdLFxuICAgICAgICBcIjExOVwiOiBbMCwgMC41MjM5NiwgMCwgMF0sXG4gICAgICAgIFwiMTIwXCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCIxMjFcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDBdLFxuICAgICAgICBcIjEyMlwiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiODIxNlwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiODIxN1wiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNTgxMTJcIjogWzAsIDAuNjIxMTksIDAsIDBdLFxuICAgICAgICBcIjU4MTEzXCI6IFswLCAwLjYyMTE5LCAwLCAwXSxcbiAgICAgICAgXCI1ODExNFwiOiBbMC4xODkwNiwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNTgxMTVcIjogWzAuMTg5MDYsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjU4MTE2XCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCI1ODExN1wiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNTgxMThcIjogWzAsIDAuNjIxMTksIDAsIDBdLFxuICAgICAgICBcIjU4MTE5XCI6IFswLCAwLjQ3NTM0LCAwLCAwXVxuICAgIH0sXG4gICAgXCJNYWluLUJvbGRcIjoge1xuICAgICAgICBcIjMzXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIzNFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMzVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjM2XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCIzN1wiOiBbMC4wNTU1NiwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiMzhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjM5XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI0MFwiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiNDFcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjQyXCI6IFswLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI0M1wiOiBbMC4xMzMzMywgMC42MzMzMywgMCwgMF0sXG4gICAgICAgIFwiNDRcIjogWzAuMTk0NDQsIDAuMTU1NTYsIDAsIDBdLFxuICAgICAgICBcIjQ1XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI0NlwiOiBbMCwgMC4xNTU1NiwgMCwgMF0sXG4gICAgICAgIFwiNDdcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjQ4XCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI0OVwiOiBbMCwgMC42NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTBcIjogWzAsIDAuNjQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjUxXCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1MlwiOiBbMCwgMC42NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTNcIjogWzAsIDAuNjQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjU0XCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1NVwiOiBbMCwgMC42NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTZcIjogWzAsIDAuNjQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjU3XCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1OFwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTlcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjYwXCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI2MVwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDBdLFxuICAgICAgICBcIjYyXCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI2M1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNjRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjY1XCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI2NlwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiNjdcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjY4XCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI2OVwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiNzBcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjcxXCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI3MlwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiNzNcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjc0XCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI3NVwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiNzZcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjc3XCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI3OFwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiNzlcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjgwXCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI4MVwiOiBbMC4xOTQ0NCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiODJcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjgzXCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI4NFwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiODVcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjg2XCI6IFswLCAwLjY4NjExLCAwLjAxNTk3LCAwXSxcbiAgICAgICAgXCI4N1wiOiBbMCwgMC42ODYxMSwgMC4wMTU5NywgMF0sXG4gICAgICAgIFwiODhcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjg5XCI6IFswLCAwLjY4NjExLCAwLjAyODc1LCAwXSxcbiAgICAgICAgXCI5MFwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiOTFcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjkyXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI5M1wiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiOTRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk1XCI6IFswLjMxLCAwLjEzNDQ0LCAwLjAzMTk0LCAwXSxcbiAgICAgICAgXCI5NlwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTdcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjk4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5OVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMDFcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwMlwiOiBbMCwgMC42OTQ0NCwgMC4xMDkwMywgMF0sXG4gICAgICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAxNTk3LCAwXSxcbiAgICAgICAgXCIxMDRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwNVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTA2XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMDdcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwOFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTA5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTBcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjExMVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjExNFwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTE1XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTZcIjogWzAsIDAuNjM0OTIsIDAsIDBdLFxuICAgICAgICBcIjExN1wiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTE4XCI6IFswLCAwLjQ0NDQ0LCAwLjAxNTk3LCAwXSxcbiAgICAgICAgXCIxMTlcIjogWzAsIDAuNDQ0NDQsIDAuMDE1OTcsIDBdLFxuICAgICAgICBcIjEyMFwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAxNTk3LCAwXSxcbiAgICAgICAgXCIxMjJcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjEyM1wiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiMTI0XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCIxMjVcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjEyNlwiOiBbMC4zNSwgMC4zNDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTY4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxNzJcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjE3NVwiOiBbMCwgMC41OTYxMSwgMCwgMF0sXG4gICAgICAgIFwiMTc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxNzdcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDBdLFxuICAgICAgICBcIjE4MFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMjE1XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwXSxcbiAgICAgICAgXCIyNDdcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDBdLFxuICAgICAgICBcIjMwNVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTY3XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3MTBcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjcxMVwiOiBbMCwgMC42MzE5NCwgMCwgMF0sXG4gICAgICAgIFwiNzEzXCI6IFswLCAwLjU5NjExLCAwLCAwXSxcbiAgICAgICAgXCI3MTRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjcxNVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzI4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3MjlcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjczMFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzMyXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NjhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc2OVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzcwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NzFcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc3MlwiOiBbMCwgMC41OTYxMSwgMCwgMF0sXG4gICAgICAgIFwiNzc0XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NzVcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzc4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NzlcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc4MFwiOiBbMCwgMC42MzE5NCwgMCwgMF0sXG4gICAgICAgIFwiODI0XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5MTVcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjkxNlwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiOTIwXCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI5MjNcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjkyNlwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiOTI4XCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI5MzFcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjkzM1wiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiOTM0XCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI5MzZcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjkzN1wiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiODIxMVwiOiBbMCwgMC40NDQ0NCwgMC4wMzE5NCwgMF0sXG4gICAgICAgIFwiODIxMlwiOiBbMCwgMC40NDQ0NCwgMC4wMzE5NCwgMF0sXG4gICAgICAgIFwiODIxNlwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODIxN1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODIyMFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODIyMVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODIyNFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODIyNVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODI0MlwiOiBbMCwgMC41NTU1NiwgMCwgMF0sXG4gICAgICAgIFwiODQwN1wiOiBbMCwgMC43MjQ0NCwgMC4xNTQ4NiwgMF0sXG4gICAgICAgIFwiODQ2M1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODQ2NVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODQ2N1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODQ3MlwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODQ3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODUwMVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODU5MlwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDBdLFxuICAgICAgICBcIjg1OTNcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjg1OTRcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwXSxcbiAgICAgICAgXCI4NTk1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NTk2XCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMF0sXG4gICAgICAgIFwiODU5N1wiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiODU5OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODU5OVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODYwMFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODYwMVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODYzNlwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDBdLFxuICAgICAgICBcIjg2MzdcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwXSxcbiAgICAgICAgXCI4NjQwXCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMF0sXG4gICAgICAgIFwiODY0MVwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDBdLFxuICAgICAgICBcIjg2NTZcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwXSxcbiAgICAgICAgXCI4NjU3XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NjU4XCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMF0sXG4gICAgICAgIFwiODY1OVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODY2MFwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDBdLFxuICAgICAgICBcIjg2NjFcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MDRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjg3MDZcIjogWzAsIDAuNjk0NDQsIDAuMDYzODksIDBdLFxuICAgICAgICBcIjg3MDdcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjg3MDlcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MTFcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjg3MTJcIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDBdLFxuICAgICAgICBcIjg3MTVcIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDBdLFxuICAgICAgICBcIjg3MjJcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDBdLFxuICAgICAgICBcIjg3MjNcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDBdLFxuICAgICAgICBcIjg3MjVcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MjZcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MjdcIjogWy0wLjAyNzc4LCAwLjQ3MjIyLCAwLCAwXSxcbiAgICAgICAgXCI4NzI4XCI6IFstMC4wMjYzOSwgMC40NzM2MSwgMCwgMF0sXG4gICAgICAgIFwiODcyOVwiOiBbLTAuMDI2MzksIDAuNDczNjEsIDAsIDBdLFxuICAgICAgICBcIjg3MzBcIjogWzAuMTgsIDAuODIsIDAsIDBdLFxuICAgICAgICBcIjg3MzNcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjg3MzRcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjg3MzZcIjogWzAsIDAuNjkyMjQsIDAsIDBdLFxuICAgICAgICBcIjg3MzlcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3NDFcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3NDNcIjogWzAsIDAuNTU1NTYsIDAsIDBdLFxuICAgICAgICBcIjg3NDRcIjogWzAsIDAuNTU1NTYsIDAsIDBdLFxuICAgICAgICBcIjg3NDVcIjogWzAsIDAuNTU1NTYsIDAsIDBdLFxuICAgICAgICBcIjg3NDZcIjogWzAsIDAuNTU1NTYsIDAsIDBdLFxuICAgICAgICBcIjg3NDdcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMTI3NzgsIDBdLFxuICAgICAgICBcIjg3NjRcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwXSxcbiAgICAgICAgXCI4NzY4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NzcxXCI6IFswLjAwMjIyLCAwLjUwMjIyLCAwLCAwXSxcbiAgICAgICAgXCI4Nzc2XCI6IFswLjAyNDQ0LCAwLjUyNDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NzgxXCI6IFswLjAwMjIyLCAwLjUwMjIyLCAwLCAwXSxcbiAgICAgICAgXCI4ODAxXCI6IFswLjAwMjIyLCAwLjUwMjIyLCAwLCAwXSxcbiAgICAgICAgXCI4ODA0XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODA1XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODEwXCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODExXCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODI2XCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODI3XCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODM0XCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODM1XCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODM4XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODM5XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODQ2XCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODQ5XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODUwXCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODUxXCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODUyXCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODUzXCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU0XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU1XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU2XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU3XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODY2XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4ODY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4ODY4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4ODY5XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4OTAwXCI6IFstMC4wMjYzOSwgMC40NzM2MSwgMCwgMF0sXG4gICAgICAgIFwiODkwMVwiOiBbLTAuMDI2MzksIDAuNDczNjEsIDAsIDBdLFxuICAgICAgICBcIjg5MDJcIjogWy0wLjAyNzc4LCAwLjQ3MjIyLCAwLCAwXSxcbiAgICAgICAgXCI4OTY4XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY5XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcwXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcxXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTk0XCI6IFstMC4xMzg4OSwgMC4zNjExMSwgMCwgMF0sXG4gICAgICAgIFwiODk5NVwiOiBbLTAuMTM4ODksIDAuMzYxMTEsIDAsIDBdLFxuICAgICAgICBcIjk2NTFcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk2NTdcIjogWy0wLjAyNzc4LCAwLjQ3MjIyLCAwLCAwXSxcbiAgICAgICAgXCI5NjYxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5NjY3XCI6IFstMC4wMjc3OCwgMC40NzIyMiwgMCwgMF0sXG4gICAgICAgIFwiOTcxMVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTgyNFwiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTgyNVwiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTgyNlwiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTgyN1wiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTgzN1wiOiBbMCwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiOTgzOFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTgzOVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTAyMTZcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjEwMjE3XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCIxMDgxNVwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiMTA5MjdcIjogWzAuMTk2NjcsIDAuNjk2NjcsIDAsIDBdLFxuICAgICAgICBcIjEwOTI4XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwXVxuICAgIH0sXG4gICAgXCJNYWluLUl0YWxpY1wiOiB7XG4gICAgICAgIFwiMzNcIjogWzAsIDAuNjk0NDQsIDAuMTI0MTcsIDBdLFxuICAgICAgICBcIjM0XCI6IFswLCAwLjY5NDQ0LCAwLjA2OTYxLCAwXSxcbiAgICAgICAgXCIzNVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNjYxNiwgMF0sXG4gICAgICAgIFwiMzdcIjogWzAuMDU1NTYsIDAuNzUsIDAuMTM2MzksIDBdLFxuICAgICAgICBcIjM4XCI6IFswLCAwLjY5NDQ0LCAwLjA5Njk0LCAwXSxcbiAgICAgICAgXCIzOVwiOiBbMCwgMC42OTQ0NCwgMC4xMjQxNywgMF0sXG4gICAgICAgIFwiNDBcIjogWzAuMjUsIDAuNzUsIDAuMTYxOTQsIDBdLFxuICAgICAgICBcIjQxXCI6IFswLjI1LCAwLjc1LCAwLjAzNjk0LCAwXSxcbiAgICAgICAgXCI0MlwiOiBbMCwgMC43NSwgMC4xNDkxNywgMF0sXG4gICAgICAgIFwiNDNcIjogWzAuMDU2NjcsIDAuNTYxNjcsIDAuMDM2OTQsIDBdLFxuICAgICAgICBcIjQ0XCI6IFswLjE5NDQ0LCAwLjEwNTU2LCAwLCAwXSxcbiAgICAgICAgXCI0NVwiOiBbMCwgMC40MzA1NiwgMC4wMjgyNiwgMF0sXG4gICAgICAgIFwiNDZcIjogWzAsIDAuMTA1NTYsIDAsIDBdLFxuICAgICAgICBcIjQ3XCI6IFswLjI1LCAwLjc1LCAwLjE2MTk0LCAwXSxcbiAgICAgICAgXCI0OFwiOiBbMCwgMC42NDQ0NCwgMC4xMzU1NiwgMF0sXG4gICAgICAgIFwiNDlcIjogWzAsIDAuNjQ0NDQsIDAuMTM1NTYsIDBdLFxuICAgICAgICBcIjUwXCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwXSxcbiAgICAgICAgXCI1MVwiOiBbMCwgMC42NDQ0NCwgMC4xMzU1NiwgMF0sXG4gICAgICAgIFwiNTJcIjogWzAuMTk0NDQsIDAuNjQ0NDQsIDAuMTM1NTYsIDBdLFxuICAgICAgICBcIjUzXCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwXSxcbiAgICAgICAgXCI1NFwiOiBbMCwgMC42NDQ0NCwgMC4xMzU1NiwgMF0sXG4gICAgICAgIFwiNTVcIjogWzAuMTk0NDQsIDAuNjQ0NDQsIDAuMTM1NTYsIDBdLFxuICAgICAgICBcIjU2XCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwXSxcbiAgICAgICAgXCI1N1wiOiBbMCwgMC42NDQ0NCwgMC4xMzU1NiwgMF0sXG4gICAgICAgIFwiNThcIjogWzAsIDAuNDMwNTYsIDAuMDU4MiwgMF0sXG4gICAgICAgIFwiNTlcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDU4MiwgMF0sXG4gICAgICAgIFwiNjFcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLjA2NjE2LCAwXSxcbiAgICAgICAgXCI2M1wiOiBbMCwgMC42OTQ0NCwgMC4xMjI1LCAwXSxcbiAgICAgICAgXCI2NFwiOiBbMCwgMC42OTQ0NCwgMC4wOTU5NywgMF0sXG4gICAgICAgIFwiNjVcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjY2XCI6IFswLCAwLjY4MzMzLCAwLjEwMjU3LCAwXSxcbiAgICAgICAgXCI2N1wiOiBbMCwgMC42ODMzMywgMC4xNDUyOCwgMF0sXG4gICAgICAgIFwiNjhcIjogWzAsIDAuNjgzMzMsIDAuMDk0MDMsIDBdLFxuICAgICAgICBcIjY5XCI6IFswLCAwLjY4MzMzLCAwLjEyMDI4LCAwXSxcbiAgICAgICAgXCI3MFwiOiBbMCwgMC42ODMzMywgMC4xMzMwNSwgMF0sXG4gICAgICAgIFwiNzFcIjogWzAsIDAuNjgzMzMsIDAuMDg3MjIsIDBdLFxuICAgICAgICBcIjcyXCI6IFswLCAwLjY4MzMzLCAwLjE2Mzg5LCAwXSxcbiAgICAgICAgXCI3M1wiOiBbMCwgMC42ODMzMywgMC4xNTgwNiwgMF0sXG4gICAgICAgIFwiNzRcIjogWzAsIDAuNjgzMzMsIDAuMTQwMjgsIDBdLFxuICAgICAgICBcIjc1XCI6IFswLCAwLjY4MzMzLCAwLjE0NTI4LCAwXSxcbiAgICAgICAgXCI3NlwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiNzdcIjogWzAsIDAuNjgzMzMsIDAuMTYzODksIDBdLFxuICAgICAgICBcIjc4XCI6IFswLCAwLjY4MzMzLCAwLjE2Mzg5LCAwXSxcbiAgICAgICAgXCI3OVwiOiBbMCwgMC42ODMzMywgMC4wOTQwMywgMF0sXG4gICAgICAgIFwiODBcIjogWzAsIDAuNjgzMzMsIDAuMTAyNTcsIDBdLFxuICAgICAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4MzMzLCAwLjA5NDAzLCAwXSxcbiAgICAgICAgXCI4MlwiOiBbMCwgMC42ODMzMywgMC4wMzg2OCwgMF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNjgzMzMsIDAuMTE5NzIsIDBdLFxuICAgICAgICBcIjg0XCI6IFswLCAwLjY4MzMzLCAwLjEzMzA1LCAwXSxcbiAgICAgICAgXCI4NVwiOiBbMCwgMC42ODMzMywgMC4xNjM4OSwgMF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNjgzMzMsIDAuMTgzNjEsIDBdLFxuICAgICAgICBcIjg3XCI6IFswLCAwLjY4MzMzLCAwLjE4MzYxLCAwXSxcbiAgICAgICAgXCI4OFwiOiBbMCwgMC42ODMzMywgMC4xNTgwNiwgMF0sXG4gICAgICAgIFwiODlcIjogWzAsIDAuNjgzMzMsIDAuMTkzODMsIDBdLFxuICAgICAgICBcIjkwXCI6IFswLCAwLjY4MzMzLCAwLjE0NTI4LCAwXSxcbiAgICAgICAgXCI5MVwiOiBbMC4yNSwgMC43NSwgMC4xODc1LCAwXSxcbiAgICAgICAgXCI5M1wiOiBbMC4yNSwgMC43NSwgMC4xMDUyOCwgMF0sXG4gICAgICAgIFwiOTRcIjogWzAsIDAuNjk0NDQsIDAuMDY2NDYsIDBdLFxuICAgICAgICBcIjk1XCI6IFswLjMxLCAwLjEyMDU2LCAwLjA5MjA4LCAwXSxcbiAgICAgICAgXCI5N1wiOiBbMCwgMC40MzA1NiwgMC4wNzY3MSwgMF0sXG4gICAgICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAuMDYzMTIsIDBdLFxuICAgICAgICBcIjk5XCI6IFswLCAwLjQzMDU2LCAwLjA1NjUzLCAwXSxcbiAgICAgICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAuMTAzMzMsIDBdLFxuICAgICAgICBcIjEwMVwiOiBbMCwgMC40MzA1NiwgMC4wNzUxNCwgMF0sXG4gICAgICAgIFwiMTAyXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjIxMTk0LCAwXSxcbiAgICAgICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDg4NDcsIDBdLFxuICAgICAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMC4wNzY3MSwgMF0sXG4gICAgICAgIFwiMTA1XCI6IFswLCAwLjY1NTM2LCAwLjEwMTksIDBdLFxuICAgICAgICBcIjEwNlwiOiBbMC4xOTQ0NCwgMC42NTUzNiwgMC4xNDQ2NywgMF0sXG4gICAgICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLjEwNzY0LCAwXSxcbiAgICAgICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAuMTAzMzMsIDBdLFxuICAgICAgICBcIjEwOVwiOiBbMCwgMC40MzA1NiwgMC4wNzY3MSwgMF0sXG4gICAgICAgIFwiMTEwXCI6IFswLCAwLjQzMDU2LCAwLjA3NjcxLCAwXSxcbiAgICAgICAgXCIxMTFcIjogWzAsIDAuNDMwNTYsIDAuMDYzMTIsIDBdLFxuICAgICAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wNjMxMiwgMF0sXG4gICAgICAgIFwiMTEzXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjA4ODQ3LCAwXSxcbiAgICAgICAgXCIxMTRcIjogWzAsIDAuNDMwNTYsIDAuMTA3NjQsIDBdLFxuICAgICAgICBcIjExNVwiOiBbMCwgMC40MzA1NiwgMC4wODIwOCwgMF0sXG4gICAgICAgIFwiMTE2XCI6IFswLCAwLjYxNTA4LCAwLjA5NDg2LCAwXSxcbiAgICAgICAgXCIxMTdcIjogWzAsIDAuNDMwNTYsIDAuMDc2NzEsIDBdLFxuICAgICAgICBcIjExOFwiOiBbMCwgMC40MzA1NiwgMC4xMDc2NCwgMF0sXG4gICAgICAgIFwiMTE5XCI6IFswLCAwLjQzMDU2LCAwLjEwNzY0LCAwXSxcbiAgICAgICAgXCIxMjBcIjogWzAsIDAuNDMwNTYsIDAuMTIwNDIsIDBdLFxuICAgICAgICBcIjEyMVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wODg0NywgMF0sXG4gICAgICAgIFwiMTIyXCI6IFswLCAwLjQzMDU2LCAwLjEyMjkyLCAwXSxcbiAgICAgICAgXCIxMjZcIjogWzAuMzUsIDAuMzE3ODYsIDAuMTE1ODUsIDBdLFxuICAgICAgICBcIjE2M1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMzA1XCI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4XSxcbiAgICAgICAgXCI1NjdcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjc2OFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzY5XCI6IFswLCAwLjY5NDQ0LCAwLjA5Njk0LCAwXSxcbiAgICAgICAgXCI3NzBcIjogWzAsIDAuNjk0NDQsIDAuMDY2NDYsIDBdLFxuICAgICAgICBcIjc3MVwiOiBbMCwgMC42Njc4NiwgMC4xMTU4NSwgMF0sXG4gICAgICAgIFwiNzcyXCI6IFswLCAwLjU2MTY3LCAwLjEwMzMzLCAwXSxcbiAgICAgICAgXCI3NzRcIjogWzAsIDAuNjk0NDQsIDAuMTA4MDYsIDBdLFxuICAgICAgICBcIjc3NVwiOiBbMCwgMC42Njc4NiwgMC4xMTc1MiwgMF0sXG4gICAgICAgIFwiNzc2XCI6IFswLCAwLjY2Nzg2LCAwLjEwNDc0LCAwXSxcbiAgICAgICAgXCI3NzhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc3OVwiOiBbMCwgMC42OTQ0NCwgMC4xMjI1LCAwXSxcbiAgICAgICAgXCI3ODBcIjogWzAsIDAuNjI4NDcsIDAuMDgyOTUsIDBdLFxuICAgICAgICBcIjkxNVwiOiBbMCwgMC42ODMzMywgMC4xMzMwNSwgMF0sXG4gICAgICAgIFwiOTE2XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI5MjBcIjogWzAsIDAuNjgzMzMsIDAuMDk0MDMsIDBdLFxuICAgICAgICBcIjkyM1wiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiOTI2XCI6IFswLCAwLjY4MzMzLCAwLjE1Mjk0LCAwXSxcbiAgICAgICAgXCI5MjhcIjogWzAsIDAuNjgzMzMsIDAuMTYzODksIDBdLFxuICAgICAgICBcIjkzMVwiOiBbMCwgMC42ODMzMywgMC4xMjAyOCwgMF0sXG4gICAgICAgIFwiOTMzXCI6IFswLCAwLjY4MzMzLCAwLjExMTExLCAwXSxcbiAgICAgICAgXCI5MzRcIjogWzAsIDAuNjgzMzMsIDAuMDU5ODYsIDBdLFxuICAgICAgICBcIjkzNlwiOiBbMCwgMC42ODMzMywgMC4xMTExMSwgMF0sXG4gICAgICAgIFwiOTM3XCI6IFswLCAwLjY4MzMzLCAwLjEwMjU3LCAwXSxcbiAgICAgICAgXCI4MjExXCI6IFswLCAwLjQzMDU2LCAwLjA5MjA4LCAwXSxcbiAgICAgICAgXCI4MjEyXCI6IFswLCAwLjQzMDU2LCAwLjA5MjA4LCAwXSxcbiAgICAgICAgXCI4MjE2XCI6IFswLCAwLjY5NDQ0LCAwLjEyNDE3LCAwXSxcbiAgICAgICAgXCI4MjE3XCI6IFswLCAwLjY5NDQ0LCAwLjEyNDE3LCAwXSxcbiAgICAgICAgXCI4MjIwXCI6IFswLCAwLjY5NDQ0LCAwLjE2ODUsIDBdLFxuICAgICAgICBcIjgyMjFcIjogWzAsIDAuNjk0NDQsIDAuMDY5NjEsIDBdLFxuICAgICAgICBcIjg0NjNcIjogWzAsIDAuNjg4ODksIDAsIDBdXG4gICAgfSxcbiAgICBcIk1haW4tUmVndWxhclwiOiB7XG4gICAgICAgIFwiMzJcIjogWzAsIDAsIDAsIDBdLFxuICAgICAgICBcIjMzXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIzNFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMzVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjM2XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCIzN1wiOiBbMC4wNTU1NiwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiMzhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjM5XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI0MFwiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiNDFcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjQyXCI6IFswLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI0M1wiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMF0sXG4gICAgICAgIFwiNDRcIjogWzAuMTk0NDQsIDAuMTA1NTYsIDAsIDBdLFxuICAgICAgICBcIjQ1XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI0NlwiOiBbMCwgMC4xMDU1NiwgMCwgMF0sXG4gICAgICAgIFwiNDdcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjQ4XCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI0OVwiOiBbMCwgMC42NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTBcIjogWzAsIDAuNjQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjUxXCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1MlwiOiBbMCwgMC42NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTNcIjogWzAsIDAuNjQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjU0XCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1NVwiOiBbMCwgMC42NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTZcIjogWzAsIDAuNjQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjU3XCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1OFwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiNTlcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjYwXCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMF0sXG4gICAgICAgIFwiNjFcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI2MlwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDBdLFxuICAgICAgICBcIjYzXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI2NFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNjVcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjY2XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI2N1wiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiNjhcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjY5XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI3MFwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiNzFcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjcyXCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI3M1wiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiNzRcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjc1XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI3NlwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiNzdcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjc4XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI3OVwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiODBcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4MlwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjg0XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4NVwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNjgzMzMsIDAuMDEzODksIDBdLFxuICAgICAgICBcIjg3XCI6IFswLCAwLjY4MzMzLCAwLjAxMzg5LCAwXSxcbiAgICAgICAgXCI4OFwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiODlcIjogWzAsIDAuNjgzMzMsIDAuMDI1LCAwXSxcbiAgICAgICAgXCI5MFwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiOTFcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjkyXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI5M1wiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiOTRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk1XCI6IFswLjMxLCAwLjEyMDU2LCAwLjAyNzc4LCAwXSxcbiAgICAgICAgXCI5NlwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTdcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjk4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5OVwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMDFcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjEwMlwiOiBbMCwgMC42OTQ0NCwgMC4wNzc3OCwgMF0sXG4gICAgICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAxMzg5LCAwXSxcbiAgICAgICAgXCIxMDRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwNVwiOiBbMCwgMC42Njc4NiwgMCwgMF0sXG4gICAgICAgIFwiMTA2XCI6IFswLjE5NDQ0LCAwLjY2Nzg2LCAwLCAwXSxcbiAgICAgICAgXCIxMDdcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwOFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTA5XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMTBcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjExMVwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjExNFwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTE1XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMTZcIjogWzAsIDAuNjE1MDgsIDAsIDBdLFxuICAgICAgICBcIjExN1wiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTE4XCI6IFswLCAwLjQzMDU2LCAwLjAxMzg5LCAwXSxcbiAgICAgICAgXCIxMTlcIjogWzAsIDAuNDMwNTYsIDAuMDEzODksIDBdLFxuICAgICAgICBcIjEyMFwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAxMzg5LCAwXSxcbiAgICAgICAgXCIxMjJcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjEyM1wiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiMTI0XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCIxMjVcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjEyNlwiOiBbMC4zNSwgMC4zMTc4NiwgMCwgMF0sXG4gICAgICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwXSxcbiAgICAgICAgXCIxNjhcIjogWzAsIDAuNjY3ODYsIDAsIDBdLFxuICAgICAgICBcIjE3MlwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTc1XCI6IFswLCAwLjU2Nzc4LCAwLCAwXSxcbiAgICAgICAgXCIxNzZcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjE3N1wiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMF0sXG4gICAgICAgIFwiMTgwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIyMTVcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDBdLFxuICAgICAgICBcIjI0N1wiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMF0sXG4gICAgICAgIFwiMzA1XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI1NjdcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjcxMFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzExXCI6IFswLCAwLjYyODQ3LCAwLCAwXSxcbiAgICAgICAgXCI3MTNcIjogWzAsIDAuNTY3NzgsIDAsIDBdLFxuICAgICAgICBcIjcxNFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzE1XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3MjhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjcyOVwiOiBbMCwgMC42Njc4NiwgMCwgMF0sXG4gICAgICAgIFwiNzMwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3MzJcIjogWzAsIDAuNjY3ODYsIDAsIDBdLFxuICAgICAgICBcIjc2OFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzY5XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NzBcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc3MVwiOiBbMCwgMC42Njc4NiwgMCwgMF0sXG4gICAgICAgIFwiNzcyXCI6IFswLCAwLjU2Nzc4LCAwLCAwXSxcbiAgICAgICAgXCI3NzRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc3NVwiOiBbMCwgMC42Njc4NiwgMCwgMF0sXG4gICAgICAgIFwiNzc2XCI6IFswLCAwLjY2Nzg2LCAwLCAwXSxcbiAgICAgICAgXCI3NzhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc3OVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzgwXCI6IFswLCAwLjYyODQ3LCAwLCAwXSxcbiAgICAgICAgXCI4MjRcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjkxNVwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiOTE2XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI5MjBcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjkyM1wiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiOTI2XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI5MjhcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjkzMVwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiOTMzXCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI5MzRcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjkzNlwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiOTM3XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4MjExXCI6IFswLCAwLjQzMDU2LCAwLjAyNzc4LCAwXSxcbiAgICAgICAgXCI4MjEyXCI6IFswLCAwLjQzMDU2LCAwLjAyNzc4LCAwXSxcbiAgICAgICAgXCI4MjE2XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MjE3XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MjIwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MjIxXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MjI0XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MjI1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MjMwXCI6IFswLCAwLjEyLCAwLCAwXSxcbiAgICAgICAgXCI4MjQyXCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4NDA3XCI6IFswLCAwLjcxNDQ0LCAwLjE1MzgyLCAwXSxcbiAgICAgICAgXCI4NDYzXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NDY1XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NDY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLjExMTExXSxcbiAgICAgICAgXCI4NDcyXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLjExMTExXSxcbiAgICAgICAgXCI4NDc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NTAxXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NTkyXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODU5M1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODU5NFwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDBdLFxuICAgICAgICBcIjg1OTVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjg1OTZcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI4NTk3XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NTk4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NTk5XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NjAwXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NjAxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NjE0XCI6IFswLjAxMSwgMC41MTEsIDAsIDBdLFxuICAgICAgICBcIjg2MTdcIjogWzAuMDExLCAwLjUxMSwgMCwgMF0sXG4gICAgICAgIFwiODYxOFwiOiBbMC4wMTEsIDAuNTExLCAwLCAwXSxcbiAgICAgICAgXCI4NjM2XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODYzN1wiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDBdLFxuICAgICAgICBcIjg2NDBcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI4NjQxXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODY1MlwiOiBbMC4wMTEsIDAuNjcxLCAwLCAwXSxcbiAgICAgICAgXCI4NjU2XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODY1N1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODY1OFwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDBdLFxuICAgICAgICBcIjg2NTlcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjg2NjBcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI4NjYxXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NzA0XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NzA2XCI6IFswLCAwLjY5NDQ0LCAwLjA1NTU2LCAwLjA4MzM0XSxcbiAgICAgICAgXCI4NzA3XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NzA5XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NzExXCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4NzEyXCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMF0sXG4gICAgICAgIFwiODcxNVwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDBdLFxuICAgICAgICBcIjg3MjJcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDBdLFxuICAgICAgICBcIjg3MjNcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDBdLFxuICAgICAgICBcIjg3MjVcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MjZcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MjdcIjogWy0wLjAzNDcyLCAwLjQ2NTI4LCAwLCAwXSxcbiAgICAgICAgXCI4NzI4XCI6IFstMC4wNTU1NSwgMC40NDQ0NSwgMCwgMF0sXG4gICAgICAgIFwiODcyOVwiOiBbLTAuMDU1NTUsIDAuNDQ0NDUsIDAsIDBdLFxuICAgICAgICBcIjg3MzBcIjogWzAuMiwgMC44LCAwLCAwXSxcbiAgICAgICAgXCI4NzMzXCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI4NzM0XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI4NzM2XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NzM5XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NzQxXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NzQzXCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4NzQ0XCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4NzQ1XCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4NzQ2XCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4NzQ3XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjExMTExLCAwXSxcbiAgICAgICAgXCI4NzY0XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODc2OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODc3MVwiOiBbLTAuMDM2MjUsIDAuNDYzNzUsIDAsIDBdLFxuICAgICAgICBcIjg3NzNcIjogWy0wLjAyMiwgMC41ODksIDAsIDBdLFxuICAgICAgICBcIjg3NzZcIjogWy0wLjAxNjg4LCAwLjQ4MzEyLCAwLCAwXSxcbiAgICAgICAgXCI4NzgxXCI6IFstMC4wMzYyNSwgMC40NjM3NSwgMCwgMF0sXG4gICAgICAgIFwiODc4NFwiOiBbLTAuMTMzLCAwLjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODAwXCI6IFswLjIxNSwgMC43MTYsIDAsIDBdLFxuICAgICAgICBcIjg4MDFcIjogWy0wLjAzNjI1LCAwLjQ2Mzc1LCAwLCAwXSxcbiAgICAgICAgXCI4ODA0XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCI4ODA1XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCI4ODEwXCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMF0sXG4gICAgICAgIFwiODgxMVwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDBdLFxuICAgICAgICBcIjg4MjZcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwXSxcbiAgICAgICAgXCI4ODI3XCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMF0sXG4gICAgICAgIFwiODgzNFwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDBdLFxuICAgICAgICBcIjg4MzVcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwXSxcbiAgICAgICAgXCI4ODM4XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCI4ODM5XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCI4ODQ2XCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODQ5XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCI4ODUwXCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCI4ODUxXCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODUyXCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODUzXCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU0XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU1XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU2XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU3XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODY2XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4ODY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4ODY4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4ODY5XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4ODcyXCI6IFswLjI0OSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiODkwMFwiOiBbLTAuMDU1NTUsIDAuNDQ0NDUsIDAsIDBdLFxuICAgICAgICBcIjg5MDFcIjogWy0wLjA1NTU1LCAwLjQ0NDQ1LCAwLCAwXSxcbiAgICAgICAgXCI4OTAyXCI6IFstMC4wMzQ3MiwgMC40NjUyOCwgMCwgMF0sXG4gICAgICAgIFwiODkwNFwiOiBbMC4wMDUsIDAuNTA1LCAwLCAwXSxcbiAgICAgICAgXCI4OTQyXCI6IFswLjAzLCAwLjksIDAsIDBdLFxuICAgICAgICBcIjg5NDNcIjogWy0wLjE5LCAwLjMxLCAwLCAwXSxcbiAgICAgICAgXCI4OTQ1XCI6IFstMC4xLCAwLjgyLCAwLCAwXSxcbiAgICAgICAgXCI4OTY4XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY5XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcwXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcxXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTk0XCI6IFstMC4xNDIzNiwgMC4zNTc2NCwgMCwgMF0sXG4gICAgICAgIFwiODk5NVwiOiBbLTAuMTQyMzYsIDAuMzU3NjQsIDAsIDBdLFxuICAgICAgICBcIjkxMzZcIjogWzAuMjQ0LCAwLjc0NCwgMCwgMF0sXG4gICAgICAgIFwiOTEzN1wiOiBbMC4yNDQsIDAuNzQ0LCAwLCAwXSxcbiAgICAgICAgXCI5NjUxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5NjU3XCI6IFstMC4wMzQ3MiwgMC40NjUyOCwgMCwgMF0sXG4gICAgICAgIFwiOTY2MVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTY2N1wiOiBbLTAuMDM0NzIsIDAuNDY1MjgsIDAsIDBdLFxuICAgICAgICBcIjk3MTFcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk4MjRcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk4MjVcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk4MjZcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk4MjdcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk4MzdcIjogWzAsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjk4MzhcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk4MzlcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwMjE2XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCIxMDIxN1wiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMjJcIjogWzAuMjQ0LCAwLjc0NCwgMCwgMF0sXG4gICAgICAgIFwiMTAyMjNcIjogWzAuMjQ0LCAwLjc0NCwgMCwgMF0sXG4gICAgICAgIFwiMTAyMjlcIjogWzAuMDExLCAwLjUxMSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMzBcIjogWzAuMDExLCAwLjUxMSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMzFcIjogWzAuMDExLCAwLjUxMSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMzJcIjogWzAuMDI0LCAwLjUyNSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMzNcIjogWzAuMDI0LCAwLjUyNSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMzRcIjogWzAuMDI0LCAwLjUyNSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMzZcIjogWzAuMDExLCAwLjUxMSwgMCwgMF0sXG4gICAgICAgIFwiMTA4MTVcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjEwOTI3XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCIxMDkyOFwiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMF1cbiAgICB9LFxuICAgIFwiTWF0aC1Cb2xkSXRhbGljXCI6IHtcbiAgICAgICAgXCI0N1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNjVcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjY2XCI6IFswLCAwLjY4NjExLCAwLjA0ODM1LCAwXSxcbiAgICAgICAgXCI2N1wiOiBbMCwgMC42ODYxMSwgMC4wNjk3OSwgMF0sXG4gICAgICAgIFwiNjhcIjogWzAsIDAuNjg2MTEsIDAuMDMxOTQsIDBdLFxuICAgICAgICBcIjY5XCI6IFswLCAwLjY4NjExLCAwLjA1NDUxLCAwXSxcbiAgICAgICAgXCI3MFwiOiBbMCwgMC42ODYxMSwgMC4xNTk3MiwgMF0sXG4gICAgICAgIFwiNzFcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjcyXCI6IFswLCAwLjY4NjExLCAwLjA4MjI5LCAwXSxcbiAgICAgICAgXCI3M1wiOiBbMCwgMC42ODYxMSwgMC4wNzc3OCwgMF0sXG4gICAgICAgIFwiNzRcIjogWzAsIDAuNjg2MTEsIDAuMTAwNjksIDBdLFxuICAgICAgICBcIjc1XCI6IFswLCAwLjY4NjExLCAwLjA2OTc5LCAwXSxcbiAgICAgICAgXCI3NlwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiNzdcIjogWzAsIDAuNjg2MTEsIDAuMTE0MjQsIDBdLFxuICAgICAgICBcIjc4XCI6IFswLCAwLjY4NjExLCAwLjExNDI0LCAwXSxcbiAgICAgICAgXCI3OVwiOiBbMCwgMC42ODYxMSwgMC4wMzE5NCwgMF0sXG4gICAgICAgIFwiODBcIjogWzAsIDAuNjg2MTEsIDAuMTU5NzIsIDBdLFxuICAgICAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI4MlwiOiBbMCwgMC42ODYxMSwgMC4wMDQyMSwgMF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNjg2MTEsIDAuMDUzODIsIDBdLFxuICAgICAgICBcIjg0XCI6IFswLCAwLjY4NjExLCAwLjE1OTcyLCAwXSxcbiAgICAgICAgXCI4NVwiOiBbMCwgMC42ODYxMSwgMC4xMTQyNCwgMF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNjg2MTEsIDAuMjU1NTUsIDBdLFxuICAgICAgICBcIjg3XCI6IFswLCAwLjY4NjExLCAwLjE1OTcyLCAwXSxcbiAgICAgICAgXCI4OFwiOiBbMCwgMC42ODYxMSwgMC4wNzc3OCwgMF0sXG4gICAgICAgIFwiODlcIjogWzAsIDAuNjg2MTEsIDAuMjU1NTUsIDBdLFxuICAgICAgICBcIjkwXCI6IFswLCAwLjY4NjExLCAwLjA2OTc5LCAwXSxcbiAgICAgICAgXCI5N1wiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwMVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTAyXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjExMDQyLCAwXSxcbiAgICAgICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDM3MDQsIDBdLFxuICAgICAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTA1XCI6IFswLCAwLjY5MzI2LCAwLCAwXSxcbiAgICAgICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjkzMjYsIDAuMDYyMiwgMF0sXG4gICAgICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLjAxODUyLCAwXSxcbiAgICAgICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAuMDA4OCwgMF0sXG4gICAgICAgIFwiMTA5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTBcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjExMVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDM3MDQsIDBdLFxuICAgICAgICBcIjExNFwiOiBbMCwgMC40NDQ0NCwgMC4wMzE5NCwgMF0sXG4gICAgICAgIFwiMTE1XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTZcIjogWzAsIDAuNjM0OTIsIDAsIDBdLFxuICAgICAgICBcIjExN1wiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTE4XCI6IFswLCAwLjQ0NDQ0LCAwLjAzNzA0LCAwXSxcbiAgICAgICAgXCIxMTlcIjogWzAsIDAuNDQ0NDQsIDAuMDI3NzgsIDBdLFxuICAgICAgICBcIjEyMFwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAzNzA0LCAwXSxcbiAgICAgICAgXCIxMjJcIjogWzAsIDAuNDQ0NDQsIDAuMDQyMTMsIDBdLFxuICAgICAgICBcIjkxNVwiOiBbMCwgMC42ODYxMSwgMC4xNTk3MiwgMF0sXG4gICAgICAgIFwiOTE2XCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI5MjBcIjogWzAsIDAuNjg2MTEsIDAuMDMxOTQsIDBdLFxuICAgICAgICBcIjkyM1wiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiOTI2XCI6IFswLCAwLjY4NjExLCAwLjA3NDU4LCAwXSxcbiAgICAgICAgXCI5MjhcIjogWzAsIDAuNjg2MTEsIDAuMDgyMjksIDBdLFxuICAgICAgICBcIjkzMVwiOiBbMCwgMC42ODYxMSwgMC4wNTQ1MSwgMF0sXG4gICAgICAgIFwiOTMzXCI6IFswLCAwLjY4NjExLCAwLjE1OTcyLCAwXSxcbiAgICAgICAgXCI5MzRcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjkzNlwiOiBbMCwgMC42ODYxMSwgMC4xMTY1MywgMF0sXG4gICAgICAgIFwiOTM3XCI6IFswLCAwLjY4NjExLCAwLjA0ODM1LCAwXSxcbiAgICAgICAgXCI5NDVcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjk0NlwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wMzQwMywgMF0sXG4gICAgICAgIFwiOTQ3XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjA2Mzg5LCAwXSxcbiAgICAgICAgXCI5NDhcIjogWzAsIDAuNjk0NDQsIDAuMDM4MTksIDBdLFxuICAgICAgICBcIjk0OVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTUwXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjA2MjE1LCAwXSxcbiAgICAgICAgXCI5NTFcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDM3MDQsIDBdLFxuICAgICAgICBcIjk1MlwiOiBbMCwgMC42OTQ0NCwgMC4wMzE5NCwgMF0sXG4gICAgICAgIFwiOTUzXCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5NTRcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjk1NVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTU2XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5NTdcIjogWzAsIDAuNDQ0NDQsIDAuMDY4OTgsIDBdLFxuICAgICAgICBcIjk1OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wMzAyMSwgMF0sXG4gICAgICAgIFwiOTU5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5NjBcIjogWzAsIDAuNDQ0NDQsIDAuMDM3MDQsIDBdLFxuICAgICAgICBcIjk2MVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTYyXCI6IFswLjA5NzIyLCAwLjQ0NDQ0LCAwLjA3OTE3LCAwXSxcbiAgICAgICAgXCI5NjNcIjogWzAsIDAuNDQ0NDQsIDAuMDM3MDQsIDBdLFxuICAgICAgICBcIjk2NFwiOiBbMCwgMC40NDQ0NCwgMC4xMzQ3MiwgMF0sXG4gICAgICAgIFwiOTY1XCI6IFswLCAwLjQ0NDQ0LCAwLjAzNzA0LCAwXSxcbiAgICAgICAgXCI5NjZcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjk2N1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTY4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjAzNzA0LCAwXSxcbiAgICAgICAgXCI5NjlcIjogWzAsIDAuNDQ0NDQsIDAuMDM3MDQsIDBdLFxuICAgICAgICBcIjk3N1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTgxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5ODJcIjogWzAsIDAuNDQ0NDQsIDAuMDMxOTQsIDBdLFxuICAgICAgICBcIjEwMDlcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwMTNcIjogWzAsIDAuNDQ0NDQsIDAsIDBdXG4gICAgfSxcbiAgICBcIk1hdGgtSXRhbGljXCI6IHtcbiAgICAgICAgXCI0N1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNjVcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTM4ODldLFxuICAgICAgICBcIjY2XCI6IFswLCAwLjY4MzMzLCAwLjA1MDE3LCAwLjA4MzM0XSxcbiAgICAgICAgXCI2N1wiOiBbMCwgMC42ODMzMywgMC4wNzE1MywgMC4wODMzNF0sXG4gICAgICAgIFwiNjhcIjogWzAsIDAuNjgzMzMsIDAuMDI3NzgsIDAuMDU1NTZdLFxuICAgICAgICBcIjY5XCI6IFswLCAwLjY4MzMzLCAwLjA1NzY0LCAwLjA4MzM0XSxcbiAgICAgICAgXCI3MFwiOiBbMCwgMC42ODMzMywgMC4xMzg4OSwgMC4wODMzNF0sXG4gICAgICAgIFwiNzFcIjogWzAsIDAuNjgzMzMsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjcyXCI6IFswLCAwLjY4MzMzLCAwLjA4MTI1LCAwLjA1NTU2XSxcbiAgICAgICAgXCI3M1wiOiBbMCwgMC42ODMzMywgMC4wNzg0NywgMC4xMTExMV0sXG4gICAgICAgIFwiNzRcIjogWzAsIDAuNjgzMzMsIDAuMDk2MTgsIDAuMTY2NjddLFxuICAgICAgICBcIjc1XCI6IFswLCAwLjY4MzMzLCAwLjA3MTUzLCAwLjA1NTU2XSxcbiAgICAgICAgXCI3NlwiOiBbMCwgMC42ODMzMywgMCwgMC4wMjc3OF0sXG4gICAgICAgIFwiNzdcIjogWzAsIDAuNjgzMzMsIDAuMTA5MDMsIDAuMDgzMzRdLFxuICAgICAgICBcIjc4XCI6IFswLCAwLjY4MzMzLCAwLjEwOTAzLCAwLjA4MzM0XSxcbiAgICAgICAgXCI3OVwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wODMzNF0sXG4gICAgICAgIFwiODBcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDgzMzRdLFxuICAgICAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4MzMzLCAwLCAwLjA4MzM0XSxcbiAgICAgICAgXCI4MlwiOiBbMCwgMC42ODMzMywgMC4wMDc3MywgMC4wODMzNF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNjgzMzMsIDAuMDU3NjQsIDAuMDgzMzRdLFxuICAgICAgICBcIjg0XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA4MzM0XSxcbiAgICAgICAgXCI4NVwiOiBbMCwgMC42ODMzMywgMC4xMDkwMywgMC4wMjc3OF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNjgzMzMsIDAuMjIyMjIsIDBdLFxuICAgICAgICBcIjg3XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwXSxcbiAgICAgICAgXCI4OFwiOiBbMCwgMC42ODMzMywgMC4wNzg0NywgMC4wODMzNF0sXG4gICAgICAgIFwiODlcIjogWzAsIDAuNjgzMzMsIDAuMjIyMjIsIDBdLFxuICAgICAgICBcIjkwXCI6IFswLCAwLjY4MzMzLCAwLjA3MTUzLCAwLjA4MzM0XSxcbiAgICAgICAgXCI5N1wiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk5XCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2XSxcbiAgICAgICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAsIDAuMTY2NjddLFxuICAgICAgICBcIjEwMVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiMTAyXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjEwNzY0LCAwLjE2NjY3XSxcbiAgICAgICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDI3NzhdLFxuICAgICAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTA1XCI6IFswLCAwLjY1OTUyLCAwLCAwXSxcbiAgICAgICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjU5NTIsIDAuMDU3MjQsIDBdLFxuICAgICAgICBcIjEwN1wiOiBbMCwgMC42OTQ0NCwgMC4wMzE0OCwgMF0sXG4gICAgICAgIFwiMTA4XCI6IFswLCAwLjY5NDQ0LCAwLjAxOTY4LCAwLjA4MzM0XSxcbiAgICAgICAgXCIxMDlcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjExMFwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTExXCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2XSxcbiAgICAgICAgXCIxMTJcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjExM1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wODMzNF0sXG4gICAgICAgIFwiMTE0XCI6IFswLCAwLjQzMDU2LCAwLjAyNzc4LCAwLjA1NTU2XSxcbiAgICAgICAgXCIxMTVcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTZdLFxuICAgICAgICBcIjExNlwiOiBbMCwgMC42MTUwOCwgMCwgMC4wODMzNF0sXG4gICAgICAgIFwiMTE3XCI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4XSxcbiAgICAgICAgXCIxMThcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDI3NzhdLFxuICAgICAgICBcIjExOVwiOiBbMCwgMC40MzA1NiwgMC4wMjY5MSwgMC4wODMzNF0sXG4gICAgICAgIFwiMTIwXCI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4XSxcbiAgICAgICAgXCIxMjFcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDU1NTZdLFxuICAgICAgICBcIjEyMlwiOiBbMCwgMC40MzA1NiwgMC4wNDM5OCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTE1XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA4MzM0XSxcbiAgICAgICAgXCI5MTZcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTY2NjddLFxuICAgICAgICBcIjkyMFwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTIzXCI6IFswLCAwLjY4MzMzLCAwLCAwLjE2NjY3XSxcbiAgICAgICAgXCI5MjZcIjogWzAsIDAuNjgzMzMsIDAuMDc1NjksIDAuMDgzMzRdLFxuICAgICAgICBcIjkyOFwiOiBbMCwgMC42ODMzMywgMC4wODEyNSwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTMxXCI6IFswLCAwLjY4MzMzLCAwLjA1NzY0LCAwLjA4MzM0XSxcbiAgICAgICAgXCI5MzNcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDU1NTZdLFxuICAgICAgICBcIjkzNFwiOiBbMCwgMC42ODMzMywgMCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTM2XCI6IFswLCAwLjY4MzMzLCAwLjExLCAwLjA1NTU2XSxcbiAgICAgICAgXCI5MzdcIjogWzAsIDAuNjgzMzMsIDAuMDUwMTcsIDAuMDgzMzRdLFxuICAgICAgICBcIjk0NVwiOiBbMCwgMC40MzA1NiwgMC4wMDM3LCAwLjAyNzc4XSxcbiAgICAgICAgXCI5NDZcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDUyNzgsIDAuMDgzMzRdLFxuICAgICAgICBcIjk0N1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wNTU1NiwgMF0sXG4gICAgICAgIFwiOTQ4XCI6IFswLCAwLjY5NDQ0LCAwLjAzNzg1LCAwLjA1NTU2XSxcbiAgICAgICAgXCI5NDlcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjk1MFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNzM3OCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTUxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAzNTg4LCAwLjA1NTU2XSxcbiAgICAgICAgXCI5NTJcIjogWzAsIDAuNjk0NDQsIDAuMDI3NzgsIDAuMDgzMzRdLFxuICAgICAgICBcIjk1M1wiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTU0XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI5NTVcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk1NlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wMjc3OF0sXG4gICAgICAgIFwiOTU3XCI6IFswLCAwLjQzMDU2LCAwLjA2MzY2LCAwLjAyNzc4XSxcbiAgICAgICAgXCI5NThcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDQ2MDEsIDAuMTExMTFdLFxuICAgICAgICBcIjk1OVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTYwXCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwXSxcbiAgICAgICAgXCI5NjFcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjk2MlwiOiBbMC4wOTcyMiwgMC40MzA1NiwgMC4wNzk4NiwgMC4wODMzNF0sXG4gICAgICAgIFwiOTYzXCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwXSxcbiAgICAgICAgXCI5NjRcIjogWzAsIDAuNDMwNTYsIDAuMTEzMiwgMC4wMjc3OF0sXG4gICAgICAgIFwiOTY1XCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwLjAyNzc4XSxcbiAgICAgICAgXCI5NjZcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjk2N1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTY4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjAzNTg4LCAwLjExMTExXSxcbiAgICAgICAgXCI5NjlcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDBdLFxuICAgICAgICBcIjk3N1wiOiBbMCwgMC42OTQ0NCwgMCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTgxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLjA4MzM0XSxcbiAgICAgICAgXCI5ODJcIjogWzAsIDAuNDMwNTYsIDAuMDI3NzgsIDBdLFxuICAgICAgICBcIjEwMDlcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjEwMTNcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTZdXG4gICAgfSxcbiAgICBcIk1hdGgtUmVndWxhclwiOiB7XG4gICAgICAgIFwiNjVcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTM4ODldLFxuICAgICAgICBcIjY2XCI6IFswLCAwLjY4MzMzLCAwLjA1MDE3LCAwLjA4MzM0XSxcbiAgICAgICAgXCI2N1wiOiBbMCwgMC42ODMzMywgMC4wNzE1MywgMC4wODMzNF0sXG4gICAgICAgIFwiNjhcIjogWzAsIDAuNjgzMzMsIDAuMDI3NzgsIDAuMDU1NTZdLFxuICAgICAgICBcIjY5XCI6IFswLCAwLjY4MzMzLCAwLjA1NzY0LCAwLjA4MzM0XSxcbiAgICAgICAgXCI3MFwiOiBbMCwgMC42ODMzMywgMC4xMzg4OSwgMC4wODMzNF0sXG4gICAgICAgIFwiNzFcIjogWzAsIDAuNjgzMzMsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjcyXCI6IFswLCAwLjY4MzMzLCAwLjA4MTI1LCAwLjA1NTU2XSxcbiAgICAgICAgXCI3M1wiOiBbMCwgMC42ODMzMywgMC4wNzg0NywgMC4xMTExMV0sXG4gICAgICAgIFwiNzRcIjogWzAsIDAuNjgzMzMsIDAuMDk2MTgsIDAuMTY2NjddLFxuICAgICAgICBcIjc1XCI6IFswLCAwLjY4MzMzLCAwLjA3MTUzLCAwLjA1NTU2XSxcbiAgICAgICAgXCI3NlwiOiBbMCwgMC42ODMzMywgMCwgMC4wMjc3OF0sXG4gICAgICAgIFwiNzdcIjogWzAsIDAuNjgzMzMsIDAuMTA5MDMsIDAuMDgzMzRdLFxuICAgICAgICBcIjc4XCI6IFswLCAwLjY4MzMzLCAwLjEwOTAzLCAwLjA4MzM0XSxcbiAgICAgICAgXCI3OVwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wODMzNF0sXG4gICAgICAgIFwiODBcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDgzMzRdLFxuICAgICAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4MzMzLCAwLCAwLjA4MzM0XSxcbiAgICAgICAgXCI4MlwiOiBbMCwgMC42ODMzMywgMC4wMDc3MywgMC4wODMzNF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNjgzMzMsIDAuMDU3NjQsIDAuMDgzMzRdLFxuICAgICAgICBcIjg0XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA4MzM0XSxcbiAgICAgICAgXCI4NVwiOiBbMCwgMC42ODMzMywgMC4xMDkwMywgMC4wMjc3OF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNjgzMzMsIDAuMjIyMjIsIDBdLFxuICAgICAgICBcIjg3XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwXSxcbiAgICAgICAgXCI4OFwiOiBbMCwgMC42ODMzMywgMC4wNzg0NywgMC4wODMzNF0sXG4gICAgICAgIFwiODlcIjogWzAsIDAuNjgzMzMsIDAuMjIyMjIsIDBdLFxuICAgICAgICBcIjkwXCI6IFswLCAwLjY4MzMzLCAwLjA3MTUzLCAwLjA4MzM0XSxcbiAgICAgICAgXCI5N1wiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk5XCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2XSxcbiAgICAgICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAsIDAuMTY2NjddLFxuICAgICAgICBcIjEwMVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiMTAyXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjEwNzY0LCAwLjE2NjY3XSxcbiAgICAgICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDI3NzhdLFxuICAgICAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTA1XCI6IFswLCAwLjY1OTUyLCAwLCAwXSxcbiAgICAgICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjU5NTIsIDAuMDU3MjQsIDBdLFxuICAgICAgICBcIjEwN1wiOiBbMCwgMC42OTQ0NCwgMC4wMzE0OCwgMF0sXG4gICAgICAgIFwiMTA4XCI6IFswLCAwLjY5NDQ0LCAwLjAxOTY4LCAwLjA4MzM0XSxcbiAgICAgICAgXCIxMDlcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjExMFwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTExXCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2XSxcbiAgICAgICAgXCIxMTJcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjExM1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wODMzNF0sXG4gICAgICAgIFwiMTE0XCI6IFswLCAwLjQzMDU2LCAwLjAyNzc4LCAwLjA1NTU2XSxcbiAgICAgICAgXCIxMTVcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTZdLFxuICAgICAgICBcIjExNlwiOiBbMCwgMC42MTUwOCwgMCwgMC4wODMzNF0sXG4gICAgICAgIFwiMTE3XCI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4XSxcbiAgICAgICAgXCIxMThcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDI3NzhdLFxuICAgICAgICBcIjExOVwiOiBbMCwgMC40MzA1NiwgMC4wMjY5MSwgMC4wODMzNF0sXG4gICAgICAgIFwiMTIwXCI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4XSxcbiAgICAgICAgXCIxMjFcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDU1NTZdLFxuICAgICAgICBcIjEyMlwiOiBbMCwgMC40MzA1NiwgMC4wNDM5OCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTE1XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA4MzM0XSxcbiAgICAgICAgXCI5MTZcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTY2NjddLFxuICAgICAgICBcIjkyMFwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTIzXCI6IFswLCAwLjY4MzMzLCAwLCAwLjE2NjY3XSxcbiAgICAgICAgXCI5MjZcIjogWzAsIDAuNjgzMzMsIDAuMDc1NjksIDAuMDgzMzRdLFxuICAgICAgICBcIjkyOFwiOiBbMCwgMC42ODMzMywgMC4wODEyNSwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTMxXCI6IFswLCAwLjY4MzMzLCAwLjA1NzY0LCAwLjA4MzM0XSxcbiAgICAgICAgXCI5MzNcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDU1NTZdLFxuICAgICAgICBcIjkzNFwiOiBbMCwgMC42ODMzMywgMCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTM2XCI6IFswLCAwLjY4MzMzLCAwLjExLCAwLjA1NTU2XSxcbiAgICAgICAgXCI5MzdcIjogWzAsIDAuNjgzMzMsIDAuMDUwMTcsIDAuMDgzMzRdLFxuICAgICAgICBcIjk0NVwiOiBbMCwgMC40MzA1NiwgMC4wMDM3LCAwLjAyNzc4XSxcbiAgICAgICAgXCI5NDZcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDUyNzgsIDAuMDgzMzRdLFxuICAgICAgICBcIjk0N1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wNTU1NiwgMF0sXG4gICAgICAgIFwiOTQ4XCI6IFswLCAwLjY5NDQ0LCAwLjAzNzg1LCAwLjA1NTU2XSxcbiAgICAgICAgXCI5NDlcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjk1MFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNzM3OCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTUxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAzNTg4LCAwLjA1NTU2XSxcbiAgICAgICAgXCI5NTJcIjogWzAsIDAuNjk0NDQsIDAuMDI3NzgsIDAuMDgzMzRdLFxuICAgICAgICBcIjk1M1wiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTU0XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI5NTVcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk1NlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wMjc3OF0sXG4gICAgICAgIFwiOTU3XCI6IFswLCAwLjQzMDU2LCAwLjA2MzY2LCAwLjAyNzc4XSxcbiAgICAgICAgXCI5NThcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDQ2MDEsIDAuMTExMTFdLFxuICAgICAgICBcIjk1OVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTYwXCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwXSxcbiAgICAgICAgXCI5NjFcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjk2MlwiOiBbMC4wOTcyMiwgMC40MzA1NiwgMC4wNzk4NiwgMC4wODMzNF0sXG4gICAgICAgIFwiOTYzXCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwXSxcbiAgICAgICAgXCI5NjRcIjogWzAsIDAuNDMwNTYsIDAuMTEzMiwgMC4wMjc3OF0sXG4gICAgICAgIFwiOTY1XCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwLjAyNzc4XSxcbiAgICAgICAgXCI5NjZcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjk2N1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTY4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjAzNTg4LCAwLjExMTExXSxcbiAgICAgICAgXCI5NjlcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDBdLFxuICAgICAgICBcIjk3N1wiOiBbMCwgMC42OTQ0NCwgMCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTgxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLjA4MzM0XSxcbiAgICAgICAgXCI5ODJcIjogWzAsIDAuNDMwNTYsIDAuMDI3NzgsIDBdLFxuICAgICAgICBcIjEwMDlcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjEwMTNcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTZdXG4gICAgfSxcbiAgICBcIlNhbnNTZXJpZi1SZWd1bGFyXCI6IHtcbiAgICAgICAgXCIzM1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMzRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjM1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIzNlwiOiBbMC4wNTU1NiwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiMzdcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjM4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIzOVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNDBcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjQxXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI0MlwiOiBbMCwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiNDNcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDBdLFxuICAgICAgICBcIjQ0XCI6IFswLjEyNSwgMC4wODMzMywgMCwgMF0sXG4gICAgICAgIFwiNDVcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjQ2XCI6IFswLCAwLjA4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI0N1wiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiNDhcIjogWzAsIDAuNjU1NTYsIDAsIDBdLFxuICAgICAgICBcIjQ5XCI6IFswLCAwLjY1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI1MFwiOiBbMCwgMC42NTU1NiwgMCwgMF0sXG4gICAgICAgIFwiNTFcIjogWzAsIDAuNjU1NTYsIDAsIDBdLFxuICAgICAgICBcIjUyXCI6IFswLCAwLjY1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI1M1wiOiBbMCwgMC42NTU1NiwgMCwgMF0sXG4gICAgICAgIFwiNTRcIjogWzAsIDAuNjU1NTYsIDAsIDBdLFxuICAgICAgICBcIjU1XCI6IFswLCAwLjY1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI1NlwiOiBbMCwgMC42NTU1NiwgMCwgMF0sXG4gICAgICAgIFwiNTdcIjogWzAsIDAuNjU1NTYsIDAsIDBdLFxuICAgICAgICBcIjU4XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1OVwiOiBbMC4xMjUsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjYxXCI6IFstMC4xMywgMC4zNywgMCwgMF0sXG4gICAgICAgIFwiNjNcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjY0XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI2NVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNjZcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI2OFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNjlcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjcwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3MVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzJcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjczXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzVcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3N1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc5XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODFcIjogWzAuMTI1LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MlwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjg0XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNjk0NDQsIDAuMDEzODksIDBdLFxuICAgICAgICBcIjg3XCI6IFswLCAwLjY5NDQ0LCAwLjAxMzg5LCAwXSxcbiAgICAgICAgXCI4OFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODlcIjogWzAsIDAuNjk0NDQsIDAuMDI1LCAwXSxcbiAgICAgICAgXCI5MFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTFcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjkzXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI5NFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTVcIjogWzAuMzUsIDAuMDk0NDQsIDAuMDI3NzgsIDBdLFxuICAgICAgICBcIjk3XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5OFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTlcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwMFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTAxXCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMDJcIjogWzAsIDAuNjk0NDQsIDAuMDY5NDQsIDBdLFxuICAgICAgICBcIjEwM1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wMTM4OSwgMF0sXG4gICAgICAgIFwiMTA0XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMDVcIjogWzAsIDAuNjc5MzcsIDAsIDBdLFxuICAgICAgICBcIjEwNlwiOiBbMC4xOTQ0NCwgMC42NzkzNywgMCwgMF0sXG4gICAgICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwOVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTEwXCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTFcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTEzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTRcIjogWzAsIDAuNDQ0NDQsIDAuMDEzODksIDBdLFxuICAgICAgICBcIjExNVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTE2XCI6IFswLCAwLjU3MTQzLCAwLCAwXSxcbiAgICAgICAgXCIxMTdcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjExOFwiOiBbMCwgMC40NDQ0NCwgMC4wMTM4OSwgMF0sXG4gICAgICAgIFwiMTE5XCI6IFswLCAwLjQ0NDQ0LCAwLjAxMzg5LCAwXSxcbiAgICAgICAgXCIxMjBcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjEyMVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wMTM4OSwgMF0sXG4gICAgICAgIFwiMTIyXCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMjZcIjogWzAuMzUsIDAuMzI2NTksIDAsIDBdLFxuICAgICAgICBcIjMwNVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTY3XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NjhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc2OVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzcwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NzFcIjogWzAsIDAuNjc2NTksIDAsIDBdLFxuICAgICAgICBcIjc3MlwiOiBbMCwgMC42MDg4OSwgMCwgMF0sXG4gICAgICAgIFwiNzc0XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NzVcIjogWzAsIDAuNjc5MzcsIDAsIDBdLFxuICAgICAgICBcIjc3NlwiOiBbMCwgMC42NzkzNywgMCwgMF0sXG4gICAgICAgIFwiNzc4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NzlcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc4MFwiOiBbMCwgMC42MzE5NCwgMCwgMF0sXG4gICAgICAgIFwiOTE1XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5MTZcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjkyMFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTIzXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5MjZcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjkyOFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTMxXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5MzNcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjkzNFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTM2XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5MzdcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjgyMTFcIjogWzAsIDAuNDQ0NDQsIDAuMDI3NzgsIDBdLFxuICAgICAgICBcIjgyMTJcIjogWzAsIDAuNDQ0NDQsIDAuMDI3NzgsIDBdLFxuICAgICAgICBcIjgyMTZcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjgyMTdcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjgyMjBcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjgyMjFcIjogWzAsIDAuNjk0NDQsIDAsIDBdXG4gICAgfSxcbiAgICBcIlNjcmlwdC1SZWd1bGFyXCI6IHtcbiAgICAgICAgXCI2NVwiOiBbMCwgMC43LCAwLjIyOTI1LCAwXSxcbiAgICAgICAgXCI2NlwiOiBbMCwgMC43LCAwLjA0MDg3LCAwXSxcbiAgICAgICAgXCI2N1wiOiBbMCwgMC43LCAwLjE2ODksIDBdLFxuICAgICAgICBcIjY4XCI6IFswLCAwLjcsIDAuMDkzNzEsIDBdLFxuICAgICAgICBcIjY5XCI6IFswLCAwLjcsIDAuMTg1ODMsIDBdLFxuICAgICAgICBcIjcwXCI6IFswLCAwLjcsIDAuMTM2MzQsIDBdLFxuICAgICAgICBcIjcxXCI6IFswLCAwLjcsIDAuMTczMjIsIDBdLFxuICAgICAgICBcIjcyXCI6IFswLCAwLjcsIDAuMjk2OTQsIDBdLFxuICAgICAgICBcIjczXCI6IFswLCAwLjcsIDAuMTkxODksIDBdLFxuICAgICAgICBcIjc0XCI6IFswLjI3Nzc4LCAwLjcsIDAuMTkxODksIDBdLFxuICAgICAgICBcIjc1XCI6IFswLCAwLjcsIDAuMzEyNTksIDBdLFxuICAgICAgICBcIjc2XCI6IFswLCAwLjcsIDAuMTkxODksIDBdLFxuICAgICAgICBcIjc3XCI6IFswLCAwLjcsIDAuMTU5ODEsIDBdLFxuICAgICAgICBcIjc4XCI6IFswLCAwLjcsIDAuMzUyNSwgMF0sXG4gICAgICAgIFwiNzlcIjogWzAsIDAuNywgMC4wODA3OCwgMF0sXG4gICAgICAgIFwiODBcIjogWzAsIDAuNywgMC4wODA3OCwgMF0sXG4gICAgICAgIFwiODFcIjogWzAsIDAuNywgMC4wMzMwNSwgMF0sXG4gICAgICAgIFwiODJcIjogWzAsIDAuNywgMC4wNjI1OSwgMF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNywgMC4xOTE4OSwgMF0sXG4gICAgICAgIFwiODRcIjogWzAsIDAuNywgMC4yOTA4NywgMF0sXG4gICAgICAgIFwiODVcIjogWzAsIDAuNywgMC4yNTgxNSwgMF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNywgMC4yNzUyMywgMF0sXG4gICAgICAgIFwiODdcIjogWzAsIDAuNywgMC4yNzUyMywgMF0sXG4gICAgICAgIFwiODhcIjogWzAsIDAuNywgMC4yNjAwNiwgMF0sXG4gICAgICAgIFwiODlcIjogWzAsIDAuNywgMC4yOTM5LCAwXSxcbiAgICAgICAgXCI5MFwiOiBbMCwgMC43LCAwLjI0MDM3LCAwXVxuICAgIH0sXG4gICAgXCJTaXplMS1SZWd1bGFyXCI6IHtcbiAgICAgICAgXCI0MFwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMF0sXG4gICAgICAgIFwiNDFcIjogWzAuMzUwMDEsIDAuODUsIDAsIDBdLFxuICAgICAgICBcIjQ3XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwXSxcbiAgICAgICAgXCI5MVwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMF0sXG4gICAgICAgIFwiOTJcIjogWzAuMzUwMDEsIDAuODUsIDAsIDBdLFxuICAgICAgICBcIjkzXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwXSxcbiAgICAgICAgXCIxMjNcIjogWzAuMzUwMDEsIDAuODUsIDAsIDBdLFxuICAgICAgICBcIjEyNVwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMF0sXG4gICAgICAgIFwiNzEwXCI6IFswLCAwLjcyMjIyLCAwLCAwXSxcbiAgICAgICAgXCI3MzJcIjogWzAsIDAuNzIyMjIsIDAsIDBdLFxuICAgICAgICBcIjc3MFwiOiBbMCwgMC43MjIyMiwgMCwgMF0sXG4gICAgICAgIFwiNzcxXCI6IFswLCAwLjcyMjIyLCAwLCAwXSxcbiAgICAgICAgXCI4MjE0XCI6IFstMC4wMDA5OSwgMC42MDEsIDAsIDBdLFxuICAgICAgICBcIjg1OTNcIjogWzFlLTA1LCAwLjYsIDAsIDBdLFxuICAgICAgICBcIjg1OTVcIjogWzFlLTA1LCAwLjYsIDAsIDBdLFxuICAgICAgICBcIjg2NTdcIjogWzFlLTA1LCAwLjYsIDAsIDBdLFxuICAgICAgICBcIjg2NTlcIjogWzFlLTA1LCAwLjYsIDAsIDBdLFxuICAgICAgICBcIjg3MTlcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MjBcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MjFcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MzBcIjogWzAuMzUwMDEsIDAuODUsIDAsIDBdLFxuICAgICAgICBcIjg3MzlcIjogWy0wLjAwNTk5LCAwLjYwNiwgMCwgMF0sXG4gICAgICAgIFwiODc0MVwiOiBbLTAuMDA1OTksIDAuNjA2LCAwLCAwXSxcbiAgICAgICAgXCI4NzQ3XCI6IFswLjMwNjEyLCAwLjgwNSwgMC4xOTQ0NSwgMF0sXG4gICAgICAgIFwiODc0OFwiOiBbMC4zMDYsIDAuODA1LCAwLjE5NDQ1LCAwXSxcbiAgICAgICAgXCI4NzQ5XCI6IFswLjMwNiwgMC44MDUsIDAuMTk0NDUsIDBdLFxuICAgICAgICBcIjg3NTBcIjogWzAuMzA2MTIsIDAuODA1LCAwLjE5NDQ1LCAwXSxcbiAgICAgICAgXCI4ODk2XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4ODk3XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4ODk4XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4ODk5XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY4XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY5XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcwXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcxXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwXSxcbiAgICAgICAgXCI5MTY4XCI6IFstMC4wMDA5OSwgMC42MDEsIDAsIDBdLFxuICAgICAgICBcIjEwMjE2XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwXSxcbiAgICAgICAgXCIxMDIxN1wiOiBbMC4zNTAwMSwgMC44NSwgMCwgMF0sXG4gICAgICAgIFwiMTA3NTJcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjEwNzUzXCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCIxMDc1NFwiOiBbMC4yNTAwMSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiMTA3NTZcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjEwNzU4XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwXVxuICAgIH0sXG4gICAgXCJTaXplMi1SZWd1bGFyXCI6IHtcbiAgICAgICAgXCI0MFwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMF0sXG4gICAgICAgIFwiNDFcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjQ3XCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwXSxcbiAgICAgICAgXCI5MVwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMF0sXG4gICAgICAgIFwiOTJcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjkzXCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwXSxcbiAgICAgICAgXCIxMjNcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjEyNVwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMF0sXG4gICAgICAgIFwiNzEwXCI6IFswLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI3MzJcIjogWzAsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjc3MFwiOiBbMCwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiNzcxXCI6IFswLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NzE5XCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwXSxcbiAgICAgICAgXCI4NzIwXCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwXSxcbiAgICAgICAgXCI4NzIxXCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwXSxcbiAgICAgICAgXCI4NzMwXCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwXSxcbiAgICAgICAgXCI4NzQ3XCI6IFswLjg2MjI1LCAxLjM2LCAwLjQ0NDQ1LCAwXSxcbiAgICAgICAgXCI4NzQ4XCI6IFswLjg2MiwgMS4zNiwgMC40NDQ0NSwgMF0sXG4gICAgICAgIFwiODc0OVwiOiBbMC44NjIsIDEuMzYsIDAuNDQ0NDUsIDBdLFxuICAgICAgICBcIjg3NTBcIjogWzAuODYyMjUsIDEuMzYsIDAuNDQ0NDUsIDBdLFxuICAgICAgICBcIjg4OTZcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDBdLFxuICAgICAgICBcIjg4OTdcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDBdLFxuICAgICAgICBcIjg4OThcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDBdLFxuICAgICAgICBcIjg4OTlcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDBdLFxuICAgICAgICBcIjg5NjhcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjg5NjlcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjg5NzBcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjg5NzFcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjEwMjE2XCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwXSxcbiAgICAgICAgXCIxMDIxN1wiOiBbMC42NTAwMiwgMS4xNSwgMCwgMF0sXG4gICAgICAgIFwiMTA3NTJcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDBdLFxuICAgICAgICBcIjEwNzUzXCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwXSxcbiAgICAgICAgXCIxMDc1NFwiOiBbMC41NTAwMSwgMS4wNSwgMCwgMF0sXG4gICAgICAgIFwiMTA3NTZcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDBdLFxuICAgICAgICBcIjEwNzU4XCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwXVxuICAgIH0sXG4gICAgXCJTaXplMy1SZWd1bGFyXCI6IHtcbiAgICAgICAgXCI0MFwiOiBbMC45NTAwMywgMS40NSwgMCwgMF0sXG4gICAgICAgIFwiNDFcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDBdLFxuICAgICAgICBcIjQ3XCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwXSxcbiAgICAgICAgXCI5MVwiOiBbMC45NTAwMywgMS40NSwgMCwgMF0sXG4gICAgICAgIFwiOTJcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDBdLFxuICAgICAgICBcIjkzXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwXSxcbiAgICAgICAgXCIxMjNcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDBdLFxuICAgICAgICBcIjEyNVwiOiBbMC45NTAwMywgMS40NSwgMCwgMF0sXG4gICAgICAgIFwiNzEwXCI6IFswLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI3MzJcIjogWzAsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjc3MFwiOiBbMCwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiNzcxXCI6IFswLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NzMwXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY4XCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY5XCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcwXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcxXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwXSxcbiAgICAgICAgXCIxMDIxNlwiOiBbMC45NTAwMywgMS40NSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMTdcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDBdXG4gICAgfSxcbiAgICBcIlNpemU0LVJlZ3VsYXJcIjoge1xuICAgICAgICBcIjQwXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI0MVwiOiBbMS4yNTAwMywgMS43NSwgMCwgMF0sXG4gICAgICAgIFwiNDdcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDBdLFxuICAgICAgICBcIjkxXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI5MlwiOiBbMS4yNTAwMywgMS43NSwgMCwgMF0sXG4gICAgICAgIFwiOTNcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDBdLFxuICAgICAgICBcIjEyM1wiOiBbMS4yNTAwMywgMS43NSwgMCwgMF0sXG4gICAgICAgIFwiMTI1XCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI3MTBcIjogWzAsIDAuODI1LCAwLCAwXSxcbiAgICAgICAgXCI3MzJcIjogWzAsIDAuODI1LCAwLCAwXSxcbiAgICAgICAgXCI3NzBcIjogWzAsIDAuODI1LCAwLCAwXSxcbiAgICAgICAgXCI3NzFcIjogWzAsIDAuODI1LCAwLCAwXSxcbiAgICAgICAgXCI4NzMwXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY4XCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY5XCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcwXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcxXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI5MTE1XCI6IFswLjY0NTAyLCAxLjE1NSwgMCwgMF0sXG4gICAgICAgIFwiOTExNlwiOiBbMWUtMDUsIDAuNiwgMCwgMF0sXG4gICAgICAgIFwiOTExN1wiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDBdLFxuICAgICAgICBcIjkxMThcIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwXSxcbiAgICAgICAgXCI5MTE5XCI6IFsxZS0wNSwgMC42LCAwLCAwXSxcbiAgICAgICAgXCI5MTIwXCI6IFswLjY0NTAyLCAxLjE1NSwgMCwgMF0sXG4gICAgICAgIFwiOTEyMVwiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDBdLFxuICAgICAgICBcIjkxMjJcIjogWy0wLjAwMDk5LCAwLjYwMSwgMCwgMF0sXG4gICAgICAgIFwiOTEyM1wiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDBdLFxuICAgICAgICBcIjkxMjRcIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwXSxcbiAgICAgICAgXCI5MTI1XCI6IFstMC4wMDA5OSwgMC42MDEsIDAsIDBdLFxuICAgICAgICBcIjkxMjZcIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwXSxcbiAgICAgICAgXCI5MTI3XCI6IFsxZS0wNSwgMC45LCAwLCAwXSxcbiAgICAgICAgXCI5MTI4XCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwXSxcbiAgICAgICAgXCI5MTI5XCI6IFswLjkwMDAxLCAwLCAwLCAwXSxcbiAgICAgICAgXCI5MTMwXCI6IFswLCAwLjMsIDAsIDBdLFxuICAgICAgICBcIjkxMzFcIjogWzFlLTA1LCAwLjksIDAsIDBdLFxuICAgICAgICBcIjkxMzJcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjkxMzNcIjogWzAuOTAwMDEsIDAsIDAsIDBdLFxuICAgICAgICBcIjkxNDNcIjogWzAuODg1MDIsIDAuOTE1LCAwLCAwXSxcbiAgICAgICAgXCIxMDIxNlwiOiBbMS4yNTAwMywgMS43NSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMTdcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDBdLFxuICAgICAgICBcIjU3MzQ0XCI6IFstMC4wMDQ5OSwgMC42MDUsIDAsIDBdLFxuICAgICAgICBcIjU3MzQ1XCI6IFstMC4wMDQ5OSwgMC42MDUsIDAsIDBdLFxuICAgICAgICBcIjU3NjgwXCI6IFswLCAwLjEyLCAwLCAwXSxcbiAgICAgICAgXCI1NzY4MVwiOiBbMCwgMC4xMiwgMCwgMF0sXG4gICAgICAgIFwiNTc2ODJcIjogWzAsIDAuMTIsIDAsIDBdLFxuICAgICAgICBcIjU3NjgzXCI6IFswLCAwLjEyLCAwLCAwXVxuICAgIH0sXG4gICAgXCJUeXBld3JpdGVyLVJlZ3VsYXJcIjoge1xuICAgICAgICBcIjMzXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCIzNFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiMzVcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjM2XCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIzN1wiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMzhcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjM5XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI0MFwiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNDFcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjQyXCI6IFswLCAwLjUyMDgzLCAwLCAwXSxcbiAgICAgICAgXCI0M1wiOiBbLTAuMDgwNTYsIDAuNTMwNTUsIDAsIDBdLFxuICAgICAgICBcIjQ0XCI6IFswLjEzODg5LCAwLjEyNSwgMCwgMF0sXG4gICAgICAgIFwiNDVcIjogWy0wLjA4MDU2LCAwLjUzMDU1LCAwLCAwXSxcbiAgICAgICAgXCI0NlwiOiBbMCwgMC4xMjUsIDAsIDBdLFxuICAgICAgICBcIjQ3XCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI0OFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNDlcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjUwXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI1MVwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNTJcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjUzXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI1NFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNTVcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjU2XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI1N1wiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNThcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjU5XCI6IFswLjEzODg5LCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI2MFwiOiBbLTAuMDU1NTYsIDAuNTU1NTYsIDAsIDBdLFxuICAgICAgICBcIjYxXCI6IFstMC4xOTU0OSwgMC40MTU2MiwgMCwgMF0sXG4gICAgICAgIFwiNjJcIjogWy0wLjA1NTU2LCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI2M1wiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNjRcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjY1XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI2NlwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNjdcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjY4XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI2OVwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNzBcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjcxXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI3MlwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNzNcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjc0XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI3NVwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNzZcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjc3XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI3OFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNzlcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjgwXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI4MVwiOiBbMC4xMzg4OSwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiODJcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjgzXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI4NFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiODVcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjg2XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI4N1wiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiODhcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjg5XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI5MFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiOTFcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjkyXCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5M1wiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTRcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjk1XCI6IFswLjA5NTE0LCAwLCAwLCAwXSxcbiAgICAgICAgXCI5NlwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiOTdcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjk4XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI5OVwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTAwXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCIxMDFcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjEwMlwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiMTAzXCI6IFswLjIyMjIyLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMDRcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjEwNVwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiMTA2XCI6IFswLjIyMjIyLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCIxMDdcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjEwOFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiMTA5XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMTBcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjExMVwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTEyXCI6IFswLjIyMjIyLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMTNcIjogWzAuMjIyMjIsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjExNFwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTE1XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMTZcIjogWzAsIDAuNTUzNTgsIDAsIDBdLFxuICAgICAgICBcIjExN1wiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTE4XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMTlcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjEyMFwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTIxXCI6IFswLjIyMjIyLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMjJcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjEyM1wiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTI0XCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMjVcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEyNlwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiMTI3XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCIzMDVcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjU2N1wiOiBbMC4yMjIyMiwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiNzY4XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI3NjlcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjc3MFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNzcxXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI3NzJcIjogWzAsIDAuNTY1NTUsIDAsIDBdLFxuICAgICAgICBcIjc3NFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNzc2XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI3NzhcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjc4MFwiOiBbMCwgMC41NjU5NywgMCwgMF0sXG4gICAgICAgIFwiOTE1XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI5MTZcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjkyMFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiOTIzXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI5MjZcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjkyOFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiOTMxXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI5MzNcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjkzNFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiOTM2XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI5MzdcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjIwMThcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjIwMTlcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjgyNDJcIjogWzAsIDAuNjExMTEsIDAsIDBdXG4gICAgfVxufTtcbiIsInZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIFBhcnNlRXJyb3IgPSByZXF1aXJlKFwiLi9QYXJzZUVycm9yXCIpO1xudmFyIHBhcnNlRGF0YSA9IHJlcXVpcmUoXCIuL3BhcnNlRGF0YVwiKTtcbnZhciBQYXJzZU5vZGUgPSBwYXJzZURhdGEuUGFyc2VOb2RlO1xuXG4vKiBUaGlzIGZpbGUgY29udGFpbnMgYSBsaXN0IG9mIGZ1bmN0aW9ucyB0aGF0IHdlIHBhcnNlLCBpZGVudGlmaWVkIGJ5XG4gKiB0aGUgY2FsbHMgdG8gZGVmaW5lRnVuY3Rpb24uXG4gKlxuICogVGhlIGZpcnN0IGFyZ3VtZW50IHRvIGRlZmluZUZ1bmN0aW9uIGlzIGEgc2luZ2xlIG5hbWUgb3IgYSBsaXN0IG9mIG5hbWVzLlxuICogQWxsIGZ1bmN0aW9ucyBuYW1lZCBpbiBzdWNoIGEgbGlzdCB3aWxsIHNoYXJlIGEgc2luZ2xlIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEVhY2ggZGVjbGFyZWQgZnVuY3Rpb24gY2FuIGhhdmUgYXNzb2NpYXRlZCBwcm9wZXJ0aWVzLCB3aGljaFxuICogaW5jbHVkZSB0aGUgZm9sbG93aW5nOlxuICpcbiAqICAtIG51bUFyZ3M6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRoZSBmdW5jdGlvbiB0YWtlcy5cbiAqICAgICAgICAgICAgIElmIHRoaXMgaXMgdGhlIG9ubHkgcHJvcGVydHksIGl0IGNhbiBiZSBwYXNzZWQgYXMgYSBudW1iZXJcbiAqICAgICAgICAgICAgIGluc3RlYWQgb2YgYW4gZWxlbWVudCBvZiBhIHByb3BlcnRpZXMgb2JqZWN0LlxuICogIC0gYXJnVHlwZXM6IChvcHRpb25hbCkgQW4gYXJyYXkgY29ycmVzcG9uZGluZyB0byBlYWNoIGFyZ3VtZW50IG9mIHRoZVxuICogICAgICAgICAgICAgIGZ1bmN0aW9uLCBnaXZpbmcgdGhlIHR5cGUgb2YgYXJndW1lbnQgdGhhdCBzaG91bGQgYmUgcGFyc2VkLiBJdHNcbiAqICAgICAgICAgICAgICBsZW5ndGggc2hvdWxkIGJlIGVxdWFsIHRvIGBudW1BcmdzICsgbnVtT3B0aW9uYWxBcmdzYC4gVmFsaWRcbiAqICAgICAgICAgICAgICB0eXBlczpcbiAqICAgICAgICAgICAgICAgLSBcInNpemVcIjogQSBzaXplLWxpa2UgdGhpbmcsIHN1Y2ggYXMgXCIxZW1cIiBvciBcIjVleFwiXG4gKiAgICAgICAgICAgICAgIC0gXCJjb2xvclwiOiBBbiBodG1sIGNvbG9yLCBsaWtlIFwiI2FiY1wiIG9yIFwiYmx1ZVwiXG4gKiAgICAgICAgICAgICAgIC0gXCJvcmlnaW5hbFwiOiBUaGUgc2FtZSB0eXBlIGFzIHRoZSBlbnZpcm9ubWVudCB0aGF0IHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGJlaW5nIHBhcnNlZCBpcyBpbiAoZS5nLiB1c2VkIGZvciB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2RpZXMgb2YgZnVuY3Rpb25zIGxpa2UgXFxjb2xvciB3aGVyZSB0aGUgZmlyc3RcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudCBpcyBzcGVjaWFsIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkIG5vcm1hbGx5KVxuICogICAgICAgICAgICAgIE90aGVyIHBvc3NpYmxlIHR5cGVzIChwcm9iYWJseSBzaG91bGRuJ3QgYmUgdXNlZClcbiAqICAgICAgICAgICAgICAgLSBcInRleHRcIjogVGV4dC1saWtlIChlLmcuIFxcdGV4dClcbiAqICAgICAgICAgICAgICAgLSBcIm1hdGhcIjogTm9ybWFsIG1hdGhcbiAqICAgICAgICAgICAgICBJZiB1bmRlZmluZWQsIHRoaXMgd2lsbCBiZSB0cmVhdGVkIGFzIGFuIGFwcHJvcHJpYXRlIGxlbmd0aFxuICogICAgICAgICAgICAgIGFycmF5IG9mIFwib3JpZ2luYWxcIiBzdHJpbmdzXG4gKiAgLSBncmVlZGluZXNzOiAob3B0aW9uYWwpIFRoZSBncmVlZGluZXNzIG9mIHRoZSBmdW5jdGlvbiB0byB1c2UgdW5ncm91cGVkXG4gKiAgICAgICAgICAgICAgICBhcmd1bWVudHMuXG4gKlxuICogICAgICAgICAgICAgICAgRS5nLiBpZiB5b3UgaGF2ZSBhbiBleHByZXNzaW9uXG4gKiAgICAgICAgICAgICAgICAgIFxcc3FydCBcXGZyYWMgMSAyXG4gKiAgICAgICAgICAgICAgICBzaW5jZSBcXGZyYWMgaGFzIGdyZWVkaW5lc3M9MiB2cyBcXHNxcnQncyBncmVlZGluZXNzPTEsIFxcZnJhY1xuICogICAgICAgICAgICAgICAgd2lsbCB1c2UgdGhlIHR3byBhcmd1bWVudHMgJzEnIGFuZCAnMicgYXMgaXRzIHR3byBhcmd1bWVudHMsXG4gKiAgICAgICAgICAgICAgICB0aGVuIHRoYXQgd2hvbGUgZnVuY3Rpb24gd2lsbCBiZSB1c2VkIGFzIHRoZSBhcmd1bWVudCB0b1xuICogICAgICAgICAgICAgICAgXFxzcXJ0LiBPbiB0aGUgb3RoZXIgaGFuZCwgdGhlIGV4cHJlc3Npb25zXG4gKiAgICAgICAgICAgICAgICAgIFxcZnJhYyBcXGZyYWMgMSAyIDNcbiAqICAgICAgICAgICAgICAgIGFuZFxuICogICAgICAgICAgICAgICAgICBcXGZyYWMgXFxzcXJ0IDEgMlxuICogICAgICAgICAgICAgICAgd2lsbCBmYWlsIGJlY2F1c2UgXFxmcmFjIGFuZCBcXGZyYWMgaGF2ZSBlcXVhbCBncmVlZGluZXNzXG4gKiAgICAgICAgICAgICAgICBhbmQgXFxzcXJ0IGhhcyBhIGxvd2VyIGdyZWVkaW5lc3MgdGhhbiBcXGZyYWMgcmVzcGVjdGl2ZWx5LiBUb1xuICogICAgICAgICAgICAgICAgbWFrZSB0aGVzZSBwYXJzZSwgd2Ugd291bGQgaGF2ZSB0byBjaGFuZ2UgdGhlbSB0bzpcbiAqICAgICAgICAgICAgICAgICAgXFxmcmFjIHtcXGZyYWMgMSAyfSAzXG4gKiAgICAgICAgICAgICAgICBhbmRcbiAqICAgICAgICAgICAgICAgICAgXFxmcmFjIHtcXHNxcnQgMX0gMlxuICpcbiAqICAgICAgICAgICAgICAgIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGAxYFxuICogIC0gYWxsb3dlZEluVGV4dDogKG9wdGlvbmFsKSBXaGV0aGVyIG9yIG5vdCB0aGUgZnVuY3Rpb24gaXMgYWxsb3dlZCBpbnNpZGVcbiAqICAgICAgICAgICAgICAgICAgIHRleHQgbW9kZSAoZGVmYXVsdCBmYWxzZSlcbiAqICAtIG51bU9wdGlvbmFsQXJnczogKG9wdGlvbmFsKSBUaGUgbnVtYmVyIG9mIG9wdGlvbmFsIGFyZ3VtZW50cyB0aGUgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgICAgICAgc2hvdWxkIHBhcnNlLiBJZiB0aGUgb3B0aW9uYWwgYXJndW1lbnRzIGFyZW4ndCBmb3VuZCxcbiAqICAgICAgICAgICAgICAgICAgICAgYG51bGxgIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBoYW5kbGVyIGluIHRoZWlyIHBsYWNlLlxuICogICAgICAgICAgICAgICAgICAgICAoZGVmYXVsdCAwKVxuICogIC0gaW5maXg6IChvcHRpb25hbCkgTXVzdCBiZSB0cnVlIGlmIHRoZSBmdW5jdGlvbiBpcyBhbiBpbmZpeCBvcGVyYXRvci5cbiAqXG4gKiBUaGUgbGFzdCBhcmd1bWVudCBpcyB0aGF0IGltcGxlbWVudGF0aW9uLCB0aGUgaGFuZGxlciBmb3IgdGhlIGZ1bmN0aW9uKHMpLlxuICogSXQgaXMgY2FsbGVkIHRvIGhhbmRsZSB0aGVzZSBmdW5jdGlvbnMgYW5kIHRoZWlyIGFyZ3VtZW50cy5cbiAqIEl0IHJlY2VpdmVzIHR3byBhcmd1bWVudHM6XG4gKiAgLSBjb250ZXh0IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFuZCByZWZlcmVuY2VzIHByb3ZpZGVkIGJ5IHRoZSBwYXJzZXJcbiAqICAtIGFyZ3MgaXMgYW4gYXJyYXkgb2YgYXJndW1lbnRzIG9idGFpbmVkIGZyb20gVGVYIGlucHV0XG4gKiBUaGUgY29udGV4dCBjb250YWlucyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiAgLSBmdW5jTmFtZTogdGhlIHRleHQgKGkuZS4gbmFtZSkgb2YgdGhlIGZ1bmN0aW9uLCBpbmNsdWRpbmcgXFxcbiAqICAtIHBhcnNlcjogdGhlIHBhcnNlciBvYmplY3RcbiAqICAtIGxleGVyOiB0aGUgbGV4ZXIgb2JqZWN0XG4gKiAgLSBwb3NpdGlvbnM6IHRoZSBwb3NpdGlvbnMgaW4gdGhlIG92ZXJhbGwgc3RyaW5nIG9mIHRoZSBmdW5jdGlvblxuICogICAgICAgICAgICAgICBhbmQgdGhlIGFyZ3VtZW50cy5cbiAqIFRoZSBsYXR0ZXIgdGhyZWUgc2hvdWxkIG9ubHkgYmUgdXNlZCB0byBwcm9kdWNlIGVycm9yIG1lc3NhZ2VzLlxuICpcbiAqIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcga2V5czpcbiAqICAtIHR5cGU6IFRoZSB0eXBlIG9mIGVsZW1lbnQgdGhhdCB0aGlzIGlzLiBUaGlzIGlzIHRoZW4gdXNlZCBpblxuICogICAgICAgICAgYnVpbGRIVE1ML2J1aWxkTWF0aE1MIHRvIGRldGVybWluZSB3aGljaCBmdW5jdGlvblxuICogICAgICAgICAgc2hvdWxkIGJlIGNhbGxlZCB0byBidWlsZCB0aGlzIG5vZGUgaW50byBhIERPTSBub2RlXG4gKiBBbnkgb3RoZXIgZGF0YSBjYW4gYmUgYWRkZWQgdG8gdGhlIG9iamVjdCwgd2hpY2ggd2lsbCBiZSBwYXNzZWRcbiAqIGluIHRvIHRoZSBmdW5jdGlvbiBpbiBidWlsZEhUTUwvYnVpbGRNYXRoTUwgYXMgYGdyb3VwLnZhbHVlYC5cbiAqL1xuXG5mdW5jdGlvbiBkZWZpbmVGdW5jdGlvbihuYW1lcywgcHJvcHMsIGhhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIG5hbWVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG5hbWVzID0gW25hbWVzXTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwcm9wcyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBwcm9wcyA9IHsgbnVtQXJnczogcHJvcHMgfTtcbiAgICB9XG4gICAgLy8gU2V0IGRlZmF1bHQgdmFsdWVzIG9mIGZ1bmN0aW9uc1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgICBudW1BcmdzOiBwcm9wcy5udW1BcmdzLFxuICAgICAgICBhcmdUeXBlczogcHJvcHMuYXJnVHlwZXMsXG4gICAgICAgIGdyZWVkaW5lc3M6IChwcm9wcy5ncmVlZGluZXNzID09PSB1bmRlZmluZWQpID8gMSA6IHByb3BzLmdyZWVkaW5lc3MsXG4gICAgICAgIGFsbG93ZWRJblRleHQ6ICEhcHJvcHMuYWxsb3dlZEluVGV4dCxcbiAgICAgICAgbnVtT3B0aW9uYWxBcmdzOiBwcm9wcy5udW1PcHRpb25hbEFyZ3MgfHwgMCxcbiAgICAgICAgaW5maXg6ICEhcHJvcHMuaW5maXgsXG4gICAgICAgIGhhbmRsZXI6IGhhbmRsZXJcbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHNbbmFtZXNbaV1dID0gZGF0YTtcbiAgICB9XG59XG5cbi8vIFNpbmNlIHRoZSBjb3JyZXNwb25kaW5nIGJ1aWxkSFRNTC9idWlsZE1hdGhNTCBmdW5jdGlvbiBleHBlY3RzIGFcbi8vIGxpc3Qgb2YgZWxlbWVudHMsIHdlIG5vcm1hbGl6ZSBmb3IgZGlmZmVyZW50IGtpbmRzIG9mIGFyZ3VtZW50c1xudmFyIG9yZGFyZ3VtZW50ID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKGFyZy50eXBlID09PSBcIm9yZGdyb3VwXCIpIHtcbiAgICAgICAgcmV0dXJuIGFyZy52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW2FyZ107XG4gICAgfVxufTtcblxuLy8gQSBub3JtYWwgc3F1YXJlIHJvb3RcbmRlZmluZUZ1bmN0aW9uKFwiXFxcXHNxcnRcIiwge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAxXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGluZGV4ID0gYXJnc1swXTtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMV07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzcXJ0XCIsXG4gICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgIGluZGV4OiBpbmRleFxuICAgIH07XG59KTtcblxuLy8gTm9uLW1hdGh5IHRleHQsIHBvc3NpYmx5IGluIGEgZm9udFxudmFyIHRleHRGdW5jdGlvblN0eWxlcyA9IHtcbiAgICBcIlxcXFx0ZXh0XCI6IHVuZGVmaW5lZCwgXCJcXFxcdGV4dHJtXCI6IFwibWF0aHJtXCIsIFwiXFxcXHRleHRzZlwiOiBcIm1hdGhzZlwiLFxuICAgIFwiXFxcXHRleHR0dFwiOiBcIm1hdGh0dFwiLCBcIlxcXFx0ZXh0bm9ybWFsXCI6IFwibWF0aHJtXCIsIFwiXFxcXHRleHRiZlwiOiBcIm1hdGhiZlwiLFxuICAgIFwiXFxcXHRleHRpdFwiOiBcInRleHRpdFwiXG59O1xuXG5kZWZpbmVGdW5jdGlvbihbXG4gICAgXCJcXFxcdGV4dFwiLCBcIlxcXFx0ZXh0cm1cIiwgXCJcXFxcdGV4dHNmXCIsIFwiXFxcXHRleHR0dFwiLCBcIlxcXFx0ZXh0bm9ybWFsXCIsXG4gICAgXCJcXFxcdGV4dGJmXCIsIFwiXFxcXHRleHRpdFwiXG5dLCB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1widGV4dFwiXSxcbiAgICBncmVlZGluZXNzOiAyLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbn0sIGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpLFxuICAgICAgICBzdHlsZTogdGV4dEZ1bmN0aW9uU3R5bGVzW2NvbnRleHQuZnVuY05hbWVdXG4gICAgfTtcbn0pO1xuXG4vLyBBIHR3by1hcmd1bWVudCBjdXN0b20gY29sb3JcbmRlZmluZUZ1bmN0aW9uKFwiXFxcXGNvbG9yXCIsIHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgZ3JlZWRpbmVzczogMyxcbiAgICBhcmdUeXBlczogW1wiY29sb3JcIiwgXCJvcmlnaW5hbFwiXVxufSwgZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHZhciBjb2xvciA9IGFyZ3NbMF07XG4gICAgdmFyIGJvZHkgPSBhcmdzWzFdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgY29sb3I6IGNvbG9yLnZhbHVlLFxuICAgICAgICB2YWx1ZTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xufSk7XG5cbi8vIEFuIG92ZXJsaW5lXG5kZWZpbmVGdW5jdGlvbihcIlxcXFxvdmVybGluZVwiLCB7XG4gICAgbnVtQXJnczogMVxufSwgZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHZhciBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm92ZXJsaW5lXCIsXG4gICAgICAgIGJvZHk6IGJvZHlcbiAgICB9O1xufSk7XG5cbi8vIEFuIHVuZGVybGluZVxuZGVmaW5lRnVuY3Rpb24oXCJcXFxcdW5kZXJsaW5lXCIsIHtcbiAgICBudW1BcmdzOiAxXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidW5kZXJsaW5lXCIsXG4gICAgICAgIGJvZHk6IGJvZHlcbiAgICB9O1xufSk7XG5cbi8vIEEgYm94IG9mIHRoZSB3aWR0aCBhbmQgaGVpZ2h0XG5kZWZpbmVGdW5jdGlvbihcIlxcXFxydWxlXCIsIHtcbiAgICBudW1BcmdzOiAyLFxuICAgIG51bU9wdGlvbmFsQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiLCBcInNpemVcIiwgXCJzaXplXCJdXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIHNoaWZ0ID0gYXJnc1swXTtcbiAgICB2YXIgd2lkdGggPSBhcmdzWzFdO1xuICAgIHZhciBoZWlnaHQgPSBhcmdzWzJdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwicnVsZVwiLFxuICAgICAgICBzaGlmdDogc2hpZnQgJiYgc2hpZnQudmFsdWUsXG4gICAgICAgIHdpZHRoOiB3aWR0aC52YWx1ZSxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQudmFsdWVcbiAgICB9O1xufSk7XG5cbi8vIFRPRE86IEluIFRlWCwgXFxta2VybiBvbmx5IGFjY2VwdHMgbXUtdW5pdHMsIGFuZCBcXGtlcm4gZG9lcyBub3QgYWNjZXB0XG4vLyBtdS11bml0cy4gSW4gY3VycmVudCBLYVRlWCB3ZSByZWxheCB0aGlzOyBib3RoIGNvbW1hbmRzIGFjY2VwdCBhbnkgdW5pdC5cbmRlZmluZUZ1bmN0aW9uKFtcIlxcXFxrZXJuXCIsIFwiXFxcXG1rZXJuXCJdLCB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiXVxufSwgZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBkaW1lbnNpb246IGFyZ3NbMF0udmFsdWVcbiAgICB9O1xufSk7XG5cbi8vIEEgS2FUZVggbG9nb1xuZGVmaW5lRnVuY3Rpb24oXCJcXFxcS2FUZVhcIiwge1xuICAgIG51bUFyZ3M6IDBcbn0sIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImthdGV4XCJcbiAgICB9O1xufSk7XG5cbmRlZmluZUZ1bmN0aW9uKFwiXFxcXHBoYW50b21cIiwge1xuICAgIG51bUFyZ3M6IDFcbn0sIGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJwaGFudG9tXCIsXG4gICAgICAgIHZhbHVlOiBvcmRhcmd1bWVudChib2R5KVxuICAgIH07XG59KTtcblxuLy8gTWF0aCBjbGFzcyBjb21tYW5kcyBleGNlcHQgXFxtYXRob3BcbmRlZmluZUZ1bmN0aW9uKFtcbiAgICBcIlxcXFxtYXRob3JkXCIsIFwiXFxcXG1hdGhiaW5cIiwgXCJcXFxcbWF0aHJlbFwiLCBcIlxcXFxtYXRob3BlblwiLFxuICAgIFwiXFxcXG1hdGhjbG9zZVwiLCBcIlxcXFxtYXRocHVuY3RcIiwgXCJcXFxcbWF0aGlubmVyXCJcbl0sIHtcbiAgICBudW1BcmdzOiAxXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibWNsYXNzXCIsXG4gICAgICAgIG1jbGFzczogXCJtXCIgKyBjb250ZXh0LmZ1bmNOYW1lLnN1YnN0cig1KSxcbiAgICAgICAgdmFsdWU6IG9yZGFyZ3VtZW50KGJvZHkpXG4gICAgfTtcbn0pO1xuXG4vLyBCdWlsZCBhIHJlbGF0aW9uIGJ5IHBsYWNpbmcgb25lIHN5bWJvbCBvbiB0b3Agb2YgYW5vdGhlclxuZGVmaW5lRnVuY3Rpb24oXCJcXFxcc3RhY2tyZWxcIiwge1xuICAgIG51bUFyZ3M6IDJcbn0sIGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB2YXIgdG9wID0gYXJnc1swXTtcbiAgICB2YXIgYm90dG9tID0gYXJnc1sxXTtcblxuICAgIHZhciBib3R0b21vcCA9IG5ldyBQYXJzZU5vZGUoXCJvcFwiLCB7XG4gICAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgICAgbGltaXRzOiB0cnVlLFxuICAgICAgICBhbHdheXNIYW5kbGVTdXBTdWI6IHRydWUsXG4gICAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBvcmRhcmd1bWVudChib3R0b20pXG4gICAgfSwgYm90dG9tLm1vZGUpO1xuXG4gICAgdmFyIHN1cHN1YiA9IG5ldyBQYXJzZU5vZGUoXCJzdXBzdWJcIiwge1xuICAgICAgICBiYXNlOiBib3R0b21vcCxcbiAgICAgICAgc3VwOiB0b3AsXG4gICAgICAgIHN1YjogbnVsbFxuICAgIH0sIHRvcC5tb2RlKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibWNsYXNzXCIsXG4gICAgICAgIG1jbGFzczogXCJtcmVsXCIsXG4gICAgICAgIHZhbHVlOiBbc3Vwc3ViXVxuICAgIH07XG59KTtcblxuLy8gXFxtb2QtdHlwZSBmdW5jdGlvbnNcbmRlZmluZUZ1bmN0aW9uKFwiXFxcXGJtb2RcIiwge1xuICAgIG51bUFyZ3M6IDBcbn0sIGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm1vZFwiLFxuICAgICAgICBtb2RUeXBlOiBcImJtb2RcIixcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICB9O1xufSk7XG5cbmRlZmluZUZ1bmN0aW9uKFtcIlxcXFxwb2RcIiwgXCJcXFxccG1vZFwiLCBcIlxcXFxtb2RcIl0sIHtcbiAgICBudW1BcmdzOiAxXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibW9kXCIsXG4gICAgICAgIG1vZFR5cGU6IGNvbnRleHQuZnVuY05hbWUuc3Vic3RyKDEpLFxuICAgICAgICB2YWx1ZTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xufSk7XG5cbi8vIEV4dHJhIGRhdGEgbmVlZGVkIGZvciB0aGUgZGVsaW1pdGVyIGhhbmRsZXIgZG93biBiZWxvd1xudmFyIGRlbGltaXRlclNpemVzID0ge1xuICAgIFwiXFxcXGJpZ2xcIiA6IHttY2xhc3M6IFwibW9wZW5cIiwgICAgc2l6ZTogMX0sXG4gICAgXCJcXFxcQmlnbFwiIDoge21jbGFzczogXCJtb3BlblwiLCAgICBzaXplOiAyfSxcbiAgICBcIlxcXFxiaWdnbFwiOiB7bWNsYXNzOiBcIm1vcGVuXCIsICAgIHNpemU6IDN9LFxuICAgIFwiXFxcXEJpZ2dsXCI6IHttY2xhc3M6IFwibW9wZW5cIiwgICAgc2l6ZTogNH0sXG4gICAgXCJcXFxcYmlnclwiIDoge21jbGFzczogXCJtY2xvc2VcIiwgICBzaXplOiAxfSxcbiAgICBcIlxcXFxCaWdyXCIgOiB7bWNsYXNzOiBcIm1jbG9zZVwiLCAgIHNpemU6IDJ9LFxuICAgIFwiXFxcXGJpZ2dyXCI6IHttY2xhc3M6IFwibWNsb3NlXCIsICAgc2l6ZTogM30sXG4gICAgXCJcXFxcQmlnZ3JcIjoge21jbGFzczogXCJtY2xvc2VcIiwgICBzaXplOiA0fSxcbiAgICBcIlxcXFxiaWdtXCIgOiB7bWNsYXNzOiBcIm1yZWxcIiwgICAgIHNpemU6IDF9LFxuICAgIFwiXFxcXEJpZ21cIiA6IHttY2xhc3M6IFwibXJlbFwiLCAgICAgc2l6ZTogMn0sXG4gICAgXCJcXFxcYmlnZ21cIjoge21jbGFzczogXCJtcmVsXCIsICAgICBzaXplOiAzfSxcbiAgICBcIlxcXFxCaWdnbVwiOiB7bWNsYXNzOiBcIm1yZWxcIiwgICAgIHNpemU6IDR9LFxuICAgIFwiXFxcXGJpZ1wiICA6IHttY2xhc3M6IFwibW9yZFwiLCAgICAgc2l6ZTogMX0sXG4gICAgXCJcXFxcQmlnXCIgIDoge21jbGFzczogXCJtb3JkXCIsICAgICBzaXplOiAyfSxcbiAgICBcIlxcXFxiaWdnXCIgOiB7bWNsYXNzOiBcIm1vcmRcIiwgICAgIHNpemU6IDN9LFxuICAgIFwiXFxcXEJpZ2dcIiA6IHttY2xhc3M6IFwibW9yZFwiLCAgICAgc2l6ZTogNH1cbn07XG5cbnZhciBkZWxpbWl0ZXJzID0gW1xuICAgIFwiKFwiLCBcIilcIiwgXCJbXCIsIFwiXFxcXGxicmFja1wiLCBcIl1cIiwgXCJcXFxccmJyYWNrXCIsXG4gICAgXCJcXFxce1wiLCBcIlxcXFxsYnJhY2VcIiwgXCJcXFxcfVwiLCBcIlxcXFxyYnJhY2VcIixcbiAgICBcIlxcXFxsZmxvb3JcIiwgXCJcXFxccmZsb29yXCIsIFwiXFxcXGxjZWlsXCIsIFwiXFxcXHJjZWlsXCIsXG4gICAgXCI8XCIsIFwiPlwiLCBcIlxcXFxsYW5nbGVcIiwgXCJcXFxccmFuZ2xlXCIsIFwiXFxcXGx0XCIsIFwiXFxcXGd0XCIsXG4gICAgXCJcXFxcbHZlcnRcIiwgXCJcXFxccnZlcnRcIiwgXCJcXFxcbFZlcnRcIiwgXCJcXFxcclZlcnRcIixcbiAgICBcIlxcXFxsZ3JvdXBcIiwgXCJcXFxccmdyb3VwXCIsIFwiXFxcXGxtb3VzdGFjaGVcIiwgXCJcXFxccm1vdXN0YWNoZVwiLFxuICAgIFwiL1wiLCBcIlxcXFxiYWNrc2xhc2hcIixcbiAgICBcInxcIiwgXCJcXFxcdmVydFwiLCBcIlxcXFx8XCIsIFwiXFxcXFZlcnRcIixcbiAgICBcIlxcXFx1cGFycm93XCIsIFwiXFxcXFVwYXJyb3dcIixcbiAgICBcIlxcXFxkb3duYXJyb3dcIiwgXCJcXFxcRG93bmFycm93XCIsXG4gICAgXCJcXFxcdXBkb3duYXJyb3dcIiwgXCJcXFxcVXBkb3duYXJyb3dcIixcbiAgICBcIi5cIlxuXTtcblxudmFyIGZvbnRBbGlhc2VzID0ge1xuICAgIFwiXFxcXEJiYlwiOiBcIlxcXFxtYXRoYmJcIixcbiAgICBcIlxcXFxib2xkXCI6IFwiXFxcXG1hdGhiZlwiLFxuICAgIFwiXFxcXGZyYWtcIjogXCJcXFxcbWF0aGZyYWtcIlxufTtcblxuLy8gU2luZ2xlLWFyZ3VtZW50IGNvbG9yIGZ1bmN0aW9uc1xuZGVmaW5lRnVuY3Rpb24oW1xuICAgIFwiXFxcXGJsdWVcIiwgXCJcXFxcb3JhbmdlXCIsIFwiXFxcXHBpbmtcIiwgXCJcXFxccmVkXCIsXG4gICAgXCJcXFxcZ3JlZW5cIiwgXCJcXFxcZ3JheVwiLCBcIlxcXFxwdXJwbGVcIixcbiAgICBcIlxcXFxibHVlQVwiLCBcIlxcXFxibHVlQlwiLCBcIlxcXFxibHVlQ1wiLCBcIlxcXFxibHVlRFwiLCBcIlxcXFxibHVlRVwiLFxuICAgIFwiXFxcXHRlYWxBXCIsIFwiXFxcXHRlYWxCXCIsIFwiXFxcXHRlYWxDXCIsIFwiXFxcXHRlYWxEXCIsIFwiXFxcXHRlYWxFXCIsXG4gICAgXCJcXFxcZ3JlZW5BXCIsIFwiXFxcXGdyZWVuQlwiLCBcIlxcXFxncmVlbkNcIiwgXCJcXFxcZ3JlZW5EXCIsIFwiXFxcXGdyZWVuRVwiLFxuICAgIFwiXFxcXGdvbGRBXCIsIFwiXFxcXGdvbGRCXCIsIFwiXFxcXGdvbGRDXCIsIFwiXFxcXGdvbGREXCIsIFwiXFxcXGdvbGRFXCIsXG4gICAgXCJcXFxccmVkQVwiLCBcIlxcXFxyZWRCXCIsIFwiXFxcXHJlZENcIiwgXCJcXFxccmVkRFwiLCBcIlxcXFxyZWRFXCIsXG4gICAgXCJcXFxcbWFyb29uQVwiLCBcIlxcXFxtYXJvb25CXCIsIFwiXFxcXG1hcm9vbkNcIiwgXCJcXFxcbWFyb29uRFwiLCBcIlxcXFxtYXJvb25FXCIsXG4gICAgXCJcXFxccHVycGxlQVwiLCBcIlxcXFxwdXJwbGVCXCIsIFwiXFxcXHB1cnBsZUNcIiwgXCJcXFxccHVycGxlRFwiLCBcIlxcXFxwdXJwbGVFXCIsXG4gICAgXCJcXFxcbWludEFcIiwgXCJcXFxcbWludEJcIiwgXCJcXFxcbWludENcIixcbiAgICBcIlxcXFxncmF5QVwiLCBcIlxcXFxncmF5QlwiLCBcIlxcXFxncmF5Q1wiLCBcIlxcXFxncmF5RFwiLCBcIlxcXFxncmF5RVwiLFxuICAgIFwiXFxcXGdyYXlGXCIsIFwiXFxcXGdyYXlHXCIsIFwiXFxcXGdyYXlIXCIsIFwiXFxcXGdyYXlJXCIsXG4gICAgXCJcXFxca2FCbHVlXCIsIFwiXFxcXGthR3JlZW5cIlxuXSwge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBncmVlZGluZXNzOiAzXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgY29sb3I6IFwia2F0ZXgtXCIgKyBjb250ZXh0LmZ1bmNOYW1lLnNsaWNlKDEpLFxuICAgICAgICB2YWx1ZTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xufSk7XG5cbi8vIFRoZXJlIGFyZSAyIGZsYWdzIGZvciBvcGVyYXRvcnM7IHdoZXRoZXIgdGhleSBwcm9kdWNlIGxpbWl0cyBpblxuLy8gZGlzcGxheXN0eWxlLCBhbmQgd2hldGhlciB0aGV5IGFyZSBzeW1ib2xzIGFuZCBzaG91bGQgZ3JvdyBpblxuLy8gZGlzcGxheXN0eWxlLiBUaGVzZSBmb3VyIGdyb3VwcyBjb3ZlciB0aGUgZm91ciBwb3NzaWJsZSBjaG9pY2VzLlxuXG4vLyBObyBsaW1pdHMsIG5vdCBzeW1ib2xzXG5kZWZpbmVGdW5jdGlvbihbXG4gICAgXCJcXFxcYXJjc2luXCIsIFwiXFxcXGFyY2Nvc1wiLCBcIlxcXFxhcmN0YW5cIiwgXCJcXFxcYXJnXCIsIFwiXFxcXGNvc1wiLCBcIlxcXFxjb3NoXCIsXG4gICAgXCJcXFxcY290XCIsIFwiXFxcXGNvdGhcIiwgXCJcXFxcY3NjXCIsIFwiXFxcXGRlZ1wiLCBcIlxcXFxkaW1cIiwgXCJcXFxcZXhwXCIsIFwiXFxcXGhvbVwiLFxuICAgIFwiXFxcXGtlclwiLCBcIlxcXFxsZ1wiLCBcIlxcXFxsblwiLCBcIlxcXFxsb2dcIiwgXCJcXFxcc2VjXCIsIFwiXFxcXHNpblwiLCBcIlxcXFxzaW5oXCIsXG4gICAgXCJcXFxcdGFuXCIsIFwiXFxcXHRhbmhcIlxuXSwge1xuICAgIG51bUFyZ3M6IDBcbn0sIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICAgIGxpbWl0czogZmFsc2UsXG4gICAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICAgIGJvZHk6IGNvbnRleHQuZnVuY05hbWVcbiAgICB9O1xufSk7XG5cbi8vIExpbWl0cywgbm90IHN5bWJvbHNcbmRlZmluZUZ1bmN0aW9uKFtcbiAgICBcIlxcXFxkZXRcIiwgXCJcXFxcZ2NkXCIsIFwiXFxcXGluZlwiLCBcIlxcXFxsaW1cIiwgXCJcXFxcbGltaW5mXCIsIFwiXFxcXGxpbXN1cFwiLCBcIlxcXFxtYXhcIixcbiAgICBcIlxcXFxtaW5cIiwgXCJcXFxcUHJcIiwgXCJcXFxcc3VwXCJcbl0sIHtcbiAgICBudW1BcmdzOiAwXG59LCBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJvcFwiLFxuICAgICAgICBsaW1pdHM6IHRydWUsXG4gICAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICAgIGJvZHk6IGNvbnRleHQuZnVuY05hbWVcbiAgICB9O1xufSk7XG5cbi8vIE5vIGxpbWl0cywgc3ltYm9sc1xuZGVmaW5lRnVuY3Rpb24oW1xuICAgIFwiXFxcXGludFwiLCBcIlxcXFxpaW50XCIsIFwiXFxcXGlpaW50XCIsIFwiXFxcXG9pbnRcIlxuXSwge1xuICAgIG51bUFyZ3M6IDBcbn0sIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICAgIGxpbWl0czogZmFsc2UsXG4gICAgICAgIHN5bWJvbDogdHJ1ZSxcbiAgICAgICAgYm9keTogY29udGV4dC5mdW5jTmFtZVxuICAgIH07XG59KTtcblxuLy8gTGltaXRzLCBzeW1ib2xzXG5kZWZpbmVGdW5jdGlvbihbXG4gICAgXCJcXFxcY29wcm9kXCIsIFwiXFxcXGJpZ3ZlZVwiLCBcIlxcXFxiaWd3ZWRnZVwiLCBcIlxcXFxiaWd1cGx1c1wiLCBcIlxcXFxiaWdjYXBcIixcbiAgICBcIlxcXFxiaWdjdXBcIiwgXCJcXFxcaW50b3BcIiwgXCJcXFxccHJvZFwiLCBcIlxcXFxzdW1cIiwgXCJcXFxcYmlnb3RpbWVzXCIsXG4gICAgXCJcXFxcYmlnb3BsdXNcIiwgXCJcXFxcYmlnb2RvdFwiLCBcIlxcXFxiaWdzcWN1cFwiLCBcIlxcXFxzbWFsbGludFwiXG5dLCB7XG4gICAgbnVtQXJnczogMFxufSwgZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgICAgbGltaXRzOiB0cnVlLFxuICAgICAgICBzeW1ib2w6IHRydWUsXG4gICAgICAgIGJvZHk6IGNvbnRleHQuZnVuY05hbWVcbiAgICB9O1xufSk7XG5cbi8vIFxcbWF0aG9wIGNsYXNzIGNvbW1hbmRcbmRlZmluZUZ1bmN0aW9uKFwiXFxcXG1hdGhvcFwiLCB7XG4gICAgbnVtQXJnczogMVxufSwgZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHZhciBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICAgIGxpbWl0czogZmFsc2UsXG4gICAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBvcmRhcmd1bWVudChib2R5KVxuICAgIH07XG59KTtcblxuLy8gRnJhY3Rpb25zXG5kZWZpbmVGdW5jdGlvbihbXG4gICAgXCJcXFxcZGZyYWNcIiwgXCJcXFxcZnJhY1wiLCBcIlxcXFx0ZnJhY1wiLFxuICAgIFwiXFxcXGRiaW5vbVwiLCBcIlxcXFxiaW5vbVwiLCBcIlxcXFx0Ymlub21cIixcbiAgICBcIlxcXFxcXFxcYXRvcGZyYWNcIiAvLyBjYW7igJl0IGJlIGVudGVyZWQgZGlyZWN0bHlcbl0sIHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGdyZWVkaW5lc3M6IDJcbn0sIGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB2YXIgbnVtZXIgPSBhcmdzWzBdO1xuICAgIHZhciBkZW5vbSA9IGFyZ3NbMV07XG4gICAgdmFyIGhhc0JhckxpbmU7XG4gICAgdmFyIGxlZnREZWxpbSA9IG51bGw7XG4gICAgdmFyIHJpZ2h0RGVsaW0gPSBudWxsO1xuICAgIHZhciBzaXplID0gXCJhdXRvXCI7XG5cbiAgICBzd2l0Y2ggKGNvbnRleHQuZnVuY05hbWUpIHtcbiAgICAgICAgY2FzZSBcIlxcXFxkZnJhY1wiOlxuICAgICAgICBjYXNlIFwiXFxcXGZyYWNcIjpcbiAgICAgICAgY2FzZSBcIlxcXFx0ZnJhY1wiOlxuICAgICAgICAgICAgaGFzQmFyTGluZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlxcXFxcXFxcYXRvcGZyYWNcIjpcbiAgICAgICAgICAgIGhhc0JhckxpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiXFxcXGRiaW5vbVwiOlxuICAgICAgICBjYXNlIFwiXFxcXGJpbm9tXCI6XG4gICAgICAgIGNhc2UgXCJcXFxcdGJpbm9tXCI6XG4gICAgICAgICAgICBoYXNCYXJMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICBsZWZ0RGVsaW0gPSBcIihcIjtcbiAgICAgICAgICAgIHJpZ2h0RGVsaW0gPSBcIilcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIGdlbmZyYWMgY29tbWFuZFwiKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGNvbnRleHQuZnVuY05hbWUpIHtcbiAgICAgICAgY2FzZSBcIlxcXFxkZnJhY1wiOlxuICAgICAgICBjYXNlIFwiXFxcXGRiaW5vbVwiOlxuICAgICAgICAgICAgc2l6ZSA9IFwiZGlzcGxheVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJcXFxcdGZyYWNcIjpcbiAgICAgICAgY2FzZSBcIlxcXFx0Ymlub21cIjpcbiAgICAgICAgICAgIHNpemUgPSBcInRleHRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZ2VuZnJhY1wiLFxuICAgICAgICBudW1lcjogbnVtZXIsXG4gICAgICAgIGRlbm9tOiBkZW5vbSxcbiAgICAgICAgaGFzQmFyTGluZTogaGFzQmFyTGluZSxcbiAgICAgICAgbGVmdERlbGltOiBsZWZ0RGVsaW0sXG4gICAgICAgIHJpZ2h0RGVsaW06IHJpZ2h0RGVsaW0sXG4gICAgICAgIHNpemU6IHNpemVcbiAgICB9O1xufSk7XG5cbi8vIExlZnQgYW5kIHJpZ2h0IG92ZXJsYXAgZnVuY3Rpb25zXG5kZWZpbmVGdW5jdGlvbihbXCJcXFxcbGxhcFwiLCBcIlxcXFxybGFwXCJdLCB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGNvbnRleHQuZnVuY05hbWUuc2xpY2UoMSksXG4gICAgICAgIGJvZHk6IGJvZHlcbiAgICB9O1xufSk7XG5cbi8vIERlbGltaXRlciBmdW5jdGlvbnNcbnZhciBjaGVja0RlbGltaXRlciA9IGZ1bmN0aW9uKGRlbGltLCBjb250ZXh0KSB7XG4gICAgaWYgKHV0aWxzLmNvbnRhaW5zKGRlbGltaXRlcnMsIGRlbGltLnZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZGVsaW07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgICAgICBcIkludmFsaWQgZGVsaW1pdGVyOiAnXCIgKyBkZWxpbS52YWx1ZSArIFwiJyBhZnRlciAnXCIgK1xuICAgICAgICAgICAgY29udGV4dC5mdW5jTmFtZSArIFwiJ1wiLCBkZWxpbSk7XG4gICAgfVxufTtcblxuZGVmaW5lRnVuY3Rpb24oW1xuICAgIFwiXFxcXGJpZ2xcIiwgXCJcXFxcQmlnbFwiLCBcIlxcXFxiaWdnbFwiLCBcIlxcXFxCaWdnbFwiLFxuICAgIFwiXFxcXGJpZ3JcIiwgXCJcXFxcQmlnclwiLCBcIlxcXFxiaWdnclwiLCBcIlxcXFxCaWdnclwiLFxuICAgIFwiXFxcXGJpZ21cIiwgXCJcXFxcQmlnbVwiLCBcIlxcXFxiaWdnbVwiLCBcIlxcXFxCaWdnbVwiLFxuICAgIFwiXFxcXGJpZ1wiLCAgXCJcXFxcQmlnXCIsICBcIlxcXFxiaWdnXCIsICBcIlxcXFxCaWdnXCJcbl0sIHtcbiAgICBudW1BcmdzOiAxXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGRlbGltID0gY2hlY2tEZWxpbWl0ZXIoYXJnc1swXSwgY29udGV4dCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImRlbGltc2l6aW5nXCIsXG4gICAgICAgIHNpemU6IGRlbGltaXRlclNpemVzW2NvbnRleHQuZnVuY05hbWVdLnNpemUsXG4gICAgICAgIG1jbGFzczogZGVsaW1pdGVyU2l6ZXNbY29udGV4dC5mdW5jTmFtZV0ubWNsYXNzLFxuICAgICAgICB2YWx1ZTogZGVsaW0udmFsdWVcbiAgICB9O1xufSk7XG5cbmRlZmluZUZ1bmN0aW9uKFtcbiAgICBcIlxcXFxsZWZ0XCIsIFwiXFxcXHJpZ2h0XCJcbl0sIHtcbiAgICBudW1BcmdzOiAxXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGRlbGltID0gY2hlY2tEZWxpbWl0ZXIoYXJnc1swXSwgY29udGV4dCk7XG5cbiAgICAvLyBcXGxlZnQgYW5kIFxccmlnaHQgYXJlIGNhdWdodCBzb21ld2hlcmUgaW4gUGFyc2VyLmpzLCB3aGljaCBpc1xuICAgIC8vIHdoeSB0aGlzIGRhdGEgZG9lc24ndCBtYXRjaCB3aGF0IGlzIGluIGJ1aWxkSFRNTC5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImxlZnRyaWdodFwiLFxuICAgICAgICB2YWx1ZTogZGVsaW0udmFsdWVcbiAgICB9O1xufSk7XG5cbmRlZmluZUZ1bmN0aW9uKFwiXFxcXG1pZGRsZVwiLCB7XG4gICAgbnVtQXJnczogMVxufSwgZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHZhciBkZWxpbSA9IGNoZWNrRGVsaW1pdGVyKGFyZ3NbMF0sIGNvbnRleHQpO1xuICAgIGlmICghY29udGV4dC5wYXJzZXIubGVmdHJpZ2h0RGVwdGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJcXFxcbWlkZGxlIHdpdGhvdXQgcHJlY2VkaW5nIFxcXFxsZWZ0XCIsIGRlbGltKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm1pZGRsZVwiLFxuICAgICAgICB2YWx1ZTogZGVsaW0udmFsdWVcbiAgICB9O1xufSk7XG5cbi8vIFNpemluZyBmdW5jdGlvbnMgKGhhbmRsZWQgaW4gUGFyc2VyLmpzIGV4cGxpY2l0bHksIGhlbmNlIG5vIGhhbmRsZXIpXG5kZWZpbmVGdW5jdGlvbihbXG4gICAgXCJcXFxcdGlueVwiLCBcIlxcXFxzY3JpcHRzaXplXCIsIFwiXFxcXGZvb3Rub3Rlc2l6ZVwiLCBcIlxcXFxzbWFsbFwiLFxuICAgIFwiXFxcXG5vcm1hbHNpemVcIiwgXCJcXFxcbGFyZ2VcIiwgXCJcXFxcTGFyZ2VcIiwgXCJcXFxcTEFSR0VcIiwgXCJcXFxcaHVnZVwiLCBcIlxcXFxIdWdlXCJcbl0sIDAsIG51bGwpO1xuXG4vLyBTdHlsZSBjaGFuZ2luZyBmdW5jdGlvbnMgKGhhbmRsZWQgaW4gUGFyc2VyLmpzIGV4cGxpY2l0bHksIGhlbmNlIG5vXG4vLyBoYW5kbGVyKVxuZGVmaW5lRnVuY3Rpb24oW1xuICAgIFwiXFxcXGRpc3BsYXlzdHlsZVwiLCBcIlxcXFx0ZXh0c3R5bGVcIiwgXCJcXFxcc2NyaXB0c3R5bGVcIixcbiAgICBcIlxcXFxzY3JpcHRzY3JpcHRzdHlsZVwiXG5dLCAwLCBudWxsKTtcblxuZGVmaW5lRnVuY3Rpb24oW1xuICAgIC8vIHN0eWxlc1xuICAgIFwiXFxcXG1hdGhybVwiLCBcIlxcXFxtYXRoaXRcIiwgXCJcXFxcbWF0aGJmXCIsXG5cbiAgICAvLyBmYW1pbGllc1xuICAgIFwiXFxcXG1hdGhiYlwiLCBcIlxcXFxtYXRoY2FsXCIsIFwiXFxcXG1hdGhmcmFrXCIsIFwiXFxcXG1hdGhzY3JcIiwgXCJcXFxcbWF0aHNmXCIsXG4gICAgXCJcXFxcbWF0aHR0XCIsXG5cbiAgICAvLyBhbGlhc2VzXG4gICAgXCJcXFxcQmJiXCIsIFwiXFxcXGJvbGRcIiwgXCJcXFxcZnJha1wiXG5dLCB7XG4gICAgbnVtQXJnczogMSxcbiAgICBncmVlZGluZXNzOiAyXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHZhciBmdW5jID0gY29udGV4dC5mdW5jTmFtZTtcbiAgICBpZiAoZnVuYyBpbiBmb250QWxpYXNlcykge1xuICAgICAgICBmdW5jID0gZm9udEFsaWFzZXNbZnVuY107XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZm9udFwiLFxuICAgICAgICBmb250OiBmdW5jLnNsaWNlKDEpLFxuICAgICAgICBib2R5OiBib2R5XG4gICAgfTtcbn0pO1xuXG4vLyBBY2NlbnRzXG5kZWZpbmVGdW5jdGlvbihbXG4gICAgXCJcXFxcYWN1dGVcIiwgXCJcXFxcZ3JhdmVcIiwgXCJcXFxcZGRvdFwiLCBcIlxcXFx0aWxkZVwiLCBcIlxcXFxiYXJcIiwgXCJcXFxcYnJldmVcIixcbiAgICBcIlxcXFxjaGVja1wiLCBcIlxcXFxoYXRcIiwgXCJcXFxcdmVjXCIsIFwiXFxcXGRvdFwiXG4gICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCBleHBhbmRpbmcgYWNjZW50cyB5ZXRcbiAgICAvLyBcIlxcXFx3aWRldGlsZGVcIiwgXCJcXFxcd2lkZWhhdFwiXG5dLCB7XG4gICAgbnVtQXJnczogMVxufSwgZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHZhciBiYXNlID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImFjY2VudFwiLFxuICAgICAgICBhY2NlbnQ6IGNvbnRleHQuZnVuY05hbWUsXG4gICAgICAgIGJhc2U6IGJhc2VcbiAgICB9O1xufSk7XG5cbi8vIEluZml4IGdlbmVyYWxpemVkIGZyYWN0aW9uc1xuZGVmaW5lRnVuY3Rpb24oW1wiXFxcXG92ZXJcIiwgXCJcXFxcY2hvb3NlXCIsIFwiXFxcXGF0b3BcIl0sIHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGluZml4OiB0cnVlXG59LCBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIHJlcGxhY2VXaXRoO1xuICAgIHN3aXRjaCAoY29udGV4dC5mdW5jTmFtZSkge1xuICAgICAgICBjYXNlIFwiXFxcXG92ZXJcIjpcbiAgICAgICAgICAgIHJlcGxhY2VXaXRoID0gXCJcXFxcZnJhY1wiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJcXFxcY2hvb3NlXCI6XG4gICAgICAgICAgICByZXBsYWNlV2l0aCA9IFwiXFxcXGJpbm9tXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlxcXFxhdG9wXCI6XG4gICAgICAgICAgICByZXBsYWNlV2l0aCA9IFwiXFxcXFxcXFxhdG9wZnJhY1wiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgaW5maXggZ2VuZnJhYyBjb21tYW5kXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImluZml4XCIsXG4gICAgICAgIHJlcGxhY2VXaXRoOiByZXBsYWNlV2l0aCxcbiAgICAgICAgdG9rZW46IGNvbnRleHQudG9rZW5cbiAgICB9O1xufSk7XG5cbi8vIFJvdyBicmVha3MgZm9yIGFsaWduZWQgZGF0YVxuZGVmaW5lRnVuY3Rpb24oW1wiXFxcXFxcXFxcIiwgXCJcXFxcY3JcIl0sIHtcbiAgICBudW1BcmdzOiAwLFxuICAgIG51bU9wdGlvbmFsQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiXVxufSwgZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHZhciBzaXplID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImNyXCIsXG4gICAgICAgIHNpemU6IHNpemVcbiAgICB9O1xufSk7XG5cbi8vIEVudmlyb25tZW50IGRlbGltaXRlcnNcbmRlZmluZUZ1bmN0aW9uKFtcIlxcXFxiZWdpblwiLCBcIlxcXFxlbmRcIl0sIHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJ0ZXh0XCJdXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIG5hbWVHcm91cCA9IGFyZ3NbMF07XG4gICAgaWYgKG5hbWVHcm91cC50eXBlICE9PSBcIm9yZGdyb3VwXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIGVudmlyb25tZW50IG5hbWVcIiwgbmFtZUdyb3VwKTtcbiAgICB9XG4gICAgdmFyIG5hbWUgPSBcIlwiO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZUdyb3VwLnZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG5hbWUgKz0gbmFtZUdyb3VwLnZhbHVlW2ldLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImVudmlyb25tZW50XCIsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIG5hbWVHcm91cDogbmFtZUdyb3VwXG4gICAgfTtcbn0pO1xuIiwiLyoqXG4gKiBUaGVzZSBvYmplY3RzIHN0b3JlIGRhdGEgYWJvdXQgTWF0aE1MIG5vZGVzLiBUaGlzIGlzIHRoZSBNYXRoTUwgZXF1aXZhbGVudFxuICogb2YgdGhlIHR5cGVzIGluIGRvbVRyZWUuanMuIFNpbmNlIE1hdGhNTCBoYW5kbGVzIGl0cyBvd24gcmVuZGVyaW5nLCBhbmRcbiAqIHNpbmNlIHdlJ3JlIG1haW5seSB1c2luZyBNYXRoTUwgdG8gaW1wcm92ZSBhY2Nlc3NpYmlsaXR5LCB3ZSBkb24ndCBtYW5hZ2VcbiAqIGFueSBvZiB0aGUgc3R5bGluZyBzdGF0ZSB0aGF0IHRoZSBwbGFpbiBET00gbm9kZXMgZG8uXG4gKlxuICogVGhlIGB0b05vZGVgIGFuZCBgdG9NYXJrdXBgIGZ1bmN0aW9ucyB3b3JrIHNpbWxhcmx5IHRvIGhvdyB0aGV5IGRvIGluXG4gKiBkb21UcmVlLmpzLCBjcmVhdGluZyBuYW1lc3BhY2VkIERPTSBub2RlcyBhbmQgSFRNTCB0ZXh0IG1hcmt1cCByZXNwZWN0aXZlbHkuXG4gKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5cbi8qKlxuICogVGhpcyBub2RlIHJlcHJlc2VudHMgYSBnZW5lcmFsIHB1cnBvc2UgTWF0aE1MIG5vZGUgb2YgYW55IHR5cGUuIFRoZVxuICogY29uc3RydWN0b3IgcmVxdWlyZXMgdGhlIHR5cGUgb2Ygbm9kZSB0byBjcmVhdGUgKGZvciBleGFtcGxlLCBgXCJtb1wiYCBvclxuICogYFwibXNwYWNlXCJgLCBjb3JyZXNwb25kaW5nIHRvIGA8bW8+YCBhbmQgYDxtc3BhY2U+YCB0YWdzKS5cbiAqL1xuZnVuY3Rpb24gTWF0aE5vZGUodHlwZSwgY2hpbGRyZW4pIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCBbXTtcbn1cblxuLyoqXG4gKiBTZXRzIGFuIGF0dHJpYnV0ZSBvbiBhIE1hdGhNTCBub2RlLiBNYXRoTUwgZGVwZW5kcyBvbiBhdHRyaWJ1dGVzIHRvIGNvbnZleSBhXG4gKiBzZW1hbnRpYyBjb250ZW50LCBzbyB0aGlzIGlzIHVzZWQgaGVhdmlseS5cbiAqL1xuTWF0aE5vZGUucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzW25hbWVdID0gdmFsdWU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhIE1hdGhNTC1uYW1lc3BhY2VkIERPTSBlbGVtZW50LlxuICovXG5NYXRoTm9kZS5wcm90b3R5cGUudG9Ob2RlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXG4gICAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiLCB0aGlzLnR5cGUpO1xuXG4gICAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZHJlbltpXS50b05vZGUoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhbiBIVE1MIG1hcmt1cCBzdHJpbmcuXG4gKi9cbk1hdGhOb2RlLnByb3RvdHlwZS50b01hcmt1cCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtYXJrdXAgPSBcIjxcIiArIHRoaXMudHlwZTtcblxuICAgIC8vIEFkZCB0aGUgYXR0cmlidXRlc1xuICAgIGZvciAodmFyIGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5hdHRyaWJ1dGVzLCBhdHRyKSkge1xuICAgICAgICAgICAgbWFya3VwICs9IFwiIFwiICsgYXR0ciArIFwiPVxcXCJcIjtcbiAgICAgICAgICAgIG1hcmt1cCArPSB1dGlscy5lc2NhcGUodGhpcy5hdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICAgICAgICAgIG1hcmt1cCArPSBcIlxcXCJcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1hcmt1cCArPSBcIj5cIjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXJrdXAgKz0gdGhpcy5jaGlsZHJlbltpXS50b01hcmt1cCgpO1xuICAgIH1cblxuICAgIG1hcmt1cCArPSBcIjwvXCIgKyB0aGlzLnR5cGUgKyBcIj5cIjtcblxuICAgIHJldHVybiBtYXJrdXA7XG59O1xuXG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgcGllY2Ugb2YgdGV4dC5cbiAqL1xuZnVuY3Rpb24gVGV4dE5vZGUodGV4dCkge1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIHRleHQgbm9kZSBpbnRvIGEgRE9NIHRleHQgbm9kZS5cbiAqL1xuVGV4dE5vZGUucHJvdG90eXBlLnRvTm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRleHQpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgdGV4dCBub2RlIGludG8gSFRNTCBtYXJrdXAgKHdoaWNoIGlzIGp1c3QgdGhlIHRleHQgaXRzZWxmKS5cbiAqL1xuVGV4dE5vZGUucHJvdG90eXBlLnRvTWFya3VwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVzY2FwZSh0aGlzLnRleHQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgTWF0aE5vZGU6IE1hdGhOb2RlLFxuICAgIFRleHROb2RlOiBUZXh0Tm9kZVxufTtcbiIsIi8qKlxuICogVGhlIHJlc3VsdGluZyBwYXJzZSB0cmVlIG5vZGVzIG9mIHRoZSBwYXJzZSB0cmVlLlxuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIHByb3ZpZGUgcG9zaXRpb24gaW5mb3JtYXRpb24sIHNvIHRoYXQgYSBQYXJzZU5vZGUgY2FuXG4gKiBmdWxmaWwgYSByb2xlIHNpbWlsYXIgdG8gYSBUb2tlbiBpbiBlcnJvciByZXBvcnRpbmcuXG4gKiBGb3IgZGV0YWlscyBvbiB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0aWVzIHNlZSBUb2tlbiBjb25zdHJ1Y3Rvci5cbiAqIFByb3ZpZGluZyBzdWNoIGluZm9ybWF0aW9uIGNhbiBsZWFkIHRvIGJldHRlciBlcnJvciByZXBvcnRpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICB0eXBlICAgICAgIHR5cGUgb2Ygbm9kZSwgbGlrZSBlLmcuIFwib3JkZ3JvdXBcIlxuICogQHBhcmFtIHs/b2JqZWN0fSB2YWx1ZSAgICAgIHR5cGUtc3BlY2lmaWMgcmVwcmVzZW50YXRpb24gb2YgdGhlIG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSAgbW9kZSAgICAgICBwYXJzZSBtb2RlIGluIGFjdGlvbiBmb3IgdGhpcyBub2RlLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWF0aFwiIG9yIFwidGV4dFwiXG4gKiBAcGFyYW0ge1Rva2VuPX0gZmlyc3RUb2tlbiAgZmlyc3QgdG9rZW4gb2YgdGhlIGlucHV0IGZvciB0aGlzIG5vZGUsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBvbWl0IHBvc2l0aW9uIGluZm9ybWF0aW9uIGlmIHVuc2V0XG4gKiBAcGFyYW0ge1Rva2VuPX0gbGFzdFRva2VuICAgbGFzdCB0b2tlbiBvZiB0aGUgaW5wdXQgZm9yIHRoaXMgbm9kZSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGRlZmF1bHQgdG8gZmlyc3RUb2tlbiBpZiB1bnNldFxuICovXG5mdW5jdGlvbiBQYXJzZU5vZGUodHlwZSwgdmFsdWUsIG1vZGUsIGZpcnN0VG9rZW4sIGxhc3RUb2tlbikge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgaWYgKGZpcnN0VG9rZW4gJiYgKCFsYXN0VG9rZW4gfHwgbGFzdFRva2VuLmxleGVyID09PSBmaXJzdFRva2VuLmxleGVyKSkge1xuICAgICAgICB0aGlzLmxleGVyID0gZmlyc3RUb2tlbi5sZXhlcjtcbiAgICAgICAgdGhpcy5zdGFydCA9IGZpcnN0VG9rZW4uc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gKGxhc3RUb2tlbiB8fCBmaXJzdFRva2VuKS5lbmQ7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBQYXJzZU5vZGU6IFBhcnNlTm9kZVxufTtcblxuIiwiLyoqXG4gKiBQcm92aWRlcyBhIHNpbmdsZSBmdW5jdGlvbiBmb3IgcGFyc2luZyBhbiBleHByZXNzaW9uIHVzaW5nIGEgUGFyc2VyXG4gKiBUT0RPKGVtaWx5KTogUmVtb3ZlIHRoaXNcbiAqL1xuXG52YXIgUGFyc2VyID0gcmVxdWlyZShcIi4vUGFyc2VyXCIpO1xuXG4vKipcbiAqIFBhcnNlcyBhbiBleHByZXNzaW9uIHVzaW5nIGEgUGFyc2VyLCB0aGVuIHJldHVybnMgdGhlIHBhcnNlZCByZXN1bHQuXG4gKi9cbnZhciBwYXJzZVRyZWUgPSBmdW5jdGlvbih0b1BhcnNlLCBzZXR0aW5ncykge1xuICAgIGlmICghKHR5cGVvZiB0b1BhcnNlID09PSAnc3RyaW5nJyB8fCB0b1BhcnNlIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdLYVRlWCBjYW4gb25seSBwYXJzZSBzdHJpbmcgdHlwZWQgZXhwcmVzc2lvbicpO1xuICAgIH1cbiAgICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcih0b1BhcnNlLCBzZXR0aW5ncyk7XG5cbiAgICByZXR1cm4gcGFyc2VyLnBhcnNlKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlVHJlZTtcbiIsIi8qKlxuICogVGhpcyBmaWxlIGhvbGRzIGEgbGlzdCBvZiBhbGwgbm8tYXJndW1lbnQgZnVuY3Rpb25zIGFuZCBzaW5nbGUtY2hhcmFjdGVyXG4gKiBzeW1ib2xzIChsaWtlICdhJyBvciAnOycpLlxuICpcbiAqIEZvciBlYWNoIG9mIHRoZSBzeW1ib2xzLCB0aGVyZSBhcmUgdGhyZWUgcHJvcGVydGllcyB0aGV5IGNhbiBoYXZlOlxuICogLSBmb250IChyZXF1aXJlZCk6IHRoZSBmb250IHRvIGJlIHVzZWQgZm9yIHRoaXMgc3ltYm9sLiBFaXRoZXIgXCJtYWluXCIgKHRoZVxuICAgICBub3JtYWwgZm9udCksIG9yIFwiYW1zXCIgKHRoZSBhbXMgZm9udHMpLlxuICogLSBncm91cCAocmVxdWlyZWQpOiB0aGUgUGFyc2VOb2RlIGdyb3VwIHR5cGUgdGhlIHN5bWJvbCBzaG91bGQgaGF2ZSAoaS5lLlxuICAgICBcInRleHRvcmRcIiwgXCJtYXRob3JkXCIsIGV0YykuXG4gICAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vS2hhbi9LYVRlWC93aWtpL0V4YW1pbmluZy1UZVgjZ3JvdXAtdHlwZXNcbiAqIC0gcmVwbGFjZTogdGhlIGNoYXJhY3RlciB0aGF0IHRoaXMgc3ltYm9sIG9yIGZ1bmN0aW9uIHNob3VsZCBiZVxuICogICByZXBsYWNlZCB3aXRoIChpLmUuIFwiXFxwaGlcIiBoYXMgYSByZXBsYWNlIHZhbHVlIG9mIFwiXFx1MDNkNVwiLCB0aGUgcGhpXG4gKiAgIGNoYXJhY3RlciBpbiB0aGUgbWFpbiBmb250KS5cbiAqXG4gKiBUaGUgb3V0ZXJtb3N0IG1hcCBpbiB0aGUgdGFibGUgaW5kaWNhdGVzIHdoYXQgbW9kZSB0aGUgc3ltYm9scyBzaG91bGQgYmVcbiAqIGFjY2VwdGVkIGluIChlLmcuIFwibWF0aFwiIG9yIFwidGV4dFwiKS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtYXRoOiB7fSxcbiAgICB0ZXh0OiB7fVxufTtcblxuZnVuY3Rpb24gZGVmaW5lU3ltYm9sKG1vZGUsIGZvbnQsIGdyb3VwLCByZXBsYWNlLCBuYW1lKSB7XG4gICAgbW9kdWxlLmV4cG9ydHNbbW9kZV1bbmFtZV0gPSB7XG4gICAgICAgIGZvbnQ6IGZvbnQsXG4gICAgICAgIGdyb3VwOiBncm91cCxcbiAgICAgICAgcmVwbGFjZTogcmVwbGFjZVxuICAgIH07XG59XG5cbi8vIFNvbWUgYWJicmV2aWF0aW9ucyBmb3IgY29tbW9ubHkgdXNlZCBzdHJpbmdzLlxuLy8gVGhpcyBoZWxwcyBtaW5pZnkgdGhlIGNvZGUsIGFuZCBhbHNvIHNwb3R0aW5nIHR5cG9zIHVzaW5nIGpzaGludC5cblxuLy8gbW9kZXM6XG52YXIgbWF0aCA9IFwibWF0aFwiO1xudmFyIHRleHQgPSBcInRleHRcIjtcblxuLy8gZm9udHM6XG52YXIgbWFpbiA9IFwibWFpblwiO1xudmFyIGFtcyA9IFwiYW1zXCI7XG5cbi8vIGdyb3VwczpcbnZhciBhY2NlbnQgPSBcImFjY2VudFwiO1xudmFyIGJpbiA9IFwiYmluXCI7XG52YXIgY2xvc2UgPSBcImNsb3NlXCI7XG52YXIgaW5uZXIgPSBcImlubmVyXCI7XG52YXIgbWF0aG9yZCA9IFwibWF0aG9yZFwiO1xudmFyIG9wID0gXCJvcFwiO1xudmFyIG9wZW4gPSBcIm9wZW5cIjtcbnZhciBwdW5jdCA9IFwicHVuY3RcIjtcbnZhciByZWwgPSBcInJlbFwiO1xudmFyIHNwYWNpbmcgPSBcInNwYWNpbmdcIjtcbnZhciB0ZXh0b3JkID0gXCJ0ZXh0b3JkXCI7XG5cbi8vIE5vdyBjb21lcyB0aGUgc3ltYm9sIHRhYmxlXG5cbi8vIFJlbGF0aW9uIFN5bWJvbHNcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI2MVwiLCBcIlxcXFxlcXVpdlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI3YVwiLCBcIlxcXFxwcmVjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjdiXCIsIFwiXFxcXHN1Y2NcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyM2NcIiwgXCJcXFxcc2ltXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMmE1XCIsIFwiXFxcXHBlcnBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTJhYWZcIiwgXCJcXFxccHJlY2VxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyYWIwXCIsIFwiXFxcXHN1Y2NlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI0M1wiLCBcIlxcXFxzaW1lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjIyM1wiLCBcIlxcXFxtaWRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNmFcIiwgXCJcXFxcbGxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNmJcIiwgXCJcXFxcZ2dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNGRcIiwgXCJcXFxcYXN5bXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyMjVcIiwgXCJcXFxccGFyYWxsZWxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyYzhcIiwgXCJcXFxcYm93dGllXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMzIzXCIsIFwiXFxcXHNtaWxlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjkxXCIsIFwiXFxcXHNxc3Vic2V0ZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyOTJcIiwgXCJcXFxcc3FzdXBzZXRlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI1MFwiLCBcIlxcXFxkb3RlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjMyMlwiLCBcIlxcXFxmcm93blwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjIwYlwiLCBcIlxcXFxuaVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjIxZFwiLCBcIlxcXFxwcm9wdG9cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyYTJcIiwgXCJcXFxcdmRhc2hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyYTNcIiwgXCJcXFxcZGFzaHZcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyMGJcIiwgXCJcXFxcb3duc1wiKTtcblxuLy8gUHVuY3R1YXRpb25cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBwdW5jdCwgXCJcXHUwMDJlXCIsIFwiXFxcXGxkb3RwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHB1bmN0LCBcIlxcdTIyYzVcIiwgXCJcXFxcY2RvdHBcIik7XG5cbi8vIE1pc2MgU3ltYm9sc1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDAyM1wiLCBcIlxcXFwjXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDAyM1wiLCBcIlxcXFwjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDAyNlwiLCBcIlxcXFwmXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDAyNlwiLCBcIlxcXFwmXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjEzNVwiLCBcIlxcXFxhbGVwaFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMDBcIiwgXCJcXFxcZm9yYWxsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjEwZlwiLCBcIlxcXFxoYmFyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIwM1wiLCBcIlxcXFxleGlzdHNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjA3XCIsIFwiXFxcXG5hYmxhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjY2ZFwiLCBcIlxcXFxmbGF0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjExM1wiLCBcIlxcXFxlbGxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyNjZlXCIsIFwiXFxcXG5hdHVyYWxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyNjYzXCIsIFwiXFxcXGNsdWJzdWl0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjExOFwiLCBcIlxcXFx3cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTI2NmZcIiwgXCJcXFxcc2hhcnBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyNjYyXCIsIFwiXFxcXGRpYW1vbmRzdWl0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjExY1wiLCBcIlxcXFxSZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTI2NjFcIiwgXCJcXFxcaGVhcnRzdWl0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjExMVwiLCBcIlxcXFxJbVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTI2NjBcIiwgXCJcXFxcc3BhZGVzdWl0XCIpO1xuXG4vLyBNYXRoIGFuZCBUZXh0XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDIwXCIsIFwiXFxcXGRhZ1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMjFcIiwgXCJcXFxcZGRhZ1wiKTtcblxuLy8gTGFyZ2UgRGVsaW1pdGVyc1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGNsb3NlLCBcIlxcdTIzYjFcIiwgXCJcXFxccm1vdXN0YWNoZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCBcIlxcdTIzYjBcIiwgXCJcXFxcbG1vdXN0YWNoZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgXCJcXHUyN2VmXCIsIFwiXFxcXHJncm91cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCBcIlxcdTI3ZWVcIiwgXCJcXFxcbGdyb3VwXCIpO1xuXG4vLyBCaW5hcnkgT3BlcmF0b3JzXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMTNcIiwgXCJcXFxcbXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOTZcIiwgXCJcXFxcb21pbnVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjhlXCIsIFwiXFxcXHVwbHVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjkzXCIsIFwiXFxcXHNxY2FwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjE3XCIsIFwiXFxcXGFzdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjI5NFwiLCBcIlxcXFxzcWN1cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjVlZlwiLCBcIlxcXFxiaWdjaXJjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjE5XCIsIFwiXFxcXGJ1bGxldFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjAyMVwiLCBcIlxcXFxkZGFnZ2VyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjQwXCIsIFwiXFxcXHdyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyYTNmXCIsIFwiXFxcXGFtYWxnXCIpO1xuXG4vLyBBcnJvdyBTeW1ib2xzXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTI3ZjVcIiwgXCJcXFxcbG9uZ2xlZnRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkMFwiLCBcIlxcXFxMZWZ0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTI3ZjhcIiwgXCJcXFxcTG9uZ2xlZnRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjdmNlwiLCBcIlxcXFxsb25ncmlnaHRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkMlwiLCBcIlxcXFxSaWdodGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyN2Y5XCIsIFwiXFxcXExvbmdyaWdodGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTk0XCIsIFwiXFxcXGxlZnRyaWdodGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyN2Y3XCIsIFwiXFxcXGxvbmdsZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkNFwiLCBcIlxcXFxMZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjdmYVwiLCBcIlxcXFxMb25nbGVmdHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxYTZcIiwgXCJcXFxcbWFwc3RvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyN2ZjXCIsIFwiXFxcXGxvbmdtYXBzdG9cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTdcIiwgXCJcXFxcbmVhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFhOVwiLCBcIlxcXFxob29rbGVmdGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWFhXCIsIFwiXFxcXGhvb2tyaWdodGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTk4XCIsIFwiXFxcXHNlYXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxYmNcIiwgXCJcXFxcbGVmdGhhcnBvb251cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFjMFwiLCBcIlxcXFxyaWdodGhhcnBvb251cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5OVwiLCBcIlxcXFxzd2Fycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWJkXCIsIFwiXFxcXGxlZnRoYXJwb29uZG93blwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFjMVwiLCBcIlxcXFxyaWdodGhhcnBvb25kb3duXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTk2XCIsIFwiXFxcXG53YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxY2NcIiwgXCJcXFxccmlnaHRsZWZ0aGFycG9vbnNcIik7XG5cbi8vIEFNUyBOZWdhdGVkIEJpbmFyeSBSZWxhdGlvbnNcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjZlXCIsIFwiXFxcXG5sZXNzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMTBcIiwgXCJcXFxcbmxlcXNsYW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMTFcIiwgXCJcXFxcbmxlcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE4N1wiLCBcIlxcXFxsbmVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNjhcIiwgXCJcXFxcbG5lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAwY1wiLCBcIlxcXFxsdmVydG5lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJlNlwiLCBcIlxcXFxsbnNpbVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYTg5XCIsIFwiXFxcXGxuYXBwcm94XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyODBcIiwgXCJcXFxcbnByZWNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJlMFwiLCBcIlxcXFxucHJlY2VxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZThcIiwgXCJcXFxccHJlY25zaW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmFiOVwiLCBcIlxcXFxwcmVjbmFwcHJveFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjQxXCIsIFwiXFxcXG5zaW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAwNlwiLCBcIlxcXFxuc2hvcnRtaWRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIyNFwiLCBcIlxcXFxubWlkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYWNcIiwgXCJcXFxcbnZkYXNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYWRcIiwgXCJcXFxcbnZEYXNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZWFcIiwgXCJcXFxcbnRyaWFuZ2xlbGVmdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmVjXCIsIFwiXFxcXG50cmlhbmdsZWxlZnRlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjhhXCIsIFwiXFxcXHN1YnNldG5lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDFhXCIsIFwiXFxcXHZhcnN1YnNldG5lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWNiXCIsIFwiXFxcXHN1YnNldG5lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAxN1wiLCBcIlxcXFx2YXJzdWJzZXRuZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNmZcIiwgXCJcXFxcbmd0clwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDBmXCIsIFwiXFxcXG5nZXFzbGFudFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDBlXCIsIFwiXFxcXG5nZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhODhcIiwgXCJcXFxcZ25lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjY5XCIsIFwiXFxcXGduZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMGRcIiwgXCJcXFxcZ3ZlcnRuZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZTdcIiwgXCJcXFxcZ25zaW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE4YVwiLCBcIlxcXFxnbmFwcHJveFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjgxXCIsIFwiXFxcXG5zdWNjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZTFcIiwgXCJcXFxcbnN1Y2NlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmU5XCIsIFwiXFxcXHN1Y2Nuc2ltXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhYmFcIiwgXCJcXFxcc3VjY25hcHByb3hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI0NlwiLCBcIlxcXFxuY29uZ1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDA3XCIsIFwiXFxcXG5zaG9ydHBhcmFsbGVsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyMjZcIiwgXCJcXFxcbnBhcmFsbGVsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYWZcIiwgXCJcXFxcblZEYXNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZWJcIiwgXCJcXFxcbnRyaWFuZ2xlcmlnaHRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJlZFwiLCBcIlxcXFxudHJpYW5nbGVyaWdodGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMThcIiwgXCJcXFxcbnN1cHNldGVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjhiXCIsIFwiXFxcXHN1cHNldG5lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDFiXCIsIFwiXFxcXHZhcnN1cHNldG5lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWNjXCIsIFwiXFxcXHN1cHNldG5lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAxOVwiLCBcIlxcXFx2YXJzdXBzZXRuZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYWVcIiwgXCJcXFxcblZkYXNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhYjVcIiwgXCJcXFxccHJlY25lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmFiNlwiLCBcIlxcXFxzdWNjbmVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDE2XCIsIFwiXFxcXG5zdWJzZXRlcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJiNFwiLCBcIlxcXFx1bmxoZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmI1XCIsIFwiXFxcXHVucmhkXCIpO1xuXG4vLyBBTVMgTmVnYXRlZCBBcnJvd3NcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMTlhXCIsIFwiXFxcXG5sZWZ0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjE5YlwiLCBcIlxcXFxucmlnaHRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWNkXCIsIFwiXFxcXG5MZWZ0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjZlwiLCBcIlxcXFxuUmlnaHRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWFlXCIsIFwiXFxcXG5sZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWNlXCIsIFwiXFxcXG5MZWZ0cmlnaHRhcnJvd1wiKTtcblxuLy8gQU1TIE1pc2NcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyNWIzXCIsIFwiXFxcXHZhcnRyaWFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMTBmXCIsIFwiXFxcXGhzbGFzaFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjViZFwiLCBcIlxcXFx0cmlhbmdsZWRvd25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI1Y2FcIiwgXCJcXFxcbG96ZW5nZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjRjOFwiLCBcIlxcXFxjaXJjbGVkU1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MDBhZVwiLCBcIlxcXFxjaXJjbGVkUlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjIyMVwiLCBcIlxcXFxtZWFzdXJlZGFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMjA0XCIsIFwiXFxcXG5leGlzdHNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTIxMjdcIiwgXCJcXFxcbWhvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMTMyXCIsIFwiXFxcXEZpbnZcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTIxNDFcIiwgXCJcXFxcR2FtZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MDA2YlwiLCBcIlxcXFxCYmJrXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMDM1XCIsIFwiXFxcXGJhY2twcmltZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjViMlwiLCBcIlxcXFxibGFja3RyaWFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNWJjXCIsIFwiXFxcXGJsYWNrdHJpYW5nbGVkb3duXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNWEwXCIsIFwiXFxcXGJsYWNrc3F1YXJlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyOWViXCIsIFwiXFxcXGJsYWNrbG96ZW5nZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjYwNVwiLCBcIlxcXFxiaWdzdGFyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMjIyXCIsIFwiXFxcXHNwaGVyaWNhbGFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMjAxXCIsIFwiXFxcXGNvbXBsZW1lbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTAwZjBcIiwgXCJcXFxcZXRoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNTcxXCIsIFwiXFxcXGRpYWd1cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjU3MlwiLCBcIlxcXFxkaWFnZG93blwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjVhMVwiLCBcIlxcXFxzcXVhcmVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI1YTFcIiwgXCJcXFxcQm94XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNWNhXCIsIFwiXFxcXERpYW1vbmRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTAwYTVcIiwgXCJcXFxceWVuXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNzEzXCIsIFwiXFxcXGNoZWNrbWFya1wiKTtcblxuLy8gQU1TIEhlYnJld1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMTM2XCIsIFwiXFxcXGJldGhcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTIxMzhcIiwgXCJcXFxcZGFsZXRoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMTM3XCIsIFwiXFxcXGdpbWVsXCIpO1xuXG4vLyBBTVMgR3JlZWtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MDNkZFwiLCBcIlxcXFxkaWdhbW1hXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUwM2YwXCIsIFwiXFxcXHZhcmthcHBhXCIpO1xuXG4vLyBBTVMgRGVsaW1pdGVyc1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgb3BlbiwgXCJcXHUyNTBjXCIsIFwiXFxcXHVsY29ybmVyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgY2xvc2UsIFwiXFx1MjUxMFwiLCBcIlxcXFx1cmNvcm5lclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIG9wZW4sIFwiXFx1MjUxNFwiLCBcIlxcXFxsbGNvcm5lclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGNsb3NlLCBcIlxcdTI1MThcIiwgXCJcXFxcbHJjb3JuZXJcIik7XG5cbi8vIEFNUyBCaW5hcnkgUmVsYXRpb25zXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI2NlwiLCBcIlxcXFxsZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhN2RcIiwgXCJcXFxcbGVxc2xhbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE5NVwiLCBcIlxcXFxlcXNsYW50bGVzc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjcyXCIsIFwiXFxcXGxlc3NzaW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE4NVwiLCBcIlxcXFxsZXNzYXBwcm94XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNGFcIiwgXCJcXFxcYXBwcm94ZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJkNlwiLCBcIlxcXFxsZXNzZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZDhcIiwgXCJcXFxcbGxsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNzZcIiwgXCJcXFxcbGVzc2d0clwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmRhXCIsIFwiXFxcXGxlc3NlcWd0clwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYThiXCIsIFwiXFxcXGxlc3NlcXFndHJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1MVwiLCBcIlxcXFxkb3RlcWRvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjUzXCIsIFwiXFxcXHJpc2luZ2RvdHNlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjUyXCIsIFwiXFxcXGZhbGxpbmdkb3RzZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIzZFwiLCBcIlxcXFxiYWNrc2ltXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyY2RcIiwgXCJcXFxcYmFja3NpbWVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhYzVcIiwgXCJcXFxcc3Vic2V0ZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZDBcIiwgXCJcXFxcU3Vic2V0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyOGZcIiwgXCJcXFxcc3FzdWJzZXRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI3Y1wiLCBcIlxcXFxwcmVjY3VybHllcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmRlXCIsIFwiXFxcXGN1cmx5ZXFwcmVjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyN2VcIiwgXCJcXFxccHJlY3NpbVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWI3XCIsIFwiXFxcXHByZWNhcHByb3hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJiMlwiLCBcIlxcXFx2YXJ0cmlhbmdsZWxlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJiNFwiLCBcIlxcXFx0cmlhbmdsZWxlZnRlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmE4XCIsIFwiXFxcXHZEYXNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYWFcIiwgXCJcXFxcVnZkYXNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIzMjNcIiwgXCJcXFxcc21hbGxzbWlsZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMzIyXCIsIFwiXFxcXHNtYWxsZnJvd25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI0ZlwiLCBcIlxcXFxidW1wZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI0ZVwiLCBcIlxcXFxCdW1wZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI2N1wiLCBcIlxcXFxnZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhN2VcIiwgXCJcXFxcZ2Vxc2xhbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE5NlwiLCBcIlxcXFxlcXNsYW50Z3RyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNzNcIiwgXCJcXFxcZ3Ryc2ltXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhODZcIiwgXCJcXFxcZ3RyYXBwcm94XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyZDdcIiwgXCJcXFxcZ3RyZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZDlcIiwgXCJcXFxcZ2dnXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNzdcIiwgXCJcXFxcZ3RybGVzc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmRiXCIsIFwiXFxcXGd0cmVxbGVzc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYThjXCIsIFwiXFxcXGd0cmVxcWxlc3NcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1NlwiLCBcIlxcXFxlcWNpcmNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1N1wiLCBcIlxcXFxjaXJjZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1Y1wiLCBcIlxcXFx0cmlhbmdsZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIzY1wiLCBcIlxcXFx0aGlja3NpbVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjQ4XCIsIFwiXFxcXHRoaWNrYXBwcm94XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhYzZcIiwgXCJcXFxcc3Vwc2V0ZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZDFcIiwgXCJcXFxcU3Vwc2V0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyOTBcIiwgXCJcXFxcc3FzdXBzZXRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI3ZFwiLCBcIlxcXFxzdWNjY3VybHllcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmRmXCIsIFwiXFxcXGN1cmx5ZXFzdWNjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyN2ZcIiwgXCJcXFxcc3VjY3NpbVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWI4XCIsIFwiXFxcXHN1Y2NhcHByb3hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJiM1wiLCBcIlxcXFx2YXJ0cmlhbmdsZXJpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYjVcIiwgXCJcXFxcdHJpYW5nbGVyaWdodGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYTlcIiwgXCJcXFxcVmRhc2hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIyM1wiLCBcIlxcXFxzaG9ydG1pZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjI1XCIsIFwiXFxcXHNob3J0cGFyYWxsZWxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI2Y1wiLCBcIlxcXFxiZXR3ZWVuXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZDRcIiwgXCJcXFxccGl0Y2hmb3JrXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyMWRcIiwgXCJcXFxcdmFycHJvcHRvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTI1YzBcIiwgXCJcXFxcYmxhY2t0cmlhbmdsZWxlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIzNFwiLCBcIlxcXFx0aGVyZWZvcmVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIwZFwiLCBcIlxcXFxiYWNrZXBzaWxvblwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyNWI2XCIsIFwiXFxcXGJsYWNrdHJpYW5nbGVyaWdodFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjM1XCIsIFwiXFxcXGJlY2F1c2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJkOFwiLCBcIlxcXFxsbGxlc3NcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJkOVwiLCBcIlxcXFxnZ2d0clwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmIyXCIsIFwiXFxcXGxoZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmIzXCIsIFwiXFxcXHJoZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjQyXCIsIFwiXFxcXGVxc2ltXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMmM4XCIsIFwiXFxcXEpvaW5cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1MVwiLCBcIlxcXFxEb3RlcVwiKTtcblxuLy8gQU1TIEJpbmFyeSBPcGVyYXRvcnNcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMjE0XCIsIFwiXFxcXGRvdHBsdXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjIxNlwiLCBcIlxcXFxzbWFsbHNldG1pbnVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyZDJcIiwgXCJcXFxcQ2FwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyZDNcIiwgXCJcXFxcQ3VwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTJhNWVcIiwgXCJcXFxcZG91YmxlYmFyd2VkZ2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjI5ZlwiLCBcIlxcXFxib3htaW51c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMjllXCIsIFwiXFxcXGJveHBsdXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJjN1wiLCBcIlxcXFxkaXZpZGVvbnRpbWVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYzlcIiwgXCJcXFxcbHRpbWVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyY2FcIiwgXCJcXFxccnRpbWVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyY2JcIiwgXCJcXFxcbGVmdHRocmVldGltZXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJjY1wiLCBcIlxcXFxyaWdodHRocmVldGltZXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJjZlwiLCBcIlxcXFxjdXJseXdlZGdlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyY2VcIiwgXCJcXFxcY3VybHl2ZWVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjI5ZFwiLCBcIlxcXFxjaXJjbGVkZGFzaFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMjliXCIsIFwiXFxcXGNpcmNsZWRhc3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJjNVwiLCBcIlxcXFxjZW50ZXJkb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJiYVwiLCBcIlxcXFxpbnRlcmNhbFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmQyXCIsIFwiXFxcXGRvdWJsZWNhcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmQzXCIsIFwiXFxcXGRvdWJsZWN1cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmEwXCIsIFwiXFxcXGJveHRpbWVzXCIpO1xuXG4vLyBBTVMgQXJyb3dzXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFlMlwiLCBcIlxcXFxkYXNocmlnaHRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWUwXCIsIFwiXFxcXGRhc2hsZWZ0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjN1wiLCBcIlxcXFxsZWZ0bGVmdGFycm93c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWM2XCIsIFwiXFxcXGxlZnRyaWdodGFycm93c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWRhXCIsIFwiXFxcXExsZWZ0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjE5ZVwiLCBcIlxcXFx0d29oZWFkbGVmdGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYTJcIiwgXCJcXFxcbGVmdGFycm93dGFpbFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWFiXCIsIFwiXFxcXGxvb3BhcnJvd2xlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjYlwiLCBcIlxcXFxsZWZ0cmlnaHRoYXJwb29uc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWI2XCIsIFwiXFxcXGN1cnZlYXJyb3dsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYmFcIiwgXCJcXFxcY2lyY2xlYXJyb3dsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYjBcIiwgXCJcXFxcTHNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYzhcIiwgXCJcXFxcdXB1cGFycm93c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWJmXCIsIFwiXFxcXHVwaGFycG9vbmxlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjM1wiLCBcIlxcXFxkb3duaGFycG9vbmxlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJiOFwiLCBcIlxcXFxtdWx0aW1hcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWFkXCIsIFwiXFxcXGxlZnRyaWdodHNxdWlnYXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjOVwiLCBcIlxcXFxyaWdodHJpZ2h0YXJyb3dzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYzRcIiwgXCJcXFxccmlnaHRsZWZ0YXJyb3dzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYTBcIiwgXCJcXFxcdHdvaGVhZHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFhM1wiLCBcIlxcXFxyaWdodGFycm93dGFpbFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWFjXCIsIFwiXFxcXGxvb3BhcnJvd3JpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYjdcIiwgXCJcXFxcY3VydmVhcnJvd3JpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYmJcIiwgXCJcXFxcY2lyY2xlYXJyb3dyaWdodFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWIxXCIsIFwiXFxcXFJzaFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWNhXCIsIFwiXFxcXGRvd25kb3duYXJyb3dzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYmVcIiwgXCJcXFxcdXBoYXJwb29ucmlnaHRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjMlwiLCBcIlxcXFxkb3duaGFycG9vbnJpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxZGRcIiwgXCJcXFxccmlnaHRzcXVpZ2Fycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxZGRcIiwgXCJcXFxcbGVhZHN0b1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWRiXCIsIFwiXFxcXFJyaWdodGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYmVcIiwgXCJcXFxccmVzdHJpY3Rpb25cIik7XG5cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMThcIiwgXCJgXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiJFwiLCBcIlxcXFwkXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiJFwiLCBcIlxcXFwkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiJVwiLCBcIlxcXFwlXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiJVwiLCBcIlxcXFwlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiX1wiLCBcIlxcXFxfXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiX1wiLCBcIlxcXFxfXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIyMFwiLCBcIlxcXFxhbmdsZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMWVcIiwgXCJcXFxcaW5mdHlcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDMyXCIsIFwiXFxcXHByaW1lXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjViM1wiLCBcIlxcXFx0cmlhbmdsZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzOTNcIiwgXCJcXFxcR2FtbWFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMzk0XCIsIFwiXFxcXERlbHRhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDM5OFwiLCBcIlxcXFxUaGV0YVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzOWJcIiwgXCJcXFxcTGFtYmRhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDM5ZVwiLCBcIlxcXFxYaVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzYTBcIiwgXCJcXFxcUGlcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwM2EzXCIsIFwiXFxcXFNpZ21hXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDNhNVwiLCBcIlxcXFxVcHNpbG9uXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDNhNlwiLCBcIlxcXFxQaGlcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwM2E4XCIsIFwiXFxcXFBzaVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzYTlcIiwgXCJcXFxcT21lZ2FcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMGFjXCIsIFwiXFxcXG5lZ1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwYWNcIiwgXCJcXFxcbG5vdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyYTRcIiwgXCJcXFxcdG9wXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjJhNVwiLCBcIlxcXFxib3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjA1XCIsIFwiXFxcXGVtcHR5c2V0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMjA1XCIsIFwiXFxcXHZhcm5vdGhpbmdcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2IxXCIsIFwiXFxcXGFscGhhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiMlwiLCBcIlxcXFxiZXRhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiM1wiLCBcIlxcXFxnYW1tYVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYjRcIiwgXCJcXFxcZGVsdGFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2Y1XCIsIFwiXFxcXGVwc2lsb25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2I2XCIsIFwiXFxcXHpldGFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2I3XCIsIFwiXFxcXGV0YVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYjhcIiwgXCJcXFxcdGhldGFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2I5XCIsIFwiXFxcXGlvdGFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2JhXCIsIFwiXFxcXGthcHBhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiYlwiLCBcIlxcXFxsYW1iZGFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2JjXCIsIFwiXFxcXG11XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiZFwiLCBcIlxcXFxudVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYmVcIiwgXCJcXFxceGlcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJvXCIsIFwiXFxcXG9taWNyb25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2MwXCIsIFwiXFxcXHBpXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNjMVwiLCBcIlxcXFxyaG9cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2MzXCIsIFwiXFxcXHNpZ21hXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNjNFwiLCBcIlxcXFx0YXVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2M1XCIsIFwiXFxcXHVwc2lsb25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2Q1XCIsIFwiXFxcXHBoaVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYzdcIiwgXCJcXFxcY2hpXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNjOFwiLCBcIlxcXFxwc2lcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2M5XCIsIFwiXFxcXG9tZWdhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiNVwiLCBcIlxcXFx2YXJlcHNpbG9uXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNkMVwiLCBcIlxcXFx2YXJ0aGV0YVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzZDZcIiwgXCJcXFxcdmFycGlcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2YxXCIsIFwiXFxcXHZhcnJob1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYzJcIiwgXCJcXFxcdmFyc2lnbWFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2M2XCIsIFwiXFxcXHZhcnBoaVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIxN1wiLCBcIipcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIitcIiwgXCIrXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjEyXCIsIFwiLVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjJjNVwiLCBcIlxcXFxjZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjE4XCIsIFwiXFxcXGNpcmNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTAwZjdcIiwgXCJcXFxcZGl2XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUwMGIxXCIsIFwiXFxcXHBtXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUwMGQ3XCIsIFwiXFxcXHRpbWVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjI5XCIsIFwiXFxcXGNhcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIyYVwiLCBcIlxcXFxjdXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMTZcIiwgXCJcXFxcc2V0bWludXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMjdcIiwgXCJcXFxcbGFuZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIyOFwiLCBcIlxcXFxsb3JcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMjdcIiwgXCJcXFxcd2VkZ2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMjhcIiwgXCJcXFxcdmVlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIxYVwiLCBcIlxcXFxzdXJkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wZW4sIFwiKFwiLCBcIihcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3BlbiwgXCJbXCIsIFwiW1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCBcIlxcdTI3ZThcIiwgXCJcXFxcbGFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wZW4sIFwiXFx1MjIyM1wiLCBcIlxcXFxsdmVydFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCBcIlxcdTIyMjVcIiwgXCJcXFxcbFZlcnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiKVwiLCBcIilcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiXVwiLCBcIl1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiP1wiLCBcIj9cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiIVwiLCBcIiFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiXFx1MjdlOVwiLCBcIlxcXFxyYW5nbGVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiXFx1MjIyM1wiLCBcIlxcXFxydmVydFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgXCJcXHUyMjI1XCIsIFwiXFxcXHJWZXJ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCI9XCIsIFwiPVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiPFwiLCBcIjxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIj5cIiwgXCI+XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCI6XCIsIFwiOlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI0OFwiLCBcIlxcXFxhcHByb3hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNDVcIiwgXCJcXFxcY29uZ1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI2NVwiLCBcIlxcXFxnZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI2NVwiLCBcIlxcXFxnZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTBcIiwgXCJcXFxcZ2V0c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiPlwiLCBcIlxcXFxndFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjIwOFwiLCBcIlxcXFxpblwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjIwOVwiLCBcIlxcXFxub3RpblwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI4MlwiLCBcIlxcXFxzdWJzZXRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyODNcIiwgXCJcXFxcc3Vwc2V0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjg2XCIsIFwiXFxcXHN1YnNldGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjg3XCIsIFwiXFxcXHN1cHNldGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyODhcIiwgXCJcXFxcbnN1YnNldGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyODlcIiwgXCJcXFxcbnN1cHNldGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMmE4XCIsIFwiXFxcXG1vZGVsc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5MFwiLCBcIlxcXFxsZWZ0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNjRcIiwgXCJcXFxcbGVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNjRcIiwgXCJcXFxcbGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCI8XCIsIFwiXFxcXGx0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjYwXCIsIFwiXFxcXG5lXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjYwXCIsIFwiXFxcXG5lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5MlwiLCBcIlxcXFxyaWdodGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTkyXCIsIFwiXFxcXHRvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNzFcIiwgXCJcXFxcbmdlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjcwXCIsIFwiXFxcXG5sZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgbnVsbCwgXCJcXFxcIVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCJcXFxcIFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCJ+XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHNwYWNpbmcsIG51bGwsIFwiXFxcXCxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgbnVsbCwgXCJcXFxcOlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzcGFjaW5nLCBudWxsLCBcIlxcXFw7XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHNwYWNpbmcsIG51bGwsIFwiXFxcXGVuc3BhY2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgbnVsbCwgXCJcXFxccXF1YWRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgbnVsbCwgXCJcXFxccXVhZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCJcXFxcc3BhY2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcHVuY3QsIFwiLFwiLCBcIixcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcHVuY3QsIFwiO1wiLCBcIjtcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcHVuY3QsIFwiOlwiLCBcIlxcXFxjb2xvblwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmJjXCIsIFwiXFxcXGJhcndlZGdlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYmJcIiwgXCJcXFxcdmVlYmFyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjk5XCIsIFwiXFxcXG9kb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOTVcIiwgXCJcXFxcb3BsdXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOTdcIiwgXCJcXFxcb3RpbWVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIwMlwiLCBcIlxcXFxwYXJ0aWFsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjk4XCIsIFwiXFxcXG9zbGFzaFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMjlhXCIsIFwiXFxcXGNpcmNsZWRjaXJjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYTFcIiwgXCJcXFxcYm94ZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyNWIzXCIsIFwiXFxcXGJpZ3RyaWFuZ2xldXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTI1YmRcIiwgXCJcXFxcYmlndHJpYW5nbGVkb3duXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMDIwXCIsIFwiXFxcXGRhZ2dlclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjJjNFwiLCBcIlxcXFxkaWFtb25kXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMmM2XCIsIFwiXFxcXHN0YXJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTI1YzNcIiwgXCJcXFxcdHJpYW5nbGVsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyNWI5XCIsIFwiXFxcXHRyaWFuZ2xlcmlnaHRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3BlbiwgXCJ7XCIsIFwiXFxcXHtcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJ7XCIsIFwiXFxcXHtcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwifVwiLCBcIlxcXFx9XCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwifVwiLCBcIlxcXFx9XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wZW4sIFwie1wiLCBcIlxcXFxsYnJhY2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwifVwiLCBcIlxcXFxyYnJhY2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3BlbiwgXCJbXCIsIFwiXFxcXGxicmFja1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgXCJdXCIsIFwiXFxcXHJicmFja1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCBcIlxcdTIzMGFcIiwgXCJcXFxcbGZsb29yXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGNsb3NlLCBcIlxcdTIzMGJcIiwgXCJcXFxccmZsb29yXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wZW4sIFwiXFx1MjMwOFwiLCBcIlxcXFxsY2VpbFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgXCJcXHUyMzA5XCIsIFwiXFxcXHJjZWlsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFxcXFwiLCBcIlxcXFxiYWNrc2xhc2hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjIzXCIsIFwifFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMjNcIiwgXCJcXFxcdmVydFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMjVcIiwgXCJcXFxcfFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMjVcIiwgXCJcXFxcVmVydFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5MVwiLCBcIlxcXFx1cGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWQxXCIsIFwiXFxcXFVwYXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTNcIiwgXCJcXFxcZG93bmFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWQzXCIsIFwiXFxcXERvd25hcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5NVwiLCBcIlxcXFx1cGRvd25hcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkNVwiLCBcIlxcXFxVcGRvd25hcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRoLCBvcCwgXCJcXHUyMjEwXCIsIFwiXFxcXGNvcHJvZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRoLCBvcCwgXCJcXHUyMmMxXCIsIFwiXFxcXGJpZ3ZlZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRoLCBvcCwgXCJcXHUyMmMwXCIsIFwiXFxcXGJpZ3dlZGdlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGgsIG9wLCBcIlxcdTJhMDRcIiwgXCJcXFxcYmlndXBsdXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjJjMlwiLCBcIlxcXFxiaWdjYXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjJjM1wiLCBcIlxcXFxiaWdjdXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjIyYlwiLCBcIlxcXFxpbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjIyYlwiLCBcIlxcXFxpbnRvcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRoLCBvcCwgXCJcXHUyMjJjXCIsIFwiXFxcXGlpbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjIyZFwiLCBcIlxcXFxpaWludFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRoLCBvcCwgXCJcXHUyMjBmXCIsIFwiXFxcXHByb2RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjIxMVwiLCBcIlxcXFxzdW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MmEwMlwiLCBcIlxcXFxiaWdvdGltZXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MmEwMVwiLCBcIlxcXFxiaWdvcGx1c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRoLCBvcCwgXCJcXHUyYTAwXCIsIFwiXFxcXGJpZ29kb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjIyZVwiLCBcIlxcXFxvaW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGgsIG9wLCBcIlxcdTJhMDZcIiwgXCJcXFxcYmlnc3FjdXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjIyYlwiLCBcIlxcXFxzbWFsbGludFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBpbm5lciwgXCJcXHUyMDI2XCIsIFwiXFxcXHRleHRlbGxpcHNpc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBpbm5lciwgXCJcXHUyMDI2XCIsIFwiXFxcXG1hdGhlbGxpcHNpc1wiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBpbm5lciwgXCJcXHUyMDI2XCIsIFwiXFxcXGxkb3RzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGlubmVyLCBcIlxcdTIwMjZcIiwgXCJcXFxcbGRvdHNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgaW5uZXIsIFwiXFx1MjJlZlwiLCBcIlxcXFxjZG90c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBpbm5lciwgXCJcXHUyMmYxXCIsIFwiXFxcXGRkb3RzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjJlZVwiLCBcIlxcXFx2ZG90c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDBiNFwiLCBcIlxcXFxhY3V0ZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDA2MFwiLCBcIlxcXFxncmF2ZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDBhOFwiLCBcIlxcXFxkZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMDdlXCIsIFwiXFxcXHRpbGRlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMGFmXCIsIFwiXFxcXGJhclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDJkOFwiLCBcIlxcXFxicmV2ZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDJjN1wiLCBcIlxcXFxjaGVja1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDA1ZVwiLCBcIlxcXFxoYXRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYWNjZW50LCBcIlxcdTIwZDdcIiwgXCJcXFxcdmVjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMmQ5XCIsIFwiXFxcXGRvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAxMzFcIiwgXCJcXFxcaW1hdGhcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwMjM3XCIsIFwiXFxcXGptYXRoXCIpO1xuXG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDEzXCIsIFwiLS1cIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDE0XCIsIFwiLS0tXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAxOFwiLCBcImBcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDE5XCIsIFwiJ1wiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMWNcIiwgXCJgYFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMWRcIiwgXCInJ1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwYjBcIiwgXCJcXFxcZGVncmVlXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBiMFwiLCBcIlxcXFxkZWdyZWVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwMGEzXCIsIFwiXFxcXHBvdW5kc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjcyMFwiLCBcIlxcXFxtYWx0ZXNlXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIGFtcywgdGV4dG9yZCwgXCJcXHUyNzIwXCIsIFwiXFxcXG1hbHRlc2VcIik7XG5cbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCJcXFxcIFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCIgXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHNwYWNpbmcsIFwiXFx1MDBhMFwiLCBcIn5cIik7XG5cbi8vIFRoZXJlIGFyZSBsb3RzIG9mIHN5bWJvbHMgd2hpY2ggYXJlIHRoZSBzYW1lLCBzbyB3ZSBhZGQgdGhlbSBpbiBhZnRlcndhcmRzLlxudmFyIGk7XG52YXIgY2g7XG5cbi8vIEFsbCBvZiB0aGVzZSBhcmUgdGV4dG9yZHMgaW4gbWF0aCBtb2RlXG52YXIgbWF0aFRleHRTeW1ib2xzID0gXCIwMTIzNDU2Nzg5L0AuXFxcIlwiO1xuZm9yIChpID0gMDsgaSA8IG1hdGhUZXh0U3ltYm9scy5sZW5ndGg7IGkrKykge1xuICAgIGNoID0gbWF0aFRleHRTeW1ib2xzLmNoYXJBdChpKTtcbiAgICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgY2gsIGNoKTtcbn1cblxuLy8gQWxsIG9mIHRoZXNlIGFyZSB0ZXh0b3JkcyBpbiB0ZXh0IG1vZGVcbnZhciB0ZXh0U3ltYm9scyA9IFwiMDEyMzQ1Njc4OSFAKigpLT0rW11cXFwiOzo/Ly4sXCI7XG5mb3IgKGkgPSAwOyBpIDwgdGV4dFN5bWJvbHMubGVuZ3RoOyBpKyspIHtcbiAgICBjaCA9IHRleHRTeW1ib2xzLmNoYXJBdChpKTtcbiAgICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgY2gsIGNoKTtcbn1cblxuLy8gQWxsIG9mIHRoZXNlIGFyZSB0ZXh0b3JkcyBpbiB0ZXh0IG1vZGUsIGFuZCBtYXRob3JkcyBpbiBtYXRoIG1vZGVcbnZhciBsZXR0ZXJzID0gXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCI7XG5mb3IgKGkgPSAwOyBpIDwgbGV0dGVycy5sZW5ndGg7IGkrKykge1xuICAgIGNoID0gbGV0dGVycy5jaGFyQXQoaSk7XG4gICAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIGNoLCBjaCk7XG4gICAgZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIGNoLCBjaCk7XG59XG5cbi8vIExhdGluLTEgbGV0dGVyc1xuZm9yIChpID0gMHgwMEMwOyBpIDw9IDB4MDBENjsgaSsrKSB7XG4gICAgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuICAgIGRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBjaCwgY2gpO1xufVxuXG5mb3IgKGkgPSAweDAwRDg7IGkgPD0gMHgwMEY2OyBpKyspIHtcbiAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG4gICAgZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIGNoLCBjaCk7XG59XG5cbmZvciAoaSA9IDB4MDBGODsgaSA8PSAweDAwRkY7IGkrKykge1xuICAgIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcbiAgICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgY2gsIGNoKTtcbn1cblxuLy8gQ3lyaWxsaWNcbmZvciAoaSA9IDB4MDQxMDsgaSA8PSAweDA0NEY7IGkrKykge1xuICAgIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcbiAgICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgY2gsIGNoKTtcbn1cblxuLy8gVW5pY29kZSB2ZXJzaW9ucyBvZiBleGlzdGluZyBjaGFyYWN0ZXJzXG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDEzXCIsIFwi4oCTXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAxNFwiLCBcIuKAlFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMThcIiwgXCLigJhcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDE5XCIsIFwi4oCZXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAxY1wiLCBcIuKAnFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMWRcIiwgXCLigJ1cIik7XG4iLCJ2YXIgaGFuZ3VsUmVnZXggPSAvW1xcdUFDMDAtXFx1RDdBRl0vO1xuXG4vLyBUaGlzIHJlZ2V4IGNvbWJpbmVzXG4vLyAtIEhpcmFnYW5hOiBbXFx1MzA0MC1cXHUzMDlGXVxuLy8gLSBLYXRha2FuYTogW1xcdTMwQTAtXFx1MzBGRl1cbi8vIC0gQ0pLIGlkZW9ncmFtczogW1xcdTRFMDAtXFx1OUZBRl1cbi8vIC0gSGFuZ3VsIHN5bGxhYmxlczogW1xcdUFDMDAtXFx1RDdBRl1cbi8vIE5vdGFibHkgbWlzc2luZyBhcmUgaGFsZndpZHRoIEthdGFrYW5hIGFuZCBSb21hbmppIGdseXBocy5cbnZhciBjamtSZWdleCA9XG4gICAgL1tcXHUzMDQwLVxcdTMwOUZdfFtcXHUzMEEwLVxcdTMwRkZdfFtcXHU0RTAwLVxcdTlGQUZdfFtcXHVBQzAwLVxcdUQ3QUZdLztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY2prUmVnZXg6IGNqa1JlZ2V4LFxuICAgIGhhbmd1bFJlZ2V4OiBoYW5ndWxSZWdleFxufTtcbiIsIi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGEgbGlzdCBvZiB1dGlsaXR5IGZ1bmN0aW9ucyB3aGljaCBhcmUgdXNlZnVsIGluIG90aGVyXG4gKiBmaWxlcy5cbiAqL1xuXG4vKipcbiAqIFByb3ZpZGUgYW4gYGluZGV4T2ZgIGZ1bmN0aW9uIHdoaWNoIHdvcmtzIGluIElFOCwgYnV0IGRlZmVycyB0byBuYXRpdmUgaWZcbiAqIHBvc3NpYmxlLlxuICovXG52YXIgbmF0aXZlSW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xudmFyIGluZGV4T2YgPSBmdW5jdGlvbihsaXN0LCBlbGVtKSB7XG4gICAgaWYgKGxpc3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChuYXRpdmVJbmRleE9mICYmIGxpc3QuaW5kZXhPZiA9PT0gbmF0aXZlSW5kZXhPZikge1xuICAgICAgICByZXR1cm4gbGlzdC5pbmRleE9mKGVsZW0pO1xuICAgIH1cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGwgPSBsaXN0Lmxlbmd0aDtcbiAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAobGlzdFtpXSA9PT0gZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBhbiBlbGVtZW50IGlzIGNvbnRhaW5lZCBpbiBhIGxpc3RcbiAqL1xudmFyIGNvbnRhaW5zID0gZnVuY3Rpb24obGlzdCwgZWxlbSkge1xuICAgIHJldHVybiBpbmRleE9mKGxpc3QsIGVsZW0pICE9PSAtMTtcbn07XG5cbi8qKlxuICogUHJvdmlkZSBhIGRlZmF1bHQgdmFsdWUgaWYgYSBzZXR0aW5nIGlzIHVuZGVmaW5lZFxuICovXG52YXIgZGVmbHQgPSBmdW5jdGlvbihzZXR0aW5nLCBkZWZhdWx0SWZVbmRlZmluZWQpIHtcbiAgICByZXR1cm4gc2V0dGluZyA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdElmVW5kZWZpbmVkIDogc2V0dGluZztcbn07XG5cbi8vIGh5cGhlbmF0ZSBhbmQgZXNjYXBlIGFkYXB0ZWQgZnJvbSBGYWNlYm9vaydzIFJlYWN0IHVuZGVyIEFwYWNoZSAyIGxpY2Vuc2VcblxudmFyIHVwcGVyY2FzZSA9IC8oW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKHVwcGVyY2FzZSwgXCItJDFcIikudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBFU0NBUEVfTE9PS1VQID0ge1xuICAgIFwiJlwiOiBcIiZhbXA7XCIsXG4gICAgXCI+XCI6IFwiJmd0O1wiLFxuICAgIFwiPFwiOiBcIiZsdDtcIixcbiAgICBcIlxcXCJcIjogXCImcXVvdDtcIixcbiAgICBcIidcIjogXCImI3gyNztcIlxufTtcblxudmFyIEVTQ0FQRV9SRUdFWCA9IC9bJj48XCInXS9nO1xuXG5mdW5jdGlvbiBlc2NhcGVyKG1hdGNoKSB7XG4gICAgcmV0dXJuIEVTQ0FQRV9MT09LVVBbbWF0Y2hdO1xufVxuXG4vKipcbiAqIEVzY2FwZXMgdGV4dCB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdGV4dCBUZXh0IHZhbHVlIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZSh0ZXh0KSB7XG4gICAgcmV0dXJuIChcIlwiICsgdGV4dCkucmVwbGFjZShFU0NBUEVfUkVHRVgsIGVzY2FwZXIpO1xufVxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdG8gc2V0IHRoZSB0ZXh0IGNvbnRlbnQgb2YgYSBET00gZWxlbWVudCBpbiBhbGwgc3VwcG9ydGVkXG4gKiBicm93c2Vycy4gTm90ZSB0aGF0IHdlIGRvbid0IGRlZmluZSB0aGlzIGlmIHRoZXJlIGlzIG5vIGRvY3VtZW50LlxuICovXG52YXIgc2V0VGV4dENvbnRlbnQ7XG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIHRlc3ROb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgaWYgKFwidGV4dENvbnRlbnRcIiBpbiB0ZXN0Tm9kZSkge1xuICAgICAgICBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uKG5vZGUsIHRleHQpIHtcbiAgICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24obm9kZSwgdGV4dCkge1xuICAgICAgICAgICAgbm9kZS5pbm5lclRleHQgPSB0ZXh0O1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRvIGNsZWFyIGEgbm9kZS5cbiAqL1xuZnVuY3Rpb24gY2xlYXJOb2RlKG5vZGUpIHtcbiAgICBzZXRUZXh0Q29udGVudChub2RlLCBcIlwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY29udGFpbnM6IGNvbnRhaW5zLFxuICAgIGRlZmx0OiBkZWZsdCxcbiAgICBlc2NhcGU6IGVzY2FwZSxcbiAgICBoeXBoZW5hdGU6IGh5cGhlbmF0ZSxcbiAgICBpbmRleE9mOiBpbmRleE9mLFxuICAgIHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcbiAgICBjbGVhck5vZGU6IGNsZWFyTm9kZVxufTtcbiIsIi8qKiBAZmxvdyAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gZ2V0UmVsb2NhdGFibGUocmUpIHtcbiAgLy8gSW4gdGhlIGZ1dHVyZSwgdGhpcyBjb3VsZCB1c2UgYSBXZWFrTWFwIGluc3RlYWQgb2YgYW4gZXhwYW5kby5cbiAgaWYgKCFyZS5fX21hdGNoQXRSZWxvY2F0YWJsZSkge1xuICAgIC8vIERpc2p1bmN0aW9ucyBhcmUgdGhlIGxvd2VzdC1wcmVjZWRlbmNlIG9wZXJhdG9yLCBzbyB3ZSBjYW4gbWFrZSBhbnlcbiAgICAvLyBwYXR0ZXJuIG1hdGNoIHRoZSBlbXB0eSBzdHJpbmcgYnkgYXBwZW5kaW5nIGB8KClgIHRvIGl0OlxuICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1wYXR0ZXJuc1xuICAgIHZhciBzb3VyY2UgPSByZS5zb3VyY2UgKyBcInwoKVwiO1xuXG4gICAgLy8gV2UgYWx3YXlzIG1ha2UgdGhlIG5ldyByZWdleCBnbG9iYWwuXG4gICAgdmFyIGZsYWdzID0gXCJnXCIgKyAocmUuaWdub3JlQ2FzZSA/IFwiaVwiIDogXCJcIikgKyAocmUubXVsdGlsaW5lID8gXCJtXCIgOiBcIlwiKSArIChyZS51bmljb2RlID8gXCJ1XCIgOiBcIlwiKVxuICAgIC8vIHN0aWNreSAoLy4uLi95KSBkb2Vzbid0IG1ha2Ugc2Vuc2UgaW4gY29uanVuY3Rpb24gd2l0aCBvdXIgcmVsb2NhdGlvblxuICAgIC8vIGxvZ2ljLCBzbyB3ZSBpZ25vcmUgaXQgaGVyZS5cbiAgICA7XG5cbiAgICByZS5fX21hdGNoQXRSZWxvY2F0YWJsZSA9IG5ldyBSZWdFeHAoc291cmNlLCBmbGFncyk7XG4gIH1cbiAgcmV0dXJuIHJlLl9fbWF0Y2hBdFJlbG9jYXRhYmxlO1xufVxuXG5mdW5jdGlvbiBtYXRjaEF0KHJlLCBzdHIsIHBvcykge1xuICBpZiAocmUuZ2xvYmFsIHx8IHJlLnN0aWNreSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm1hdGNoQXQoLi4uKTogT25seSBub24tZ2xvYmFsIHJlZ2V4ZXMgYXJlIHN1cHBvcnRlZFwiKTtcbiAgfVxuICB2YXIgcmVsb2MgPSBnZXRSZWxvY2F0YWJsZShyZSk7XG4gIHJlbG9jLmxhc3RJbmRleCA9IHBvcztcbiAgdmFyIG1hdGNoID0gcmVsb2MuZXhlYyhzdHIpO1xuICAvLyBMYXN0IGNhcHR1cmluZyBncm91cCBpcyBvdXIgc2VudGluZWwgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgcmVnZXhcbiAgLy8gbWF0Y2hlZCBhdCB0aGUgZ2l2ZW4gbG9jYXRpb24uXG4gIGlmIChtYXRjaFttYXRjaC5sZW5ndGggLSAxXSA9PSBudWxsKSB7XG4gICAgLy8gT3JpZ2luYWwgcmVnZXggbWF0Y2hlZC5cbiAgICBtYXRjaC5sZW5ndGggPSBtYXRjaC5sZW5ndGggLSAxO1xuICAgIHJldHVybiBtYXRjaDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdGNoQXQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuL1N1YnNjcmliZXInKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgSW5uZXJTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5uZXJTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIElubmVyU3Vic2NyaWJlcihwYXJlbnQsIG91dGVyVmFsdWUsIG91dGVySW5kZXgpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLm91dGVyVmFsdWUgPSBvdXRlclZhbHVlO1xuICAgICAgICB0aGlzLm91dGVySW5kZXggPSBvdXRlckluZGV4O1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgSW5uZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnBhcmVudC5ub3RpZnlOZXh0KHRoaXMub3V0ZXJWYWx1ZSwgdmFsdWUsIHRoaXMub3V0ZXJJbmRleCwgdGhpcy5pbmRleCsrLCB0aGlzKTtcbiAgICB9O1xuICAgIElubmVyU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lm5vdGlmeUVycm9yKGVycm9yLCB0aGlzKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgSW5uZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lm5vdGlmeUNvbXBsZXRlKHRoaXMpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gSW5uZXJTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5Jbm5lclN1YnNjcmliZXIgPSBJbm5lclN1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Jbm5lclN1YnNjcmliZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi91dGlsL3Jvb3QnKTtcbnZhciB0b1N1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vdXRpbC90b1N1YnNjcmliZXInKTtcbnZhciBvYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL3N5bWJvbC9vYnNlcnZhYmxlJyk7XG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYW55IHNldCBvZiB2YWx1ZXMgb3ZlciBhbnkgYW1vdW50IG9mIHRpbWUuIFRoaXMgdGhlIG1vc3QgYmFzaWMgYnVpbGRpbmcgYmxvY2tcbiAqIG9mIFJ4SlMuXG4gKlxuICogQGNsYXNzIE9ic2VydmFibGU8VD5cbiAqL1xudmFyIE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YnNjcmliZSB0aGUgZnVuY3Rpb24gdGhhdCBpcyAgY2FsbGVkIHdoZW4gdGhlIE9ic2VydmFibGUgaXNcbiAgICAgKiBpbml0aWFsbHkgc3Vic2NyaWJlZCB0by4gVGhpcyBmdW5jdGlvbiBpcyBnaXZlbiBhIFN1YnNjcmliZXIsIHRvIHdoaWNoIG5ldyB2YWx1ZXNcbiAgICAgKiBjYW4gYmUgYG5leHRgZWQsIG9yIGFuIGBlcnJvcmAgbWV0aG9kIGNhbiBiZSBjYWxsZWQgdG8gcmFpc2UgYW4gZXJyb3IsIG9yXG4gICAgICogYGNvbXBsZXRlYCBjYW4gYmUgY2FsbGVkIHRvIG5vdGlmeSBvZiBhIHN1Y2Nlc3NmdWwgY29tcGxldGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZSkge1xuICAgICAgICB0aGlzLl9pc1NjYWxhciA9IGZhbHNlO1xuICAgICAgICBpZiAoc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBPYnNlcnZhYmxlLCB3aXRoIHRoaXMgT2JzZXJ2YWJsZSBhcyB0aGUgc291cmNlLCBhbmQgdGhlIHBhc3NlZFxuICAgICAqIG9wZXJhdG9yIGRlZmluZWQgYXMgdGhlIG5ldyBvYnNlcnZhYmxlJ3Mgb3BlcmF0b3IuXG4gICAgICogQG1ldGhvZCBsaWZ0XG4gICAgICogQHBhcmFtIHtPcGVyYXRvcn0gb3BlcmF0b3IgdGhlIG9wZXJhdG9yIGRlZmluaW5nIHRoZSBvcGVyYXRpb24gdG8gdGFrZSBvbiB0aGUgb2JzZXJ2YWJsZVxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IGEgbmV3IG9ic2VydmFibGUgd2l0aCB0aGUgT3BlcmF0b3IgYXBwbGllZFxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZSgpO1xuICAgICAgICBvYnNlcnZhYmxlLnNvdXJjZSA9IHRoaXM7XG4gICAgICAgIG9ic2VydmFibGUub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGFuIGV4ZWN1dGlvbiBvZiBhbiBPYnNlcnZhYmxlIGFuZCByZWdpc3RlcnMgT2JzZXJ2ZXIgaGFuZGxlcnMgZm9yIG5vdGlmaWNhdGlvbnMgaXQgd2lsbCBlbWl0LlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlVzZSBpdCB3aGVuIHlvdSBoYXZlIGFsbCB0aGVzZSBPYnNlcnZhYmxlcywgYnV0IHN0aWxsIG5vdGhpbmcgaXMgaGFwcGVuaW5nLjwvc3Bhbj5cbiAgICAgKlxuICAgICAqIGBzdWJzY3JpYmVgIGlzIG5vdCBhIHJlZ3VsYXIgb3BlcmF0b3IsIGJ1dCBhIG1ldGhvZCB0aGF0IGNhbGxzIE9ic2VydmFibGVzIGludGVybmFsIGBzdWJzY3JpYmVgIGZ1bmN0aW9uLiBJdFxuICAgICAqIG1pZ2h0IGJlIGZvciBleGFtcGxlIGEgZnVuY3Rpb24gdGhhdCB5b3UgcGFzc2VkIHRvIGEge0BsaW5rIGNyZWF0ZX0gc3RhdGljIGZhY3RvcnksIGJ1dCBtb3N0IG9mIHRoZSB0aW1lIGl0IGlzXG4gICAgICogYSBsaWJyYXJ5IGltcGxlbWVudGF0aW9uLCB3aGljaCBkZWZpbmVzIHdoYXQgYW5kIHdoZW4gd2lsbCBiZSBlbWl0dGVkIGJ5IGFuIE9ic2VydmFibGUuIFRoaXMgbWVhbnMgdGhhdCBjYWxsaW5nXG4gICAgICogYHN1YnNjcmliZWAgaXMgYWN0dWFsbHkgdGhlIG1vbWVudCB3aGVuIE9ic2VydmFibGUgc3RhcnRzIGl0cyB3b3JrLCBub3Qgd2hlbiBpdCBpcyBjcmVhdGVkLCBhcyBpdCBpcyBvZnRlblxuICAgICAqIHRob3VnaHQuXG4gICAgICpcbiAgICAgKiBBcGFydCBmcm9tIHN0YXJ0aW5nIHRoZSBleGVjdXRpb24gb2YgYW4gT2JzZXJ2YWJsZSwgdGhpcyBtZXRob2QgYWxsb3dzIHlvdSB0byBsaXN0ZW4gZm9yIHZhbHVlc1xuICAgICAqIHRoYXQgYW4gT2JzZXJ2YWJsZSBlbWl0cywgYXMgd2VsbCBhcyBmb3Igd2hlbiBpdCBjb21wbGV0ZXMgb3IgZXJyb3JzLiBZb3UgY2FuIGFjaGlldmUgdGhpcyBpbiB0d29cbiAgICAgKiBmb2xsb3dpbmcgd2F5cy5cbiAgICAgKlxuICAgICAqIFRoZSBmaXJzdCB3YXkgaXMgY3JlYXRpbmcgYW4gb2JqZWN0IHRoYXQgaW1wbGVtZW50cyB7QGxpbmsgT2JzZXJ2ZXJ9IGludGVyZmFjZS4gSXQgc2hvdWxkIGhhdmUgbWV0aG9kc1xuICAgICAqIGRlZmluZWQgYnkgdGhhdCBpbnRlcmZhY2UsIGJ1dCBub3RlIHRoYXQgaXQgc2hvdWxkIGJlIGp1c3QgYSByZWd1bGFyIEphdmFTY3JpcHQgb2JqZWN0LCB3aGljaCB5b3UgY2FuIGNyZWF0ZVxuICAgICAqIHlvdXJzZWxmIGluIGFueSB3YXkgeW91IHdhbnQgKEVTNiBjbGFzcywgY2xhc3NpYyBmdW5jdGlvbiBjb25zdHJ1Y3Rvciwgb2JqZWN0IGxpdGVyYWwgZXRjLikuIEluIHBhcnRpY3VsYXIgZG9cbiAgICAgKiBub3QgYXR0ZW1wdCB0byB1c2UgYW55IFJ4SlMgaW1wbGVtZW50YXRpb24gZGV0YWlscyB0byBjcmVhdGUgT2JzZXJ2ZXJzIC0geW91IGRvbid0IG5lZWQgdGhlbS4gUmVtZW1iZXIgYWxzb1xuICAgICAqIHRoYXQgeW91ciBvYmplY3QgZG9lcyBub3QgaGF2ZSB0byBpbXBsZW1lbnQgYWxsIG1ldGhvZHMuIElmIHlvdSBmaW5kIHlvdXJzZWxmIGNyZWF0aW5nIGEgbWV0aG9kIHRoYXQgZG9lc24ndFxuICAgICAqIGRvIGFueXRoaW5nLCB5b3UgY2FuIHNpbXBseSBvbWl0IGl0LiBOb3RlIGhvd2V2ZXIsIHRoYXQgaWYgYGVycm9yYCBtZXRob2QgaXMgbm90IHByb3ZpZGVkLCBhbGwgZXJyb3JzIHdpbGxcbiAgICAgKiBiZSBsZWZ0IHVuY2F1Z2h0LlxuICAgICAqXG4gICAgICogVGhlIHNlY29uZCB3YXkgaXMgdG8gZ2l2ZSB1cCBvbiBPYnNlcnZlciBvYmplY3QgYWx0b2dldGhlciBhbmQgc2ltcGx5IHByb3ZpZGUgY2FsbGJhY2sgZnVuY3Rpb25zIGluIHBsYWNlIG9mIGl0cyBtZXRob2RzLlxuICAgICAqIFRoaXMgbWVhbnMgeW91IGNhbiBwcm92aWRlIHRocmVlIGZ1bmN0aW9ucyBhcyBhcmd1bWVudHMgdG8gYHN1YnNjcmliZWAsIHdoZXJlIGZpcnN0IGZ1bmN0aW9uIGlzIGVxdWl2YWxlbnRcbiAgICAgKiBvZiBhIGBuZXh0YCBtZXRob2QsIHNlY29uZCBvZiBhbiBgZXJyb3JgIG1ldGhvZCBhbmQgdGhpcmQgb2YgYSBgY29tcGxldGVgIG1ldGhvZC4gSnVzdCBhcyBpbiBjYXNlIG9mIE9ic2VydmVyLFxuICAgICAqIGlmIHlvdSBkbyBub3QgbmVlZCB0byBsaXN0ZW4gZm9yIHNvbWV0aGluZywgeW91IGNhbiBvbWl0IGEgZnVuY3Rpb24sIHByZWZlcmFibHkgYnkgcGFzc2luZyBgdW5kZWZpbmVkYCBvciBgbnVsbGAsXG4gICAgICogc2luY2UgYHN1YnNjcmliZWAgcmVjb2duaXplcyB0aGVzZSBmdW5jdGlvbnMgYnkgd2hlcmUgdGhleSB3ZXJlIHBsYWNlZCBpbiBmdW5jdGlvbiBjYWxsLiBXaGVuIGl0IGNvbWVzXG4gICAgICogdG8gYGVycm9yYCBmdW5jdGlvbiwganVzdCBhcyBiZWZvcmUsIGlmIG5vdCBwcm92aWRlZCwgZXJyb3JzIGVtaXR0ZWQgYnkgYW4gT2JzZXJ2YWJsZSB3aWxsIGJlIHRocm93bi5cbiAgICAgKlxuICAgICAqIFdoYXRldmVyIHN0eWxlIG9mIGNhbGxpbmcgYHN1YnNjcmliZWAgeW91IHVzZSwgaW4gYm90aCBjYXNlcyBpdCByZXR1cm5zIGEgU3Vic2NyaXB0aW9uIG9iamVjdC5cbiAgICAgKiBUaGlzIG9iamVjdCBhbGxvd3MgeW91IHRvIGNhbGwgYHVuc3Vic2NyaWJlYCBvbiBpdCwgd2hpY2ggaW4gdHVybiB3aWxsIHN0b3Agd29yayB0aGF0IGFuIE9ic2VydmFibGUgZG9lcyBhbmQgd2lsbCBjbGVhblxuICAgICAqIHVwIGFsbCByZXNvdXJjZXMgdGhhdCBhbiBPYnNlcnZhYmxlIHVzZWQuIE5vdGUgdGhhdCBjYW5jZWxsaW5nIGEgc3Vic2NyaXB0aW9uIHdpbGwgbm90IGNhbGwgYGNvbXBsZXRlYCBjYWxsYmFja1xuICAgICAqIHByb3ZpZGVkIHRvIGBzdWJzY3JpYmVgIGZ1bmN0aW9uLCB3aGljaCBpcyByZXNlcnZlZCBmb3IgYSByZWd1bGFyIGNvbXBsZXRpb24gc2lnbmFsIHRoYXQgY29tZXMgZnJvbSBhbiBPYnNlcnZhYmxlLlxuICAgICAqXG4gICAgICogUmVtZW1iZXIgdGhhdCBjYWxsYmFja3MgcHJvdmlkZWQgdG8gYHN1YnNjcmliZWAgYXJlIG5vdCBndWFyYW50ZWVkIHRvIGJlIGNhbGxlZCBhc3luY2hyb25vdXNseS5cbiAgICAgKiBJdCBpcyBhbiBPYnNlcnZhYmxlIGl0c2VsZiB0aGF0IGRlY2lkZXMgd2hlbiB0aGVzZSBmdW5jdGlvbnMgd2lsbCBiZSBjYWxsZWQuIEZvciBleGFtcGxlIHtAbGluayBvZn1cbiAgICAgKiBieSBkZWZhdWx0IGVtaXRzIGFsbCBpdHMgdmFsdWVzIHN5bmNocm9ub3VzbHkuIEFsd2F5cyBjaGVjayBkb2N1bWVudGF0aW9uIGZvciBob3cgZ2l2ZW4gT2JzZXJ2YWJsZVxuICAgICAqIHdpbGwgYmVoYXZlIHdoZW4gc3Vic2NyaWJlZCBhbmQgaWYgaXRzIGRlZmF1bHQgYmVoYXZpb3IgY2FuIGJlIG1vZGlmaWVkIHdpdGggYSB7QGxpbmsgU2NoZWR1bGVyfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlN1YnNjcmliZSB3aXRoIGFuIE9ic2VydmVyPC9jYXB0aW9uPlxuICAgICAqIGNvbnN0IHN1bU9ic2VydmVyID0ge1xuICAgICAqICAgc3VtOiAwLFxuICAgICAqICAgbmV4dCh2YWx1ZSkge1xuICAgICAqICAgICBjb25zb2xlLmxvZygnQWRkaW5nOiAnICsgdmFsdWUpO1xuICAgICAqICAgICB0aGlzLnN1bSA9IHRoaXMuc3VtICsgdmFsdWU7XG4gICAgICogICB9LFxuICAgICAqICAgZXJyb3IoKSB7IC8vIFdlIGFjdHVhbGx5IGNvdWxkIGp1c3QgcmVtb3RlIHRoaXMgbWV0aG9kLFxuICAgICAqICAgfSwgICAgICAgIC8vIHNpbmNlIHdlIGRvIG5vdCByZWFsbHkgY2FyZSBhYm91dCBlcnJvcnMgcmlnaHQgbm93LlxuICAgICAqICAgY29tcGxldGUoKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdTdW0gZXF1YWxzOiAnICsgdGhpcy5zdW0pO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBSeC5PYnNlcnZhYmxlLm9mKDEsIDIsIDMpIC8vIFN5bmNocm9ub3VzbHkgZW1pdHMgMSwgMiwgMyBhbmQgdGhlbiBjb21wbGV0ZXMuXG4gICAgICogLnN1YnNjcmliZShzdW1PYnNlcnZlcik7XG4gICAgICpcbiAgICAgKiAvLyBMb2dzOlxuICAgICAqIC8vIFwiQWRkaW5nOiAxXCJcbiAgICAgKiAvLyBcIkFkZGluZzogMlwiXG4gICAgICogLy8gXCJBZGRpbmc6IDNcIlxuICAgICAqIC8vIFwiU3VtIGVxdWFsczogNlwiXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlN1YnNjcmliZSB3aXRoIGZ1bmN0aW9uczwvY2FwdGlvbj5cbiAgICAgKiBsZXQgc3VtID0gMDtcbiAgICAgKlxuICAgICAqIFJ4Lk9ic2VydmFibGUub2YoMSwgMiwgMylcbiAgICAgKiAuc3Vic2NyaWJlKFxuICAgICAqICAgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ0FkZGluZzogJyArIHZhbHVlKTtcbiAgICAgKiAgICAgc3VtID0gc3VtICsgdmFsdWU7XG4gICAgICogICB9LFxuICAgICAqICAgdW5kZWZpbmVkLFxuICAgICAqICAgZnVuY3Rpb24oKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdTdW0gZXF1YWxzOiAnICsgc3VtKTtcbiAgICAgKiAgIH1cbiAgICAgKiApO1xuICAgICAqXG4gICAgICogLy8gTG9nczpcbiAgICAgKiAvLyBcIkFkZGluZzogMVwiXG4gICAgICogLy8gXCJBZGRpbmc6IDJcIlxuICAgICAqIC8vIFwiQWRkaW5nOiAzXCJcbiAgICAgKiAvLyBcIlN1bSBlcXVhbHM6IDZcIlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5DYW5jZWwgYSBzdWJzY3JpcHRpb248L2NhcHRpb24+XG4gICAgICogY29uc3Qgc3Vic2NyaXB0aW9uID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS5zdWJzY3JpYmUoXG4gICAgICogICBudW0gPT4gY29uc29sZS5sb2cobnVtKSxcbiAgICAgKiAgIHVuZGVmaW5lZCxcbiAgICAgKiAgICgpID0+IGNvbnNvbGUubG9nKCdjb21wbGV0ZWQhJykgLy8gV2lsbCBub3QgYmUgY2FsbGVkLCBldmVuXG4gICAgICogKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gY2FuY2VsbGluZyBzdWJzY3JpcHRpb25cbiAgICAgKlxuICAgICAqXG4gICAgICogc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICogICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCd1bnN1YnNjcmliZWQhJyk7XG4gICAgICogfSwgMjUwMCk7XG4gICAgICpcbiAgICAgKiAvLyBMb2dzOlxuICAgICAqIC8vIDAgYWZ0ZXIgMXNcbiAgICAgKiAvLyAxIGFmdGVyIDJzXG4gICAgICogLy8gXCJ1bnN1YnNjcmliZWQhXCIgYWZ0ZXIgMiw1c1xuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09ic2VydmVyfEZ1bmN0aW9ufSBvYnNlcnZlck9yTmV4dCAob3B0aW9uYWwpIEVpdGhlciBhbiBvYnNlcnZlciB3aXRoIG1ldGhvZHMgdG8gYmUgY2FsbGVkLFxuICAgICAqICBvciB0aGUgZmlyc3Qgb2YgdGhyZWUgcG9zc2libGUgaGFuZGxlcnMsIHdoaWNoIGlzIHRoZSBoYW5kbGVyIGZvciBlYWNoIHZhbHVlIGVtaXR0ZWQgZnJvbSB0aGUgc3Vic2NyaWJlZFxuICAgICAqICBPYnNlcnZhYmxlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVycm9yIChvcHRpb25hbCkgQSBoYW5kbGVyIGZvciBhIHRlcm1pbmFsIGV2ZW50IHJlc3VsdGluZyBmcm9tIGFuIGVycm9yLiBJZiBubyBlcnJvciBoYW5kbGVyIGlzIHByb3ZpZGVkLFxuICAgICAqICB0aGUgZXJyb3Igd2lsbCBiZSB0aHJvd24gYXMgdW5oYW5kbGVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBsZXRlIChvcHRpb25hbCkgQSBoYW5kbGVyIGZvciBhIHRlcm1pbmFsIGV2ZW50IHJlc3VsdGluZyBmcm9tIHN1Y2Nlc3NmdWwgY29tcGxldGlvbi5cbiAgICAgKiBAcmV0dXJuIHtJU3Vic2NyaXB0aW9ufSBhIHN1YnNjcmlwdGlvbiByZWZlcmVuY2UgdG8gdGhlIHJlZ2lzdGVyZWQgaGFuZGxlcnNcbiAgICAgKiBAbWV0aG9kIHN1YnNjcmliZVxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChvYnNlcnZlck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBvcGVyYXRvciA9IHRoaXMub3BlcmF0b3I7XG4gICAgICAgIHZhciBzaW5rID0gdG9TdWJzY3JpYmVyXzEudG9TdWJzY3JpYmVyKG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICBpZiAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgIG9wZXJhdG9yLmNhbGwoc2luaywgdGhpcy5zb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2luay5hZGQodGhpcy5zb3VyY2UgPyB0aGlzLl9zdWJzY3JpYmUoc2luaykgOiB0aGlzLl90cnlTdWJzY3JpYmUoc2luaykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaW5rLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgc2luay5zeW5jRXJyb3JUaHJvd2FibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzaW5rLnN5bmNFcnJvclRocm93bikge1xuICAgICAgICAgICAgICAgIHRocm93IHNpbmsuc3luY0Vycm9yVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpbms7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5fdHJ5U3Vic2NyaWJlID0gZnVuY3Rpb24gKHNpbmspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpYmUoc2luayk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgc2luay5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICAgICAgc2luay5zeW5jRXJyb3JWYWx1ZSA9IGVycjtcbiAgICAgICAgICAgIHNpbmsuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBmb3JFYWNoXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dCBhIGhhbmRsZXIgZm9yIGVhY2ggdmFsdWUgZW1pdHRlZCBieSB0aGUgb2JzZXJ2YWJsZVxuICAgICAqIEBwYXJhbSB7UHJvbWlzZUNvbnN0cnVjdG9yfSBbUHJvbWlzZUN0b3JdIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gdXNlZCB0byBpbnN0YW50aWF0ZSB0aGUgUHJvbWlzZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB0aGF0IGVpdGhlciByZXNvbHZlcyBvbiBvYnNlcnZhYmxlIGNvbXBsZXRpb24gb3JcbiAgICAgKiAgcmVqZWN0cyB3aXRoIHRoZSBoYW5kbGVkIGVycm9yXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChuZXh0LCBQcm9taXNlQ3Rvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIVByb21pc2VDdG9yKSB7XG4gICAgICAgICAgICBpZiAocm9vdF8xLnJvb3QuUnggJiYgcm9vdF8xLnJvb3QuUnguY29uZmlnICYmIHJvb3RfMS5yb290LlJ4LmNvbmZpZy5Qcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgUHJvbWlzZUN0b3IgPSByb290XzEucm9vdC5SeC5jb25maWcuUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJvb3RfMS5yb290LlByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBQcm9taXNlQ3RvciA9IHJvb3RfMS5yb290LlByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFQcm9taXNlQ3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBQcm9taXNlIGltcGwgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VDdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIC8vIE11c3QgYmUgZGVjbGFyZWQgaW4gYSBzZXBhcmF0ZSBzdGF0ZW1lbnQgdG8gYXZvaWQgYSBSZWZlcm5jZUVycm9yIHdoZW5cbiAgICAgICAgICAgIC8vIGFjY2Vzc2luZyBzdWJzY3JpcHRpb24gYmVsb3cgaW4gdGhlIGNsb3N1cmUgZHVlIHRvIFRlbXBvcmFsIERlYWQgWm9uZS5cbiAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBfdGhpcy5zdWJzY3JpYmUoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHN1YnNjcmlwdGlvbiwgdGhlbiB3ZSBjYW4gc3VybWlzZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbmV4dCBoYW5kbGluZyBpcyBhc3luY2hyb25vdXMuIEFueSBlcnJvcnMgdGhyb3duXG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gYmUgcmVqZWN0ZWQgZXhwbGljaXRseSBhbmQgdW5zdWJzY3JpYmUgbXVzdCBiZVxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsZWQgbWFudWFsbHlcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIE5PIHN1YnNjcmlwdGlvbiwgdGhlbiB3ZSdyZSBnZXR0aW5nIGEgbmV4dGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlIHN5bmNocm9ub3VzbHkgZHVyaW5nIHN1YnNjcmlwdGlvbi4gV2UgY2FuIGp1c3QgY2FsbCBpdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgZXJyb3JzLCBPYnNlcnZhYmxlJ3MgYHN1YnNjcmliZWAgd2lsbCBlbnN1cmUgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHVuc3Vic2NyaXB0aW9uIGxvZ2ljIGlzIGNhbGxlZCwgdGhlbiBzeW5jaHJvbm91c2x5IHJldGhyb3cgdGhlIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICAvLyBBZnRlciB0aGF0LCBQcm9taXNlIHdpbGwgdHJhcCB0aGUgZXJyb3IgYW5kIHNlbmQgaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gZG93biB0aGUgcmVqZWN0aW9uIHBhdGguXG4gICAgICAgICAgICAgICAgICAgIG5leHQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlamVjdCwgcmVzb2x2ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBbiBpbnRlcm9wIHBvaW50IGRlZmluZWQgYnkgdGhlIGVzNy1vYnNlcnZhYmxlIHNwZWMgaHR0cHM6Ly9naXRodWIuY29tL3plbnBhcnNpbmcvZXMtb2JzZXJ2YWJsZVxuICAgICAqIEBtZXRob2QgU3ltYm9sLm9ic2VydmFibGVcbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSB0aGlzIGluc3RhbmNlIG9mIHRoZSBvYnNlcnZhYmxlXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGVbb2JzZXJ2YWJsZV8xLm9ic2VydmFibGVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8vIEhBQ0s6IFNpbmNlIFR5cGVTY3JpcHQgaW5oZXJpdHMgc3RhdGljIHByb3BlcnRpZXMgdG9vLCB3ZSBoYXZlIHRvXG4gICAgLy8gZmlnaHQgYWdhaW5zdCBUeXBlU2NyaXB0IGhlcmUgc28gU3ViamVjdCBjYW4gaGF2ZSBhIGRpZmZlcmVudCBzdGF0aWMgY3JlYXRlIHNpZ25hdHVyZVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29sZCBPYnNlcnZhYmxlIGJ5IGNhbGxpbmcgdGhlIE9ic2VydmFibGUgY29uc3RydWN0b3JcbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3Vic2NyaWJlPyB0aGUgc3Vic2NyaWJlciBmdW5jdGlvbiB0byBiZSBwYXNzZWQgdG8gdGhlIE9ic2VydmFibGUgY29uc3RydWN0b3JcbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBhIG5ldyBjb2xkIG9ic2VydmFibGVcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKHN1YnNjcmliZSk7XG4gICAgfTtcbiAgICByZXR1cm4gT2JzZXJ2YWJsZTtcbn0oKSk7XG5leHBvcnRzLk9ic2VydmFibGUgPSBPYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZW1wdHkgPSB7XG4gICAgY2xvc2VkOiB0cnVlLFxuICAgIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB9LFxuICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyKSB7IHRocm93IGVycjsgfSxcbiAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkgeyB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JzZXJ2ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuL1N1YnNjcmliZXInKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgT3V0ZXJTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT3V0ZXJTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE91dGVyU3Vic2NyaWJlcigpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE91dGVyU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgfTtcbiAgICBPdXRlclN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycm9yKTtcbiAgICB9O1xuICAgIE91dGVyU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIE91dGVyU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuT3V0ZXJTdWJzY3JpYmVyID0gT3V0ZXJTdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T3V0ZXJTdWJzY3JpYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBBbiBleGVjdXRpb24gY29udGV4dCBhbmQgYSBkYXRhIHN0cnVjdHVyZSB0byBvcmRlciB0YXNrcyBhbmQgc2NoZWR1bGUgdGhlaXJcbiAqIGV4ZWN1dGlvbi4gUHJvdmlkZXMgYSBub3Rpb24gb2YgKHBvdGVudGlhbGx5IHZpcnR1YWwpIHRpbWUsIHRocm91Z2ggdGhlXG4gKiBgbm93KClgIGdldHRlciBtZXRob2QuXG4gKlxuICogRWFjaCB1bml0IG9mIHdvcmsgaW4gYSBTY2hlZHVsZXIgaXMgY2FsbGVkIGFuIHtAbGluayBBY3Rpb259LlxuICpcbiAqIGBgYHRzXG4gKiBjbGFzcyBTY2hlZHVsZXIge1xuICogICBub3coKTogbnVtYmVyO1xuICogICBzY2hlZHVsZSh3b3JrLCBkZWxheT8sIHN0YXRlPyk6IFN1YnNjcmlwdGlvbjtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBjbGFzcyBTY2hlZHVsZXJcbiAqL1xudmFyIFNjaGVkdWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2NoZWR1bGVyKFNjaGVkdWxlckFjdGlvbiwgbm93KSB7XG4gICAgICAgIGlmIChub3cgPT09IHZvaWQgMCkgeyBub3cgPSBTY2hlZHVsZXIubm93OyB9XG4gICAgICAgIHRoaXMuU2NoZWR1bGVyQWN0aW9uID0gU2NoZWR1bGVyQWN0aW9uO1xuICAgICAgICB0aGlzLm5vdyA9IG5vdztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGEgZnVuY3Rpb24sIGB3b3JrYCwgZm9yIGV4ZWN1dGlvbi4gTWF5IGhhcHBlbiBhdCBzb21lIHBvaW50IGluXG4gICAgICogdGhlIGZ1dHVyZSwgYWNjb3JkaW5nIHRvIHRoZSBgZGVsYXlgIHBhcmFtZXRlciwgaWYgc3BlY2lmaWVkLiBNYXkgYmUgcGFzc2VkXG4gICAgICogc29tZSBjb250ZXh0IG9iamVjdCwgYHN0YXRlYCwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGB3b3JrYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBnaXZlbiBhcmd1bWVudHMgd2lsbCBiZSBwcm9jZXNzZWQgYW4gc3RvcmVkIGFzIGFuIEFjdGlvbiBvYmplY3QgaW4gYVxuICAgICAqIHF1ZXVlIG9mIGFjdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0YXRlOiA/VCk6ID9TdWJzY3JpcHRpb259IHdvcmsgQSBmdW5jdGlvbiByZXByZXNlbnRpbmcgYVxuICAgICAqIHRhc2ssIG9yIHNvbWUgdW5pdCBvZiB3b3JrIHRvIGJlIGV4ZWN1dGVkIGJ5IHRoZSBTY2hlZHVsZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheV0gVGltZSB0byB3YWl0IGJlZm9yZSBleGVjdXRpbmcgdGhlIHdvcmssIHdoZXJlIHRoZVxuICAgICAqIHRpbWUgdW5pdCBpcyBpbXBsaWNpdCBhbmQgZGVmaW5lZCBieSB0aGUgU2NoZWR1bGVyIGl0c2VsZi5cbiAgICAgKiBAcGFyYW0ge1R9IFtzdGF0ZV0gU29tZSBjb250ZXh0dWFsIGRhdGEgdGhhdCB0aGUgYHdvcmtgIGZ1bmN0aW9uIHVzZXMgd2hlblxuICAgICAqIGNhbGxlZCBieSB0aGUgU2NoZWR1bGVyLlxuICAgICAqIEByZXR1cm4ge1N1YnNjcmlwdGlvbn0gQSBzdWJzY3JpcHRpb24gaW4gb3JkZXIgdG8gYmUgYWJsZSB0byB1bnN1YnNjcmliZVxuICAgICAqIHRoZSBzY2hlZHVsZWQgd29yay5cbiAgICAgKi9cbiAgICBTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHdvcmssIGRlbGF5LCBzdGF0ZSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLlNjaGVkdWxlckFjdGlvbih0aGlzLCB3b3JrKS5zY2hlZHVsZShzdGF0ZSwgZGVsYXkpO1xuICAgIH07XG4gICAgU2NoZWR1bGVyLm5vdyA9IERhdGUubm93ID8gRGF0ZS5ub3cgOiBmdW5jdGlvbiAoKSB7IHJldHVybiArbmV3IERhdGUoKTsgfTtcbiAgICByZXR1cm4gU2NoZWR1bGVyO1xufSgpKTtcbmV4cG9ydHMuU2NoZWR1bGVyID0gU2NoZWR1bGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2NoZWR1bGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9PYnNlcnZhYmxlJyk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpYmVyJyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YnNjcmlwdGlvbicpO1xudmFyIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEgPSByZXF1aXJlKCcuL3V0aWwvT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3InKTtcbnZhciBTdWJqZWN0U3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YmplY3RTdWJzY3JpcHRpb24nKTtcbnZhciByeFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vc3ltYm9sL3J4U3Vic2NyaWJlcicpO1xuLyoqXG4gKiBAY2xhc3MgU3ViamVjdFN1YnNjcmliZXI8VD5cbiAqL1xudmFyIFN1YmplY3RTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3ViamVjdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3ViamVjdFN1YnNjcmliZXIoZGVzdGluYXRpb24pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgfVxuICAgIHJldHVybiBTdWJqZWN0U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuU3ViamVjdFN1YnNjcmliZXIgPSBTdWJqZWN0U3Vic2NyaWJlcjtcbi8qKlxuICogQGNsYXNzIFN1YmplY3Q8VD5cbiAqL1xudmFyIFN1YmplY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJqZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YmplY3QoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc0Vycm9yID0gZmFsc2U7XG4gICAgICAgIHRoaXMudGhyb3duRXJyb3IgPSBudWxsO1xuICAgIH1cbiAgICBTdWJqZWN0LnByb3RvdHlwZVtyeFN1YnNjcmliZXJfMS5yeFN1YnNjcmliZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN1YmplY3RTdWJzY3JpYmVyKHRoaXMpO1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUubGlmdCA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgICAgICB2YXIgc3ViamVjdCA9IG5ldyBBbm9ueW1vdXNTdWJqZWN0KHRoaXMsIHRoaXMpO1xuICAgICAgICBzdWJqZWN0Lm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzO1xuICAgICAgICAgICAgdmFyIGxlbiA9IG9ic2VydmVycy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgY29weSA9IG9ic2VydmVycy5zbGljZSgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvcHlbaV0ubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYXNFcnJvciA9IHRydWU7XG4gICAgICAgIHRoaXMudGhyb3duRXJyb3IgPSBlcnI7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzO1xuICAgICAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvcHkgPSBvYnNlcnZlcnMuc2xpY2UoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29weVtpXS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMS5PYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzO1xuICAgICAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvcHkgPSBvYnNlcnZlcnMuc2xpY2UoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29weVtpXS5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gbnVsbDtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLl90cnlTdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5fdHJ5U3Vic2NyaWJlLmNhbGwodGhpcywgc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcih0aGlzLnRocm93bkVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdWJqZWN0U3Vic2NyaXB0aW9uXzEuU3ViamVjdFN1YnNjcmlwdGlvbih0aGlzLCBzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuYXNPYnNlcnZhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSgpO1xuICAgICAgICBvYnNlcnZhYmxlLnNvdXJjZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICAgIH07XG4gICAgU3ViamVjdC5jcmVhdGUgPSBmdW5jdGlvbiAoZGVzdGluYXRpb24sIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gbmV3IEFub255bW91c1N1YmplY3QoZGVzdGluYXRpb24sIHNvdXJjZSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3ViamVjdDtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuU3ViamVjdCA9IFN1YmplY3Q7XG4vKipcbiAqIEBjbGFzcyBBbm9ueW1vdXNTdWJqZWN0PFQ+XG4gKi9cbnZhciBBbm9ueW1vdXNTdWJqZWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQW5vbnltb3VzU3ViamVjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBbm9ueW1vdXNTdWJqZWN0KGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIEFub255bW91c1N1YmplY3QucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uICYmIGRlc3RpbmF0aW9uLm5leHQpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uICYmIGRlc3RpbmF0aW9uLmVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFub255bW91c1N1YmplY3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAoZGVzdGluYXRpb24gJiYgZGVzdGluYXRpb24uY29tcGxldGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBbm9ueW1vdXNTdWJqZWN0O1xufShTdWJqZWN0KSk7XG5leHBvcnRzLkFub255bW91c1N1YmplY3QgPSBBbm9ueW1vdXNTdWJqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3ViamVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpcHRpb24nKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU3ViamVjdFN1YnNjcmlwdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YmplY3RTdWJzY3JpcHRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3ViamVjdFN1YnNjcmlwdGlvbihzdWJqZWN0LCBzdWJzY3JpYmVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnN1YmplY3QgPSBzdWJqZWN0O1xuICAgICAgICB0aGlzLnN1YnNjcmliZXIgPSBzdWJzY3JpYmVyO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBTdWJqZWN0U3Vic2NyaXB0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgICB2YXIgc3ViamVjdCA9IHRoaXMuc3ViamVjdDtcbiAgICAgICAgdmFyIG9ic2VydmVycyA9IHN1YmplY3Qub2JzZXJ2ZXJzO1xuICAgICAgICB0aGlzLnN1YmplY3QgPSBudWxsO1xuICAgICAgICBpZiAoIW9ic2VydmVycyB8fCBvYnNlcnZlcnMubGVuZ3RoID09PSAwIHx8IHN1YmplY3QuaXNTdG9wcGVkIHx8IHN1YmplY3QuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YnNjcmliZXJJbmRleCA9IG9ic2VydmVycy5pbmRleE9mKHRoaXMuc3Vic2NyaWJlcik7XG4gICAgICAgIGlmIChzdWJzY3JpYmVySW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBvYnNlcnZlcnMuc3BsaWNlKHN1YnNjcmliZXJJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTdWJqZWN0U3Vic2NyaXB0aW9uO1xufShTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24pKTtcbmV4cG9ydHMuU3ViamVjdFN1YnNjcmlwdGlvbiA9IFN1YmplY3RTdWJzY3JpcHRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJqZWN0U3Vic2NyaXB0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgaXNGdW5jdGlvbl8xID0gcmVxdWlyZSgnLi91dGlsL2lzRnVuY3Rpb24nKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4vU3Vic2NyaXB0aW9uJyk7XG52YXIgT2JzZXJ2ZXJfMSA9IHJlcXVpcmUoJy4vT2JzZXJ2ZXInKTtcbnZhciByeFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vc3ltYm9sL3J4U3Vic2NyaWJlcicpO1xuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGludGVyZmFjZSBhbmQgZXh0ZW5kcyB0aGVcbiAqIHtAbGluayBTdWJzY3JpcHRpb259IGNsYXNzLiBXaGlsZSB0aGUge0BsaW5rIE9ic2VydmVyfSBpcyB0aGUgcHVibGljIEFQSSBmb3JcbiAqIGNvbnN1bWluZyB0aGUgdmFsdWVzIG9mIGFuIHtAbGluayBPYnNlcnZhYmxlfSwgYWxsIE9ic2VydmVycyBnZXQgY29udmVydGVkIHRvXG4gKiBhIFN1YnNjcmliZXIsIGluIG9yZGVyIHRvIHByb3ZpZGUgU3Vic2NyaXB0aW9uLWxpa2UgY2FwYWJpbGl0aWVzIHN1Y2ggYXNcbiAqIGB1bnN1YnNjcmliZWAuIFN1YnNjcmliZXIgaXMgYSBjb21tb24gdHlwZSBpbiBSeEpTLCBhbmQgY3J1Y2lhbCBmb3JcbiAqIGltcGxlbWVudGluZyBvcGVyYXRvcnMsIGJ1dCBpdCBpcyByYXJlbHkgdXNlZCBhcyBhIHB1YmxpYyBBUEkuXG4gKlxuICogQGNsYXNzIFN1YnNjcmliZXI8VD5cbiAqL1xudmFyIFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JzZXJ2ZXJ8ZnVuY3Rpb24odmFsdWU6IFQpOiB2b2lkfSBbZGVzdGluYXRpb25Pck5leHRdIEEgcGFydGlhbGx5XG4gICAgICogZGVmaW5lZCBPYnNlcnZlciBvciBhIGBuZXh0YCBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGU6ID9hbnkpOiB2b2lkfSBbZXJyb3JdIFRoZSBgZXJyb3JgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbY29tcGxldGVdIFRoZSBgY29tcGxldGVgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3Vic2NyaWJlcihkZXN0aW5hdGlvbk9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnN5bmNFcnJvclZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zeW5jRXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zeW5jRXJyb3JUaHJvd2FibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IE9ic2VydmVyXzEuZW1wdHk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgaWYgKCFkZXN0aW5hdGlvbk9yTmV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gT2JzZXJ2ZXJfMS5lbXB0eTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVzdGluYXRpb25Pck5leHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbk9yTmV4dCBpbnN0YW5jZW9mIFN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbk9yTmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uYWRkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zeW5jRXJyb3JUaHJvd2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTYWZlU3Vic2NyaWJlcih0aGlzLCBkZXN0aW5hdGlvbk9yTmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTYWZlU3Vic2NyaWJlcih0aGlzLCBkZXN0aW5hdGlvbk9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZVtyeFN1YnNjcmliZXJfMS5yeFN1YnNjcmliZXJdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcbiAgICAvKipcbiAgICAgKiBBIHN0YXRpYyBmYWN0b3J5IGZvciBhIFN1YnNjcmliZXIsIGdpdmVuIGEgKHBvdGVudGlhbGx5IHBhcnRpYWwpIGRlZmluaXRpb25cbiAgICAgKiBvZiBhbiBPYnNlcnZlci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHg6ID9UKTogdm9pZH0gW25leHRdIFRoZSBgbmV4dGAgY2FsbGJhY2sgb2YgYW4gT2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihlOiA/YW55KTogdm9pZH0gW2Vycm9yXSBUaGUgYGVycm9yYCBjYWxsYmFjayBvZiBhblxuICAgICAqIE9ic2VydmVyLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gW2NvbXBsZXRlXSBUaGUgYGNvbXBsZXRlYCBjYWxsYmFjayBvZiBhblxuICAgICAqIE9ic2VydmVyLlxuICAgICAqIEByZXR1cm4ge1N1YnNjcmliZXI8VD59IEEgU3Vic2NyaWJlciB3cmFwcGluZyB0aGUgKHBhcnRpYWxseSBkZWZpbmVkKVxuICAgICAqIE9ic2VydmVyIHJlcHJlc2VudGVkIGJ5IHRoZSBnaXZlbiBhcmd1bWVudHMuXG4gICAgICovXG4gICAgU3Vic2NyaWJlci5jcmVhdGUgPSBmdW5jdGlvbiAobmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBzdWJzY3JpYmVyID0gbmV3IFN1YnNjcmliZXIobmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgc3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUge0BsaW5rIE9ic2VydmVyfSBjYWxsYmFjayB0byByZWNlaXZlIG5vdGlmaWNhdGlvbnMgb2YgdHlwZSBgbmV4dGAgZnJvbVxuICAgICAqIHRoZSBPYnNlcnZhYmxlLCB3aXRoIGEgdmFsdWUuIFRoZSBPYnNlcnZhYmxlIG1heSBjYWxsIHRoaXMgbWV0aG9kIDAgb3IgbW9yZVxuICAgICAqIHRpbWVzLlxuICAgICAqIEBwYXJhbSB7VH0gW3ZhbHVlXSBUaGUgYG5leHRgIHZhbHVlLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIHtAbGluayBPYnNlcnZlcn0gY2FsbGJhY2sgdG8gcmVjZWl2ZSBub3RpZmljYXRpb25zIG9mIHR5cGUgYGVycm9yYCBmcm9tXG4gICAgICogdGhlIE9ic2VydmFibGUsIHdpdGggYW4gYXR0YWNoZWQge0BsaW5rIEVycm9yfS4gTm90aWZpZXMgdGhlIE9ic2VydmVyIHRoYXRcbiAgICAgKiB0aGUgT2JzZXJ2YWJsZSBoYXMgZXhwZXJpZW5jZWQgYW4gZXJyb3IgY29uZGl0aW9uLlxuICAgICAqIEBwYXJhbSB7YW55fSBbZXJyXSBUaGUgYGVycm9yYCBleGNlcHRpb24uXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIHtAbGluayBPYnNlcnZlcn0gY2FsbGJhY2sgdG8gcmVjZWl2ZSBhIHZhbHVlbGVzcyBub3RpZmljYXRpb24gb2YgdHlwZVxuICAgICAqIGBjb21wbGV0ZWAgZnJvbSB0aGUgT2JzZXJ2YWJsZS4gTm90aWZpZXMgdGhlIE9ic2VydmVyIHRoYXQgdGhlIE9ic2VydmFibGVcbiAgICAgKiBoYXMgZmluaXNoZWQgc2VuZGluZyBwdXNoLWJhc2VkIG5vdGlmaWNhdGlvbnMuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51bnN1YnNjcmliZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlQW5kUmVjeWNsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgX3BhcmVudCA9IF9hLl9wYXJlbnQsIF9wYXJlbnRzID0gX2EuX3BhcmVudHM7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhcmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHRoaXMuX3BhcmVudHMgPSBfcGFyZW50cztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gU3Vic2NyaWJlcjtcbn0oU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKSk7XG5leHBvcnRzLlN1YnNjcmliZXIgPSBTdWJzY3JpYmVyO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTYWZlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNhZmVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNhZmVTdWJzY3JpYmVyKF9wYXJlbnRTdWJzY3JpYmVyLCBvYnNlcnZlck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9wYXJlbnRTdWJzY3JpYmVyID0gX3BhcmVudFN1YnNjcmliZXI7XG4gICAgICAgIHZhciBuZXh0O1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihvYnNlcnZlck9yTmV4dCkpIHtcbiAgICAgICAgICAgIG5leHQgPSBvYnNlcnZlck9yTmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYnNlcnZlck9yTmV4dCkge1xuICAgICAgICAgICAgbmV4dCA9IG9ic2VydmVyT3JOZXh0Lm5leHQ7XG4gICAgICAgICAgICBlcnJvciA9IG9ic2VydmVyT3JOZXh0LmVycm9yO1xuICAgICAgICAgICAgY29tcGxldGUgPSBvYnNlcnZlck9yTmV4dC5jb21wbGV0ZTtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlck9yTmV4dCAhPT0gT2JzZXJ2ZXJfMS5lbXB0eSkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBPYmplY3QuY3JlYXRlKG9ic2VydmVyT3JOZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24oY29udGV4dC51bnN1YnNjcmliZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQoY29udGV4dC51bnN1YnNjcmliZS5iaW5kKGNvbnRleHQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGV4dC51bnN1YnNjcmliZSA9IHRoaXMudW5zdWJzY3JpYmUuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5fbmV4dCA9IG5leHQ7XG4gICAgICAgIHRoaXMuX2Vycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMuX2NvbXBsZXRlID0gY29tcGxldGU7XG4gICAgfVxuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQgJiYgdGhpcy5fbmV4dCkge1xuICAgICAgICAgICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgICAgIGlmICghX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yVW5zdWIodGhpcy5fbmV4dCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fX3RyeU9yU2V0RXJyb3IoX3BhcmVudFN1YnNjcmliZXIsIHRoaXMuX25leHQsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgX3BhcmVudFN1YnNjcmliZXIgPSB0aGlzLl9wYXJlbnRTdWJzY3JpYmVyO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Vycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yVW5zdWIodGhpcy5fZXJyb3IsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnRTdWJzY3JpYmVyLCB0aGlzLl9lcnJvciwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVmFsdWUgPSBlcnI7XG4gICAgICAgICAgICAgICAgX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIHZhciB3cmFwcGVkQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fY29tcGxldGUuY2FsbChfdGhpcy5fY29udGV4dCk7IH07XG4gICAgICAgICAgICAgICAgaWYgKCFfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yVW5zdWIod3JhcHBlZENvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yU2V0RXJyb3IoX3BhcmVudFN1YnNjcmliZXIsIHdyYXBwZWRDb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fX3RyeU9yVW5zdWIgPSBmdW5jdGlvbiAoZm4sIHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMuX2NvbnRleHQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fX3RyeU9yU2V0RXJyb3IgPSBmdW5jdGlvbiAocGFyZW50LCBmbiwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcy5fY29udGV4dCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHBhcmVudC5zeW5jRXJyb3JWYWx1ZSA9IGVycjtcbiAgICAgICAgICAgIHBhcmVudC5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhcmVudFN1YnNjcmliZXIgPSBudWxsO1xuICAgICAgICBfcGFyZW50U3Vic2NyaWJlci51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFNhZmVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJzY3JpYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGlzQXJyYXlfMSA9IHJlcXVpcmUoJy4vdXRpbC9pc0FycmF5Jyk7XG52YXIgaXNPYmplY3RfMSA9IHJlcXVpcmUoJy4vdXRpbC9pc09iamVjdCcpO1xudmFyIGlzRnVuY3Rpb25fMSA9IHJlcXVpcmUoJy4vdXRpbC9pc0Z1bmN0aW9uJyk7XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4vdXRpbC90cnlDYXRjaCcpO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBVbnN1YnNjcmlwdGlvbkVycm9yXzEgPSByZXF1aXJlKCcuL3V0aWwvVW5zdWJzY3JpcHRpb25FcnJvcicpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgZGlzcG9zYWJsZSByZXNvdXJjZSwgc3VjaCBhcyB0aGUgZXhlY3V0aW9uIG9mIGFuIE9ic2VydmFibGUuIEFcbiAqIFN1YnNjcmlwdGlvbiBoYXMgb25lIGltcG9ydGFudCBtZXRob2QsIGB1bnN1YnNjcmliZWAsIHRoYXQgdGFrZXMgbm8gYXJndW1lbnRcbiAqIGFuZCBqdXN0IGRpc3Bvc2VzIHRoZSByZXNvdXJjZSBoZWxkIGJ5IHRoZSBzdWJzY3JpcHRpb24uXG4gKlxuICogQWRkaXRpb25hbGx5LCBzdWJzY3JpcHRpb25zIG1heSBiZSBncm91cGVkIHRvZ2V0aGVyIHRocm91Z2ggdGhlIGBhZGQoKWBcbiAqIG1ldGhvZCwgd2hpY2ggd2lsbCBhdHRhY2ggYSBjaGlsZCBTdWJzY3JpcHRpb24gdG8gdGhlIGN1cnJlbnQgU3Vic2NyaXB0aW9uLlxuICogV2hlbiBhIFN1YnNjcmlwdGlvbiBpcyB1bnN1YnNjcmliZWQsIGFsbCBpdHMgY2hpbGRyZW4gKGFuZCBpdHMgZ3JhbmRjaGlsZHJlbilcbiAqIHdpbGwgYmUgdW5zdWJzY3JpYmVkIGFzIHdlbGwuXG4gKlxuICogQGNsYXNzIFN1YnNjcmlwdGlvblxuICovXG52YXIgU3Vic2NyaXB0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFt1bnN1YnNjcmliZV0gQSBmdW5jdGlvbiBkZXNjcmliaW5nIGhvdyB0b1xuICAgICAqIHBlcmZvcm0gdGhlIGRpc3Bvc2FsIG9mIHJlc291cmNlcyB3aGVuIHRoZSBgdW5zdWJzY3JpYmVgIG1ldGhvZCBpcyBjYWxsZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uKHVuc3Vic2NyaWJlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciB0aGlzIFN1YnNjcmlwdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHVuc3Vic2NyaWJlZC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYXJlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IG51bGw7XG4gICAgICAgIGlmICh1bnN1YnNjcmliZSkge1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUgPSB1bnN1YnNjcmliZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyB0aGUgcmVzb3VyY2VzIGhlbGQgYnkgdGhlIHN1YnNjcmlwdGlvbi4gTWF5LCBmb3IgaW5zdGFuY2UsIGNhbmNlbFxuICAgICAqIGFuIG9uZ29pbmcgT2JzZXJ2YWJsZSBleGVjdXRpb24gb3IgY2FuY2VsIGFueSBvdGhlciB0eXBlIG9mIHdvcmsgdGhhdFxuICAgICAqIHN0YXJ0ZWQgd2hlbiB0aGUgU3Vic2NyaXB0aW9uIHdhcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhhc0Vycm9ycyA9IGZhbHNlO1xuICAgICAgICB2YXIgZXJyb3JzO1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLCBfcGFyZW50ID0gX2EuX3BhcmVudCwgX3BhcmVudHMgPSBfYS5fcGFyZW50cywgX3Vuc3Vic2NyaWJlID0gX2EuX3Vuc3Vic2NyaWJlLCBfc3Vic2NyaXB0aW9ucyA9IF9hLl9zdWJzY3JpcHRpb25zO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhcmVudHMgPSBudWxsO1xuICAgICAgICAvLyBudWxsIG91dCBfc3Vic2NyaXB0aW9ucyBmaXJzdCBzbyBhbnkgY2hpbGQgc3Vic2NyaXB0aW9ucyB0aGF0IGF0dGVtcHRcbiAgICAgICAgLy8gdG8gcmVtb3ZlIHRoZW1zZWx2ZXMgZnJvbSB0aGlzIHN1YnNjcmlwdGlvbiB3aWxsIG5vb3BcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IG51bGw7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICB2YXIgbGVuID0gX3BhcmVudHMgPyBfcGFyZW50cy5sZW5ndGggOiAwO1xuICAgICAgICAvLyBpZiB0aGlzLl9wYXJlbnQgaXMgbnVsbCwgdGhlbiBzbyBpcyB0aGlzLl9wYXJlbnRzLCBhbmQgd2VcbiAgICAgICAgLy8gZG9uJ3QgaGF2ZSB0byByZW1vdmUgb3Vyc2VsdmVzIGZyb20gYW55IHBhcmVudCBzdWJzY3JpcHRpb25zLlxuICAgICAgICB3aGlsZSAoX3BhcmVudCkge1xuICAgICAgICAgICAgX3BhcmVudC5yZW1vdmUodGhpcyk7XG4gICAgICAgICAgICAvLyBpZiB0aGlzLl9wYXJlbnRzIGlzIG51bGwgb3IgaW5kZXggPj0gbGVuLFxuICAgICAgICAgICAgLy8gdGhlbiBfcGFyZW50IGlzIHNldCB0byBudWxsLCBhbmQgdGhlIGxvb3AgZXhpdHNcbiAgICAgICAgICAgIF9wYXJlbnQgPSArK2luZGV4IDwgbGVuICYmIF9wYXJlbnRzW2luZGV4XSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihfdW5zdWJzY3JpYmUpKSB7XG4gICAgICAgICAgICB2YXIgdHJpYWwgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKF91bnN1YnNjcmliZSkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGlmICh0cmlhbCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIGhhc0Vycm9ycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzIHx8IChlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUgaW5zdGFuY2VvZiBVbnN1YnNjcmlwdGlvbkVycm9yXzEuVW5zdWJzY3JpcHRpb25FcnJvciA/XG4gICAgICAgICAgICAgICAgICAgIGZsYXR0ZW5VbnN1YnNjcmlwdGlvbkVycm9ycyhlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUuZXJyb3JzKSA6IFtlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheV8xLmlzQXJyYXkoX3N1YnNjcmlwdGlvbnMpKSB7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgbGVuID0gX3N1YnNjcmlwdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViID0gX3N1YnNjcmlwdGlvbnNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdF8xLmlzT2JqZWN0KHN1YikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyaWFsID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChzdWIudW5zdWJzY3JpYmUpLmNhbGwoc3ViKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyaWFsID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNFcnJvcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBVbnN1YnNjcmlwdGlvbkVycm9yXzEuVW5zdWJzY3JpcHRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoZmxhdHRlblVuc3Vic2NyaXB0aW9uRXJyb3JzKGVyci5lcnJvcnMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0Vycm9ycykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3Vic2NyaXB0aW9uRXJyb3JfMS5VbnN1YnNjcmlwdGlvbkVycm9yKGVycm9ycyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSB0ZWFyIGRvd24gdG8gYmUgY2FsbGVkIGR1cmluZyB0aGUgdW5zdWJzY3JpYmUoKSBvZiB0aGlzXG4gICAgICogU3Vic2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogSWYgdGhlIHRlYXIgZG93biBiZWluZyBhZGRlZCBpcyBhIHN1YnNjcmlwdGlvbiB0aGF0IGlzIGFscmVhZHlcbiAgICAgKiB1bnN1YnNjcmliZWQsIGlzIHRoZSBzYW1lIHJlZmVyZW5jZSBgYWRkYCBpcyBiZWluZyBjYWxsZWQgb24sIG9yIGlzXG4gICAgICogYFN1YnNjcmlwdGlvbi5FTVBUWWAsIGl0IHdpbGwgbm90IGJlIGFkZGVkLlxuICAgICAqXG4gICAgICogSWYgdGhpcyBzdWJzY3JpcHRpb24gaXMgYWxyZWFkeSBpbiBhbiBgY2xvc2VkYCBzdGF0ZSwgdGhlIHBhc3NlZFxuICAgICAqIHRlYXIgZG93biBsb2dpYyB3aWxsIGJlIGV4ZWN1dGVkIGltbWVkaWF0ZWx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtUZWFyZG93bkxvZ2ljfSB0ZWFyZG93biBUaGUgYWRkaXRpb25hbCBsb2dpYyB0byBleGVjdXRlIG9uXG4gICAgICogdGVhcmRvd24uXG4gICAgICogQHJldHVybiB7U3Vic2NyaXB0aW9ufSBSZXR1cm5zIHRoZSBTdWJzY3JpcHRpb24gdXNlZCBvciBjcmVhdGVkIHRvIGJlXG4gICAgICogYWRkZWQgdG8gdGhlIGlubmVyIHN1YnNjcmlwdGlvbnMgbGlzdC4gVGhpcyBTdWJzY3JpcHRpb24gY2FuIGJlIHVzZWQgd2l0aFxuICAgICAqIGByZW1vdmUoKWAgdG8gcmVtb3ZlIHRoZSBwYXNzZWQgdGVhcmRvd24gbG9naWMgZnJvbSB0aGUgaW5uZXIgc3Vic2NyaXB0aW9uc1xuICAgICAqIGxpc3QuXG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodGVhcmRvd24pIHtcbiAgICAgICAgaWYgKCF0ZWFyZG93biB8fCAodGVhcmRvd24gPT09IFN1YnNjcmlwdGlvbi5FTVBUWSkpIHtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRlYXJkb3duID09PSB0aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGVhcmRvd247XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHRlYXJkb3duKSB7XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbih0ZWFyZG93bik7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uY2xvc2VkIHx8IHR5cGVvZiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdWJzY3JpcHRpb24uX2FkZFBhcmVudCAhPT0gJ2Z1bmN0aW9uJyAvKiBxdWFjayBxdWFjayAqLykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5fc3Vic2NyaXB0aW9ucyA9IFt0bXBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlY29nbml6ZWQgdGVhcmRvd24gJyArIHRlYXJkb3duICsgJyBhZGRlZCB0byBTdWJzY3JpcHRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSB0aGlzLl9zdWJzY3JpcHRpb25zIHx8ICh0aGlzLl9zdWJzY3JpcHRpb25zID0gW10pO1xuICAgICAgICBzdWJzY3JpcHRpb25zLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uLl9hZGRQYXJlbnQodGhpcyk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgU3Vic2NyaXB0aW9uIGZyb20gdGhlIGludGVybmFsIGxpc3Qgb2Ygc3Vic2NyaXB0aW9ucyB0aGF0IHdpbGxcbiAgICAgKiB1bnN1YnNjcmliZSBkdXJpbmcgdGhlIHVuc3Vic2NyaWJlIHByb2Nlc3Mgb2YgdGhpcyBTdWJzY3JpcHRpb24uXG4gICAgICogQHBhcmFtIHtTdWJzY3JpcHRpb259IHN1YnNjcmlwdGlvbiBUaGUgc3Vic2NyaXB0aW9uIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnM7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uSW5kZXggPSBzdWJzY3JpcHRpb25zLmluZGV4T2Yoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25JbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zLnNwbGljZShzdWJzY3JpcHRpb25JbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuX2FkZFBhcmVudCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgX3BhcmVudCA9IF9hLl9wYXJlbnQsIF9wYXJlbnRzID0gX2EuX3BhcmVudHM7XG4gICAgICAgIGlmICghX3BhcmVudCB8fCBfcGFyZW50ID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBwYXJlbnQsIG9yIHRoZSBuZXcgcGFyZW50IGlzIHRoZSBzYW1lIGFzIHRoZVxuICAgICAgICAgICAgLy8gY3VycmVudCBwYXJlbnQsIHRoZW4gc2V0IHRoaXMuX3BhcmVudCB0byB0aGUgbmV3IHBhcmVudC5cbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghX3BhcmVudHMpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYWxyZWFkeSBvbmUgcGFyZW50LCBidXQgbm90IG11bHRpcGxlLCBhbGxvY2F0ZSBhbiBBcnJheSB0b1xuICAgICAgICAgICAgLy8gc3RvcmUgdGhlIHJlc3Qgb2YgdGhlIHBhcmVudCBTdWJzY3JpcHRpb25zLlxuICAgICAgICAgICAgdGhpcy5fcGFyZW50cyA9IFtwYXJlbnRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9wYXJlbnRzLmluZGV4T2YocGFyZW50KSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgYWRkIHRoZSBuZXcgcGFyZW50IHRvIHRoZSBfcGFyZW50cyBsaXN0IGlmIGl0J3Mgbm90IGFscmVhZHkgdGhlcmUuXG4gICAgICAgICAgICBfcGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5FTVBUWSA9IChmdW5jdGlvbiAoZW1wdHkpIHtcbiAgICAgICAgZW1wdHkuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH0obmV3IFN1YnNjcmlwdGlvbigpKSk7XG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvbjtcbn0oKSk7XG5leHBvcnRzLlN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbjtcbmZ1bmN0aW9uIGZsYXR0ZW5VbnN1YnNjcmlwdGlvbkVycm9ycyhlcnJvcnMpIHtcbiAgICByZXR1cm4gZXJyb3JzLnJlZHVjZShmdW5jdGlvbiAoZXJycywgZXJyKSB7IHJldHVybiBlcnJzLmNvbmNhdCgoZXJyIGluc3RhbmNlb2YgVW5zdWJzY3JpcHRpb25FcnJvcl8xLlVuc3Vic2NyaXB0aW9uRXJyb3IpID8gZXJyLmVycm9ycyA6IGVycik7IH0sIFtdKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YnNjcmlwdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBTY2FsYXJPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL1NjYWxhck9ic2VydmFibGUnKTtcbnZhciBFbXB0eU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vRW1wdHlPYnNlcnZhYmxlJyk7XG52YXIgaXNTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNTY2hlZHVsZXInKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgQXJyYXlPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJyYXlPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFycmF5T2JzZXJ2YWJsZShhcnJheSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICBpZiAoIXNjaGVkdWxlciAmJiBhcnJheS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2NhbGFyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBhcnJheVswXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBcnJheU9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGFycmF5LCBzY2hlZHVsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheU9ic2VydmFibGUoYXJyYXksIHNjaGVkdWxlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBzb21lIHZhbHVlcyB5b3Ugc3BlY2lmeSBhcyBhcmd1bWVudHMsXG4gICAgICogaW1tZWRpYXRlbHkgb25lIGFmdGVyIHRoZSBvdGhlciwgYW5kIHRoZW4gZW1pdHMgYSBjb21wbGV0ZSBub3RpZmljYXRpb24uXG4gICAgICpcbiAgICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RW1pdHMgdGhlIGFyZ3VtZW50cyB5b3UgcHJvdmlkZSwgdGhlbiBjb21wbGV0ZXMuXG4gICAgICogPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy9vZi5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICAgKlxuICAgICAqIFRoaXMgc3RhdGljIG9wZXJhdG9yIGlzIHVzZWZ1bCBmb3IgY3JlYXRpbmcgYSBzaW1wbGUgT2JzZXJ2YWJsZSB0aGF0IG9ubHlcbiAgICAgKiBlbWl0cyB0aGUgYXJndW1lbnRzIGdpdmVuLCBhbmQgdGhlIGNvbXBsZXRlIG5vdGlmaWNhdGlvbiB0aGVyZWFmdGVyLiBJdCBjYW5cbiAgICAgKiBiZSB1c2VkIGZvciBjb21wb3Npbmcgd2l0aCBvdGhlciBPYnNlcnZhYmxlcywgc3VjaCBhcyB3aXRoIHtAbGluayBjb25jYXR9LlxuICAgICAqIEJ5IGRlZmF1bHQsIGl0IHVzZXMgYSBgbnVsbGAgSVNjaGVkdWxlciwgd2hpY2ggbWVhbnMgdGhlIGBuZXh0YFxuICAgICAqIG5vdGlmaWNhdGlvbnMgYXJlIHNlbnQgc3luY2hyb25vdXNseSwgYWx0aG91Z2ggd2l0aCBhIGRpZmZlcmVudCBJU2NoZWR1bGVyXG4gICAgICogaXQgaXMgcG9zc2libGUgdG8gZGV0ZXJtaW5lIHdoZW4gdGhvc2Ugbm90aWZpY2F0aW9ucyB3aWxsIGJlIGRlbGl2ZXJlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgMTAsIDIwLCAzMCwgdGhlbiAnYScsICdiJywgJ2MnLCB0aGVuIHN0YXJ0IHRpY2tpbmcgZXZlcnkgc2Vjb25kLjwvY2FwdGlvbj5cbiAgICAgKiB2YXIgbnVtYmVycyA9IFJ4Lk9ic2VydmFibGUub2YoMTAsIDIwLCAzMCk7XG4gICAgICogdmFyIGxldHRlcnMgPSBSeC5PYnNlcnZhYmxlLm9mKCdhJywgJ2InLCAnYycpO1xuICAgICAqIHZhciBpbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gICAgICogdmFyIHJlc3VsdCA9IG51bWJlcnMuY29uY2F0KGxldHRlcnMpLmNvbmNhdChpbnRlcnZhbCk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGNyZWF0ZX1cbiAgICAgKiBAc2VlIHtAbGluayBlbXB0eX1cbiAgICAgKiBAc2VlIHtAbGluayBuZXZlcn1cbiAgICAgKiBAc2VlIHtAbGluayB0aHJvd31cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Li4uVH0gdmFsdWVzIEFyZ3VtZW50cyB0aGF0IHJlcHJlc2VudCBgbmV4dGAgdmFsdWVzIHRvIGJlIGVtaXR0ZWQuXG4gICAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIEEge0BsaW5rIElTY2hlZHVsZXJ9IHRvIHVzZSBmb3Igc2NoZWR1bGluZ1xuICAgICAqIHRoZSBlbWlzc2lvbnMgb2YgdGhlIGBuZXh0YCBub3RpZmljYXRpb25zLlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBlYWNoIGdpdmVuIGlucHV0IHZhbHVlLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIG9mXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBBcnJheU9ic2VydmFibGUub2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJyYXlbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihzY2hlZHVsZXIpKSB7XG4gICAgICAgICAgICBhcnJheS5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjaGVkdWxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlPYnNlcnZhYmxlKGFycmF5LCBzY2hlZHVsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTY2FsYXJPYnNlcnZhYmxlXzEuU2NhbGFyT2JzZXJ2YWJsZShhcnJheVswXSwgc2NoZWR1bGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlPYnNlcnZhYmxlXzEuRW1wdHlPYnNlcnZhYmxlKHNjaGVkdWxlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFycmF5T2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgYXJyYXkgPSBzdGF0ZS5hcnJheSwgaW5kZXggPSBzdGF0ZS5pbmRleCwgY291bnQgPSBzdGF0ZS5jb3VudCwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXI7XG4gICAgICAgIGlmIChpbmRleCA+PSBjb3VudCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIubmV4dChhcnJheVtpbmRleF0pO1xuICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5pbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZShzdGF0ZSk7XG4gICAgfTtcbiAgICBBcnJheU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgICAgICB2YXIgY291bnQgPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShBcnJheU9ic2VydmFibGUuZGlzcGF0Y2gsIDAsIHtcbiAgICAgICAgICAgICAgICBhcnJheTogYXJyYXksIGluZGV4OiBpbmRleCwgY291bnQ6IGNvdW50LCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQgJiYgIXN1YnNjcmliZXIuY2xvc2VkOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoYXJyYXlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQXJyYXlPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5BcnJheU9ic2VydmFibGUgPSBBcnJheU9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BcnJheU9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9TdWJqZWN0Jyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmlwdGlvbicpO1xuLyoqXG4gKiBAY2xhc3MgQ29ubmVjdGFibGVPYnNlcnZhYmxlPFQ+XG4gKi9cbnZhciBDb25uZWN0YWJsZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb25uZWN0YWJsZU9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29ubmVjdGFibGVPYnNlcnZhYmxlKHNvdXJjZSwgc3ViamVjdEZhY3RvcnkpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnN1YmplY3RGYWN0b3J5ID0gc3ViamVjdEZhY3Rvcnk7XG4gICAgICAgIHRoaXMuX3JlZkNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5faXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdWJqZWN0KCkuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgIH07XG4gICAgQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5nZXRTdWJqZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3ViamVjdCA9IHRoaXMuX3N1YmplY3Q7XG4gICAgICAgIGlmICghc3ViamVjdCB8fCBzdWJqZWN0LmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5fc3ViamVjdCA9IHRoaXMuc3ViamVjdEZhY3RvcnkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3ViamVjdDtcbiAgICB9O1xuICAgIENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSB0aGlzLl9jb25uZWN0aW9uO1xuICAgICAgICBpZiAoIWNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2lzQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24gPSB0aGlzLl9jb25uZWN0aW9uID0gbmV3IFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgY29ubmVjdGlvbi5hZGQodGhpcy5zb3VyY2VcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKG5ldyBDb25uZWN0YWJsZVN1YnNjcmliZXIodGhpcy5nZXRTdWJqZWN0KCksIHRoaXMpKSk7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uID0gU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgfTtcbiAgICBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLnJlZkNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBSZWZDb3VudE9wZXJhdG9yKHRoaXMpKTtcbiAgICB9O1xuICAgIHJldHVybiBDb25uZWN0YWJsZU9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkNvbm5lY3RhYmxlT2JzZXJ2YWJsZSA9IENvbm5lY3RhYmxlT2JzZXJ2YWJsZTtcbnZhciBjb25uZWN0YWJsZVByb3RvID0gQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZTtcbmV4cG9ydHMuY29ubmVjdGFibGVPYnNlcnZhYmxlRGVzY3JpcHRvciA9IHtcbiAgICBvcGVyYXRvcjogeyB2YWx1ZTogbnVsbCB9LFxuICAgIF9yZWZDb3VudDogeyB2YWx1ZTogMCwgd3JpdGFibGU6IHRydWUgfSxcbiAgICBfc3ViamVjdDogeyB2YWx1ZTogbnVsbCwgd3JpdGFibGU6IHRydWUgfSxcbiAgICBfY29ubmVjdGlvbjogeyB2YWx1ZTogbnVsbCwgd3JpdGFibGU6IHRydWUgfSxcbiAgICBfc3Vic2NyaWJlOiB7IHZhbHVlOiBjb25uZWN0YWJsZVByb3RvLl9zdWJzY3JpYmUgfSxcbiAgICBfaXNDb21wbGV0ZTogeyB2YWx1ZTogY29ubmVjdGFibGVQcm90by5faXNDb21wbGV0ZSwgd3JpdGFibGU6IHRydWUgfSxcbiAgICBnZXRTdWJqZWN0OiB7IHZhbHVlOiBjb25uZWN0YWJsZVByb3RvLmdldFN1YmplY3QgfSxcbiAgICBjb25uZWN0OiB7IHZhbHVlOiBjb25uZWN0YWJsZVByb3RvLmNvbm5lY3QgfSxcbiAgICByZWZDb3VudDogeyB2YWx1ZTogY29ubmVjdGFibGVQcm90by5yZWZDb3VudCB9XG59O1xudmFyIENvbm5lY3RhYmxlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbm5lY3RhYmxlU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25uZWN0YWJsZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGNvbm5lY3RhYmxlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5jb25uZWN0YWJsZSA9IGNvbm5lY3RhYmxlO1xuICAgIH1cbiAgICBDb25uZWN0YWJsZVN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fZXJyb3IuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH07XG4gICAgQ29ubmVjdGFibGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGFibGUuX2lzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl91bnN1YnNjcmliZSgpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgQ29ubmVjdGFibGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25uZWN0YWJsZSA9IHRoaXMuY29ubmVjdGFibGU7XG4gICAgICAgIGlmIChjb25uZWN0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0YWJsZSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbiA9IGNvbm5lY3RhYmxlLl9jb25uZWN0aW9uO1xuICAgICAgICAgICAgY29ubmVjdGFibGUuX3JlZkNvdW50ID0gMDtcbiAgICAgICAgICAgIGNvbm5lY3RhYmxlLl9zdWJqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbm5lY3RhYmxlLl9jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ29ubmVjdGFibGVTdWJzY3JpYmVyO1xufShTdWJqZWN0XzEuU3ViamVjdFN1YnNjcmliZXIpKTtcbnZhciBSZWZDb3VudE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWZDb3VudE9wZXJhdG9yKGNvbm5lY3RhYmxlKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGFibGUgPSBjb25uZWN0YWJsZTtcbiAgICB9XG4gICAgUmVmQ291bnRPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgdmFyIGNvbm5lY3RhYmxlID0gdGhpcy5jb25uZWN0YWJsZTtcbiAgICAgICAgY29ubmVjdGFibGUuX3JlZkNvdW50Kys7XG4gICAgICAgIHZhciByZWZDb3VudGVyID0gbmV3IFJlZkNvdW50U3Vic2NyaWJlcihzdWJzY3JpYmVyLCBjb25uZWN0YWJsZSk7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBzb3VyY2Uuc3Vic2NyaWJlKHJlZkNvdW50ZXIpO1xuICAgICAgICBpZiAoIXJlZkNvdW50ZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICByZWZDb3VudGVyLmNvbm5lY3Rpb24gPSBjb25uZWN0YWJsZS5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICB9O1xuICAgIHJldHVybiBSZWZDb3VudE9wZXJhdG9yO1xufSgpKTtcbnZhciBSZWZDb3VudFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWZDb3VudFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVmQ291bnRTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjb25uZWN0YWJsZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuY29ubmVjdGFibGUgPSBjb25uZWN0YWJsZTtcbiAgICB9XG4gICAgUmVmQ291bnRTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25uZWN0YWJsZSA9IHRoaXMuY29ubmVjdGFibGU7XG4gICAgICAgIGlmICghY29ubmVjdGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0YWJsZSA9IG51bGw7XG4gICAgICAgIHZhciByZWZDb3VudCA9IGNvbm5lY3RhYmxlLl9yZWZDb3VudDtcbiAgICAgICAgaWYgKHJlZkNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGFibGUuX3JlZkNvdW50ID0gcmVmQ291bnQgLSAxO1xuICAgICAgICBpZiAocmVmQ291bnQgPiAxKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vL1xuICAgICAgICAvLyBDb21wYXJlIHRoZSBsb2NhbCBSZWZDb3VudFN1YnNjcmliZXIncyBjb25uZWN0aW9uIFN1YnNjcmlwdGlvbiB0byB0aGVcbiAgICAgICAgLy8gY29ubmVjdGlvbiBTdWJzY3JpcHRpb24gb24gdGhlIHNoYXJlZCBDb25uZWN0YWJsZU9ic2VydmFibGUuIEluIGNhc2VzXG4gICAgICAgIC8vIHdoZXJlIHRoZSBDb25uZWN0YWJsZU9ic2VydmFibGUgc291cmNlIHN5bmNocm9ub3VzbHkgZW1pdHMgdmFsdWVzLCBhbmRcbiAgICAgICAgLy8gdGhlIFJlZkNvdW50U3Vic2NyaWJlcidzIGRvd25zdHJlYW0gT2JzZXJ2ZXJzIHN5bmNocm9ub3VzbHkgdW5zdWJzY3JpYmUsXG4gICAgICAgIC8vIGV4ZWN1dGlvbiBjb250aW51ZXMgdG8gaGVyZSBiZWZvcmUgdGhlIFJlZkNvdW50T3BlcmF0b3IgaGFzIGEgY2hhbmNlIHRvXG4gICAgICAgIC8vIHN1cHBseSB0aGUgUmVmQ291bnRTdWJzY3JpYmVyIHdpdGggdGhlIHNoYXJlZCBjb25uZWN0aW9uIFN1YnNjcmlwdGlvbi5cbiAgICAgICAgLy8gRm9yIGV4YW1wbGU6XG4gICAgICAgIC8vIGBgYFxuICAgICAgICAvLyBPYnNlcnZhYmxlLnJhbmdlKDAsIDEwKVxuICAgICAgICAvLyAgIC5wdWJsaXNoKClcbiAgICAgICAgLy8gICAucmVmQ291bnQoKVxuICAgICAgICAvLyAgIC50YWtlKDUpXG4gICAgICAgIC8vICAgLnN1YnNjcmliZSgpO1xuICAgICAgICAvLyBgYGBcbiAgICAgICAgLy8gSW4gb3JkZXIgdG8gYWNjb3VudCBmb3IgdGhpcyBjYXNlLCBSZWZDb3VudFN1YnNjcmliZXIgc2hvdWxkIG9ubHkgZGlzcG9zZVxuICAgICAgICAvLyB0aGUgQ29ubmVjdGFibGVPYnNlcnZhYmxlJ3Mgc2hhcmVkIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uIGlmIHRoZVxuICAgICAgICAvLyBjb25uZWN0aW9uIFN1YnNjcmlwdGlvbiBleGlzdHMsICphbmQqIGVpdGhlcjpcbiAgICAgICAgLy8gICBhLiBSZWZDb3VudFN1YnNjcmliZXIgZG9lc24ndCBoYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBzaGFyZWQgY29ubmVjdGlvblxuICAgICAgICAvLyAgICAgIFN1YnNjcmlwdGlvbiB5ZXQsIG9yLFxuICAgICAgICAvLyAgIGIuIFJlZkNvdW50U3Vic2NyaWJlcidzIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uIHJlZmVyZW5jZSBpcyBpZGVudGljYWxcbiAgICAgICAgLy8gICAgICB0byB0aGUgc2hhcmVkIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uXG4gICAgICAgIC8vL1xuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IHRoaXMuY29ubmVjdGlvbjtcbiAgICAgICAgdmFyIHNoYXJlZENvbm5lY3Rpb24gPSBjb25uZWN0YWJsZS5fY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgaWYgKHNoYXJlZENvbm5lY3Rpb24gJiYgKCFjb25uZWN0aW9uIHx8IHNoYXJlZENvbm5lY3Rpb24gPT09IGNvbm5lY3Rpb24pKSB7XG4gICAgICAgICAgICBzaGFyZWRDb25uZWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSZWZDb3VudFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db25uZWN0YWJsZU9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEVtcHR5T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVtcHR5T2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFbXB0eU9ic2VydmFibGUoc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgbm8gaXRlbXMgdG8gdGhlIE9ic2VydmVyIGFuZCBpbW1lZGlhdGVseVxuICAgICAqIGVtaXRzIGEgY29tcGxldGUgbm90aWZpY2F0aW9uLlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkp1c3QgZW1pdHMgJ2NvbXBsZXRlJywgYW5kIG5vdGhpbmcgZWxzZS5cbiAgICAgKiA8L3NwYW4+XG4gICAgICpcbiAgICAgKiA8aW1nIHNyYz1cIi4vaW1nL2VtcHR5LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgICAqXG4gICAgICogVGhpcyBzdGF0aWMgb3BlcmF0b3IgaXMgdXNlZnVsIGZvciBjcmVhdGluZyBhIHNpbXBsZSBPYnNlcnZhYmxlIHRoYXQgb25seVxuICAgICAqIGVtaXRzIHRoZSBjb21wbGV0ZSBub3RpZmljYXRpb24uIEl0IGNhbiBiZSB1c2VkIGZvciBjb21wb3Npbmcgd2l0aCBvdGhlclxuICAgICAqIE9ic2VydmFibGVzLCBzdWNoIGFzIGluIGEge0BsaW5rIG1lcmdlTWFwfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgdGhlIG51bWJlciA3LCB0aGVuIGNvbXBsZXRlLjwvY2FwdGlvbj5cbiAgICAgKiB2YXIgcmVzdWx0ID0gUnguT2JzZXJ2YWJsZS5lbXB0eSgpLnN0YXJ0V2l0aCg3KTtcbiAgICAgKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+TWFwIGFuZCBmbGF0dGVuIG9ubHkgb2RkIG51bWJlcnMgdG8gdGhlIHNlcXVlbmNlICdhJywgJ2InLCAnYyc8L2NhcHRpb24+XG4gICAgICogdmFyIGludGVydmFsID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAgICAgKiB2YXIgcmVzdWx0ID0gaW50ZXJ2YWwubWVyZ2VNYXAoeCA9PlxuICAgICAqICAgeCAlIDIgPT09IDEgPyBSeC5PYnNlcnZhYmxlLm9mKCdhJywgJ2InLCAnYycpIDogUnguT2JzZXJ2YWJsZS5lbXB0eSgpXG4gICAgICogKTtcbiAgICAgKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nIHRvIHRoZSBjb25zb2xlOlxuICAgICAqIC8vIHggaXMgZXF1YWwgdG8gdGhlIGNvdW50IG9uIHRoZSBpbnRlcnZhbCBlZygwLDEsMiwzLC4uLilcbiAgICAgKiAvLyB4IHdpbGwgb2NjdXIgZXZlcnkgMTAwMG1zXG4gICAgICogLy8gaWYgeCAlIDIgaXMgZXF1YWwgdG8gMSBwcmludCBhYmNcbiAgICAgKiAvLyBpZiB4ICUgMiBpcyBub3QgZXF1YWwgdG8gMSBub3RoaW5nIHdpbGwgYmUgb3V0cHV0XG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBjcmVhdGV9XG4gICAgICogQHNlZSB7QGxpbmsgbmV2ZXJ9XG4gICAgICogQHNlZSB7QGxpbmsgb2Z9XG4gICAgICogQHNlZSB7QGxpbmsgdGhyb3d9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gQSB7QGxpbmsgSVNjaGVkdWxlcn0gdG8gdXNlIGZvciBzY2hlZHVsaW5nXG4gICAgICogdGhlIGVtaXNzaW9uIG9mIHRoZSBjb21wbGV0ZSBub3RpZmljYXRpb24uXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gXCJlbXB0eVwiIE9ic2VydmFibGU6IGVtaXRzIG9ubHkgdGhlIGNvbXBsZXRlXG4gICAgICogbm90aWZpY2F0aW9uLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGVtcHR5XG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBFbXB0eU9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xuICAgICAgICByZXR1cm4gbmV3IEVtcHR5T2JzZXJ2YWJsZShzY2hlZHVsZXIpO1xuICAgIH07XG4gICAgRW1wdHlPYnNlcnZhYmxlLmRpc3BhdGNoID0gZnVuY3Rpb24gKGFyZykge1xuICAgICAgICB2YXIgc3Vic2NyaWJlciA9IGFyZy5zdWJzY3JpYmVyO1xuICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBFbXB0eU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIGlmIChzY2hlZHVsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoRW1wdHlPYnNlcnZhYmxlLmRpc3BhdGNoLCAwLCB7IHN1YnNjcmliZXI6IHN1YnNjcmliZXIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBFbXB0eU9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkVtcHR5T2JzZXJ2YWJsZSA9IEVtcHR5T2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVtcHR5T2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciB0cnlDYXRjaF8xID0gcmVxdWlyZSgnLi4vdXRpbC90cnlDYXRjaCcpO1xudmFyIGlzRnVuY3Rpb25fMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNGdW5jdGlvbicpO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuLi91dGlsL2Vycm9yT2JqZWN0Jyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpcHRpb24nKTtcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5mdW5jdGlvbiBpc05vZGVTdHlsZUV2ZW50RW1pdHRlcihzb3VyY2VPYmopIHtcbiAgICByZXR1cm4gISFzb3VyY2VPYmogJiYgdHlwZW9mIHNvdXJjZU9iai5hZGRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc291cmNlT2JqLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gaXNKUXVlcnlTdHlsZUV2ZW50RW1pdHRlcihzb3VyY2VPYmopIHtcbiAgICByZXR1cm4gISFzb3VyY2VPYmogJiYgdHlwZW9mIHNvdXJjZU9iai5vbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc291cmNlT2JqLm9mZiA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGlzTm9kZUxpc3Qoc291cmNlT2JqKSB7XG4gICAgcmV0dXJuICEhc291cmNlT2JqICYmIHRvU3RyaW5nLmNhbGwoc291cmNlT2JqKSA9PT0gJ1tvYmplY3QgTm9kZUxpc3RdJztcbn1cbmZ1bmN0aW9uIGlzSFRNTENvbGxlY3Rpb24oc291cmNlT2JqKSB7XG4gICAgcmV0dXJuICEhc291cmNlT2JqICYmIHRvU3RyaW5nLmNhbGwoc291cmNlT2JqKSA9PT0gJ1tvYmplY3QgSFRNTENvbGxlY3Rpb25dJztcbn1cbmZ1bmN0aW9uIGlzRXZlbnRUYXJnZXQoc291cmNlT2JqKSB7XG4gICAgcmV0dXJuICEhc291cmNlT2JqICYmIHR5cGVvZiBzb3VyY2VPYmouYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc291cmNlT2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbic7XG59XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEZyb21FdmVudE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGcm9tRXZlbnRPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZyb21FdmVudE9ic2VydmFibGUoc291cmNlT2JqLCBldmVudE5hbWUsIHNlbGVjdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnNvdXJjZU9iaiA9IHNvdXJjZU9iajtcbiAgICAgICAgdGhpcy5ldmVudE5hbWUgPSBldmVudE5hbWU7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBldmVudHMgb2YgYSBzcGVjaWZpYyB0eXBlIGNvbWluZyBmcm9tIHRoZVxuICAgICAqIGdpdmVuIGV2ZW50IHRhcmdldC5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5DcmVhdGVzIGFuIE9ic2VydmFibGUgZnJvbSBET00gZXZlbnRzLCBvciBOb2RlXG4gICAgICogRXZlbnRFbWl0dGVyIGV2ZW50cyBvciBvdGhlcnMuPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy9mcm9tRXZlbnQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gICAgICpcbiAgICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgYnkgYXR0YWNoaW5nIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGFuIFwiZXZlbnQgdGFyZ2V0XCIsXG4gICAgICogd2hpY2ggbWF5IGJlIGFuIG9iamVjdCB3aXRoIGBhZGRFdmVudExpc3RlbmVyYCBhbmQgYHJlbW92ZUV2ZW50TGlzdGVuZXJgLFxuICAgICAqIGEgTm9kZS5qcyBFdmVudEVtaXR0ZXIsIGEgalF1ZXJ5IHN0eWxlIEV2ZW50RW1pdHRlciwgYSBOb2RlTGlzdCBmcm9tIHRoZVxuICAgICAqIERPTSwgb3IgYW4gSFRNTENvbGxlY3Rpb24gZnJvbSB0aGUgRE9NLiBUaGUgZXZlbnQgaGFuZGxlciBpcyBhdHRhY2hlZCB3aGVuXG4gICAgICogdGhlIG91dHB1dCBPYnNlcnZhYmxlIGlzIHN1YnNjcmliZWQsIGFuZCByZW1vdmVkIHdoZW4gdGhlIFN1YnNjcmlwdGlvbiBpc1xuICAgICAqIHVuc3Vic2NyaWJlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXRzIGNsaWNrcyBoYXBwZW5pbmcgb24gdGhlIERPTSBkb2N1bWVudDwvY2FwdGlvbj5cbiAgICAgKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICAgICAqIGNsaWNrcy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiAvLyBSZXN1bHRzIGluOlxuICAgICAqIC8vIE1vdXNlRXZlbnQgb2JqZWN0IGxvZ2dlZCB0byBjb25zb2xlIGV2ZXJ5dGltZSBhIGNsaWNrXG4gICAgICogLy8gb2NjdXJzIG9uIHRoZSBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGZyb219XG4gICAgICogQHNlZSB7QGxpbmsgZnJvbUV2ZW50UGF0dGVybn1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnRUYXJnZXRMaWtlfSB0YXJnZXQgVGhlIERPTUVsZW1lbnQsIGV2ZW50IHRhcmdldCwgTm9kZS5qc1xuICAgICAqIEV2ZW50RW1pdHRlciwgTm9kZUxpc3Qgb3IgSFRNTENvbGxlY3Rpb24gdG8gYXR0YWNoIHRoZSBldmVudCBoYW5kbGVyIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgb2YgaW50ZXJlc3QsIGJlaW5nIGVtaXR0ZWQgYnkgdGhlXG4gICAgICogYHRhcmdldGAuXG4gICAgICogQHBhcmFtIHtFdmVudExpc3RlbmVyT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMgdG8gcGFzcyB0aHJvdWdoIHRvIGFkZEV2ZW50TGlzdGVuZXJcbiAgICAgKiBAcGFyYW0ge1NlbGVjdG9yTWV0aG9kU2lnbmF0dXJlPFQ+fSBbc2VsZWN0b3JdIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvXG4gICAgICogcG9zdC1wcm9jZXNzIHJlc3VsdHMuIEl0IHRha2VzIHRoZSBhcmd1bWVudHMgZnJvbSB0aGUgZXZlbnQgaGFuZGxlciBhbmRcbiAgICAgKiBzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHZhbHVlLlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGU8VD59XG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgZnJvbUV2ZW50XG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBGcm9tRXZlbnRPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50TmFtZSwgb3B0aW9ucywgc2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBzZWxlY3RvciA9IG9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRnJvbUV2ZW50T2JzZXJ2YWJsZSh0YXJnZXQsIGV2ZW50TmFtZSwgc2VsZWN0b3IsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgRnJvbUV2ZW50T2JzZXJ2YWJsZS5zZXR1cFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChzb3VyY2VPYmosIGV2ZW50TmFtZSwgaGFuZGxlciwgc3Vic2NyaWJlciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdW5zdWJzY3JpYmU7XG4gICAgICAgIGlmIChpc05vZGVMaXN0KHNvdXJjZU9iaikgfHwgaXNIVE1MQ29sbGVjdGlvbihzb3VyY2VPYmopKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlT2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgRnJvbUV2ZW50T2JzZXJ2YWJsZS5zZXR1cFN1YnNjcmlwdGlvbihzb3VyY2VPYmpbaV0sIGV2ZW50TmFtZSwgaGFuZGxlciwgc3Vic2NyaWJlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNFdmVudFRhcmdldChzb3VyY2VPYmopKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlXzEgPSBzb3VyY2VPYmo7XG4gICAgICAgICAgICBzb3VyY2VPYmouYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzb3VyY2VfMS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNKUXVlcnlTdHlsZUV2ZW50RW1pdHRlcihzb3VyY2VPYmopKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlXzIgPSBzb3VyY2VPYmo7XG4gICAgICAgICAgICBzb3VyY2VPYmoub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc291cmNlXzIub2ZmKGV2ZW50TmFtZSwgaGFuZGxlcik7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNOb2RlU3R5bGVFdmVudEVtaXR0ZXIoc291cmNlT2JqKSkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZV8zID0gc291cmNlT2JqO1xuICAgICAgICAgICAgc291cmNlT2JqLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNvdXJjZV8zLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGV2ZW50IHRhcmdldCcpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIuYWRkKG5ldyBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24odW5zdWJzY3JpYmUpKTtcbiAgICB9O1xuICAgIEZyb21FdmVudE9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgc291cmNlT2JqID0gdGhpcy5zb3VyY2VPYmo7XG4gICAgICAgIHZhciBldmVudE5hbWUgPSB0aGlzLmV2ZW50TmFtZTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3I7XG4gICAgICAgIHZhciBoYW5kbGVyID0gc2VsZWN0b3IgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2goc2VsZWN0b3IpLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gc3Vic2NyaWJlci5uZXh0KGUpOyB9O1xuICAgICAgICBGcm9tRXZlbnRPYnNlcnZhYmxlLnNldHVwU3Vic2NyaXB0aW9uKHNvdXJjZU9iaiwgZXZlbnROYW1lLCBoYW5kbGVyLCBzdWJzY3JpYmVyLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIHJldHVybiBGcm9tRXZlbnRPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5Gcm9tRXZlbnRPYnNlcnZhYmxlID0gRnJvbUV2ZW50T2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZyb21FdmVudE9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIFNjYWxhck9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTY2FsYXJPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNjYWxhck9ic2VydmFibGUodmFsdWUsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5faXNTY2FsYXIgPSB0cnVlO1xuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1NjYWxhciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIFNjYWxhck9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKHZhbHVlLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTY2FsYXJPYnNlcnZhYmxlKHZhbHVlLCBzY2hlZHVsZXIpO1xuICAgIH07XG4gICAgU2NhbGFyT2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgZG9uZSA9IHN0YXRlLmRvbmUsIHZhbHVlID0gc3RhdGUudmFsdWUsIHN1YnNjcmliZXIgPSBzdGF0ZS5zdWJzY3JpYmVyO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmRvbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlKHN0YXRlKTtcbiAgICB9O1xuICAgIFNjYWxhck9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIGlmIChzY2hlZHVsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoU2NhbGFyT2JzZXJ2YWJsZS5kaXNwYXRjaCwgMCwge1xuICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlLCB2YWx1ZTogdmFsdWUsIHN1YnNjcmliZXI6IHN1YnNjcmliZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTY2FsYXJPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5TY2FsYXJPYnNlcnZhYmxlID0gU2NhbGFyT2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNjYWxhck9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBpc051bWVyaWNfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNOdW1lcmljJyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi9zY2hlZHVsZXIvYXN5bmMnKTtcbnZhciBpc1NjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc1NjaGVkdWxlcicpO1xudmFyIGlzRGF0ZV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0RhdGUnKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgVGltZXJPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZXJPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVyT2JzZXJ2YWJsZShkdWVUaW1lLCBwZXJpb2QsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoZHVlVGltZSA9PT0gdm9pZCAwKSB7IGR1ZVRpbWUgPSAwOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnBlcmlvZCA9IC0xO1xuICAgICAgICB0aGlzLmR1ZVRpbWUgPSAwO1xuICAgICAgICBpZiAoaXNOdW1lcmljXzEuaXNOdW1lcmljKHBlcmlvZCkpIHtcbiAgICAgICAgICAgIHRoaXMucGVyaW9kID0gTnVtYmVyKHBlcmlvZCkgPCAxICYmIDEgfHwgTnVtYmVyKHBlcmlvZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihwZXJpb2QpKSB7XG4gICAgICAgICAgICBzY2hlZHVsZXIgPSBwZXJpb2Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1NjaGVkdWxlcl8xLmlzU2NoZWR1bGVyKHNjaGVkdWxlcikpIHtcbiAgICAgICAgICAgIHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuZHVlVGltZSA9IGlzRGF0ZV8xLmlzRGF0ZShkdWVUaW1lKSA/XG4gICAgICAgICAgICAoK2R1ZVRpbWUgLSB0aGlzLnNjaGVkdWxlci5ub3coKSkgOlxuICAgICAgICAgICAgZHVlVGltZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgc3RhcnRzIGVtaXR0aW5nIGFmdGVyIGFuIGBpbml0aWFsRGVsYXlgIGFuZFxuICAgICAqIGVtaXRzIGV2ZXIgaW5jcmVhc2luZyBudW1iZXJzIGFmdGVyIGVhY2ggYHBlcmlvZGAgb2YgdGltZSB0aGVyZWFmdGVyLlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0cyBsaWtlIHtAbGluayBpbnRlcnZhbH0sIGJ1dCB5b3UgY2FuIHNwZWNpZnkgd2hlblxuICAgICAqIHNob3VsZCB0aGUgZW1pc3Npb25zIHN0YXJ0Ljwvc3Bhbj5cbiAgICAgKlxuICAgICAqIDxpbWcgc3JjPVwiLi9pbWcvdGltZXIucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gICAgICpcbiAgICAgKiBgdGltZXJgIHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGFuIGluZmluaXRlIHNlcXVlbmNlIG9mIGFzY2VuZGluZ1xuICAgICAqIGludGVnZXJzLCB3aXRoIGEgY29uc3RhbnQgaW50ZXJ2YWwgb2YgdGltZSwgYHBlcmlvZGAgb2YgeW91ciBjaG9vc2luZ1xuICAgICAqIGJldHdlZW4gdGhvc2UgZW1pc3Npb25zLiBUaGUgZmlyc3QgZW1pc3Npb24gaGFwcGVucyBhZnRlciB0aGUgc3BlY2lmaWVkXG4gICAgICogYGluaXRpYWxEZWxheWAuIFRoZSBpbml0aWFsIGRlbGF5IG1heSBiZSBhIHtAbGluayBEYXRlfS4gQnkgZGVmYXVsdCwgdGhpc1xuICAgICAqIG9wZXJhdG9yIHVzZXMgdGhlIGBhc3luY2AgSVNjaGVkdWxlciB0byBwcm92aWRlIGEgbm90aW9uIG9mIHRpbWUsIGJ1dCB5b3VcbiAgICAgKiBtYXkgcGFzcyBhbnkgSVNjaGVkdWxlciB0byBpdC4gSWYgYHBlcmlvZGAgaXMgbm90IHNwZWNpZmllZCwgdGhlIG91dHB1dFxuICAgICAqIE9ic2VydmFibGUgZW1pdHMgb25seSBvbmUgdmFsdWUsIGAwYC4gT3RoZXJ3aXNlLCBpdCBlbWl0cyBhbiBpbmZpbml0ZVxuICAgICAqIHNlcXVlbmNlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdHMgYXNjZW5kaW5nIG51bWJlcnMsIG9uZSBldmVyeSBzZWNvbmQgKDEwMDBtcyksIHN0YXJ0aW5nIGFmdGVyIDMgc2Vjb25kczwvY2FwdGlvbj5cbiAgICAgKiB2YXIgbnVtYmVycyA9IFJ4Lk9ic2VydmFibGUudGltZXIoMzAwMCwgMTAwMCk7XG4gICAgICogbnVtYmVycy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0cyBvbmUgbnVtYmVyIGFmdGVyIGZpdmUgc2Vjb25kczwvY2FwdGlvbj5cbiAgICAgKiB2YXIgbnVtYmVycyA9IFJ4Lk9ic2VydmFibGUudGltZXIoNTAwMCk7XG4gICAgICogbnVtYmVycy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBpbnRlcnZhbH1cbiAgICAgKiBAc2VlIHtAbGluayBkZWxheX1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfERhdGV9IGluaXRpYWxEZWxheSBUaGUgaW5pdGlhbCBkZWxheSB0aW1lIHRvIHdhaXQgYmVmb3JlXG4gICAgICogZW1pdHRpbmcgdGhlIGZpcnN0IHZhbHVlIG9mIGAwYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BlcmlvZF0gVGhlIHBlcmlvZCBvZiB0aW1lIGJldHdlZW4gZW1pc3Npb25zIG9mIHRoZVxuICAgICAqIHN1YnNlcXVlbnQgbnVtYmVycy5cbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1hc3luY10gVGhlIElTY2hlZHVsZXIgdG8gdXNlIGZvciBzY2hlZHVsaW5nXG4gICAgICogdGhlIGVtaXNzaW9uIG9mIHZhbHVlcywgYW5kIHByb3ZpZGluZyBhIG5vdGlvbiBvZiBcInRpbWVcIi5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYSBgMGAgYWZ0ZXIgdGhlXG4gICAgICogYGluaXRpYWxEZWxheWAgYW5kIGV2ZXIgaW5jcmVhc2luZyBudW1iZXJzIGFmdGVyIGVhY2ggYHBlcmlvZGAgb2YgdGltZVxuICAgICAqIHRoZXJlYWZ0ZXIuXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgdGltZXJcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIFRpbWVyT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoaW5pdGlhbERlbGF5LCBwZXJpb2QsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoaW5pdGlhbERlbGF5ID09PSB2b2lkIDApIHsgaW5pdGlhbERlbGF5ID0gMDsgfVxuICAgICAgICByZXR1cm4gbmV3IFRpbWVyT2JzZXJ2YWJsZShpbml0aWFsRGVsYXksIHBlcmlvZCwgc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIFRpbWVyT2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleCwgcGVyaW9kID0gc3RhdGUucGVyaW9kLCBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlcjtcbiAgICAgICAgdmFyIGFjdGlvbiA9IHRoaXM7XG4gICAgICAgIHN1YnNjcmliZXIubmV4dChpbmRleCk7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBlcmlvZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuaW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgIGFjdGlvbi5zY2hlZHVsZShzdGF0ZSwgcGVyaW9kKTtcbiAgICB9O1xuICAgIFRpbWVyT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHBlcmlvZCA9IF9hLnBlcmlvZCwgZHVlVGltZSA9IF9hLmR1ZVRpbWUsIHNjaGVkdWxlciA9IF9hLnNjaGVkdWxlcjtcbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShUaW1lck9ic2VydmFibGUuZGlzcGF0Y2gsIGR1ZVRpbWUsIHtcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCwgcGVyaW9kOiBwZXJpb2QsIHN1YnNjcmliZXI6IHN1YnNjcmliZXJcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZXJPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5UaW1lck9ic2VydmFibGUgPSBUaW1lck9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaW1lck9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRW1wdHlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0VtcHR5T2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5lbXB0eSA9IEVtcHR5T2JzZXJ2YWJsZV8xLkVtcHR5T2JzZXJ2YWJsZS5jcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbXB0eS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBGcm9tRXZlbnRPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0Zyb21FdmVudE9ic2VydmFibGUnKTtcbmV4cG9ydHMuZnJvbUV2ZW50ID0gRnJvbUV2ZW50T2JzZXJ2YWJsZV8xLkZyb21FdmVudE9ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJvbUV2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIFRpbWVyT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9UaW1lck9ic2VydmFibGUnKTtcbmV4cG9ydHMudGltZXIgPSBUaW1lck9ic2VydmFibGVfMS5UaW1lck9ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIENhdGNoZXMgZXJyb3JzIG9uIHRoZSBvYnNlcnZhYmxlIHRvIGJlIGhhbmRsZWQgYnkgcmV0dXJuaW5nIGEgbmV3IG9ic2VydmFibGUgb3IgdGhyb3dpbmcgYW4gZXJyb3IuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9jYXRjaC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db250aW51ZXMgd2l0aCBhIGRpZmZlcmVudCBPYnNlcnZhYmxlIHdoZW4gdGhlcmUncyBhbiBlcnJvcjwvY2FwdGlvbj5cbiAqXG4gKiBPYnNlcnZhYmxlLm9mKDEsIDIsIDMsIDQsIDUpXG4gKiAgIC5tYXAobiA9PiB7XG4gKiBcdCAgIGlmIChuID09IDQpIHtcbiAqIFx0ICAgICB0aHJvdyAnZm91ciEnO1xuICogICAgIH1cbiAqXHQgICByZXR1cm4gbjtcbiAqICAgfSlcbiAqICAgLmNhdGNoKGVyciA9PiBPYnNlcnZhYmxlLm9mKCdJJywgJ0lJJywgJ0lJSScsICdJVicsICdWJykpXG4gKiAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKiAgIC8vIDEsIDIsIDMsIEksIElJLCBJSUksIElWLCBWXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UmV0cmllcyB0aGUgY2F1Z2h0IHNvdXJjZSBPYnNlcnZhYmxlIGFnYWluIGluIGNhc2Ugb2YgZXJyb3IsIHNpbWlsYXIgdG8gcmV0cnkoKSBvcGVyYXRvcjwvY2FwdGlvbj5cbiAqXG4gKiBPYnNlcnZhYmxlLm9mKDEsIDIsIDMsIDQsIDUpXG4gKiAgIC5tYXAobiA9PiB7XG4gKiBcdCAgIGlmIChuID09PSA0KSB7XG4gKiBcdCAgICAgdGhyb3cgJ2ZvdXIhJztcbiAqICAgICB9XG4gKiBcdCAgIHJldHVybiBuO1xuICogICB9KVxuICogICAuY2F0Y2goKGVyciwgY2F1Z2h0KSA9PiBjYXVnaHQpXG4gKiAgIC50YWtlKDMwKVxuICogICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICogICAvLyAxLCAyLCAzLCAxLCAyLCAzLCAuLi5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5UaHJvd3MgYSBuZXcgZXJyb3Igd2hlbiB0aGUgc291cmNlIE9ic2VydmFibGUgdGhyb3dzIGFuIGVycm9yPC9jYXB0aW9uPlxuICpcbiAqIE9ic2VydmFibGUub2YoMSwgMiwgMywgNCwgNSlcbiAqICAgLm1hcChuID0+IHtcbiAqICAgICBpZiAobiA9PSA0KSB7XG4gKiAgICAgICB0aHJvdyAnZm91ciEnO1xuICogICAgIH1cbiAqICAgICByZXR1cm4gbjtcbiAqICAgfSlcbiAqICAgLmNhdGNoKGVyciA9PiB7XG4gKiAgICAgdGhyb3cgJ2Vycm9yIGluIHNvdXJjZS4gRGV0YWlsczogJyArIGVycjtcbiAqICAgfSlcbiAqICAgLnN1YnNjcmliZShcbiAqICAgICB4ID0+IGNvbnNvbGUubG9nKHgpLFxuICogICAgIGVyciA9PiBjb25zb2xlLmxvZyhlcnIpXG4gKiAgICk7XG4gKiAgIC8vIDEsIDIsIDMsIGVycm9yIGluIHNvdXJjZS4gRGV0YWlsczogZm91ciFcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzZWxlY3RvciBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYXMgYXJndW1lbnRzIGBlcnJgLCB3aGljaCBpcyB0aGUgZXJyb3IsIGFuZCBgY2F1Z2h0YCwgd2hpY2hcbiAqICBpcyB0aGUgc291cmNlIG9ic2VydmFibGUsIGluIGNhc2UgeW91J2QgbGlrZSB0byBcInJldHJ5XCIgdGhhdCBvYnNlcnZhYmxlIGJ5IHJldHVybmluZyBpdCBhZ2Fpbi4gV2hhdGV2ZXIgb2JzZXJ2YWJsZVxuICogIGlzIHJldHVybmVkIGJ5IHRoZSBgc2VsZWN0b3JgIHdpbGwgYmUgdXNlZCB0byBjb250aW51ZSB0aGUgb2JzZXJ2YWJsZSBjaGFpbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgdGhhdCBvcmlnaW5hdGVzIGZyb20gZWl0aGVyIHRoZSBzb3VyY2Ugb3IgdGhlIG9ic2VydmFibGUgcmV0dXJuZWQgYnkgdGhlXG4gKiAgY2F0Y2ggYHNlbGVjdG9yYCBmdW5jdGlvbi5cbiAqIEBtZXRob2QgY2F0Y2hcbiAqIEBuYW1lIGNhdGNoXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBfY2F0Y2goc2VsZWN0b3IpIHtcbiAgICB2YXIgb3BlcmF0b3IgPSBuZXcgQ2F0Y2hPcGVyYXRvcihzZWxlY3Rvcik7XG4gICAgdmFyIGNhdWdodCA9IHRoaXMubGlmdChvcGVyYXRvcik7XG4gICAgcmV0dXJuIChvcGVyYXRvci5jYXVnaHQgPSBjYXVnaHQpO1xufVxuZXhwb3J0cy5fY2F0Y2ggPSBfY2F0Y2g7XG52YXIgQ2F0Y2hPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2F0Y2hPcGVyYXRvcihzZWxlY3Rvcikge1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgfVxuICAgIENhdGNoT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBDYXRjaFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5zZWxlY3RvciwgdGhpcy5jYXVnaHQpKTtcbiAgICB9O1xuICAgIHJldHVybiBDYXRjaE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgQ2F0Y2hTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2F0Y2hTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhdGNoU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgc2VsZWN0b3IsIGNhdWdodCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5jYXVnaHQgPSBjYXVnaHQ7XG4gICAgfVxuICAgIC8vIE5PVEU6IG92ZXJyaWRpbmcgYGVycm9yYCBpbnN0ZWFkIG9mIGBfZXJyb3JgIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudFxuICAgIC8vIHRvIGhhdmUgdGhpcyBmbGFnIHRoaXMgc3Vic2NyaWJlciBhcyBgaXNTdG9wcGVkYC4gV2UgY2FuIG1pbWljIHRoZVxuICAgIC8vIGJlaGF2aW9yIG9mIHRoZSBSZXRyeVN1YnNjcmliZXIgKGZyb20gdGhlIGByZXRyeWAgb3BlcmF0b3IpLCB3aGVyZVxuICAgIC8vIHdlIHVuc3Vic2NyaWJlIGZyb20gb3VyIHNvdXJjZSBjaGFpbiwgcmVzZXQgb3VyIFN1YnNjcmliZXIgZmxhZ3MsXG4gICAgLy8gdGhlbiBzdWJzY3JpYmUgdG8gdGhlIHNlbGVjdG9yIHJlc3VsdC5cbiAgICBDYXRjaFN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnNlbGVjdG9yKGVyciwgdGhpcy5jYXVnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycjIpIHtcbiAgICAgICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmVycm9yLmNhbGwodGhpcywgZXJyMik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVBbmRSZWN5Y2xlKCk7XG4gICAgICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHJlc3VsdCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2F0Y2hTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhdGNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBpc1NjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc1NjaGVkdWxlcicpO1xudmFyIEFycmF5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9BcnJheU9ic2VydmFibGUnKTtcbnZhciBtZXJnZUFsbF8xID0gcmVxdWlyZSgnLi9tZXJnZUFsbCcpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQ3JlYXRlcyBhbiBvdXRwdXQgT2JzZXJ2YWJsZSB3aGljaCBzZXF1ZW50aWFsbHkgZW1pdHMgYWxsIHZhbHVlcyBmcm9tIGV2ZXJ5XG4gKiBnaXZlbiBpbnB1dCBPYnNlcnZhYmxlIGFmdGVyIHRoZSBjdXJyZW50IE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNvbmNhdGVuYXRlcyBtdWx0aXBsZSBPYnNlcnZhYmxlcyB0b2dldGhlciBieVxuICogc2VxdWVudGlhbGx5IGVtaXR0aW5nIHRoZWlyIHZhbHVlcywgb25lIE9ic2VydmFibGUgYWZ0ZXIgdGhlIG90aGVyLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2NvbmNhdC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBKb2lucyB0aGlzIE9ic2VydmFibGUgd2l0aCBtdWx0aXBsZSBvdGhlciBPYnNlcnZhYmxlcyBieSBzdWJzY3JpYmluZyB0byB0aGVtXG4gKiBvbmUgYXQgYSB0aW1lLCBzdGFydGluZyB3aXRoIHRoZSBzb3VyY2UsIGFuZCBtZXJnaW5nIHRoZWlyIHJlc3VsdHMgaW50byB0aGVcbiAqIG91dHB1dCBPYnNlcnZhYmxlLiBXaWxsIHdhaXQgZm9yIGVhY2ggT2JzZXJ2YWJsZSB0byBjb21wbGV0ZSBiZWZvcmUgbW92aW5nXG4gKiBvbiB0byB0aGUgbmV4dC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db25jYXRlbmF0ZSBhIHRpbWVyIGNvdW50aW5nIGZyb20gMCB0byAzIHdpdGggYSBzeW5jaHJvbm91cyBzZXF1ZW5jZSBmcm9tIDEgdG8gMTA8L2NhcHRpb24+XG4gKiB2YXIgdGltZXIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLnRha2UoNCk7XG4gKiB2YXIgc2VxdWVuY2UgPSBSeC5PYnNlcnZhYmxlLnJhbmdlKDEsIDEwKTtcbiAqIHZhciByZXN1bHQgPSB0aW1lci5jb25jYXQoc2VxdWVuY2UpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyByZXN1bHRzIGluOlxuICogLy8gMTAwMG1zLT4gMCAtMTAwMG1zLT4gMSAtMTAwMG1zLT4gMiAtMTAwMG1zLT4gMyAtaW1tZWRpYXRlLT4gMSAuLi4gMTBcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db25jYXRlbmF0ZSAzIE9ic2VydmFibGVzPC9jYXB0aW9uPlxuICogdmFyIHRpbWVyMSA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSgxMCk7XG4gKiB2YXIgdGltZXIyID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgyMDAwKS50YWtlKDYpO1xuICogdmFyIHRpbWVyMyA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoNTAwKS50YWtlKDEwKTtcbiAqIHZhciByZXN1bHQgPSB0aW1lcjEuY29uY2F0KHRpbWVyMiwgdGltZXIzKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gcmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICogLy8gKFByaW50cyB0byBjb25zb2xlIHNlcXVlbnRpYWxseSlcbiAqIC8vIC0xMDAwbXMtPiAwIC0xMDAwbXMtPiAxIC0xMDAwbXMtPiAuLi4gOVxuICogLy8gLTIwMDBtcy0+IDAgLTIwMDBtcy0+IDEgLTIwMDBtcy0+IC4uLiA1XG4gKiAvLyAtNTAwbXMtPiAwIC01MDBtcy0+IDEgLTUwMG1zLT4gLi4uIDlcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXRBbGx9XG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXB9XG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXBUb31cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGVJbnB1dH0gb3RoZXIgQW4gaW5wdXQgT2JzZXJ2YWJsZSB0byBjb25jYXRlbmF0ZSBhZnRlciB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBNb3JlIHRoYW4gb25lIGlucHV0IE9ic2VydmFibGVzIG1heSBiZSBnaXZlbiBhcyBhcmd1bWVudC5cbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyPW51bGxdIEFuIG9wdGlvbmFsIElTY2hlZHVsZXIgdG8gc2NoZWR1bGUgZWFjaFxuICogT2JzZXJ2YWJsZSBzdWJzY3JpcHRpb24gb24uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbGwgdmFsdWVzIG9mIGVhY2ggcGFzc2VkIE9ic2VydmFibGUgbWVyZ2VkIGludG8gYVxuICogc2luZ2xlIE9ic2VydmFibGUsIGluIG9yZGVyLCBpbiBzZXJpYWwgZmFzaGlvbi5cbiAqIEBtZXRob2QgY29uY2F0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBjb25jYXQoKSB7XG4gICAgdmFyIG9ic2VydmFibGVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb2JzZXJ2YWJsZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxpZnQuY2FsbChjb25jYXRTdGF0aWMuYXBwbHkodm9pZCAwLCBbdGhpc10uY29uY2F0KG9ic2VydmFibGVzKSkpO1xufVxuZXhwb3J0cy5jb25jYXQgPSBjb25jYXQ7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBDcmVhdGVzIGFuIG91dHB1dCBPYnNlcnZhYmxlIHdoaWNoIHNlcXVlbnRpYWxseSBlbWl0cyBhbGwgdmFsdWVzIGZyb20gZ2l2ZW5cbiAqIE9ic2VydmFibGUgYW5kIHRoZW4gbW92ZXMgb24gdG8gdGhlIG5leHQuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNvbmNhdGVuYXRlcyBtdWx0aXBsZSBPYnNlcnZhYmxlcyB0b2dldGhlciBieVxuICogc2VxdWVudGlhbGx5IGVtaXR0aW5nIHRoZWlyIHZhbHVlcywgb25lIE9ic2VydmFibGUgYWZ0ZXIgdGhlIG90aGVyLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2NvbmNhdC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgY29uY2F0YCBqb2lucyBtdWx0aXBsZSBPYnNlcnZhYmxlcyB0b2dldGhlciwgYnkgc3Vic2NyaWJpbmcgdG8gdGhlbSBvbmUgYXQgYSB0aW1lIGFuZFxuICogbWVyZ2luZyB0aGVpciByZXN1bHRzIGludG8gdGhlIG91dHB1dCBPYnNlcnZhYmxlLiBZb3UgY2FuIHBhc3MgZWl0aGVyIGFuIGFycmF5IG9mXG4gKiBPYnNlcnZhYmxlcywgb3IgcHV0IHRoZW0gZGlyZWN0bHkgYXMgYXJndW1lbnRzLiBQYXNzaW5nIGFuIGVtcHR5IGFycmF5IHdpbGwgcmVzdWx0XG4gKiBpbiBPYnNlcnZhYmxlIHRoYXQgY29tcGxldGVzIGltbWVkaWF0ZWx5LlxuICpcbiAqIGBjb25jYXRgIHdpbGwgc3Vic2NyaWJlIHRvIGZpcnN0IGlucHV0IE9ic2VydmFibGUgYW5kIGVtaXQgYWxsIGl0cyB2YWx1ZXMsIHdpdGhvdXRcbiAqIGNoYW5naW5nIG9yIGFmZmVjdGluZyB0aGVtIGluIGFueSB3YXkuIFdoZW4gdGhhdCBPYnNlcnZhYmxlIGNvbXBsZXRlcywgaXQgd2lsbFxuICogc3Vic2NyaWJlIHRvIHRoZW4gbmV4dCBPYnNlcnZhYmxlIHBhc3NlZCBhbmQsIGFnYWluLCBlbWl0IGl0cyB2YWx1ZXMuIFRoaXMgd2lsbCBiZVxuICogcmVwZWF0ZWQsIHVudGlsIHRoZSBvcGVyYXRvciBydW5zIG91dCBvZiBPYnNlcnZhYmxlcy4gV2hlbiBsYXN0IGlucHV0IE9ic2VydmFibGUgY29tcGxldGVzLFxuICogYGNvbmNhdGAgd2lsbCBjb21wbGV0ZSBhcyB3ZWxsLiBBdCBhbnkgZ2l2ZW4gbW9tZW50IG9ubHkgb25lIE9ic2VydmFibGUgcGFzc2VkIHRvIG9wZXJhdG9yXG4gKiBlbWl0cyB2YWx1ZXMuIElmIHlvdSB3b3VsZCBsaWtlIHRvIGVtaXQgdmFsdWVzIGZyb20gcGFzc2VkIE9ic2VydmFibGVzIGNvbmN1cnJlbnRseSwgY2hlY2sgb3V0XG4gKiB7QGxpbmsgbWVyZ2V9IGluc3RlYWQsIGVzcGVjaWFsbHkgd2l0aCBvcHRpb25hbCBgY29uY3VycmVudGAgcGFyYW1ldGVyLiBBcyBhIG1hdHRlciBvZiBmYWN0LFxuICogYGNvbmNhdGAgaXMgYW4gZXF1aXZhbGVudCBvZiBgbWVyZ2VgIG9wZXJhdG9yIHdpdGggYGNvbmN1cnJlbnRgIHBhcmFtZXRlciBzZXQgdG8gYDFgLlxuICpcbiAqIE5vdGUgdGhhdCBpZiBzb21lIGlucHV0IE9ic2VydmFibGUgbmV2ZXIgY29tcGxldGVzLCBgY29uY2F0YCB3aWxsIGFsc28gbmV2ZXIgY29tcGxldGVcbiAqIGFuZCBPYnNlcnZhYmxlcyBmb2xsb3dpbmcgdGhlIG9uZSB0aGF0IGRpZCBub3QgY29tcGxldGUgd2lsbCBuZXZlciBiZSBzdWJzY3JpYmVkLiBPbiB0aGUgb3RoZXJcbiAqIGhhbmQsIGlmIHNvbWUgT2JzZXJ2YWJsZSBzaW1wbHkgY29tcGxldGVzIGltbWVkaWF0ZWx5IGFmdGVyIGl0IGlzIHN1YnNjcmliZWQsIGl0IHdpbGwgYmVcbiAqIGludmlzaWJsZSBmb3IgYGNvbmNhdGAsIHdoaWNoIHdpbGwganVzdCBtb3ZlIG9uIHRvIHRoZSBuZXh0IE9ic2VydmFibGUuXG4gKlxuICogSWYgYW55IE9ic2VydmFibGUgaW4gY2hhaW4gZXJyb3JzLCBpbnN0ZWFkIG9mIHBhc3NpbmcgY29udHJvbCB0byB0aGUgbmV4dCBPYnNlcnZhYmxlLFxuICogYGNvbmNhdGAgd2lsbCBlcnJvciBpbW1lZGlhdGVseSBhcyB3ZWxsLiBPYnNlcnZhYmxlcyB0aGF0IHdvdWxkIGJlIHN1YnNjcmliZWQgYWZ0ZXJcbiAqIHRoZSBvbmUgdGhhdCBlbWl0dGVkIGVycm9yLCBuZXZlciB3aWxsLlxuICpcbiAqIElmIHlvdSBwYXNzIHRvIGBjb25jYXRgIHRoZSBzYW1lIE9ic2VydmFibGUgbWFueSB0aW1lcywgaXRzIHN0cmVhbSBvZiB2YWx1ZXNcbiAqIHdpbGwgYmUgXCJyZXBsYXllZFwiIG9uIGV2ZXJ5IHN1YnNjcmlwdGlvbiwgd2hpY2ggbWVhbnMgeW91IGNhbiByZXBlYXQgZ2l2ZW4gT2JzZXJ2YWJsZVxuICogYXMgbWFueSB0aW1lcyBhcyB5b3UgbGlrZS4gSWYgcGFzc2luZyB0aGUgc2FtZSBPYnNlcnZhYmxlIHRvIGBjb25jYXRgIDEwMDAgdGltZXMgYmVjb21lcyB0ZWRpb3VzLFxuICogeW91IGNhbiBhbHdheXMgdXNlIHtAbGluayByZXBlYXR9LlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbmNhdGVuYXRlIGEgdGltZXIgY291bnRpbmcgZnJvbSAwIHRvIDMgd2l0aCBhIHN5bmNocm9ub3VzIHNlcXVlbmNlIGZyb20gMSB0byAxMDwvY2FwdGlvbj5cbiAqIHZhciB0aW1lciA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSg0KTtcbiAqIHZhciBzZXF1ZW5jZSA9IFJ4Lk9ic2VydmFibGUucmFuZ2UoMSwgMTApO1xuICogdmFyIHJlc3VsdCA9IFJ4Lk9ic2VydmFibGUuY29uY2F0KHRpbWVyLCBzZXF1ZW5jZSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIHJlc3VsdHMgaW46XG4gKiAvLyAwIC0xMDAwbXMtPiAxIC0xMDAwbXMtPiAyIC0xMDAwbXMtPiAzIC1pbW1lZGlhdGUtPiAxIC4uLiAxMFxuICpcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db25jYXRlbmF0ZSBhbiBhcnJheSBvZiAzIE9ic2VydmFibGVzPC9jYXB0aW9uPlxuICogdmFyIHRpbWVyMSA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSgxMCk7XG4gKiB2YXIgdGltZXIyID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgyMDAwKS50YWtlKDYpO1xuICogdmFyIHRpbWVyMyA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoNTAwKS50YWtlKDEwKTtcbiAqIHZhciByZXN1bHQgPSBSeC5PYnNlcnZhYmxlLmNvbmNhdChbdGltZXIxLCB0aW1lcjIsIHRpbWVyM10pOyAvLyBub3RlIHRoYXQgYXJyYXkgaXMgcGFzc2VkXG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIHJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZzpcbiAqIC8vIChQcmludHMgdG8gY29uc29sZSBzZXF1ZW50aWFsbHkpXG4gKiAvLyAtMTAwMG1zLT4gMCAtMTAwMG1zLT4gMSAtMTAwMG1zLT4gLi4uIDlcbiAqIC8vIC0yMDAwbXMtPiAwIC0yMDAwbXMtPiAxIC0yMDAwbXMtPiAuLi4gNVxuICogLy8gLTUwMG1zLT4gMCAtNTAwbXMtPiAxIC01MDBtcy0+IC4uLiA5XG4gKlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbmNhdGVuYXRlIHRoZSBzYW1lIE9ic2VydmFibGUgdG8gcmVwZWF0IGl0PC9jYXB0aW9uPlxuICogY29uc3QgdGltZXIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLnRha2UoMik7XG4gKlxuICogUnguT2JzZXJ2YWJsZS5jb25jYXQodGltZXIsIHRpbWVyKSAvLyBjb25jYXRpbmcgdGhlIHNhbWUgT2JzZXJ2YWJsZSFcbiAqIC5zdWJzY3JpYmUoXG4gKiAgIHZhbHVlID0+IGNvbnNvbGUubG9nKHZhbHVlKSxcbiAqICAgZXJyID0+IHt9LFxuICogICAoKSA9PiBjb25zb2xlLmxvZygnLi4uYW5kIGl0IGlzIGRvbmUhJylcbiAqICk7XG4gKlxuICogLy8gTG9nczpcbiAqIC8vIDAgYWZ0ZXIgMXNcbiAqIC8vIDEgYWZ0ZXIgMnNcbiAqIC8vIDAgYWZ0ZXIgM3NcbiAqIC8vIDEgYWZ0ZXIgNHNcbiAqIC8vIFwiLi4uYW5kIGl0IGlzIGRvbmUhXCIgYWxzbyBhZnRlciA0c1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdEFsbH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcFRvfVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZUlucHV0fSBpbnB1dDEgQW4gaW5wdXQgT2JzZXJ2YWJsZSB0byBjb25jYXRlbmF0ZSB3aXRoIG90aGVycy5cbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZUlucHV0fSBpbnB1dDIgQW4gaW5wdXQgT2JzZXJ2YWJsZSB0byBjb25jYXRlbmF0ZSB3aXRoIG90aGVycy5cbiAqIE1vcmUgdGhhbiBvbmUgaW5wdXQgT2JzZXJ2YWJsZXMgbWF5IGJlIGdpdmVuIGFzIGFyZ3VtZW50LlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9bnVsbF0gQW4gb3B0aW9uYWwgSVNjaGVkdWxlciB0byBzY2hlZHVsZSBlYWNoXG4gKiBPYnNlcnZhYmxlIHN1YnNjcmlwdGlvbiBvbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFsbCB2YWx1ZXMgb2YgZWFjaCBwYXNzZWQgT2JzZXJ2YWJsZSBtZXJnZWQgaW50byBhXG4gKiBzaW5nbGUgT2JzZXJ2YWJsZSwgaW4gb3JkZXIsIGluIHNlcmlhbCBmYXNoaW9uLlxuICogQHN0YXRpYyB0cnVlXG4gKiBAbmFtZSBjb25jYXRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdFN0YXRpYygpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYnNlcnZhYmxlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIHNjaGVkdWxlciA9IG51bGw7XG4gICAgdmFyIGFyZ3MgPSBvYnNlcnZhYmxlcztcbiAgICBpZiAoaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihhcmdzW29ic2VydmFibGVzLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICBzY2hlZHVsZXIgPSBhcmdzLnBvcCgpO1xuICAgIH1cbiAgICBpZiAoc2NoZWR1bGVyID09PSBudWxsICYmIG9ic2VydmFibGVzLmxlbmd0aCA9PT0gMSAmJiBvYnNlcnZhYmxlc1swXSBpbnN0YW5jZW9mIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSB7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcnJheU9ic2VydmFibGVfMS5BcnJheU9ic2VydmFibGUob2JzZXJ2YWJsZXMsIHNjaGVkdWxlcikubGlmdChuZXcgbWVyZ2VBbGxfMS5NZXJnZUFsbE9wZXJhdG9yKDEpKTtcbn1cbmV4cG9ydHMuY29uY2F0U3RhdGljID0gY29uY2F0U3RhdGljO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi9zY2hlZHVsZXIvYXN5bmMnKTtcbi8qKlxuICogRW1pdHMgYSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBvbmx5IGFmdGVyIGEgcGFydGljdWxhciB0aW1lIHNwYW5cbiAqIGhhcyBwYXNzZWQgd2l0aG91dCBhbm90aGVyIHNvdXJjZSBlbWlzc2lvbi5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBkZWxheX0sIGJ1dCBwYXNzZXMgb25seSB0aGUgbW9zdFxuICogcmVjZW50IHZhbHVlIGZyb20gZWFjaCBidXJzdCBvZiBlbWlzc2lvbnMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZGVib3VuY2VUaW1lLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBkZWJvdW5jZVRpbWVgIGRlbGF5cyB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIGJ1dCBkcm9wc1xuICogcHJldmlvdXMgcGVuZGluZyBkZWxheWVkIGVtaXNzaW9ucyBpZiBhIG5ldyB2YWx1ZSBhcnJpdmVzIG9uIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIFRoaXMgb3BlcmF0b3Iga2VlcHMgdHJhY2sgb2YgdGhlIG1vc3QgcmVjZW50IHZhbHVlIGZyb20gdGhlXG4gKiBzb3VyY2UgT2JzZXJ2YWJsZSwgYW5kIGVtaXRzIHRoYXQgb25seSB3aGVuIGBkdWVUaW1lYCBlbm91Z2ggdGltZSBoYXMgcGFzc2VkXG4gKiB3aXRob3V0IGFueSBvdGhlciB2YWx1ZSBhcHBlYXJpbmcgb24gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBJZiBhIG5ldyB2YWx1ZVxuICogYXBwZWFycyBiZWZvcmUgYGR1ZVRpbWVgIHNpbGVuY2Ugb2NjdXJzLCB0aGUgcHJldmlvdXMgdmFsdWUgd2lsbCBiZSBkcm9wcGVkXG4gKiBhbmQgd2lsbCBub3QgYmUgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogVGhpcyBpcyBhIHJhdGUtbGltaXRpbmcgb3BlcmF0b3IsIGJlY2F1c2UgaXQgaXMgaW1wb3NzaWJsZSBmb3IgbW9yZSB0aGFuIG9uZVxuICogdmFsdWUgdG8gYmUgZW1pdHRlZCBpbiBhbnkgdGltZSB3aW5kb3cgb2YgZHVyYXRpb24gYGR1ZVRpbWVgLCBidXQgaXQgaXMgYWxzb1xuICogYSBkZWxheS1saWtlIG9wZXJhdG9yIHNpbmNlIG91dHB1dCBlbWlzc2lvbnMgZG8gbm90IG9jY3VyIGF0IHRoZSBzYW1lIHRpbWUgYXNcbiAqIHRoZXkgZGlkIG9uIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gT3B0aW9uYWxseSB0YWtlcyBhIHtAbGluayBJU2NoZWR1bGVyfSBmb3JcbiAqIG1hbmFnaW5nIHRpbWVycy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IHRoZSBtb3N0IHJlY2VudCBjbGljayBhZnRlciBhIGJ1cnN0IG9mIGNsaWNrczwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLmRlYm91bmNlVGltZSgxMDAwKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgYXVkaXRUaW1lfVxuICogQHNlZSB7QGxpbmsgZGVib3VuY2V9XG4gKiBAc2VlIHtAbGluayBkZWxheX1cbiAqIEBzZWUge0BsaW5rIHNhbXBsZVRpbWV9XG4gKiBAc2VlIHtAbGluayB0aHJvdHRsZVRpbWV9XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGR1ZVRpbWUgVGhlIHRpbWVvdXQgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIChvciB0aGUgdGltZVxuICogdW5pdCBkZXRlcm1pbmVkIGludGVybmFsbHkgYnkgdGhlIG9wdGlvbmFsIGBzY2hlZHVsZXJgKSBmb3IgdGhlIHdpbmRvdyBvZlxuICogdGltZSByZXF1aXJlZCB0byB3YWl0IGZvciBlbWlzc2lvbiBzaWxlbmNlIGJlZm9yZSBlbWl0dGluZyB0aGUgbW9zdCByZWNlbnRcbiAqIHNvdXJjZSB2YWx1ZS5cbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyPWFzeW5jXSBUaGUge0BsaW5rIElTY2hlZHVsZXJ9IHRvIHVzZSBmb3JcbiAqIG1hbmFnaW5nIHRoZSB0aW1lcnMgdGhhdCBoYW5kbGUgdGhlIHRpbWVvdXQgZm9yIGVhY2ggdmFsdWUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZGVsYXlzIHRoZSBlbWlzc2lvbnMgb2YgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBieSB0aGUgc3BlY2lmaWVkIGBkdWVUaW1lYCwgYW5kIG1heSBkcm9wIHNvbWUgdmFsdWVzIGlmIHRoZXkgb2NjdXJcbiAqIHRvbyBmcmVxdWVudGx5LlxuICogQG1ldGhvZCBkZWJvdW5jZVRpbWVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlVGltZShkdWVUaW1lLCBzY2hlZHVsZXIpIHtcbiAgICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHsgc2NoZWR1bGVyID0gYXN5bmNfMS5hc3luYzsgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IERlYm91bmNlVGltZU9wZXJhdG9yKGR1ZVRpbWUsIHNjaGVkdWxlcikpO1xufVxuZXhwb3J0cy5kZWJvdW5jZVRpbWUgPSBkZWJvdW5jZVRpbWU7XG52YXIgRGVib3VuY2VUaW1lT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlYm91bmNlVGltZU9wZXJhdG9yKGR1ZVRpbWUsIHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLmR1ZVRpbWUgPSBkdWVUaW1lO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgRGVib3VuY2VUaW1lT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuZHVlVGltZSwgdGhpcy5zY2hlZHVsZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWJvdW5jZVRpbWVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIERlYm91bmNlVGltZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWJvdW5jZVRpbWVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlYm91bmNlVGltZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGR1ZVRpbWUsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZHVlVGltZSA9IGR1ZVRpbWU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmRlYm91bmNlZFN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdFZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmNsZWFyRGVib3VuY2UoKTtcbiAgICAgICAgdGhpcy5sYXN0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuYWRkKHRoaXMuZGVib3VuY2VkU3Vic2NyaXB0aW9uID0gdGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hOZXh0LCB0aGlzLmR1ZVRpbWUsIHRoaXMpKTtcbiAgICB9O1xuICAgIERlYm91bmNlVGltZVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZWJvdW5jZWROZXh0KCk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIERlYm91bmNlVGltZVN1YnNjcmliZXIucHJvdG90eXBlLmRlYm91bmNlZE5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJEZWJvdW5jZSgpO1xuICAgICAgICBpZiAodGhpcy5oYXNWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHRoaXMubGFzdFZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMubGFzdFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVib3VuY2VUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuY2xlYXJEZWJvdW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlYm91bmNlZFN1YnNjcmlwdGlvbiA9IHRoaXMuZGVib3VuY2VkU3Vic2NyaXB0aW9uO1xuICAgICAgICBpZiAoZGVib3VuY2VkU3Vic2NyaXB0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShkZWJvdW5jZWRTdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgZGVib3VuY2VkU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLmRlYm91bmNlZFN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuZnVuY3Rpb24gZGlzcGF0Y2hOZXh0KHN1YnNjcmliZXIpIHtcbiAgICBzdWJzY3JpYmVyLmRlYm91bmNlZE5leHQoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYm91bmNlVGltZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFBlcmZvcm0gYSBzaWRlIGVmZmVjdCBmb3IgZXZlcnkgZW1pc3Npb24gb24gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBidXQgcmV0dXJuXG4gKiBhbiBPYnNlcnZhYmxlIHRoYXQgaXMgaWRlbnRpY2FsIHRvIHRoZSBzb3VyY2UuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkludGVyY2VwdHMgZWFjaCBlbWlzc2lvbiBvbiB0aGUgc291cmNlIGFuZCBydW5zIGFcbiAqIGZ1bmN0aW9uLCBidXQgcmV0dXJucyBhbiBvdXRwdXQgd2hpY2ggaXMgaWRlbnRpY2FsIHRvIHRoZSBzb3VyY2UgYXMgbG9uZyBhcyBlcnJvcnMgZG9uJ3Qgb2NjdXIuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZG8ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhIG1pcnJvcmVkIE9ic2VydmFibGUgb2YgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBidXQgbW9kaWZpZWQgc28gdGhhdFxuICogdGhlIHByb3ZpZGVkIE9ic2VydmVyIGlzIGNhbGxlZCB0byBwZXJmb3JtIGEgc2lkZSBlZmZlY3QgZm9yIGV2ZXJ5IHZhbHVlLFxuICogZXJyb3IsIGFuZCBjb21wbGV0aW9uIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZS4gQW55IGVycm9ycyB0aGF0IGFyZSB0aHJvd24gaW5cbiAqIHRoZSBhZm9yZW1lbnRpb25lZCBPYnNlcnZlciBvciBoYW5kbGVycyBhcmUgc2FmZWx5IHNlbnQgZG93biB0aGUgZXJyb3IgcGF0aFxuICogb2YgdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIFRoaXMgb3BlcmF0b3IgaXMgdXNlZnVsIGZvciBkZWJ1Z2dpbmcgeW91ciBPYnNlcnZhYmxlcyBmb3IgdGhlIGNvcnJlY3QgdmFsdWVzXG4gKiBvciBwZXJmb3JtaW5nIG90aGVyIHNpZGUgZWZmZWN0cy5cbiAqXG4gKiBOb3RlOiB0aGlzIGlzIGRpZmZlcmVudCB0byBhIGBzdWJzY3JpYmVgIG9uIHRoZSBPYnNlcnZhYmxlLiBJZiB0aGUgT2JzZXJ2YWJsZVxuICogcmV0dXJuZWQgYnkgYGRvYCBpcyBub3Qgc3Vic2NyaWJlZCwgdGhlIHNpZGUgZWZmZWN0cyBzcGVjaWZpZWQgYnkgdGhlXG4gKiBPYnNlcnZlciB3aWxsIG5ldmVyIGhhcHBlbi4gYGRvYCB0aGVyZWZvcmUgc2ltcGx5IHNwaWVzIG9uIGV4aXN0aW5nXG4gKiBleGVjdXRpb24sIGl0IGRvZXMgbm90IHRyaWdnZXIgYW4gZXhlY3V0aW9uIHRvIGhhcHBlbiBsaWtlIGBzdWJzY3JpYmVgIGRvZXMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+TWFwIGV2ZXJ5IGNsaWNrIHRvIHRoZSBjbGllbnRYIHBvc2l0aW9uIG9mIHRoYXQgY2xpY2ssIHdoaWxlIGFsc28gbG9nZ2luZyB0aGUgY2xpY2sgZXZlbnQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHBvc2l0aW9ucyA9IGNsaWNrc1xuICogICAuZG8oZXYgPT4gY29uc29sZS5sb2coZXYpKVxuICogICAubWFwKGV2ID0+IGV2LmNsaWVudFgpO1xuICogcG9zaXRpb25zLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBtYXB9XG4gKiBAc2VlIHtAbGluayBzdWJzY3JpYmV9XG4gKlxuICogQHBhcmFtIHtPYnNlcnZlcnxmdW5jdGlvbn0gW25leHRPck9ic2VydmVyXSBBIG5vcm1hbCBPYnNlcnZlciBvYmplY3Qgb3IgYVxuICogY2FsbGJhY2sgZm9yIGBuZXh0YC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtlcnJvcl0gQ2FsbGJhY2sgZm9yIGVycm9ycyBpbiB0aGUgc291cmNlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2NvbXBsZXRlXSBDYWxsYmFjayBmb3IgdGhlIGNvbXBsZXRpb24gb2YgdGhlIHNvdXJjZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgaWRlbnRpY2FsIHRvIHRoZSBzb3VyY2UsIGJ1dCBydW5zIHRoZVxuICogc3BlY2lmaWVkIE9ic2VydmVyIG9yIGNhbGxiYWNrKHMpIGZvciBlYWNoIGl0ZW0uXG4gKiBAbWV0aG9kIGRvXG4gKiBAbmFtZSBkb1xuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gX2RvKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBEb09wZXJhdG9yKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpKTtcbn1cbmV4cG9ydHMuX2RvID0gX2RvO1xudmFyIERvT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERvT3BlcmF0b3IobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB0aGlzLm5leHRPck9ic2VydmVyID0gbmV4dE9yT2JzZXJ2ZXI7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5jb21wbGV0ZSA9IGNvbXBsZXRlO1xuICAgIH1cbiAgICBEb09wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRG9TdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMubmV4dE9yT2JzZXJ2ZXIsIHRoaXMuZXJyb3IsIHRoaXMuY29tcGxldGUpKTtcbiAgICB9O1xuICAgIHJldHVybiBEb09wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRG9TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRG9TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERvU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgbmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHZhciBzYWZlU3Vic2NyaWJlciA9IG5ldyBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgc2FmZVN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hZGQoc2FmZVN1YnNjcmliZXIpO1xuICAgICAgICB0aGlzLnNhZmVTdWJzY3JpYmVyID0gc2FmZVN1YnNjcmliZXI7XG4gICAgfVxuICAgIERvU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHNhZmVTdWJzY3JpYmVyID0gdGhpcy5zYWZlU3Vic2NyaWJlcjtcbiAgICAgICAgc2FmZVN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgIGlmIChzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3Ioc2FmZVN1YnNjcmliZXIuc3luY0Vycm9yVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9TdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciBzYWZlU3Vic2NyaWJlciA9IHRoaXMuc2FmZVN1YnNjcmliZXI7XG4gICAgICAgIHNhZmVTdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgICAgIGlmIChzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3Ioc2FmZVN1YnNjcmliZXIuc3luY0Vycm9yVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEb1N1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNhZmVTdWJzY3JpYmVyID0gdGhpcy5zYWZlU3Vic2NyaWJlcjtcbiAgICAgICAgc2FmZVN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgaWYgKHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93bikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEb1N1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kby5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFByb2plY3RzIGVhY2ggc291cmNlIHZhbHVlIHRvIGFuIE9ic2VydmFibGUgd2hpY2ggaXMgbWVyZ2VkIGluIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUgb25seSBpZiB0aGUgcHJldmlvdXMgcHJvamVjdGVkIE9ic2VydmFibGUgaGFzIGNvbXBsZXRlZC5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TWFwcyBlYWNoIHZhbHVlIHRvIGFuIE9ic2VydmFibGUsIHRoZW4gZmxhdHRlbnMgYWxsIG9mXG4gKiB0aGVzZSBpbm5lciBPYnNlcnZhYmxlcyB1c2luZyB7QGxpbmsgZXhoYXVzdH0uPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZXhoYXVzdE1hcC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBiYXNlZCBvbiBhcHBseWluZyBhIGZ1bmN0aW9uIHRoYXQgeW91XG4gKiBzdXBwbHkgdG8gZWFjaCBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB3aGVyZSB0aGF0IGZ1bmN0aW9uXG4gKiByZXR1cm5zIGFuIChzby1jYWxsZWQgXCJpbm5lclwiKSBPYnNlcnZhYmxlLiBXaGVuIGl0IHByb2plY3RzIGEgc291cmNlIHZhbHVlIHRvXG4gKiBhbiBPYnNlcnZhYmxlLCB0aGUgb3V0cHV0IE9ic2VydmFibGUgYmVnaW5zIGVtaXR0aW5nIHRoZSBpdGVtcyBlbWl0dGVkIGJ5XG4gKiB0aGF0IHByb2plY3RlZCBPYnNlcnZhYmxlLiBIb3dldmVyLCBgZXhoYXVzdE1hcGAgaWdub3JlcyBldmVyeSBuZXcgcHJvamVjdGVkXG4gKiBPYnNlcnZhYmxlIGlmIHRoZSBwcmV2aW91cyBwcm9qZWN0ZWQgT2JzZXJ2YWJsZSBoYXMgbm90IHlldCBjb21wbGV0ZWQuIE9uY2VcbiAqIHRoYXQgb25lIGNvbXBsZXRlcywgaXQgd2lsbCBhY2NlcHQgYW5kIGZsYXR0ZW4gdGhlIG5leHQgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIGFuZCByZXBlYXQgdGhpcyBwcm9jZXNzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlJ1biBhIGZpbml0ZSB0aW1lciBmb3IgZWFjaCBjbGljaywgb25seSBpZiB0aGVyZSBpcyBubyBjdXJyZW50bHkgYWN0aXZlIHRpbWVyPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MuZXhoYXVzdE1hcCgoZXYpID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSg1KSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcH1cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3R9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcH1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCA/aW5kZXg6IG51bWJlcik6IE9ic2VydmFibGVJbnB1dH0gcHJvamVjdCBBIGZ1bmN0aW9uXG4gKiB0aGF0LCB3aGVuIGFwcGxpZWQgdG8gYW4gaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgcmV0dXJucyBhblxuICogT2JzZXJ2YWJsZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSwgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpOiBhbnl9IFtyZXN1bHRTZWxlY3Rvcl1cbiAqIEEgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJhc2VkIG9uIHRoZSB2YWx1ZXNcbiAqIGFuZCB0aGUgaW5kaWNlcyBvZiB0aGUgc291cmNlIChvdXRlcikgZW1pc3Npb24gYW5kIHRoZSBpbm5lciBPYnNlcnZhYmxlXG4gKiBlbWlzc2lvbi4gVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmU6XG4gKiAtIGBvdXRlclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiAtIGBvdXRlckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIGNvbnRhaW5pbmcgcHJvamVjdGVkIE9ic2VydmFibGVzXG4gKiBvZiBlYWNoIGl0ZW0gb2YgdGhlIHNvdXJjZSwgaWdub3JpbmcgcHJvamVjdGVkIE9ic2VydmFibGVzIHRoYXQgc3RhcnQgYmVmb3JlXG4gKiB0aGVpciBwcmVjZWRpbmcgT2JzZXJ2YWJsZSBoYXMgY29tcGxldGVkLlxuICogQG1ldGhvZCBleGhhdXN0TWFwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBleGhhdXN0TWFwKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgU3dpdGNoRmlyc3RNYXBPcGVyYXRvcihwcm9qZWN0LCByZXN1bHRTZWxlY3RvcikpO1xufVxuZXhwb3J0cy5leGhhdXN0TWFwID0gZXhoYXVzdE1hcDtcbnZhciBTd2l0Y2hGaXJzdE1hcE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTd2l0Y2hGaXJzdE1hcE9wZXJhdG9yKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICB9XG4gICAgU3dpdGNoRmlyc3RNYXBPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QsIHRoaXMucmVzdWx0U2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hGaXJzdE1hcE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU3dpdGNoRmlyc3RNYXBTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3dpdGNoRmlyc3RNYXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuaGFzU3Vic2NyaXB0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMudHJ5TmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlci5wcm90b3R5cGUudHJ5TmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wcm9qZWN0KHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB0aGlzLmhhc1N1YnNjcmlwdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHJlc3VsdCwgdmFsdWUsIGluZGV4KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoRmlyc3RNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcmVzdWx0U2VsZWN0b3IgPSBfYS5yZXN1bHRTZWxlY3RvciwgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnRyeVNlbGVjdFJlc3VsdChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlci5wcm90b3R5cGUudHJ5U2VsZWN0UmVzdWx0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcmVzdWx0U2VsZWN0b3IgPSBfYS5yZXN1bHRTZWxlY3RvciwgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRTZWxlY3RvcihvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgfTtcbiAgICBTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3ViKTtcbiAgICAgICAgdGhpcy5oYXNTdWJzY3JpcHRpb24gPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29tcGxldGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhoYXVzdE1hcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIEZpbHRlciBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBieSBvbmx5IGVtaXR0aW5nIHRob3NlIHRoYXRcbiAqIHNhdGlzZnkgYSBzcGVjaWZpZWQgcHJlZGljYXRlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5MaWtlXG4gKiBbQXJyYXkucHJvdG90eXBlLmZpbHRlcigpXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9maWx0ZXIpLFxuICogaXQgb25seSBlbWl0cyBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBpZiBpdCBwYXNzZXMgYSBjcml0ZXJpb24gZnVuY3Rpb24uPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZmlsdGVyLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFNpbWlsYXIgdG8gdGhlIHdlbGwta25vd24gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgIG1ldGhvZCwgdGhpcyBvcGVyYXRvclxuICogdGFrZXMgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBwYXNzZXMgdGhlbSB0aHJvdWdoIGEgYHByZWRpY2F0ZWBcbiAqIGZ1bmN0aW9uIGFuZCBvbmx5IGVtaXRzIHRob3NlIHZhbHVlcyB0aGF0IHlpZWxkZWQgYHRydWVgLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgb25seSBjbGljayBldmVudHMgd2hvc2UgdGFyZ2V0IHdhcyBhIERJViBlbGVtZW50PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBjbGlja3NPbkRpdnMgPSBjbGlja3MuZmlsdGVyKGV2ID0+IGV2LnRhcmdldC50YWdOYW1lID09PSAnRElWJyk7XG4gKiBjbGlja3NPbkRpdnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0fVxuICogQHNlZSB7QGxpbmsgZGlzdGluY3RVbnRpbENoYW5nZWR9XG4gKiBAc2VlIHtAbGluayBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZH1cbiAqIEBzZWUge0BsaW5rIGlnbm9yZUVsZW1lbnRzfVxuICogQHNlZSB7QGxpbmsgcGFydGl0aW9ufVxuICogQHNlZSB7QGxpbmsgc2tpcH1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKTogYm9vbGVhbn0gcHJlZGljYXRlIEEgZnVuY3Rpb24gdGhhdFxuICogZXZhbHVhdGVzIGVhY2ggdmFsdWUgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuIElmIGl0IHJldHVybnMgYHRydWVgLFxuICogdGhlIHZhbHVlIGlzIGVtaXR0ZWQsIGlmIGBmYWxzZWAgdGhlIHZhbHVlIGlzIG5vdCBwYXNzZWQgdG8gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZS4gVGhlIGBpbmRleGAgcGFyYW1ldGVyIGlzIHRoZSBudW1iZXIgYGlgIGZvciB0aGUgaS10aCBzb3VyY2VcbiAqIGVtaXNzaW9uIHRoYXQgaGFzIGhhcHBlbmVkIHNpbmNlIHRoZSBzdWJzY3JpcHRpb24sIHN0YXJ0aW5nIGZyb20gdGhlIG51bWJlclxuICogYDBgLlxuICogQHBhcmFtIHthbnl9IFt0aGlzQXJnXSBBbiBvcHRpb25hbCBhcmd1bWVudCB0byBkZXRlcm1pbmUgdGhlIHZhbHVlIG9mIGB0aGlzYFxuICogaW4gdGhlIGBwcmVkaWNhdGVgIGZ1bmN0aW9uLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBvZiB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIHRoYXQgd2VyZVxuICogYWxsb3dlZCBieSB0aGUgYHByZWRpY2F0ZWAgZnVuY3Rpb24uXG4gKiBAbWV0aG9kIGZpbHRlclxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZmlsdGVyKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IEZpbHRlck9wZXJhdG9yKHByZWRpY2F0ZSwgdGhpc0FyZykpO1xufVxuZXhwb3J0cy5maWx0ZXIgPSBmaWx0ZXI7XG52YXIgRmlsdGVyT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpbHRlck9wZXJhdG9yKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy50aGlzQXJnID0gdGhpc0FyZztcbiAgICB9XG4gICAgRmlsdGVyT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBGaWx0ZXJTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJlZGljYXRlLCB0aGlzLnRoaXNBcmcpKTtcbiAgICB9O1xuICAgIHJldHVybiBGaWx0ZXJPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEZpbHRlclN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGaWx0ZXJTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZpbHRlclN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLnRoaXNBcmcgPSB0aGlzQXJnO1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgfVxuICAgIC8vIHRoZSB0cnkgY2F0Y2ggYmxvY2sgYmVsb3cgaXMgbGVmdCBzcGVjaWZpY2FsbHkgZm9yXG4gICAgLy8gb3B0aW1pemF0aW9uIGFuZCBwZXJmIHJlYXNvbnMuIGEgdHJ5Q2F0Y2hlciBpcyBub3QgbmVjZXNzYXJ5IGhlcmUuXG4gICAgRmlsdGVyU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJlZGljYXRlLmNhbGwodGhpcy50aGlzQXJnLCB2YWx1ZSwgdGhpcy5jb3VudCsrKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEZpbHRlclN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWx0ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpcHRpb24nKTtcbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgbWlycm9ycyB0aGUgc291cmNlIE9ic2VydmFibGUsIGJ1dCB3aWxsIGNhbGwgYSBzcGVjaWZpZWQgZnVuY3Rpb24gd2hlblxuICogdGhlIHNvdXJjZSB0ZXJtaW5hdGVzIG9uIGNvbXBsZXRlIG9yIGVycm9yLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gc291cmNlIHRlcm1pbmF0ZXMuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgbWlycm9ycyB0aGUgc291cmNlLCBidXQgd2lsbCBjYWxsIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gb24gdGVybWluYXRpb24uXG4gKiBAbWV0aG9kIGZpbmFsbHlcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIF9maW5hbGx5KGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgRmluYWxseU9wZXJhdG9yKGNhbGxiYWNrKSk7XG59XG5leHBvcnRzLl9maW5hbGx5ID0gX2ZpbmFsbHk7XG52YXIgRmluYWxseU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaW5hbGx5T3BlcmF0b3IoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBGaW5hbGx5T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBGaW5hbGx5U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmNhbGxiYWNrKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRmluYWxseU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRmluYWxseVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGaW5hbGx5U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGaW5hbGx5U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmFkZChuZXcgU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKGNhbGxiYWNrKSk7XG4gICAgfVxuICAgIHJldHVybiBGaW5hbGx5U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbmFsbHkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIEFwcGxpZXMgYSBnaXZlbiBgcHJvamVjdGAgZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUsIGFuZCBlbWl0cyB0aGUgcmVzdWx0aW5nIHZhbHVlcyBhcyBhbiBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5MaWtlIFtBcnJheS5wcm90b3R5cGUubWFwKCldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L21hcCksXG4gKiBpdCBwYXNzZXMgZWFjaCBzb3VyY2UgdmFsdWUgdGhyb3VnaCBhIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uIHRvIGdldFxuICogY29ycmVzcG9uZGluZyBvdXRwdXQgdmFsdWVzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL21hcC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBTaW1pbGFyIHRvIHRoZSB3ZWxsIGtub3duIGBBcnJheS5wcm90b3R5cGUubWFwYCBmdW5jdGlvbiwgdGhpcyBvcGVyYXRvclxuICogYXBwbGllcyBhIHByb2plY3Rpb24gdG8gZWFjaCB2YWx1ZSBhbmQgZW1pdHMgdGhhdCBwcm9qZWN0aW9uIGluIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+TWFwIGV2ZXJ5IGNsaWNrIHRvIHRoZSBjbGllbnRYIHBvc2l0aW9uIG9mIHRoYXQgY2xpY2s8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHBvc2l0aW9ucyA9IGNsaWNrcy5tYXAoZXYgPT4gZXYuY2xpZW50WCk7XG4gKiBwb3NpdGlvbnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIG1hcFRvfVxuICogQHNlZSB7QGxpbmsgcGx1Y2t9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgaW5kZXg6IG51bWJlcik6IFJ9IHByb2plY3QgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5XG4gKiB0byBlYWNoIGB2YWx1ZWAgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuIFRoZSBgaW5kZXhgIHBhcmFtZXRlciBpc1xuICogdGhlIG51bWJlciBgaWAgZm9yIHRoZSBpLXRoIGVtaXNzaW9uIHRoYXQgaGFzIGhhcHBlbmVkIHNpbmNlIHRoZVxuICogc3Vic2NyaXB0aW9uLCBzdGFydGluZyBmcm9tIHRoZSBudW1iZXIgYDBgLlxuICogQHBhcmFtIHthbnl9IFt0aGlzQXJnXSBBbiBvcHRpb25hbCBhcmd1bWVudCB0byBkZWZpbmUgd2hhdCBgdGhpc2AgaXMgaW4gdGhlXG4gKiBgcHJvamVjdGAgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFI+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgdHJhbnNmb3JtZWQgYnkgdGhlIGdpdmVuIGBwcm9qZWN0YCBmdW5jdGlvbi5cbiAqIEBtZXRob2QgbWFwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtYXAocHJvamVjdCwgdGhpc0FyZykge1xuICAgIGlmICh0eXBlb2YgcHJvamVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBpcyBub3QgYSBmdW5jdGlvbi4gQXJlIHlvdSBsb29raW5nIGZvciBgbWFwVG8oKWA/Jyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IE1hcE9wZXJhdG9yKHByb2plY3QsIHRoaXNBcmcpKTtcbn1cbmV4cG9ydHMubWFwID0gbWFwO1xudmFyIE1hcE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXBPcGVyYXRvcihwcm9qZWN0LCB0aGlzQXJnKSB7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmc7XG4gICAgfVxuICAgIE1hcE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgTWFwU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QsIHRoaXMudGhpc0FyZykpO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcE9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuTWFwT3BlcmF0b3IgPSBNYXBPcGVyYXRvcjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgTWFwU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hcFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFwU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJvamVjdCwgdGhpc0FyZykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB0aGlzLnRoaXNBcmcgPSB0aGlzQXJnIHx8IHRoaXM7XG4gICAgfVxuICAgIC8vIE5PVEU6IFRoaXMgbG9va3MgdW5vcHRpbWl6ZWQsIGJ1dCBpdCdzIGFjdHVhbGx5IHB1cnBvc2VmdWxseSBOT1RcbiAgICAvLyB1c2luZyB0cnkvY2F0Y2ggb3B0aW1pemF0aW9ucy5cbiAgICBNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcm9qZWN0LmNhbGwodGhpcy50aGlzQXJnLCB2YWx1ZSwgdGhpcy5jb3VudCsrKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gICAgfTtcbiAgICByZXR1cm4gTWFwU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogQ29udmVydHMgYSBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZSBpbnRvIGEgZmlyc3Qtb3JkZXIgT2JzZXJ2YWJsZSB3aGljaFxuICogY29uY3VycmVudGx5IGRlbGl2ZXJzIGFsbCB2YWx1ZXMgdGhhdCBhcmUgZW1pdHRlZCBvbiB0aGUgaW5uZXIgT2JzZXJ2YWJsZXMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkZsYXR0ZW5zIGFuIE9ic2VydmFibGUtb2YtT2JzZXJ2YWJsZXMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWVyZ2VBbGwucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYG1lcmdlQWxsYCBzdWJzY3JpYmVzIHRvIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBPYnNlcnZhYmxlcywgYWxzbyBrbm93biBhc1xuICogYSBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZS4gRWFjaCB0aW1lIGl0IG9ic2VydmVzIG9uZSBvZiB0aGVzZSBlbWl0dGVkIGlubmVyXG4gKiBPYnNlcnZhYmxlcywgaXQgc3Vic2NyaWJlcyB0byB0aGF0IGFuZCBkZWxpdmVycyBhbGwgdGhlIHZhbHVlcyBmcm9tIHRoZVxuICogaW5uZXIgT2JzZXJ2YWJsZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuIFRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBvbmx5XG4gKiBjb21wbGV0ZXMgb25jZSBhbGwgaW5uZXIgT2JzZXJ2YWJsZXMgaGF2ZSBjb21wbGV0ZWQuIEFueSBlcnJvciBkZWxpdmVyZWQgYnlcbiAqIGEgaW5uZXIgT2JzZXJ2YWJsZSB3aWxsIGJlIGltbWVkaWF0ZWx5IGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlNwYXduIGEgbmV3IGludGVydmFsIE9ic2VydmFibGUgZm9yIGVhY2ggY2xpY2sgZXZlbnQsIGFuZCBibGVuZCB0aGVpciBvdXRwdXRzIGFzIG9uZSBPYnNlcnZhYmxlPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBoaWdoZXJPcmRlciA9IGNsaWNrcy5tYXAoKGV2KSA9PiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApKTtcbiAqIHZhciBmaXJzdE9yZGVyID0gaGlnaGVyT3JkZXIubWVyZ2VBbGwoKTtcbiAqIGZpcnN0T3JkZXIuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvdW50IGZyb20gMCB0byA5IGV2ZXJ5IHNlY29uZCBmb3IgZWFjaCBjbGljaywgYnV0IG9ubHkgYWxsb3cgMiBjb25jdXJyZW50IHRpbWVyczwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgaGlnaGVyT3JkZXIgPSBjbGlja3MubWFwKChldikgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDEwKSk7XG4gKiB2YXIgZmlyc3RPcmRlciA9IGhpZ2hlck9yZGVyLm1lcmdlQWxsKDIpO1xuICogZmlyc3RPcmRlci5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgY29tYmluZUFsbH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdEFsbH1cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3R9XG4gKiBAc2VlIHtAbGluayBtZXJnZX1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXBUb31cbiAqIEBzZWUge0BsaW5rIG1lcmdlU2Nhbn1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaH1cbiAqIEBzZWUge0BsaW5rIHppcEFsbH1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbnQ9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSBNYXhpbXVtIG51bWJlciBvZiBpbm5lclxuICogT2JzZXJ2YWJsZXMgYmVpbmcgc3Vic2NyaWJlZCB0byBjb25jdXJyZW50bHkuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdmFsdWVzIGNvbWluZyBmcm9tIGFsbCB0aGVcbiAqIGlubmVyIE9ic2VydmFibGVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBtZXJnZUFsbFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gbWVyZ2VBbGwoY29uY3VycmVudCkge1xuICAgIGlmIChjb25jdXJyZW50ID09PSB2b2lkIDApIHsgY29uY3VycmVudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IE1lcmdlQWxsT3BlcmF0b3IoY29uY3VycmVudCkpO1xufVxuZXhwb3J0cy5tZXJnZUFsbCA9IG1lcmdlQWxsO1xudmFyIE1lcmdlQWxsT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lcmdlQWxsT3BlcmF0b3IoY29uY3VycmVudCkge1xuICAgICAgICB0aGlzLmNvbmN1cnJlbnQgPSBjb25jdXJyZW50O1xuICAgIH1cbiAgICBNZXJnZUFsbE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKG9ic2VydmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IE1lcmdlQWxsU3Vic2NyaWJlcihvYnNlcnZlciwgdGhpcy5jb25jdXJyZW50KSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWVyZ2VBbGxPcGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLk1lcmdlQWxsT3BlcmF0b3IgPSBNZXJnZUFsbE9wZXJhdG9yO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBNZXJnZUFsbFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZXJnZUFsbFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVyZ2VBbGxTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjb25jdXJyZW50KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5jb25jdXJyZW50ID0gY29uY3VycmVudDtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSAwO1xuICAgIH1cbiAgICBNZXJnZUFsbFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKG9ic2VydmFibGUpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlIDwgdGhpcy5jb25jdXJyZW50KSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSsrO1xuICAgICAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBvYnNlcnZhYmxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKG9ic2VydmFibGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXJnZUFsbFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPT09IDAgJiYgdGhpcy5idWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lcmdlQWxsU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB0aGlzLnJlbW92ZShpbm5lclN1Yik7XG4gICAgICAgIHRoaXMuYWN0aXZlLS07XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dChidWZmZXIuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hY3RpdmUgPT09IDAgJiYgdGhpcy5oYXNDb21wbGV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1lcmdlQWxsU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG5leHBvcnRzLk1lcmdlQWxsU3Vic2NyaWJlciA9IE1lcmdlQWxsU3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlQWxsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUHJvamVjdHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSB3aGljaCBpcyBtZXJnZWQgaW4gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TWFwcyBlYWNoIHZhbHVlIHRvIGFuIE9ic2VydmFibGUsIHRoZW4gZmxhdHRlbnMgYWxsIG9mXG4gKiB0aGVzZSBpbm5lciBPYnNlcnZhYmxlcyB1c2luZyB7QGxpbmsgbWVyZ2VBbGx9Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL21lcmdlTWFwLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGJhc2VkIG9uIGFwcGx5aW5nIGEgZnVuY3Rpb24gdGhhdCB5b3VcbiAqIHN1cHBseSB0byBlYWNoIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIHdoZXJlIHRoYXQgZnVuY3Rpb25cbiAqIHJldHVybnMgYW4gT2JzZXJ2YWJsZSwgYW5kIHRoZW4gbWVyZ2luZyB0aG9zZSByZXN1bHRpbmcgT2JzZXJ2YWJsZXMgYW5kXG4gKiBlbWl0dGluZyB0aGUgcmVzdWx0cyBvZiB0aGlzIG1lcmdlci5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5NYXAgYW5kIGZsYXR0ZW4gZWFjaCBsZXR0ZXIgdG8gYW4gT2JzZXJ2YWJsZSB0aWNraW5nIGV2ZXJ5IDEgc2Vjb25kPC9jYXB0aW9uPlxuICogdmFyIGxldHRlcnMgPSBSeC5PYnNlcnZhYmxlLm9mKCdhJywgJ2InLCAnYycpO1xuICogdmFyIHJlc3VsdCA9IGxldHRlcnMubWVyZ2VNYXAoeCA9PlxuICogICBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLm1hcChpID0+IHgraSlcbiAqICk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIFJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZzpcbiAqIC8vIGEwXG4gKiAvLyBiMFxuICogLy8gYzBcbiAqIC8vIGExXG4gKiAvLyBiMVxuICogLy8gYzFcbiAqIC8vIGNvbnRpbnVlcyB0byBsaXN0IGEsYixjIHdpdGggcmVzcGVjdGl2ZSBhc2NlbmRpbmcgaW50ZWdlcnNcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXB9XG4gKiBAc2VlIHtAbGluayBleGhhdXN0TWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2V9XG4gKiBAc2VlIHtAbGluayBtZXJnZUFsbH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwVG99XG4gKiBAc2VlIHtAbGluayBtZXJnZVNjYW59XG4gKiBAc2VlIHtAbGluayBzd2l0Y2hNYXB9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgP2luZGV4OiBudW1iZXIpOiBPYnNlcnZhYmxlSW5wdXR9IHByb2plY3QgQSBmdW5jdGlvblxuICogdGhhdCwgd2hlbiBhcHBsaWVkIHRvIGFuIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIHJldHVybnMgYW5cbiAqIE9ic2VydmFibGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKTogYW55fSBbcmVzdWx0U2VsZWN0b3JdXG4gKiBBIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHZhbHVlIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiYXNlZCBvbiB0aGUgdmFsdWVzXG4gKiBhbmQgdGhlIGluZGljZXMgb2YgdGhlIHNvdXJjZSAob3V0ZXIpIGVtaXNzaW9uIGFuZCB0aGUgaW5uZXIgT2JzZXJ2YWJsZVxuICogZW1pc3Npb24uIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gYXJlOlxuICogLSBgb3V0ZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogLSBgb3V0ZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW50PU51bWJlci5QT1NJVElWRV9JTkZJTklUWV0gTWF4aW11bSBudW1iZXIgb2YgaW5wdXRcbiAqIE9ic2VydmFibGVzIGJlaW5nIHN1YnNjcmliZWQgdG8gY29uY3VycmVudGx5LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlXG4gKiBwcm9qZWN0aW9uIGZ1bmN0aW9uIChhbmQgdGhlIG9wdGlvbmFsIGByZXN1bHRTZWxlY3RvcmApIHRvIGVhY2ggaXRlbSBlbWl0dGVkXG4gKiBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYW5kIG1lcmdpbmcgdGhlIHJlc3VsdHMgb2YgdGhlIE9ic2VydmFibGVzIG9idGFpbmVkXG4gKiBmcm9tIHRoaXMgdHJhbnNmb3JtYXRpb24uXG4gKiBAbWV0aG9kIG1lcmdlTWFwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtZXJnZU1hcChwcm9qZWN0LCByZXN1bHRTZWxlY3RvciwgY29uY3VycmVudCkge1xuICAgIGlmIChjb25jdXJyZW50ID09PSB2b2lkIDApIHsgY29uY3VycmVudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsgfVxuICAgIGlmICh0eXBlb2YgcmVzdWx0U2VsZWN0b3IgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbmN1cnJlbnQgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgcmVzdWx0U2VsZWN0b3IgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBNZXJnZU1hcE9wZXJhdG9yKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yLCBjb25jdXJyZW50KSk7XG59XG5leHBvcnRzLm1lcmdlTWFwID0gbWVyZ2VNYXA7XG52YXIgTWVyZ2VNYXBPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVyZ2VNYXBPcGVyYXRvcihwcm9qZWN0LCByZXN1bHRTZWxlY3RvciwgY29uY3VycmVudCkge1xuICAgICAgICBpZiAoY29uY3VycmVudCA9PT0gdm9pZCAwKSB7IGNvbmN1cnJlbnQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7IH1cbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICB0aGlzLmNvbmN1cnJlbnQgPSBjb25jdXJyZW50O1xuICAgIH1cbiAgICBNZXJnZU1hcE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKG9ic2VydmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IE1lcmdlTWFwU3Vic2NyaWJlcihvYnNlcnZlciwgdGhpcy5wcm9qZWN0LCB0aGlzLnJlc3VsdFNlbGVjdG9yLCB0aGlzLmNvbmN1cnJlbnQpKTtcbiAgICB9O1xuICAgIHJldHVybiBNZXJnZU1hcE9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuTWVyZ2VNYXBPcGVyYXRvciA9IE1lcmdlTWFwT3BlcmF0b3I7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIE1lcmdlTWFwU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lcmdlTWFwU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZXJnZU1hcFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByb2plY3QsIHJlc3VsdFNlbGVjdG9yLCBjb25jdXJyZW50KSB7XG4gICAgICAgIGlmIChjb25jdXJyZW50ID09PSB2b2lkIDApIHsgY29uY3VycmVudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5jb25jdXJyZW50ID0gY29uY3VycmVudDtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSAwO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgTWVyZ2VNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPCB0aGlzLmNvbmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyeU5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lcmdlTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX3RyeU5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleCsrO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcm9qZWN0KHZhbHVlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlKys7XG4gICAgICAgIHRoaXMuX2lubmVyU3ViKHJlc3VsdCwgdmFsdWUsIGluZGV4KTtcbiAgICB9O1xuICAgIE1lcmdlTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX2lubmVyU3ViID0gZnVuY3Rpb24gKGlzaCwgdmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgaXNoLCB2YWx1ZSwgaW5kZXgpKTtcbiAgICB9O1xuICAgIE1lcmdlTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCAmJiB0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVyZ2VNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9ub3RpZnlSZXN1bHRTZWxlY3RvcihvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChpbm5lclZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVyZ2VNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbm90aWZ5UmVzdWx0U2VsZWN0b3IgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5yZXN1bHRTZWxlY3RvcihvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gICAgfTtcbiAgICBNZXJnZU1hcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgdGhpcy5yZW1vdmUoaW5uZXJTdWIpO1xuICAgICAgICB0aGlzLmFjdGl2ZS0tO1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX25leHQoYnVmZmVyLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYWN0aXZlID09PSAwICYmIHRoaXMuaGFzQ29tcGxldGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNZXJnZU1hcFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5NZXJnZU1hcFN1YnNjcmliZXIgPSBNZXJnZU1hcFN1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXJnZU1hcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBDb25uZWN0YWJsZU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvQ29ubmVjdGFibGVPYnNlcnZhYmxlJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgcmVzdWx0cyBvZiBpbnZva2luZyBhIHNwZWNpZmllZCBzZWxlY3RvciBvbiBpdGVtc1xuICogZW1pdHRlZCBieSBhIENvbm5lY3RhYmxlT2JzZXJ2YWJsZSB0aGF0IHNoYXJlcyBhIHNpbmdsZSBzdWJzY3JpcHRpb24gdG8gdGhlIHVuZGVybHlpbmcgc3RyZWFtLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbXVsdGljYXN0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb258U3ViamVjdH0gc3ViamVjdE9yU3ViamVjdEZhY3RvcnkgLSBGYWN0b3J5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBhbiBpbnRlcm1lZGlhdGUgc3ViamVjdCB0aHJvdWdoXG4gKiB3aGljaCB0aGUgc291cmNlIHNlcXVlbmNlJ3MgZWxlbWVudHMgd2lsbCBiZSBtdWx0aWNhc3QgdG8gdGhlIHNlbGVjdG9yIGZ1bmN0aW9uXG4gKiBvciBTdWJqZWN0IHRvIHB1c2ggc291cmNlIGVsZW1lbnRzIGludG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc2VsZWN0b3JdIC0gT3B0aW9uYWwgc2VsZWN0b3IgZnVuY3Rpb24gdGhhdCBjYW4gdXNlIHRoZSBtdWx0aWNhc3RlZCBzb3VyY2Ugc3RyZWFtXG4gKiBhcyBtYW55IHRpbWVzIGFzIG5lZWRlZCwgd2l0aG91dCBjYXVzaW5nIG11bHRpcGxlIHN1YnNjcmlwdGlvbnMgdG8gdGhlIHNvdXJjZSBzdHJlYW0uXG4gKiBTdWJzY3JpYmVycyB0byB0aGUgZ2l2ZW4gc291cmNlIHdpbGwgcmVjZWl2ZSBhbGwgbm90aWZpY2F0aW9ucyBvZiB0aGUgc291cmNlIGZyb20gdGhlXG4gKiB0aW1lIG9mIHRoZSBzdWJzY3JpcHRpb24gZm9yd2FyZC5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgcmVzdWx0cyBvZiBpbnZva2luZyB0aGUgc2VsZWN0b3JcbiAqIG9uIHRoZSBpdGVtcyBlbWl0dGVkIGJ5IGEgYENvbm5lY3RhYmxlT2JzZXJ2YWJsZWAgdGhhdCBzaGFyZXMgYSBzaW5nbGUgc3Vic2NyaXB0aW9uIHRvXG4gKiB0aGUgdW5kZXJseWluZyBzdHJlYW0uXG4gKiBAbWV0aG9kIG11bHRpY2FzdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gbXVsdGljYXN0KHN1YmplY3RPclN1YmplY3RGYWN0b3J5LCBzZWxlY3Rvcikge1xuICAgIHZhciBzdWJqZWN0RmFjdG9yeTtcbiAgICBpZiAodHlwZW9mIHN1YmplY3RPclN1YmplY3RGYWN0b3J5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHN1YmplY3RGYWN0b3J5ID0gc3ViamVjdE9yU3ViamVjdEZhY3Rvcnk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdWJqZWN0RmFjdG9yeSA9IGZ1bmN0aW9uIHN1YmplY3RGYWN0b3J5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHN1YmplY3RPclN1YmplY3RGYWN0b3J5O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpZnQobmV3IE11bHRpY2FzdE9wZXJhdG9yKHN1YmplY3RGYWN0b3J5LCBzZWxlY3RvcikpO1xuICAgIH1cbiAgICB2YXIgY29ubmVjdGFibGUgPSBPYmplY3QuY3JlYXRlKHRoaXMsIENvbm5lY3RhYmxlT2JzZXJ2YWJsZV8xLmNvbm5lY3RhYmxlT2JzZXJ2YWJsZURlc2NyaXB0b3IpO1xuICAgIGNvbm5lY3RhYmxlLnNvdXJjZSA9IHRoaXM7XG4gICAgY29ubmVjdGFibGUuc3ViamVjdEZhY3RvcnkgPSBzdWJqZWN0RmFjdG9yeTtcbiAgICByZXR1cm4gY29ubmVjdGFibGU7XG59XG5leHBvcnRzLm11bHRpY2FzdCA9IG11bHRpY2FzdDtcbnZhciBNdWx0aWNhc3RPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTXVsdGljYXN0T3BlcmF0b3Ioc3ViamVjdEZhY3RvcnksIHNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuc3ViamVjdEZhY3RvcnkgPSBzdWJqZWN0RmFjdG9yeTtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgIH1cbiAgICBNdWx0aWNhc3RPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gdGhpcy5zZWxlY3RvcjtcbiAgICAgICAgdmFyIHN1YmplY3QgPSB0aGlzLnN1YmplY3RGYWN0b3J5KCk7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBzZWxlY3RvcihzdWJqZWN0KS5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5hZGQoc291cmNlLnN1YnNjcmliZShzdWJqZWN0KSk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICByZXR1cm4gTXVsdGljYXN0T3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5NdWx0aWNhc3RPcGVyYXRvciA9IE11bHRpY2FzdE9wZXJhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXVsdGljYXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBHcm91cHMgcGFpcnMgb2YgY29uc2VjdXRpdmUgZW1pc3Npb25zIHRvZ2V0aGVyIGFuZCBlbWl0cyB0aGVtIGFzIGFuIGFycmF5IG9mXG4gKiB0d28gdmFsdWVzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5QdXRzIHRoZSBjdXJyZW50IHZhbHVlIGFuZCBwcmV2aW91cyB2YWx1ZSB0b2dldGhlciBhc1xuICogYW4gYXJyYXksIGFuZCBlbWl0cyB0aGF0Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3BhaXJ3aXNlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFRoZSBOdGggZW1pc3Npb24gZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgd2lsbCBjYXVzZSB0aGUgb3V0cHV0IE9ic2VydmFibGVcbiAqIHRvIGVtaXQgYW4gYXJyYXkgWyhOLTEpdGgsIE50aF0gb2YgdGhlIHByZXZpb3VzIGFuZCB0aGUgY3VycmVudCB2YWx1ZSwgYXMgYVxuICogcGFpci4gRm9yIHRoaXMgcmVhc29uLCBgcGFpcndpc2VgIGVtaXRzIG9uIHRoZSBzZWNvbmQgYW5kIHN1YnNlcXVlbnRcbiAqIGVtaXNzaW9ucyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYnV0IG5vdCBvbiB0aGUgZmlyc3QgZW1pc3Npb24sIGJlY2F1c2VcbiAqIHRoZXJlIGlzIG5vIHByZXZpb3VzIHZhbHVlIGluIHRoYXQgY2FzZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5PbiBldmVyeSBjbGljayAoc3RhcnRpbmcgZnJvbSB0aGUgc2Vjb25kKSwgZW1pdCB0aGUgcmVsYXRpdmUgZGlzdGFuY2UgdG8gdGhlIHByZXZpb3VzIGNsaWNrPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBwYWlycyA9IGNsaWNrcy5wYWlyd2lzZSgpO1xuICogdmFyIGRpc3RhbmNlID0gcGFpcnMubWFwKHBhaXIgPT4ge1xuICogICB2YXIgeDAgPSBwYWlyWzBdLmNsaWVudFg7XG4gKiAgIHZhciB5MCA9IHBhaXJbMF0uY2xpZW50WTtcbiAqICAgdmFyIHgxID0gcGFpclsxXS5jbGllbnRYO1xuICogICB2YXIgeTEgPSBwYWlyWzFdLmNsaWVudFk7XG4gKiAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeDAgLSB4MSwgMikgKyBNYXRoLnBvdyh5MCAtIHkxLCAyKSk7XG4gKiB9KTtcbiAqIGRpc3RhbmNlLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBidWZmZXJ9XG4gKiBAc2VlIHtAbGluayBidWZmZXJDb3VudH1cbiAqXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPEFycmF5PFQ+Pn0gQW4gT2JzZXJ2YWJsZSBvZiBwYWlycyAoYXMgYXJyYXlzKSBvZlxuICogY29uc2VjdXRpdmUgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBwYWlyd2lzZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gcGFpcndpc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgUGFpcndpc2VPcGVyYXRvcigpKTtcbn1cbmV4cG9ydHMucGFpcndpc2UgPSBwYWlyd2lzZTtcbnZhciBQYWlyd2lzZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYWlyd2lzZU9wZXJhdG9yKCkge1xuICAgIH1cbiAgICBQYWlyd2lzZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgUGFpcndpc2VTdWJzY3JpYmVyKHN1YnNjcmliZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBQYWlyd2lzZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgUGFpcndpc2VTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFpcndpc2VTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhaXJ3aXNlU3Vic2NyaWJlcihkZXN0aW5hdGlvbikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuaGFzUHJldiA9IGZhbHNlO1xuICAgIH1cbiAgICBQYWlyd2lzZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1ByZXYpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChbdGhpcy5wcmV2LCB2YWx1ZV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYXNQcmV2ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXYgPSB2YWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiBQYWlyd2lzZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWlyd2lzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBtdWx0aWNhc3RfMSA9IHJlcXVpcmUoJy4vbXVsdGljYXN0Jyk7XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vU3ViamVjdCcpO1xuZnVuY3Rpb24gc2hhcmVTdWJqZWN0RmFjdG9yeSgpIHtcbiAgICByZXR1cm4gbmV3IFN1YmplY3RfMS5TdWJqZWN0KCk7XG59XG4vKipcbiAqIFJldHVybnMgYSBuZXcgT2JzZXJ2YWJsZSB0aGF0IG11bHRpY2FzdHMgKHNoYXJlcykgdGhlIG9yaWdpbmFsIE9ic2VydmFibGUuIEFzIGxvbmcgYXMgdGhlcmUgaXMgYXQgbGVhc3Qgb25lXG4gKiBTdWJzY3JpYmVyIHRoaXMgT2JzZXJ2YWJsZSB3aWxsIGJlIHN1YnNjcmliZWQgYW5kIGVtaXR0aW5nIGRhdGEuIFdoZW4gYWxsIHN1YnNjcmliZXJzIGhhdmUgdW5zdWJzY3JpYmVkIGl0IHdpbGxcbiAqIHVuc3Vic2NyaWJlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBCZWNhdXNlIHRoZSBPYnNlcnZhYmxlIGlzIG11bHRpY2FzdGluZyBpdCBtYWtlcyB0aGUgc3RyZWFtIGBob3RgLlxuICogVGhpcyBpcyBhbiBhbGlhcyBmb3IgLnB1Ymxpc2goKS5yZWZDb3VudCgpLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc2hhcmUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IHVwb24gY29ubmVjdGlvbiBjYXVzZXMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRvIGVtaXQgaXRlbXMgdG8gaXRzIE9ic2VydmVycy5cbiAqIEBtZXRob2Qgc2hhcmVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHNoYXJlKCkge1xuICAgIHJldHVybiBtdWx0aWNhc3RfMS5tdWx0aWNhc3QuY2FsbCh0aGlzLCBzaGFyZVN1YmplY3RGYWN0b3J5KS5yZWZDb3VudCgpO1xufVxuZXhwb3J0cy5zaGFyZSA9IHNoYXJlO1xuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQXJyYXlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0FycmF5T2JzZXJ2YWJsZScpO1xudmFyIFNjYWxhck9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvU2NhbGFyT2JzZXJ2YWJsZScpO1xudmFyIEVtcHR5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9FbXB0eU9ic2VydmFibGUnKTtcbnZhciBjb25jYXRfMSA9IHJlcXVpcmUoJy4vY29uY2F0Jyk7XG52YXIgaXNTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNTY2hlZHVsZXInKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBpdGVtcyB5b3Ugc3BlY2lmeSBhcyBhcmd1bWVudHMgYmVmb3JlIGl0IGJlZ2lucyB0byBlbWl0XG4gKiBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3N0YXJ0V2l0aC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAcGFyYW0gey4uLlR9IHZhbHVlcyAtIEl0ZW1zIHlvdSB3YW50IHRoZSBtb2RpZmllZCBPYnNlcnZhYmxlIHRvIGVtaXQgZmlyc3QuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gLSBBIHtAbGluayBJU2NoZWR1bGVyfSB0byB1c2UgZm9yIHNjaGVkdWxpbmdcbiAqIHRoZSBlbWlzc2lvbnMgb2YgdGhlIGBuZXh0YCBub3RpZmljYXRpb25zLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBpdGVtcyBpbiB0aGUgc3BlY2lmaWVkIEl0ZXJhYmxlIGFuZCB0aGVuIGVtaXRzIHRoZSBpdGVtc1xuICogZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHN0YXJ0V2l0aFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gc3RhcnRXaXRoKCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFycmF5W19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgc2NoZWR1bGVyID0gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgaWYgKGlzU2NoZWR1bGVyXzEuaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSkge1xuICAgICAgICBhcnJheS5wb3AoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNjaGVkdWxlciA9IG51bGw7XG4gICAgfVxuICAgIHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gY29uY2F0XzEuY29uY2F0U3RhdGljKG5ldyBTY2FsYXJPYnNlcnZhYmxlXzEuU2NhbGFyT2JzZXJ2YWJsZShhcnJheVswXSwgc2NoZWR1bGVyKSwgdGhpcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdF8xLmNvbmNhdFN0YXRpYyhuZXcgQXJyYXlPYnNlcnZhYmxlXzEuQXJyYXlPYnNlcnZhYmxlKGFycmF5LCBzY2hlZHVsZXIpLCB0aGlzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjb25jYXRfMS5jb25jYXRTdGF0aWMobmV3IEVtcHR5T2JzZXJ2YWJsZV8xLkVtcHR5T2JzZXJ2YWJsZShzY2hlZHVsZXIpLCB0aGlzKTtcbiAgICB9XG59XG5leHBvcnRzLnN0YXJ0V2l0aCA9IHN0YXJ0V2l0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXJ0V2l0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFByb2plY3RzIGVhY2ggc291cmNlIHZhbHVlIHRvIGFuIE9ic2VydmFibGUgd2hpY2ggaXMgbWVyZ2VkIGluIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUsIGVtaXR0aW5nIHZhbHVlcyBvbmx5IGZyb20gdGhlIG1vc3QgcmVjZW50bHkgcHJvamVjdGVkIE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPk1hcHMgZWFjaCB2YWx1ZSB0byBhbiBPYnNlcnZhYmxlLCB0aGVuIGZsYXR0ZW5zIGFsbCBvZlxuICogdGhlc2UgaW5uZXIgT2JzZXJ2YWJsZXMgdXNpbmcge0BsaW5rIHN3aXRjaH0uPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc3dpdGNoTWFwLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGJhc2VkIG9uIGFwcGx5aW5nIGEgZnVuY3Rpb24gdGhhdCB5b3VcbiAqIHN1cHBseSB0byBlYWNoIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIHdoZXJlIHRoYXQgZnVuY3Rpb25cbiAqIHJldHVybnMgYW4gKHNvLWNhbGxlZCBcImlubmVyXCIpIE9ic2VydmFibGUuIEVhY2ggdGltZSBpdCBvYnNlcnZlcyBvbmUgb2YgdGhlc2VcbiAqIGlubmVyIE9ic2VydmFibGVzLCB0aGUgb3V0cHV0IE9ic2VydmFibGUgYmVnaW5zIGVtaXR0aW5nIHRoZSBpdGVtcyBlbWl0dGVkIGJ5XG4gKiB0aGF0IGlubmVyIE9ic2VydmFibGUuIFdoZW4gYSBuZXcgaW5uZXIgT2JzZXJ2YWJsZSBpcyBlbWl0dGVkLCBgc3dpdGNoTWFwYFxuICogc3RvcHMgZW1pdHRpbmcgaXRlbXMgZnJvbSB0aGUgZWFybGllci1lbWl0dGVkIGlubmVyIE9ic2VydmFibGUgYW5kIGJlZ2luc1xuICogZW1pdHRpbmcgaXRlbXMgZnJvbSB0aGUgbmV3IG9uZS4gSXQgY29udGludWVzIHRvIGJlaGF2ZSBsaWtlIHRoaXMgZm9yXG4gKiBzdWJzZXF1ZW50IGlubmVyIE9ic2VydmFibGVzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlJlcnVuIGFuIGludGVydmFsIE9ic2VydmFibGUgb24gZXZlcnkgY2xpY2sgZXZlbnQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5zd2l0Y2hNYXAoKGV2KSA9PiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgY29uY2F0TWFwfVxuICogQHNlZSB7QGxpbmsgZXhoYXVzdE1hcH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwfVxuICogQHNlZSB7QGxpbmsgc3dpdGNofVxuICogQHNlZSB7QGxpbmsgc3dpdGNoTWFwVG99XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgP2luZGV4OiBudW1iZXIpOiBPYnNlcnZhYmxlSW5wdXR9IHByb2plY3QgQSBmdW5jdGlvblxuICogdGhhdCwgd2hlbiBhcHBsaWVkIHRvIGFuIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIHJldHVybnMgYW5cbiAqIE9ic2VydmFibGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKTogYW55fSBbcmVzdWx0U2VsZWN0b3JdXG4gKiBBIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHZhbHVlIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiYXNlZCBvbiB0aGUgdmFsdWVzXG4gKiBhbmQgdGhlIGluZGljZXMgb2YgdGhlIHNvdXJjZSAob3V0ZXIpIGVtaXNzaW9uIGFuZCB0aGUgaW5uZXIgT2JzZXJ2YWJsZVxuICogZW1pc3Npb24uIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gYXJlOlxuICogLSBgb3V0ZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogLSBgb3V0ZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlXG4gKiBwcm9qZWN0aW9uIGZ1bmN0aW9uIChhbmQgdGhlIG9wdGlvbmFsIGByZXN1bHRTZWxlY3RvcmApIHRvIGVhY2ggaXRlbSBlbWl0dGVkXG4gKiBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYW5kIHRha2luZyBvbmx5IHRoZSB2YWx1ZXMgZnJvbSB0aGUgbW9zdCByZWNlbnRseVxuICogcHJvamVjdGVkIGlubmVyIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHN3aXRjaE1hcFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gc3dpdGNoTWFwKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgU3dpdGNoTWFwT3BlcmF0b3IocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpKTtcbn1cbmV4cG9ydHMuc3dpdGNoTWFwID0gc3dpdGNoTWFwO1xudmFyIFN3aXRjaE1hcE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTd2l0Y2hNYXBPcGVyYXRvcihwcm9qZWN0LCByZXN1bHRTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgfVxuICAgIFN3aXRjaE1hcE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgU3dpdGNoTWFwU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QsIHRoaXMucmVzdWx0U2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hNYXBPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFN3aXRjaE1hcFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTd2l0Y2hNYXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN3aXRjaE1hcFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgU3dpdGNoTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleCsrO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcm9qZWN0KHZhbHVlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbm5lclN1YihyZXN1bHQsIHZhbHVlLCBpbmRleCk7XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5faW5uZXJTdWIgPSBmdW5jdGlvbiAocmVzdWx0LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGlubmVyU3Vic2NyaXB0aW9uID0gdGhpcy5pbm5lclN1YnNjcmlwdGlvbjtcbiAgICAgICAgaWYgKGlubmVyU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBpbm5lclN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkKHRoaXMuaW5uZXJTdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHJlc3VsdCwgdmFsdWUsIGluZGV4KSk7XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbm5lclN1YnNjcmlwdGlvbiA9IHRoaXMuaW5uZXJTdWJzY3JpcHRpb247XG4gICAgICAgIGlmICghaW5uZXJTdWJzY3JpcHRpb24gfHwgaW5uZXJTdWJzY3JpcHRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5uZXJTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgIH07XG4gICAgU3dpdGNoTWFwU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoaW5uZXJTdWIpO1xuICAgICAgICB0aGlzLmlubmVyU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl90cnlOb3RpZnlOZXh0KG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGlubmVyVmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fdHJ5Tm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnJlc3VsdFNlbGVjdG9yKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQocmVzdWx0KTtcbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hNYXBTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN3aXRjaE1hcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogRW1pdHMgdGhlIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB1bnRpbCBhIGBub3RpZmllcmBcbiAqIE9ic2VydmFibGUgZW1pdHMgYSB2YWx1ZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TGV0cyB2YWx1ZXMgcGFzcyB1bnRpbCBhIHNlY29uZCBPYnNlcnZhYmxlLFxuICogYG5vdGlmaWVyYCwgZW1pdHMgc29tZXRoaW5nLiBUaGVuLCBpdCBjb21wbGV0ZXMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvdGFrZVVudGlsLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGB0YWtlVW50aWxgIHN1YnNjcmliZXMgYW5kIGJlZ2lucyBtaXJyb3JpbmcgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBJdCBhbHNvXG4gKiBtb25pdG9ycyBhIHNlY29uZCBPYnNlcnZhYmxlLCBgbm90aWZpZXJgIHRoYXQgeW91IHByb3ZpZGUuIElmIHRoZSBgbm90aWZpZXJgXG4gKiBlbWl0cyBhIHZhbHVlIG9yIGEgY29tcGxldGUgbm90aWZpY2F0aW9uLCB0aGUgb3V0cHV0IE9ic2VydmFibGUgc3RvcHNcbiAqIG1pcnJvcmluZyB0aGUgc291cmNlIE9ic2VydmFibGUgYW5kIGNvbXBsZXRlcy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5UaWNrIGV2ZXJ5IHNlY29uZCB1bnRpbCB0aGUgZmlyc3QgY2xpY2sgaGFwcGVuczwvY2FwdGlvbj5cbiAqIHZhciBpbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGludGVydmFsLnRha2VVbnRpbChjbGlja3MpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayB0YWtlfVxuICogQHNlZSB7QGxpbmsgdGFrZUxhc3R9XG4gKiBAc2VlIHtAbGluayB0YWtlV2hpbGV9XG4gKiBAc2VlIHtAbGluayBza2lwfVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gbm90aWZpZXIgVGhlIE9ic2VydmFibGUgd2hvc2UgZmlyc3QgZW1pdHRlZCB2YWx1ZSB3aWxsXG4gKiBjYXVzZSB0aGUgb3V0cHV0IE9ic2VydmFibGUgb2YgYHRha2VVbnRpbGAgdG8gc3RvcCBlbWl0dGluZyB2YWx1ZXMgZnJvbSB0aGVcbiAqIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSB2YWx1ZXMgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIHVudGlsIHN1Y2ggdGltZSBhcyBgbm90aWZpZXJgIGVtaXRzIGl0cyBmaXJzdCB2YWx1ZS5cbiAqIEBtZXRob2QgdGFrZVVudGlsXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB0YWtlVW50aWwobm90aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBUYWtlVW50aWxPcGVyYXRvcihub3RpZmllcikpO1xufVxuZXhwb3J0cy50YWtlVW50aWwgPSB0YWtlVW50aWw7XG52YXIgVGFrZVVudGlsT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRha2VVbnRpbE9wZXJhdG9yKG5vdGlmaWVyKSB7XG4gICAgICAgIHRoaXMubm90aWZpZXIgPSBub3RpZmllcjtcbiAgICB9XG4gICAgVGFrZVVudGlsT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBUYWtlVW50aWxTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMubm90aWZpZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWtlVW50aWxPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFRha2VVbnRpbFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWtlVW50aWxTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRha2VVbnRpbFN1YnNjcmliZXIoZGVzdGluYXRpb24sIG5vdGlmaWVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5ub3RpZmllciA9IG5vdGlmaWVyO1xuICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIG5vdGlmaWVyKSk7XG4gICAgfVxuICAgIFRha2VVbnRpbFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgVGFrZVVudGlsU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIG5vb3BcbiAgICB9O1xuICAgIHJldHVybiBUYWtlVW50aWxTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRha2VVbnRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIEFycmF5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9BcnJheU9ic2VydmFibGUnKTtcbnZhciBpc0FycmF5XzEgPSByZXF1aXJlKCcuLi91dGlsL2lzQXJyYXknKTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xudmFyIGl0ZXJhdG9yXzEgPSByZXF1aXJlKCcuLi9zeW1ib2wvaXRlcmF0b3InKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIEBwYXJhbSBvYnNlcnZhYmxlc1xuICogQHJldHVybiB7T2JzZXJ2YWJsZTxSPn1cbiAqIEBtZXRob2QgemlwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB6aXBQcm90bygpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYnNlcnZhYmxlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGlmdC5jYWxsKHppcFN0YXRpYy5hcHBseSh2b2lkIDAsIFt0aGlzXS5jb25jYXQob2JzZXJ2YWJsZXMpKSk7XG59XG5leHBvcnRzLnppcFByb3RvID0gemlwUHJvdG87XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBDb21iaW5lcyBtdWx0aXBsZSBPYnNlcnZhYmxlcyB0byBjcmVhdGUgYW4gT2JzZXJ2YWJsZSB3aG9zZSB2YWx1ZXMgYXJlIGNhbGN1bGF0ZWQgZnJvbSB0aGUgdmFsdWVzLCBpbiBvcmRlciwgb2YgZWFjaFxuICogb2YgaXRzIGlucHV0IE9ic2VydmFibGVzLlxuICpcbiAqIElmIHRoZSBsYXRlc3QgcGFyYW1ldGVyIGlzIGEgZnVuY3Rpb24sIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBjb21wdXRlIHRoZSBjcmVhdGVkIHZhbHVlIGZyb20gdGhlIGlucHV0IHZhbHVlcy5cbiAqIE90aGVyd2lzZSwgYW4gYXJyYXkgb2YgdGhlIGlucHV0IHZhbHVlcyBpcyByZXR1cm5lZC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db21iaW5lIGFnZSBhbmQgbmFtZSBmcm9tIGRpZmZlcmVudCBzb3VyY2VzPC9jYXB0aW9uPlxuICpcbiAqIGxldCBhZ2UkID0gT2JzZXJ2YWJsZS5vZjxudW1iZXI+KDI3LCAyNSwgMjkpO1xuICogbGV0IG5hbWUkID0gT2JzZXJ2YWJsZS5vZjxzdHJpbmc+KCdGb28nLCAnQmFyJywgJ0JlZXInKTtcbiAqIGxldCBpc0RldiQgPSBPYnNlcnZhYmxlLm9mPGJvb2xlYW4+KHRydWUsIHRydWUsIGZhbHNlKTtcbiAqXG4gKiBPYnNlcnZhYmxlXG4gKiAgICAgLnppcChhZ2UkLFxuICogICAgICAgICAgbmFtZSQsXG4gKiAgICAgICAgICBpc0RldiQsXG4gKiAgICAgICAgICAoYWdlOiBudW1iZXIsIG5hbWU6IHN0cmluZywgaXNEZXY6IGJvb2xlYW4pID0+ICh7IGFnZSwgbmFtZSwgaXNEZXYgfSkpXG4gKiAgICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBvdXRwdXRzXG4gKiAvLyB7IGFnZTogMjcsIG5hbWU6ICdGb28nLCBpc0RldjogdHJ1ZSB9XG4gKiAvLyB7IGFnZTogMjUsIG5hbWU6ICdCYXInLCBpc0RldjogdHJ1ZSB9XG4gKiAvLyB7IGFnZTogMjksIG5hbWU6ICdCZWVyJywgaXNEZXY6IGZhbHNlIH1cbiAqXG4gKiBAcGFyYW0gb2JzZXJ2YWJsZXNcbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj59XG4gKiBAc3RhdGljIHRydWVcbiAqIEBuYW1lIHppcFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gemlwU3RhdGljKCkge1xuICAgIHZhciBvYnNlcnZhYmxlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9ic2VydmFibGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgcHJvamVjdCA9IG9ic2VydmFibGVzW29ic2VydmFibGVzLmxlbmd0aCAtIDFdO1xuICAgIGlmICh0eXBlb2YgcHJvamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvYnNlcnZhYmxlcy5wb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcnJheU9ic2VydmFibGVfMS5BcnJheU9ic2VydmFibGUob2JzZXJ2YWJsZXMpLmxpZnQobmV3IFppcE9wZXJhdG9yKHByb2plY3QpKTtcbn1cbmV4cG9ydHMuemlwU3RhdGljID0gemlwU3RhdGljO1xudmFyIFppcE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBaaXBPcGVyYXRvcihwcm9qZWN0KSB7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgfVxuICAgIFppcE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgWmlwU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QpKTtcbiAgICB9O1xuICAgIHJldHVybiBaaXBPcGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLlppcE9wZXJhdG9yID0gWmlwT3BlcmF0b3I7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFppcFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhaaXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFppcFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByb2plY3QsIHZhbHVlcykge1xuICAgICAgICBpZiAodmFsdWVzID09PSB2b2lkIDApIHsgdmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuaXRlcmF0b3JzID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlID0gMDtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gKHR5cGVvZiBwcm9qZWN0ID09PSAnZnVuY3Rpb24nKSA/IHByb2plY3QgOiBudWxsO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgICB9XG4gICAgWmlwU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9ycyA9IHRoaXMuaXRlcmF0b3JzO1xuICAgICAgICBpZiAoaXNBcnJheV8xLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBpdGVyYXRvcnMucHVzaChuZXcgU3RhdGljQXJyYXlJdGVyYXRvcih2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZVtpdGVyYXRvcl8xLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaXRlcmF0b3JzLnB1c2gobmV3IFN0YXRpY0l0ZXJhdG9yKHZhbHVlW2l0ZXJhdG9yXzEuaXRlcmF0b3JdKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZXJhdG9ycy5wdXNoKG5ldyBaaXBCdWZmZXJJdGVyYXRvcih0aGlzLmRlc3RpbmF0aW9uLCB0aGlzLCB2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpdGVyYXRvcnMgPSB0aGlzLml0ZXJhdG9ycztcbiAgICAgICAgdmFyIGxlbiA9IGl0ZXJhdG9ycy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZSA9IGxlbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JzW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLnN0aWxsVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoaXRlcmF0b3Iuc3Vic2NyaWJlKGl0ZXJhdG9yLCBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZS0tOyAvLyBub3QgYW4gb2JzZXJ2YWJsZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlJbmFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUtLTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFppcFN1YnNjcmliZXIucHJvdG90eXBlLmNoZWNrSXRlcmF0b3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXRlcmF0b3JzID0gdGhpcy5pdGVyYXRvcnM7XG4gICAgICAgIHZhciBsZW4gPSBpdGVyYXRvcnMubGVuZ3RoO1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICAvLyBhYm9ydCBpZiBub3QgYWxsIG9mIHRoZW0gaGF2ZSB2YWx1ZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JzW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvci5oYXNWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXRlcmF0b3IuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hvdWxkQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JzW2ldO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiBpdCdzIGNvbXBsZXRlZCBub3cgdGhhdCB5b3UndmUgZ290dGVuXG4gICAgICAgICAgICAvLyB0aGUgbmV4dCB2YWx1ZS5cbiAgICAgICAgICAgIGlmIChpdGVyYXRvci5oYXNDb21wbGV0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHNob3VsZENvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJncy5wdXNoKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvamVjdCkge1xuICAgICAgICAgICAgdGhpcy5fdHJ5UHJvamVjdChhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZENvbXBsZXRlKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fdHJ5UHJvamVjdCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByb2plY3QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFppcFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLlppcFN1YnNjcmliZXIgPSBaaXBTdWJzY3JpYmVyO1xudmFyIFN0YXRpY0l0ZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0aWNJdGVyYXRvcihpdGVyYXRvcikge1xuICAgICAgICB0aGlzLml0ZXJhdG9yID0gaXRlcmF0b3I7XG4gICAgICAgIHRoaXMubmV4dFJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICB9XG4gICAgU3RhdGljSXRlcmF0b3IucHJvdG90eXBlLmhhc1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFN0YXRpY0l0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5uZXh0UmVzdWx0O1xuICAgICAgICB0aGlzLm5leHRSZXN1bHQgPSB0aGlzLml0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFN0YXRpY0l0ZXJhdG9yLnByb3RvdHlwZS5oYXNDb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXh0UmVzdWx0ID0gdGhpcy5uZXh0UmVzdWx0O1xuICAgICAgICByZXR1cm4gbmV4dFJlc3VsdCAmJiBuZXh0UmVzdWx0LmRvbmU7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGljSXRlcmF0b3I7XG59KCkpO1xudmFyIFN0YXRpY0FycmF5SXRlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRpY0FycmF5SXRlcmF0b3IoYXJyYXkpIHtcbiAgICAgICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICB9XG4gICAgU3RhdGljQXJyYXlJdGVyYXRvci5wcm90b3R5cGVbaXRlcmF0b3JfMS5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU3RhdGljQXJyYXlJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgICAgcmV0dXJuIGkgPCB0aGlzLmxlbmd0aCA/IHsgdmFsdWU6IGFycmF5W2ldLCBkb25lOiBmYWxzZSB9IDogeyB2YWx1ZTogbnVsbCwgZG9uZTogdHJ1ZSB9O1xuICAgIH07XG4gICAgU3RhdGljQXJyYXlJdGVyYXRvci5wcm90b3R5cGUuaGFzVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aCA+IHRoaXMuaW5kZXg7XG4gICAgfTtcbiAgICBTdGF0aWNBcnJheUl0ZXJhdG9yLnByb3RvdHlwZS5oYXNDb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aCA9PT0gdGhpcy5pbmRleDtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0aWNBcnJheUl0ZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgWmlwQnVmZmVySXRlcmF0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhaaXBCdWZmZXJJdGVyYXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBaaXBCdWZmZXJJdGVyYXRvcihkZXN0aW5hdGlvbiwgcGFyZW50LCBvYnNlcnZhYmxlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZSA9IG9ic2VydmFibGU7XG4gICAgICAgIHRoaXMuc3RpbGxVbnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmlzQ29tcGxldGUgPSBmYWxzZTtcbiAgICB9XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlW2l0ZXJhdG9yXzEuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8vIE5PVEU6IHRoZXJlIGlzIGFjdHVhbGx5IGEgbmFtZSBjb2xsaXNpb24gaGVyZSB3aXRoIFN1YnNjcmliZXIubmV4dCBhbmQgSXRlcmF0b3IubmV4dFxuICAgIC8vICAgIHRoaXMgaXMgbGVnaXQgYmVjYXVzZSBgbmV4dCgpYCB3aWxsIG5ldmVyIGJlIGNhbGxlZCBieSBhIHN1YnNjcmlwdGlvbiBpbiB0aGlzIGNhc2UuXG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDAgJiYgdGhpcy5pc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbnVsbCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGJ1ZmZlci5zaGlmdCgpLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGUuaGFzVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5sZW5ndGggPiAwO1xuICAgIH07XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLmhhc0NvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmlzQ29tcGxldGU7XG4gICAgfTtcbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmlzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQubm90aWZ5SW5hY3RpdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaChpbm5lclZhbHVlKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuY2hlY2tJdGVyYXRvcnMoKTtcbiAgICB9O1xuICAgIFppcEJ1ZmZlckl0ZXJhdG9yLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHRoaXMub2JzZXJ2YWJsZSwgdGhpcywgaW5kZXgpO1xuICAgIH07XG4gICAgcmV0dXJuIFppcEJ1ZmZlckl0ZXJhdG9yO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXppcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaXB0aW9uJyk7XG4vKipcbiAqIEEgdW5pdCBvZiB3b3JrIHRvIGJlIGV4ZWN1dGVkIGluIGEge0BsaW5rIFNjaGVkdWxlcn0uIEFuIGFjdGlvbiBpcyB0eXBpY2FsbHlcbiAqIGNyZWF0ZWQgZnJvbSB3aXRoaW4gYSBTY2hlZHVsZXIgYW5kIGFuIFJ4SlMgdXNlciBkb2VzIG5vdCBuZWVkIHRvIGNvbmNlcm5cbiAqIHRoZW1zZWx2ZXMgYWJvdXQgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBhbiBBY3Rpb24uXG4gKlxuICogYGBgdHNcbiAqIGNsYXNzIEFjdGlvbjxUPiBleHRlbmRzIFN1YnNjcmlwdGlvbiB7XG4gKiAgIG5ldyAoc2NoZWR1bGVyOiBTY2hlZHVsZXIsIHdvcms6IChzdGF0ZT86IFQpID0+IHZvaWQpO1xuICogICBzY2hlZHVsZShzdGF0ZT86IFQsIGRlbGF5OiBudW1iZXIgPSAwKTogU3Vic2NyaXB0aW9uO1xuICogfVxuICogYGBgXG4gKlxuICogQGNsYXNzIEFjdGlvbjxUPlxuICovXG52YXIgQWN0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjdGlvbihzY2hlZHVsZXIsIHdvcmspIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyB0aGlzIGFjdGlvbiBvbiBpdHMgcGFyZW50IFNjaGVkdWxlciBmb3IgZXhlY3V0aW9uLiBNYXkgYmUgcGFzc2VkXG4gICAgICogc29tZSBjb250ZXh0IG9iamVjdCwgYHN0YXRlYC4gTWF5IGhhcHBlbiBhdCBzb21lIHBvaW50IGluIHRoZSBmdXR1cmUsXG4gICAgICogYWNjb3JkaW5nIHRvIHRoZSBgZGVsYXlgIHBhcmFtZXRlciwgaWYgc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7VH0gW3N0YXRlXSBTb21lIGNvbnRleHR1YWwgZGF0YSB0aGF0IHRoZSBgd29ya2AgZnVuY3Rpb24gdXNlcyB3aGVuXG4gICAgICogY2FsbGVkIGJ5IHRoZSBTY2hlZHVsZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheV0gVGltZSB0byB3YWl0IGJlZm9yZSBleGVjdXRpbmcgdGhlIHdvcmssIHdoZXJlIHRoZVxuICAgICAqIHRpbWUgdW5pdCBpcyBpbXBsaWNpdCBhbmQgZGVmaW5lZCBieSB0aGUgU2NoZWR1bGVyLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgQWN0aW9uLnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIEFjdGlvbjtcbn0oU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKSk7XG5leHBvcnRzLkFjdGlvbiA9IEFjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFjdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvcm9vdCcpO1xudmFyIEFjdGlvbl8xID0gcmVxdWlyZSgnLi9BY3Rpb24nKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgQXN5bmNBY3Rpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBc3luY0FjdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBc3luY0FjdGlvbihzY2hlZHVsZXIsIHdvcmspIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc2NoZWR1bGVyLCB3b3JrKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMud29yayA9IHdvcms7XG4gICAgICAgIHRoaXMucGVuZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsd2F5cyByZXBsYWNlIHRoZSBjdXJyZW50IHN0YXRlIHdpdGggdGhlIG5ldyBzdGF0ZS5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAvLyBTZXQgdGhlIHBlbmRpbmcgZmxhZyBpbmRpY2F0aW5nIHRoYXQgdGhpcyBhY3Rpb24gaGFzIGJlZW4gc2NoZWR1bGVkLCBvclxuICAgICAgICAvLyBoYXMgcmVjdXJzaXZlbHkgcmVzY2hlZHVsZWQgaXRzZWxmLlxuICAgICAgICB0aGlzLnBlbmRpbmcgPSB0cnVlO1xuICAgICAgICB2YXIgaWQgPSB0aGlzLmlkO1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEltcG9ydGFudCBpbXBsZW1lbnRhdGlvbiBub3RlOlxuICAgICAgICAvL1xuICAgICAgICAvLyBBY3Rpb25zIG9ubHkgZXhlY3V0ZSBvbmNlIGJ5IGRlZmF1bHQsIHVubGVzcyByZXNjaGVkdWxlZCBmcm9tIHdpdGhpbiB0aGVcbiAgICAgICAgLy8gc2NoZWR1bGVkIGNhbGxiYWNrLiBUaGlzIGFsbG93cyB1cyB0byBpbXBsZW1lbnQgc2luZ2xlIGFuZCByZXBlYXRcbiAgICAgICAgLy8gYWN0aW9ucyB2aWEgdGhlIHNhbWUgY29kZSBwYXRoLCB3aXRob3V0IGFkZGluZyBBUEkgc3VyZmFjZSBhcmVhLCBhcyB3ZWxsXG4gICAgICAgIC8vIGFzIG1pbWljIHRyYWRpdGlvbmFsIHJlY3Vyc2lvbiBidXQgYWNyb3NzIGFzeW5jaHJvbm91cyBib3VuZGFyaWVzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBIb3dldmVyLCBKUyBydW50aW1lcyBhbmQgdGltZXJzIGRpc3Rpbmd1aXNoIGJldHdlZW4gaW50ZXJ2YWxzIGFjaGlldmVkIGJ5XG4gICAgICAgIC8vIHNlcmlhbCBgc2V0VGltZW91dGAgY2FsbHMgdnMuIGEgc2luZ2xlIGBzZXRJbnRlcnZhbGAgY2FsbC4gQW4gaW50ZXJ2YWwgb2ZcbiAgICAgICAgLy8gc2VyaWFsIGBzZXRUaW1lb3V0YCBjYWxscyBjYW4gYmUgaW5kaXZpZHVhbGx5IGRlbGF5ZWQsIHdoaWNoIGRlbGF5c1xuICAgICAgICAvLyBzY2hlZHVsaW5nIHRoZSBuZXh0IGBzZXRUaW1lb3V0YCwgYW5kIHNvIG9uLiBgc2V0SW50ZXJ2YWxgIGF0dGVtcHRzIHRvXG4gICAgICAgIC8vIGd1YXJhbnRlZSB0aGUgaW50ZXJ2YWwgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkIG1vcmUgcHJlY2lzZWx5IHRvIHRoZVxuICAgICAgICAvLyBpbnRlcnZhbCBwZXJpb2QsIHJlZ2FyZGxlc3Mgb2YgbG9hZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlcmVmb3JlLCB3ZSB1c2UgYHNldEludGVydmFsYCB0byBzY2hlZHVsZSBzaW5nbGUgYW5kIHJlcGVhdCBhY3Rpb25zLlxuICAgICAgICAvLyBJZiB0aGUgYWN0aW9uIHJlc2NoZWR1bGVzIGl0c2VsZiB3aXRoIHRoZSBzYW1lIGRlbGF5LCB0aGUgaW50ZXJ2YWwgaXMgbm90XG4gICAgICAgIC8vIGNhbmNlbGVkLiBJZiB0aGUgYWN0aW9uIGRvZXNuJ3QgcmVzY2hlZHVsZSwgb3IgcmVzY2hlZHVsZXMgd2l0aCBhXG4gICAgICAgIC8vIGRpZmZlcmVudCBkZWxheSwgdGhlIGludGVydmFsIHdpbGwgYmUgY2FuY2VsZWQgYWZ0ZXIgc2NoZWR1bGVkIGNhbGxiYWNrXG4gICAgICAgIC8vIGV4ZWN1dGlvbi5cbiAgICAgICAgLy9cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSB0aGlzLnJlY3ljbGVBc3luY0lkKHNjaGVkdWxlciwgaWQsIGRlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgICAgIC8vIElmIHRoaXMgYWN0aW9uIGhhcyBhbHJlYWR5IGFuIGFzeW5jIElkLCBkb24ndCByZXF1ZXN0IGEgbmV3IG9uZS5cbiAgICAgICAgdGhpcy5pZCA9IHRoaXMuaWQgfHwgdGhpcy5yZXF1ZXN0QXN5bmNJZChzY2hlZHVsZXIsIHRoaXMuaWQsIGRlbGF5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUucmVxdWVzdEFzeW5jSWQgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBpZCwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIHJldHVybiByb290XzEucm9vdC5zZXRJbnRlcnZhbChzY2hlZHVsZXIuZmx1c2guYmluZChzY2hlZHVsZXIsIHRoaXMpLCBkZWxheSk7XG4gICAgfTtcbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUucmVjeWNsZUFzeW5jSWQgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBpZCwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIC8vIElmIHRoaXMgYWN0aW9uIGlzIHJlc2NoZWR1bGVkIHdpdGggdGhlIHNhbWUgZGVsYXkgdGltZSwgZG9uJ3QgY2xlYXIgdGhlIGludGVydmFsIGlkLlxuICAgICAgICBpZiAoZGVsYXkgIT09IG51bGwgJiYgdGhpcy5kZWxheSA9PT0gZGVsYXkgJiYgdGhpcy5wZW5kaW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgaWYgdGhlIGFjdGlvbidzIGRlbGF5IHRpbWUgaXMgZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgZGVsYXksXG4gICAgICAgIC8vIG9yIHRoZSBhY3Rpb24gaGFzIGJlZW4gcmVzY2hlZHVsZWQgYmVmb3JlIGl0J3MgZXhlY3V0ZWQsIGNsZWFyIHRoZSBpbnRlcnZhbCBpZFxuICAgICAgICByZXR1cm4gcm9vdF8xLnJvb3QuY2xlYXJJbnRlcnZhbChpZCkgJiYgdW5kZWZpbmVkIHx8IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEltbWVkaWF0ZWx5IGV4ZWN1dGVzIHRoaXMgYWN0aW9uIGFuZCB0aGUgYHdvcmtgIGl0IGNvbnRhaW5zLlxuICAgICAqIEByZXR1cm4ge2FueX1cbiAgICAgKi9cbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdleGVjdXRpbmcgYSBjYW5jZWxsZWQgYWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHZhciBlcnJvciA9IHRoaXMuX2V4ZWN1dGUoc3RhdGUsIGRlbGF5KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wZW5kaW5nID09PSBmYWxzZSAmJiB0aGlzLmlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIERlcXVldWUgaWYgdGhlIGFjdGlvbiBkaWRuJ3QgcmVzY2hlZHVsZSBpdHNlbGYuIERvbid0IGNhbGxcbiAgICAgICAgICAgIC8vIHVuc3Vic2NyaWJlKCksIGJlY2F1c2UgdGhlIGFjdGlvbiBjb3VsZCByZXNjaGVkdWxlIGxhdGVyLlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6XG4gICAgICAgICAgICAvLyBgYGBcbiAgICAgICAgICAgIC8vIHNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiBkb1dvcmsoY291bnRlcikge1xuICAgICAgICAgICAgLy8gICAvKiAuLi4gSSdtIGEgYnVzeSB3b3JrZXIgYmVlIC4uLiAqL1xuICAgICAgICAgICAgLy8gICB2YXIgb3JpZ2luYWxBY3Rpb24gPSB0aGlzO1xuICAgICAgICAgICAgLy8gICAvKiB3YWl0IDEwMG1zIGJlZm9yZSByZXNjaGVkdWxpbmcgdGhlIGFjdGlvbiAqL1xuICAgICAgICAgICAgLy8gICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vICAgICBvcmlnaW5hbEFjdGlvbi5zY2hlZHVsZShjb3VudGVyICsgMSk7XG4gICAgICAgICAgICAvLyAgIH0sIDEwMCk7XG4gICAgICAgICAgICAvLyB9LCAxMDAwKTtcbiAgICAgICAgICAgIC8vIGBgYFxuICAgICAgICAgICAgdGhpcy5pZCA9IHRoaXMucmVjeWNsZUFzeW5jSWQodGhpcy5zY2hlZHVsZXIsIHRoaXMuaWQsIG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUuX2V4ZWN1dGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlbGF5KSB7XG4gICAgICAgIHZhciBlcnJvcmVkID0gZmFsc2U7XG4gICAgICAgIHZhciBlcnJvclZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy53b3JrKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3JlZCA9IHRydWU7XG4gICAgICAgICAgICBlcnJvclZhbHVlID0gISFlICYmIGUgfHwgbmV3IEVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcmVkKSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JWYWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5pZDtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICB2YXIgYWN0aW9ucyA9IHNjaGVkdWxlci5hY3Rpb25zO1xuICAgICAgICB2YXIgaW5kZXggPSBhY3Rpb25zLmluZGV4T2YodGhpcyk7XG4gICAgICAgIHRoaXMud29yayA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBudWxsO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSB0aGlzLnJlY3ljbGVBc3luY0lkKHNjaGVkdWxlciwgaWQsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVsYXkgPSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIEFzeW5jQWN0aW9uO1xufShBY3Rpb25fMS5BY3Rpb24pKTtcbmV4cG9ydHMuQXN5bmNBY3Rpb24gPSBBc3luY0FjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzeW5jQWN0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuLi9TY2hlZHVsZXInKTtcbnZhciBBc3luY1NjaGVkdWxlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFzeW5jU2NoZWR1bGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFzeW5jU2NoZWR1bGVyKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciB0aGUgU2NoZWR1bGVyIGlzIGN1cnJlbnRseSBleGVjdXRpbmcgYSBiYXRjaCBvZlxuICAgICAgICAgKiBxdWV1ZWQgYWN0aW9ucy5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaW50ZXJuYWwgSUQgdXNlZCB0byB0cmFjayB0aGUgbGF0ZXN0IGFzeW5jaHJvbm91cyB0YXNrIHN1Y2ggYXMgdGhvc2VcbiAgICAgICAgICogY29taW5nIGZyb20gYHNldFRpbWVvdXRgLCBgc2V0SW50ZXJ2YWxgLCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCwgYW5kXG4gICAgICAgICAqIG90aGVycy5cbiAgICAgICAgICogQHR5cGUge2FueX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2NoZWR1bGVkID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBBc3luY1NjaGVkdWxlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHZhciBhY3Rpb25zID0gdGhpcy5hY3Rpb25zO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChhY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgPSBhY3Rpb24uZXhlY3V0ZShhY3Rpb24uc3RhdGUsIGFjdGlvbi5kZWxheSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoYWN0aW9uID0gYWN0aW9ucy5zaGlmdCgpKTsgLy8gZXhoYXVzdCB0aGUgc2NoZWR1bGVyIHF1ZXVlXG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgd2hpbGUgKGFjdGlvbiA9IGFjdGlvbnMuc2hpZnQoKSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBc3luY1NjaGVkdWxlcjtcbn0oU2NoZWR1bGVyXzEuU2NoZWR1bGVyKSk7XG5leHBvcnRzLkFzeW5jU2NoZWR1bGVyID0gQXN5bmNTY2hlZHVsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bc3luY1NjaGVkdWxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBBc3luY0FjdGlvbl8xID0gcmVxdWlyZSgnLi9Bc3luY0FjdGlvbicpO1xudmFyIEFzeW5jU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuL0FzeW5jU2NoZWR1bGVyJyk7XG4vKipcbiAqXG4gKiBBc3luYyBTY2hlZHVsZXJcbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+U2NoZWR1bGUgdGFzayBhcyBpZiB5b3UgdXNlZCBzZXRUaW1lb3V0KHRhc2ssIGR1cmF0aW9uKTwvc3Bhbj5cbiAqXG4gKiBgYXN5bmNgIHNjaGVkdWxlciBzY2hlZHVsZXMgdGFza3MgYXN5bmNocm9ub3VzbHksIGJ5IHB1dHRpbmcgdGhlbSBvbiB0aGUgSmF2YVNjcmlwdFxuICogZXZlbnQgbG9vcCBxdWV1ZS4gSXQgaXMgYmVzdCB1c2VkIHRvIGRlbGF5IHRhc2tzIGluIHRpbWUgb3IgdG8gc2NoZWR1bGUgdGFza3MgcmVwZWF0aW5nXG4gKiBpbiBpbnRlcnZhbHMuXG4gKlxuICogSWYgeW91IGp1c3Qgd2FudCB0byBcImRlZmVyXCIgdGFzaywgdGhhdCBpcyB0byBwZXJmb3JtIGl0IHJpZ2h0IGFmdGVyIGN1cnJlbnRseVxuICogZXhlY3V0aW5nIHN5bmNocm9ub3VzIGNvZGUgZW5kcyAoY29tbW9ubHkgYWNoaWV2ZWQgYnkgYHNldFRpbWVvdXQoZGVmZXJyZWRUYXNrLCAwKWApLFxuICogYmV0dGVyIGNob2ljZSB3aWxsIGJlIHRoZSB7QGxpbmsgYXNhcH0gc2NoZWR1bGVyLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlVzZSBhc3luYyBzY2hlZHVsZXIgdG8gZGVsYXkgdGFzazwvY2FwdGlvbj5cbiAqIGNvbnN0IHRhc2sgPSAoKSA9PiBjb25zb2xlLmxvZygnaXQgd29ya3MhJyk7XG4gKlxuICogUnguU2NoZWR1bGVyLmFzeW5jLnNjaGVkdWxlKHRhc2ssIDIwMDApO1xuICpcbiAqIC8vIEFmdGVyIDIgc2Vjb25kcyBsb2dzOlxuICogLy8gXCJpdCB3b3JrcyFcIlxuICpcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Vc2UgYXN5bmMgc2NoZWR1bGVyIHRvIHJlcGVhdCB0YXNrIGluIGludGVydmFsczwvY2FwdGlvbj5cbiAqIGZ1bmN0aW9uIHRhc2soc3RhdGUpIHtcbiAqICAgY29uc29sZS5sb2coc3RhdGUpO1xuICogICB0aGlzLnNjaGVkdWxlKHN0YXRlICsgMSwgMTAwMCk7IC8vIGB0aGlzYCByZWZlcmVuY2VzIGN1cnJlbnRseSBleGVjdXRpbmcgQWN0aW9uLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIHdlIHJlc2NoZWR1bGUgd2l0aCBuZXcgc3RhdGUgYW5kIGRlbGF5XG4gKiB9XG4gKlxuICogUnguU2NoZWR1bGVyLmFzeW5jLnNjaGVkdWxlKHRhc2ssIDMwMDAsIDApO1xuICpcbiAqIC8vIExvZ3M6XG4gKiAvLyAwIGFmdGVyIDNzXG4gKiAvLyAxIGFmdGVyIDRzXG4gKiAvLyAyIGFmdGVyIDVzXG4gKiAvLyAzIGFmdGVyIDZzXG4gKlxuICogQHN0YXRpYyB0cnVlXG4gKiBAbmFtZSBhc3luY1xuICogQG93bmVyIFNjaGVkdWxlclxuICovXG5leHBvcnRzLmFzeW5jID0gbmV3IEFzeW5jU2NoZWR1bGVyXzEuQXN5bmNTY2hlZHVsZXIoQXN5bmNBY3Rpb25fMS5Bc3luY0FjdGlvbik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3luYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi91dGlsL3Jvb3QnKTtcbmZ1bmN0aW9uIHN5bWJvbEl0ZXJhdG9yUG9ueWZpbGwocm9vdCkge1xuICAgIHZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoIVN5bWJvbC5pdGVyYXRvcikge1xuICAgICAgICAgICAgU3ltYm9sLml0ZXJhdG9yID0gU3ltYm9sKCdpdGVyYXRvciBwb2x5ZmlsbCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTeW1ib2wuaXRlcmF0b3I7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBbZm9yIE1vemlsbGEgR2Vja28gMjctMzU6XShodHRwczovL216bC5sYS8yZXdFMXpDKVxuICAgICAgICB2YXIgU2V0XzEgPSByb290LlNldDtcbiAgICAgICAgaWYgKFNldF8xICYmIHR5cGVvZiBuZXcgU2V0XzEoKVsnQEBpdGVyYXRvciddID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0BAaXRlcmF0b3InO1xuICAgICAgICB9XG4gICAgICAgIHZhciBNYXBfMSA9IHJvb3QuTWFwO1xuICAgICAgICAvLyByZXF1aXJlZCBmb3IgY29tcGF0YWJpbGl0eSB3aXRoIGVzNi1zaGltXG4gICAgICAgIGlmIChNYXBfMSkge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhNYXBfMS5wcm90b3R5cGUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgLy8gYWNjb3JkaW5nIHRvIHNwZWMsIE1hcC5wcm90b3R5cGVbQEBpdGVyYXRvcl0gYW5kIE1hcC5vcm90b3R5cGUuZW50cmllcyBtdXN0IGJlIGVxdWFsLlxuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdlbnRyaWVzJyAmJiBrZXkgIT09ICdzaXplJyAmJiBNYXBfMS5wcm90b3R5cGVba2V5XSA9PT0gTWFwXzEucHJvdG90eXBlWydlbnRyaWVzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdAQGl0ZXJhdG9yJztcbiAgICB9XG59XG5leHBvcnRzLnN5bWJvbEl0ZXJhdG9yUG9ueWZpbGwgPSBzeW1ib2xJdGVyYXRvclBvbnlmaWxsO1xuZXhwb3J0cy5pdGVyYXRvciA9IHN5bWJvbEl0ZXJhdG9yUG9ueWZpbGwocm9vdF8xLnJvb3QpO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2UgaXRlcmF0b3IgaW5zdGVhZFxuICovXG5leHBvcnRzLiQkaXRlcmF0b3IgPSBleHBvcnRzLml0ZXJhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXRlcmF0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9yb290Jyk7XG5mdW5jdGlvbiBnZXRTeW1ib2xPYnNlcnZhYmxlKGNvbnRleHQpIHtcbiAgICB2YXIgJCRvYnNlcnZhYmxlO1xuICAgIHZhciBTeW1ib2wgPSBjb250ZXh0LlN5bWJvbDtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoU3ltYm9sLm9ic2VydmFibGUpIHtcbiAgICAgICAgICAgICQkb2JzZXJ2YWJsZSA9IFN5bWJvbC5vYnNlcnZhYmxlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgJCRvYnNlcnZhYmxlID0gU3ltYm9sKCdvYnNlcnZhYmxlJyk7XG4gICAgICAgICAgICBTeW1ib2wub2JzZXJ2YWJsZSA9ICQkb2JzZXJ2YWJsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgJCRvYnNlcnZhYmxlID0gJ0BAb2JzZXJ2YWJsZSc7XG4gICAgfVxuICAgIHJldHVybiAkJG9ic2VydmFibGU7XG59XG5leHBvcnRzLmdldFN5bWJvbE9ic2VydmFibGUgPSBnZXRTeW1ib2xPYnNlcnZhYmxlO1xuZXhwb3J0cy5vYnNlcnZhYmxlID0gZ2V0U3ltYm9sT2JzZXJ2YWJsZShyb290XzEucm9vdCk7XG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSBvYnNlcnZhYmxlIGluc3RlYWRcbiAqL1xuZXhwb3J0cy4kJG9ic2VydmFibGUgPSBleHBvcnRzLm9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvcm9vdCcpO1xudmFyIFN5bWJvbCA9IHJvb3RfMS5yb290LlN5bWJvbDtcbmV4cG9ydHMucnhTdWJzY3JpYmVyID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5mb3IgPT09ICdmdW5jdGlvbicpID9cbiAgICBTeW1ib2wuZm9yKCdyeFN1YnNjcmliZXInKSA6ICdAQHJ4U3Vic2NyaWJlcic7XG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSByeFN1YnNjcmliZXIgaW5zdGVhZFxuICovXG5leHBvcnRzLiQkcnhTdWJzY3JpYmVyID0gZXhwb3J0cy5yeFN1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yeFN1YnNjcmliZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gYW4gYWN0aW9uIGlzIGludmFsaWQgYmVjYXVzZSB0aGUgb2JqZWN0IGhhcyBiZWVuXG4gKiB1bnN1YnNjcmliZWQuXG4gKlxuICogQHNlZSB7QGxpbmsgU3ViamVjdH1cbiAqIEBzZWUge0BsaW5rIEJlaGF2aW9yU3ViamVjdH1cbiAqXG4gKiBAY2xhc3MgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JcbiAqL1xudmFyIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKSB7XG4gICAgICAgIHZhciBlcnIgPSBfc3VwZXIuY2FsbCh0aGlzLCAnb2JqZWN0IHVuc3Vic2NyaWJlZCcpO1xuICAgICAgICB0aGlzLm5hbWUgPSBlcnIubmFtZSA9ICdPYmplY3RVbnN1YnNjcmliZWRFcnJvcic7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBlcnIuc3RhY2s7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yID0gT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYmplY3RVbnN1YnNjcmliZWRFcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiBvbmUgb3IgbW9yZSBlcnJvcnMgaGF2ZSBvY2N1cnJlZCBkdXJpbmcgdGhlXG4gKiBgdW5zdWJzY3JpYmVgIG9mIGEge0BsaW5rIFN1YnNjcmlwdGlvbn0uXG4gKi9cbnZhciBVbnN1YnNjcmlwdGlvbkVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVW5zdWJzY3JpcHRpb25FcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVbnN1YnNjcmlwdGlvbkVycm9yKGVycm9ycykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHZhciBlcnIgPSBFcnJvci5jYWxsKHRoaXMsIGVycm9ycyA/XG4gICAgICAgICAgICBlcnJvcnMubGVuZ3RoICsgXCIgZXJyb3JzIG9jY3VycmVkIGR1cmluZyB1bnN1YnNjcmlwdGlvbjpcXG4gIFwiICsgZXJyb3JzLm1hcChmdW5jdGlvbiAoZXJyLCBpKSB7IHJldHVybiAoKGkgKyAxKSArIFwiKSBcIiArIGVyci50b1N0cmluZygpKTsgfSkuam9pbignXFxuICAnKSA6ICcnKTtcbiAgICAgICAgdGhpcy5uYW1lID0gZXJyLm5hbWUgPSAnVW5zdWJzY3JpcHRpb25FcnJvcic7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBlcnIuc3RhY2s7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4gVW5zdWJzY3JpcHRpb25FcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuVW5zdWJzY3JpcHRpb25FcnJvciA9IFVuc3Vic2NyaXB0aW9uRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1VbnN1YnNjcmlwdGlvbkVycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLy8gdHlwZW9mIGFueSBzbyB0aGF0IGl0IHdlIGRvbid0IGhhdmUgdG8gY2FzdCB3aGVuIGNvbXBhcmluZyBhIHJlc3VsdCB0byB0aGUgZXJyb3Igb2JqZWN0XG5leHBvcnRzLmVycm9yT2JqZWN0ID0geyBlOiB7fSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JPYmplY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IChmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAmJiB0eXBlb2YgeC5sZW5ndGggPT09ICdudW1iZXInOyB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzQXJyYXkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmlzQXJyYXlMaWtlID0gKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICYmIHR5cGVvZiB4Lmxlbmd0aCA9PT0gJ251bWJlcic7IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNBcnJheUxpa2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTigrdmFsdWUpO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0RhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNGdW5jdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBpc0FycmF5XzEgPSByZXF1aXJlKCcuLi91dGlsL2lzQXJyYXknKTtcbmZ1bmN0aW9uIGlzTnVtZXJpYyh2YWwpIHtcbiAgICAvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAobnVsbHx0cnVlfGZhbHNlfFwiXCIpXG4gICAgLy8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuICAgIC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuICAgIC8vIGFkZGluZyAxIGNvcnJlY3RzIGxvc3Mgb2YgcHJlY2lzaW9uIGZyb20gcGFyc2VGbG9hdCAoIzE1MTAwKVxuICAgIHJldHVybiAhaXNBcnJheV8xLmlzQXJyYXkodmFsKSAmJiAodmFsIC0gcGFyc2VGbG9hdCh2YWwpICsgMSkgPj0gMDtcbn1cbmV4cG9ydHMuaXNOdW1lcmljID0gaXNOdW1lcmljO1xuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNOdW1lcmljLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gaXNPYmplY3QoeCkge1xuICAgIHJldHVybiB4ICE9IG51bGwgJiYgdHlwZW9mIHggPT09ICdvYmplY3QnO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNPYmplY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBpc1Byb21pc2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNQcm9taXNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gaXNTY2hlZHVsZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnNjaGVkdWxlID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc1NjaGVkdWxlciA9IGlzU2NoZWR1bGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNTY2hlZHVsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb21tb25KUyAvIE5vZGUgaGF2ZSBnbG9iYWwgY29udGV4dCBleHBvc2VkIGFzIFwiZ2xvYmFsXCIgdmFyaWFibGUuXG4vLyBXZSBkb24ndCB3YW50IHRvIGluY2x1ZGUgdGhlIHdob2xlIG5vZGUuZC50cyB0aGlzIHRoaXMgY29tcGlsYXRpb24gdW5pdCBzbyB3ZSdsbCBqdXN0IGZha2Vcbi8vIHRoZSBnbG9iYWwgXCJnbG9iYWxcIiB2YXIgZm9yIG5vdy5cbnZhciBfX3dpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdztcbnZhciBfX3NlbGYgPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSAmJiBzZWxmO1xudmFyIF9fZ2xvYmFsID0gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsO1xudmFyIF9yb290ID0gX193aW5kb3cgfHwgX19nbG9iYWwgfHwgX19zZWxmO1xuZXhwb3J0cy5yb290ID0gX3Jvb3Q7XG4vLyBXb3JrYXJvdW5kIENsb3N1cmUgQ29tcGlsZXIgcmVzdHJpY3Rpb246IFRoZSBib2R5IG9mIGEgZ29vZy5tb2R1bGUgY2Fubm90IHVzZSB0aHJvdy5cbi8vIFRoaXMgaXMgbmVlZGVkIHdoZW4gdXNlZCB3aXRoIGFuZ3VsYXIvdHNpY2tsZSB3aGljaCBpbnNlcnRzIGEgZ29vZy5tb2R1bGUgc3RhdGVtZW50LlxuLy8gV3JhcCBpbiBJSUZFXG4oZnVuY3Rpb24gKCkge1xuICAgIGlmICghX3Jvb3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSeEpTIGNvdWxkIG5vdCBmaW5kIGFueSBnbG9iYWwgY29udGV4dCAod2luZG93LCBzZWxmLCBnbG9iYWwpJyk7XG4gICAgfVxufSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvb3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi9yb290Jyk7XG52YXIgaXNBcnJheUxpa2VfMSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcbnZhciBpc1Byb21pc2VfMSA9IHJlcXVpcmUoJy4vaXNQcm9taXNlJyk7XG52YXIgaXNPYmplY3RfMSA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgaXRlcmF0b3JfMSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9pdGVyYXRvcicpO1xudmFyIElubmVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vSW5uZXJTdWJzY3JpYmVyJyk7XG52YXIgb2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vc3ltYm9sL29ic2VydmFibGUnKTtcbmZ1bmN0aW9uIHN1YnNjcmliZVRvUmVzdWx0KG91dGVyU3Vic2NyaWJlciwgcmVzdWx0LCBvdXRlclZhbHVlLCBvdXRlckluZGV4KSB7XG4gICAgdmFyIGRlc3RpbmF0aW9uID0gbmV3IElubmVyU3Vic2NyaWJlcl8xLklubmVyU3Vic2NyaWJlcihvdXRlclN1YnNjcmliZXIsIG91dGVyVmFsdWUsIG91dGVySW5kZXgpO1xuICAgIGlmIChkZXN0aW5hdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkge1xuICAgICAgICBpZiAocmVzdWx0Ll9pc1NjYWxhcikge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWJzY3JpYmUoZGVzdGluYXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlXzEuaXNBcnJheUxpa2UocmVzdWx0KSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmVzdWx0Lmxlbmd0aDsgaSA8IGxlbiAmJiAhZGVzdGluYXRpb24uY2xvc2VkOyBpKyspIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQocmVzdWx0W2ldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlc3RpbmF0aW9uLmNsb3NlZCkge1xuICAgICAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1Byb21pc2VfMS5pc1Byb21pc2UocmVzdWx0KSkge1xuICAgICAgICByZXN1bHQudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghZGVzdGluYXRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gZGVzdGluYXRpb24uZXJyb3IoZXJyKTsgfSlcbiAgICAgICAgICAgIC50aGVuKG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIC8vIEVzY2FwaW5nIHRoZSBQcm9taXNlIHRyYXA6IGdsb2JhbGx5IHRocm93IHVuaGFuZGxlZCBlcnJvcnNcbiAgICAgICAgICAgIHJvb3RfMS5yb290LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyB0aHJvdyBlcnI7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdFtpdGVyYXRvcl8xLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSByZXN1bHRbaXRlcmF0b3JfMS5pdGVyYXRvcl0oKTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoaXRlbS5kb25lKSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQoaXRlbS52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoZGVzdGluYXRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdFtvYnNlcnZhYmxlXzEub2JzZXJ2YWJsZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIG9icyA9IHJlc3VsdFtvYnNlcnZhYmxlXzEub2JzZXJ2YWJsZV0oKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvYnMuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihuZXcgVHlwZUVycm9yKCdQcm92aWRlZCBvYmplY3QgZG9lcyBub3QgY29ycmVjdGx5IGltcGxlbWVudCBTeW1ib2wub2JzZXJ2YWJsZScpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvYnMuc3Vic2NyaWJlKG5ldyBJbm5lclN1YnNjcmliZXJfMS5Jbm5lclN1YnNjcmliZXIob3V0ZXJTdWJzY3JpYmVyLCBvdXRlclZhbHVlLCBvdXRlckluZGV4KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGlzT2JqZWN0XzEuaXNPYmplY3QocmVzdWx0KSA/ICdhbiBpbnZhbGlkIG9iamVjdCcgOiBcIidcIiArIHJlc3VsdCArIFwiJ1wiO1xuICAgICAgICB2YXIgbXNnID0gKFwiWW91IHByb3ZpZGVkIFwiICsgdmFsdWUgKyBcIiB3aGVyZSBhIHN0cmVhbSB3YXMgZXhwZWN0ZWQuXCIpXG4gICAgICAgICAgICArICcgWW91IGNhbiBwcm92aWRlIGFuIE9ic2VydmFibGUsIFByb21pc2UsIEFycmF5LCBvciBJdGVyYWJsZS4nO1xuICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihuZXcgVHlwZUVycm9yKG1zZykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMuc3Vic2NyaWJlVG9SZXN1bHQgPSBzdWJzY3JpYmVUb1Jlc3VsdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnNjcmliZVRvUmVzdWx0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciByeFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9yeFN1YnNjcmliZXInKTtcbnZhciBPYnNlcnZlcl8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2ZXInKTtcbmZ1bmN0aW9uIHRvU3Vic2NyaWJlcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgaWYgKG5leHRPck9ic2VydmVyKSB7XG4gICAgICAgIGlmIChuZXh0T3JPYnNlcnZlciBpbnN0YW5jZW9mIFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dE9yT2JzZXJ2ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRPck9ic2VydmVyW3J4U3Vic2NyaWJlcl8xLnJ4U3Vic2NyaWJlcl0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0T3JPYnNlcnZlcltyeFN1YnNjcmliZXJfMS5yeFN1YnNjcmliZXJdKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFuZXh0T3JPYnNlcnZlciAmJiAhZXJyb3IgJiYgIWNvbXBsZXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIoT2JzZXJ2ZXJfMS5lbXB0eSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSk7XG59XG5leHBvcnRzLnRvU3Vic2NyaWJlciA9IHRvU3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvU3Vic2NyaWJlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi9lcnJvck9iamVjdCcpO1xudmFyIHRyeUNhdGNoVGFyZ2V0O1xuZnVuY3Rpb24gdHJ5Q2F0Y2hlcigpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHJ5Q2F0Y2hUYXJnZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lID0gZTtcbiAgICAgICAgcmV0dXJuIGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3Q7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJ5Q2F0Y2goZm4pIHtcbiAgICB0cnlDYXRjaFRhcmdldCA9IGZuO1xuICAgIHJldHVybiB0cnlDYXRjaGVyO1xufVxuZXhwb3J0cy50cnlDYXRjaCA9IHRyeUNhdGNoO1xuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJ5Q2F0Y2guanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBcnJheWlzaCA9IHJlcXVpcmUoJ2lzLWFycmF5aXNoJyk7XG5cbnZhciBjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG52YXIgc3dpenpsZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3dpenpsZShhcmdzKSB7XG5cdHZhciByZXN1bHRzID0gW107XG5cblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHR2YXIgYXJnID0gYXJnc1tpXTtcblxuXHRcdGlmIChpc0FycmF5aXNoKGFyZykpIHtcblx0XHRcdC8vIGh0dHA6Ly9qc3BlcmYuY29tL2phdmFzY3JpcHQtYXJyYXktY29uY2F0LXZzLXB1c2gvOThcblx0XHRcdHJlc3VsdHMgPSBjb25jYXQuY2FsbChyZXN1bHRzLCBzbGljZS5jYWxsKGFyZykpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN1bHRzLnB1c2goYXJnKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbnN3aXp6bGUud3JhcCA9IGZ1bmN0aW9uIChmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBmbihzd2l6emxlKGFyZ3VtZW50cykpO1xuXHR9O1xufTtcbiIsIi8vIENvcHlyaWdodCAyMDE0IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vICAgICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vICAgICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuIWZ1bmN0aW9uKGEsYil7dmFyIGM9e30sZD17fSxlPXt9LGY9bnVsbDshZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhKXJldHVybiBhO3ZhciBiPXt9O2Zvcih2YXIgYyBpbiBhKWJbY109YVtjXTtyZXR1cm4gYn1mdW5jdGlvbiBkKCl7dGhpcy5fZGVsYXk9MCx0aGlzLl9lbmREZWxheT0wLHRoaXMuX2ZpbGw9XCJub25lXCIsdGhpcy5faXRlcmF0aW9uU3RhcnQ9MCx0aGlzLl9pdGVyYXRpb25zPTEsdGhpcy5fZHVyYXRpb249MCx0aGlzLl9wbGF5YmFja1JhdGU9MSx0aGlzLl9kaXJlY3Rpb249XCJub3JtYWxcIix0aGlzLl9lYXNpbmc9XCJsaW5lYXJcIix0aGlzLl9lYXNpbmdGdW5jdGlvbj14fWZ1bmN0aW9uIGUoKXtyZXR1cm4gYS5pc0RlcHJlY2F0ZWQoXCJJbnZhbGlkIHRpbWluZyBpbnB1dHNcIixcIjIwMTYtMDMtMDJcIixcIlR5cGVFcnJvciBleGNlcHRpb25zIHdpbGwgYmUgdGhyb3duIGluc3RlYWQuXCIsITApfWZ1bmN0aW9uIGYoYixjLGUpe3ZhciBmPW5ldyBkO3JldHVybiBjJiYoZi5maWxsPVwiYm90aFwiLGYuZHVyYXRpb249XCJhdXRvXCIpLFwibnVtYmVyXCIhPXR5cGVvZiBifHxpc05hTihiKT92b2lkIDAhPT1iJiZPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhiKS5mb3JFYWNoKGZ1bmN0aW9uKGMpe2lmKFwiYXV0b1wiIT1iW2NdKXtpZigoXCJudW1iZXJcIj09dHlwZW9mIGZbY118fFwiZHVyYXRpb25cIj09YykmJihcIm51bWJlclwiIT10eXBlb2YgYltjXXx8aXNOYU4oYltjXSkpKXJldHVybjtpZihcImZpbGxcIj09YyYmLTE9PXYuaW5kZXhPZihiW2NdKSlyZXR1cm47aWYoXCJkaXJlY3Rpb25cIj09YyYmLTE9PXcuaW5kZXhPZihiW2NdKSlyZXR1cm47aWYoXCJwbGF5YmFja1JhdGVcIj09YyYmMSE9PWJbY10mJmEuaXNEZXByZWNhdGVkKFwiQW5pbWF0aW9uRWZmZWN0VGltaW5nLnBsYXliYWNrUmF0ZVwiLFwiMjAxNC0xMS0yOFwiLFwiVXNlIEFuaW1hdGlvbi5wbGF5YmFja1JhdGUgaW5zdGVhZC5cIikpcmV0dXJuO2ZbY109YltjXX19KTpmLmR1cmF0aW9uPWIsZn1mdW5jdGlvbiBnKGEpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiBhJiYoYT1pc05hTihhKT97ZHVyYXRpb246MH06e2R1cmF0aW9uOmF9KSxhfWZ1bmN0aW9uIGgoYixjKXtyZXR1cm4gYj1hLm51bWVyaWNUaW1pbmdUb09iamVjdChiKSxmKGIsYyl9ZnVuY3Rpb24gaShhLGIsYyxkKXtyZXR1cm4gYTwwfHxhPjF8fGM8MHx8Yz4xP3g6ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gZihhLGIsYyl7cmV0dXJuIDMqYSooMS1jKSooMS1jKSpjKzMqYiooMS1jKSpjKmMrYypjKmN9aWYoZTw9MCl7dmFyIGc9MDtyZXR1cm4gYT4wP2c9Yi9hOiFiJiZjPjAmJihnPWQvYyksZyplfWlmKGU+PTEpe3ZhciBoPTA7cmV0dXJuIGM8MT9oPShkLTEpLyhjLTEpOjE9PWMmJmE8MSYmKGg9KGItMSkvKGEtMSkpLDEraCooZS0xKX1mb3IodmFyIGk9MCxqPTE7aTxqOyl7dmFyIGs9KGkraikvMixsPWYoYSxjLGspO2lmKE1hdGguYWJzKGUtbCk8MWUtNSlyZXR1cm4gZihiLGQsayk7bDxlP2k9azpqPWt9cmV0dXJuIGYoYixkLGspfX1mdW5jdGlvbiBqKGEsYil7cmV0dXJuIGZ1bmN0aW9uKGMpe2lmKGM+PTEpcmV0dXJuIDE7dmFyIGQ9MS9hO3JldHVybihjKz1iKmQpLWMlZH19ZnVuY3Rpb24gayhhKXtDfHwoQz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlKSxDLmFuaW1hdGlvblRpbWluZ0Z1bmN0aW9uPVwiXCIsQy5hbmltYXRpb25UaW1pbmdGdW5jdGlvbj1hO3ZhciBiPUMuYW5pbWF0aW9uVGltaW5nRnVuY3Rpb247aWYoXCJcIj09YiYmZSgpKXRocm93IG5ldyBUeXBlRXJyb3IoYStcIiBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgZWFzaW5nXCIpO3JldHVybiBifWZ1bmN0aW9uIGwoYSl7aWYoXCJsaW5lYXJcIj09YSlyZXR1cm4geDt2YXIgYj1FLmV4ZWMoYSk7aWYoYilyZXR1cm4gaS5hcHBseSh0aGlzLGIuc2xpY2UoMSkubWFwKE51bWJlcikpO3ZhciBjPUYuZXhlYyhhKTtyZXR1cm4gYz9qKE51bWJlcihjWzFdKSx7c3RhcnQ6eSxtaWRkbGU6eixlbmQ6QX1bY1syXV0pOkJbYV18fHh9ZnVuY3Rpb24gbShhKXtyZXR1cm4gTWF0aC5hYnMobihhKS9hLnBsYXliYWNrUmF0ZSl9ZnVuY3Rpb24gbihhKXtyZXR1cm4gMD09PWEuZHVyYXRpb258fDA9PT1hLml0ZXJhdGlvbnM/MDphLmR1cmF0aW9uKmEuaXRlcmF0aW9uc31mdW5jdGlvbiBvKGEsYixjKXtpZihudWxsPT1iKXJldHVybiBHO3ZhciBkPWMuZGVsYXkrYStjLmVuZERlbGF5O3JldHVybiBiPE1hdGgubWluKGMuZGVsYXksZCk/SDpiPj1NYXRoLm1pbihjLmRlbGF5K2EsZCk/STpKfWZ1bmN0aW9uIHAoYSxiLGMsZCxlKXtzd2l0Y2goZCl7Y2FzZSBIOnJldHVyblwiYmFja3dhcmRzXCI9PWJ8fFwiYm90aFwiPT1iPzA6bnVsbDtjYXNlIEo6cmV0dXJuIGMtZTtjYXNlIEk6cmV0dXJuXCJmb3J3YXJkc1wiPT1ifHxcImJvdGhcIj09Yj9hOm51bGw7Y2FzZSBHOnJldHVybiBudWxsfX1mdW5jdGlvbiBxKGEsYixjLGQsZSl7dmFyIGY9ZTtyZXR1cm4gMD09PWE/YiE9PUgmJihmKz1jKTpmKz1kL2EsZn1mdW5jdGlvbiByKGEsYixjLGQsZSxmKXt2YXIgZz1hPT09MS8wP2IlMTphJTE7cmV0dXJuIDAhPT1nfHxjIT09SXx8MD09PWR8fDA9PT1lJiYwIT09Znx8KGc9MSksZ31mdW5jdGlvbiBzKGEsYixjLGQpe3JldHVybiBhPT09SSYmYj09PTEvMD8xLzA6MT09PWM/TWF0aC5mbG9vcihkKS0xOk1hdGguZmxvb3IoZCl9ZnVuY3Rpb24gdChhLGIsYyl7dmFyIGQ9YTtpZihcIm5vcm1hbFwiIT09YSYmXCJyZXZlcnNlXCIhPT1hKXt2YXIgZT1iO1wiYWx0ZXJuYXRlLXJldmVyc2VcIj09PWEmJihlKz0xKSxkPVwibm9ybWFsXCIsZSE9PTEvMCYmZSUyIT0wJiYoZD1cInJldmVyc2VcIil9cmV0dXJuXCJub3JtYWxcIj09PWQ/YzoxLWN9ZnVuY3Rpb24gdShhLGIsYyl7dmFyIGQ9byhhLGIsYyksZT1wKGEsYy5maWxsLGIsZCxjLmRlbGF5KTtpZihudWxsPT09ZSlyZXR1cm4gbnVsbDt2YXIgZj1xKGMuZHVyYXRpb24sZCxjLml0ZXJhdGlvbnMsZSxjLml0ZXJhdGlvblN0YXJ0KSxnPXIoZixjLml0ZXJhdGlvblN0YXJ0LGQsYy5pdGVyYXRpb25zLGUsYy5kdXJhdGlvbiksaD1zKGQsYy5pdGVyYXRpb25zLGcsZiksaT10KGMuZGlyZWN0aW9uLGgsZyk7cmV0dXJuIGMuX2Vhc2luZ0Z1bmN0aW9uKGkpfXZhciB2PVwiYmFja3dhcmRzfGZvcndhcmRzfGJvdGh8bm9uZVwiLnNwbGl0KFwifFwiKSx3PVwicmV2ZXJzZXxhbHRlcm5hdGV8YWx0ZXJuYXRlLXJldmVyc2VcIi5zcGxpdChcInxcIikseD1mdW5jdGlvbihhKXtyZXR1cm4gYX07ZC5wcm90b3R5cGU9e19zZXRNZW1iZXI6ZnVuY3Rpb24oYixjKXt0aGlzW1wiX1wiK2JdPWMsdGhpcy5fZWZmZWN0JiYodGhpcy5fZWZmZWN0Ll90aW1pbmdJbnB1dFtiXT1jLHRoaXMuX2VmZmVjdC5fdGltaW5nPWEubm9ybWFsaXplVGltaW5nSW5wdXQodGhpcy5fZWZmZWN0Ll90aW1pbmdJbnB1dCksdGhpcy5fZWZmZWN0LmFjdGl2ZUR1cmF0aW9uPWEuY2FsY3VsYXRlQWN0aXZlRHVyYXRpb24odGhpcy5fZWZmZWN0Ll90aW1pbmcpLHRoaXMuX2VmZmVjdC5fYW5pbWF0aW9uJiZ0aGlzLl9lZmZlY3QuX2FuaW1hdGlvbi5fcmVidWlsZFVuZGVybHlpbmdBbmltYXRpb24oKSl9LGdldCBwbGF5YmFja1JhdGUoKXtyZXR1cm4gdGhpcy5fcGxheWJhY2tSYXRlfSxzZXQgZGVsYXkoYSl7dGhpcy5fc2V0TWVtYmVyKFwiZGVsYXlcIixhKX0sZ2V0IGRlbGF5KCl7cmV0dXJuIHRoaXMuX2RlbGF5fSxzZXQgZW5kRGVsYXkoYSl7dGhpcy5fc2V0TWVtYmVyKFwiZW5kRGVsYXlcIixhKX0sZ2V0IGVuZERlbGF5KCl7cmV0dXJuIHRoaXMuX2VuZERlbGF5fSxzZXQgZmlsbChhKXt0aGlzLl9zZXRNZW1iZXIoXCJmaWxsXCIsYSl9LGdldCBmaWxsKCl7cmV0dXJuIHRoaXMuX2ZpbGx9LHNldCBpdGVyYXRpb25TdGFydChhKXtpZigoaXNOYU4oYSl8fGE8MCkmJmUoKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXRlcmF0aW9uU3RhcnQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIsIHJlY2VpdmVkOiBcIit0aW1pbmcuaXRlcmF0aW9uU3RhcnQpO3RoaXMuX3NldE1lbWJlcihcIml0ZXJhdGlvblN0YXJ0XCIsYSl9LGdldCBpdGVyYXRpb25TdGFydCgpe3JldHVybiB0aGlzLl9pdGVyYXRpb25TdGFydH0sc2V0IGR1cmF0aW9uKGEpe2lmKFwiYXV0b1wiIT1hJiYoaXNOYU4oYSl8fGE8MCkmJmUoKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiZHVyYXRpb24gbXVzdCBiZSBub24tbmVnYXRpdmUgb3IgYXV0bywgcmVjZWl2ZWQ6IFwiK2EpO3RoaXMuX3NldE1lbWJlcihcImR1cmF0aW9uXCIsYSl9LGdldCBkdXJhdGlvbigpe3JldHVybiB0aGlzLl9kdXJhdGlvbn0sc2V0IGRpcmVjdGlvbihhKXt0aGlzLl9zZXRNZW1iZXIoXCJkaXJlY3Rpb25cIixhKX0sZ2V0IGRpcmVjdGlvbigpe3JldHVybiB0aGlzLl9kaXJlY3Rpb259LHNldCBlYXNpbmcoYSl7dGhpcy5fZWFzaW5nRnVuY3Rpb249bChrKGEpKSx0aGlzLl9zZXRNZW1iZXIoXCJlYXNpbmdcIixhKX0sZ2V0IGVhc2luZygpe3JldHVybiB0aGlzLl9lYXNpbmd9LHNldCBpdGVyYXRpb25zKGEpe2lmKChpc05hTihhKXx8YTwwKSYmZSgpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRpb25zIG11c3QgYmUgbm9uLW5lZ2F0aXZlLCByZWNlaXZlZDogXCIrYSk7dGhpcy5fc2V0TWVtYmVyKFwiaXRlcmF0aW9uc1wiLGEpfSxnZXQgaXRlcmF0aW9ucygpe3JldHVybiB0aGlzLl9pdGVyYXRpb25zfX07dmFyIHk9MSx6PS41LEE9MCxCPXtlYXNlOmkoLjI1LC4xLC4yNSwxKSxcImVhc2UtaW5cIjppKC40MiwwLDEsMSksXCJlYXNlLW91dFwiOmkoMCwwLC41OCwxKSxcImVhc2UtaW4tb3V0XCI6aSguNDIsMCwuNTgsMSksXCJzdGVwLXN0YXJ0XCI6aigxLHkpLFwic3RlcC1taWRkbGVcIjpqKDEseiksXCJzdGVwLWVuZFwiOmooMSxBKX0sQz1udWxsLEQ9XCJcXFxccyooLT9cXFxcZCtcXFxcLj9cXFxcZCp8LT9cXFxcLlxcXFxkKylcXFxccypcIixFPW5ldyBSZWdFeHAoXCJjdWJpYy1iZXppZXJcXFxcKFwiK0QrXCIsXCIrRCtcIixcIitEK1wiLFwiK0QrXCJcXFxcKVwiKSxGPS9zdGVwc1xcKFxccyooXFxkKylcXHMqLFxccyooc3RhcnR8bWlkZGxlfGVuZClcXHMqXFwpLyxHPTAsSD0xLEk9MixKPTM7YS5jbG9uZVRpbWluZ0lucHV0PWMsYS5tYWtlVGltaW5nPWYsYS5udW1lcmljVGltaW5nVG9PYmplY3Q9ZyxhLm5vcm1hbGl6ZVRpbWluZ0lucHV0PWgsYS5jYWxjdWxhdGVBY3RpdmVEdXJhdGlvbj1tLGEuY2FsY3VsYXRlSXRlcmF0aW9uUHJvZ3Jlc3M9dSxhLmNhbGN1bGF0ZVBoYXNlPW8sYS5ub3JtYWxpemVFYXNpbmc9ayxhLnBhcnNlRWFzaW5nRnVuY3Rpb249bH0oYyksZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEsYil7cmV0dXJuIGEgaW4gaz9rW2FdW2JdfHxiOmJ9ZnVuY3Rpb24gZChhKXtyZXR1cm5cImRpc3BsYXlcIj09PWF8fDA9PT1hLmxhc3RJbmRleE9mKFwiYW5pbWF0aW9uXCIsMCl8fDA9PT1hLmxhc3RJbmRleE9mKFwidHJhbnNpdGlvblwiLDApfWZ1bmN0aW9uIGUoYSxiLGUpe2lmKCFkKGEpKXt2YXIgZj1oW2FdO2lmKGYpe2kuc3R5bGVbYV09Yjtmb3IodmFyIGcgaW4gZil7dmFyIGo9ZltnXSxrPWkuc3R5bGVbal07ZVtqXT1jKGosayl9fWVsc2UgZVthXT1jKGEsYil9fWZ1bmN0aW9uIGYoYSl7dmFyIGI9W107Zm9yKHZhciBjIGluIGEpaWYoIShjIGluW1wiZWFzaW5nXCIsXCJvZmZzZXRcIixcImNvbXBvc2l0ZVwiXSkpe3ZhciBkPWFbY107QXJyYXkuaXNBcnJheShkKXx8KGQ9W2RdKTtmb3IodmFyIGUsZj1kLmxlbmd0aCxnPTA7ZzxmO2crKyllPXt9LGUub2Zmc2V0PVwib2Zmc2V0XCJpbiBhP2Eub2Zmc2V0OjE9PWY/MTpnLyhmLTEpLFwiZWFzaW5nXCJpbiBhJiYoZS5lYXNpbmc9YS5lYXNpbmcpLFwiY29tcG9zaXRlXCJpbiBhJiYoZS5jb21wb3NpdGU9YS5jb21wb3NpdGUpLGVbY109ZFtnXSxiLnB1c2goZSl9cmV0dXJuIGIuc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBhLm9mZnNldC1iLm9mZnNldH0pLGJ9ZnVuY3Rpb24gZyhiKXtmdW5jdGlvbiBjKCl7dmFyIGE9ZC5sZW5ndGg7bnVsbD09ZFthLTFdLm9mZnNldCYmKGRbYS0xXS5vZmZzZXQ9MSksYT4xJiZudWxsPT1kWzBdLm9mZnNldCYmKGRbMF0ub2Zmc2V0PTApO2Zvcih2YXIgYj0wLGM9ZFswXS5vZmZzZXQsZT0xO2U8YTtlKyspe3ZhciBmPWRbZV0ub2Zmc2V0O2lmKG51bGwhPWYpe2Zvcih2YXIgZz0xO2c8ZS1iO2crKylkW2IrZ10ub2Zmc2V0PWMrKGYtYykqZy8oZS1iKTtiPWUsYz1mfX19aWYobnVsbD09YilyZXR1cm5bXTt3aW5kb3cuU3ltYm9sJiZTeW1ib2wuaXRlcmF0b3ImJkFycmF5LnByb3RvdHlwZS5mcm9tJiZiW1N5bWJvbC5pdGVyYXRvcl0mJihiPUFycmF5LmZyb20oYikpLEFycmF5LmlzQXJyYXkoYil8fChiPWYoYikpO2Zvcih2YXIgZD1iLm1hcChmdW5jdGlvbihiKXt2YXIgYz17fTtmb3IodmFyIGQgaW4gYil7dmFyIGY9YltkXTtpZihcIm9mZnNldFwiPT1kKXtpZihudWxsIT1mKXtpZihmPU51bWJlcihmKSwhaXNGaW5pdGUoZikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIktleWZyYW1lIG9mZnNldHMgbXVzdCBiZSBudW1iZXJzLlwiKTtpZihmPDB8fGY+MSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiS2V5ZnJhbWUgb2Zmc2V0cyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMS5cIil9fWVsc2UgaWYoXCJjb21wb3NpdGVcIj09ZCl7aWYoXCJhZGRcIj09Znx8XCJhY2N1bXVsYXRlXCI9PWYpdGhyb3d7dHlwZTpET01FeGNlcHRpb24uTk9UX1NVUFBPUlRFRF9FUlIsbmFtZTpcIk5vdFN1cHBvcnRlZEVycm9yXCIsbWVzc2FnZTpcImFkZCBjb21wb3NpdGluZyBpcyBub3Qgc3VwcG9ydGVkXCJ9O2lmKFwicmVwbGFjZVwiIT1mKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGNvbXBvc2l0ZSBtb2RlIFwiK2YrXCIuXCIpfWVsc2UgZj1cImVhc2luZ1wiPT1kP2Eubm9ybWFsaXplRWFzaW5nKGYpOlwiXCIrZjtlKGQsZixjKX1yZXR1cm4gdm9pZCAwPT1jLm9mZnNldCYmKGMub2Zmc2V0PW51bGwpLHZvaWQgMD09Yy5lYXNpbmcmJihjLmVhc2luZz1cImxpbmVhclwiKSxjfSksZz0hMCxoPS0xLzAsaT0wO2k8ZC5sZW5ndGg7aSsrKXt2YXIgaj1kW2ldLm9mZnNldDtpZihudWxsIT1qKXtpZihqPGgpdGhyb3cgbmV3IFR5cGVFcnJvcihcIktleWZyYW1lcyBhcmUgbm90IGxvb3NlbHkgc29ydGVkIGJ5IG9mZnNldC4gU29ydCBvciBzcGVjaWZ5IG9mZnNldHMuXCIpO2g9an1lbHNlIGc9ITF9cmV0dXJuIGQ9ZC5maWx0ZXIoZnVuY3Rpb24oYSl7cmV0dXJuIGEub2Zmc2V0Pj0wJiZhLm9mZnNldDw9MX0pLGd8fGMoKSxkfXZhciBoPXtiYWNrZ3JvdW5kOltcImJhY2tncm91bmRJbWFnZVwiLFwiYmFja2dyb3VuZFBvc2l0aW9uXCIsXCJiYWNrZ3JvdW5kU2l6ZVwiLFwiYmFja2dyb3VuZFJlcGVhdFwiLFwiYmFja2dyb3VuZEF0dGFjaG1lbnRcIixcImJhY2tncm91bmRPcmlnaW5cIixcImJhY2tncm91bmRDbGlwXCIsXCJiYWNrZ3JvdW5kQ29sb3JcIl0sYm9yZGVyOltcImJvcmRlclRvcENvbG9yXCIsXCJib3JkZXJUb3BTdHlsZVwiLFwiYm9yZGVyVG9wV2lkdGhcIixcImJvcmRlclJpZ2h0Q29sb3JcIixcImJvcmRlclJpZ2h0U3R5bGVcIixcImJvcmRlclJpZ2h0V2lkdGhcIixcImJvcmRlckJvdHRvbUNvbG9yXCIsXCJib3JkZXJCb3R0b21TdHlsZVwiLFwiYm9yZGVyQm90dG9tV2lkdGhcIixcImJvcmRlckxlZnRDb2xvclwiLFwiYm9yZGVyTGVmdFN0eWxlXCIsXCJib3JkZXJMZWZ0V2lkdGhcIl0sYm9yZGVyQm90dG9tOltcImJvcmRlckJvdHRvbVdpZHRoXCIsXCJib3JkZXJCb3R0b21TdHlsZVwiLFwiYm9yZGVyQm90dG9tQ29sb3JcIl0sYm9yZGVyQ29sb3I6W1wiYm9yZGVyVG9wQ29sb3JcIixcImJvcmRlclJpZ2h0Q29sb3JcIixcImJvcmRlckJvdHRvbUNvbG9yXCIsXCJib3JkZXJMZWZ0Q29sb3JcIl0sYm9yZGVyTGVmdDpbXCJib3JkZXJMZWZ0V2lkdGhcIixcImJvcmRlckxlZnRTdHlsZVwiLFwiYm9yZGVyTGVmdENvbG9yXCJdLGJvcmRlclJhZGl1czpbXCJib3JkZXJUb3BMZWZ0UmFkaXVzXCIsXCJib3JkZXJUb3BSaWdodFJhZGl1c1wiLFwiYm9yZGVyQm90dG9tUmlnaHRSYWRpdXNcIixcImJvcmRlckJvdHRvbUxlZnRSYWRpdXNcIl0sYm9yZGVyUmlnaHQ6W1wiYm9yZGVyUmlnaHRXaWR0aFwiLFwiYm9yZGVyUmlnaHRTdHlsZVwiLFwiYm9yZGVyUmlnaHRDb2xvclwiXSxib3JkZXJUb3A6W1wiYm9yZGVyVG9wV2lkdGhcIixcImJvcmRlclRvcFN0eWxlXCIsXCJib3JkZXJUb3BDb2xvclwiXSxib3JkZXJXaWR0aDpbXCJib3JkZXJUb3BXaWR0aFwiLFwiYm9yZGVyUmlnaHRXaWR0aFwiLFwiYm9yZGVyQm90dG9tV2lkdGhcIixcImJvcmRlckxlZnRXaWR0aFwiXSxmbGV4OltcImZsZXhHcm93XCIsXCJmbGV4U2hyaW5rXCIsXCJmbGV4QmFzaXNcIl0sZm9udDpbXCJmb250RmFtaWx5XCIsXCJmb250U2l6ZVwiLFwiZm9udFN0eWxlXCIsXCJmb250VmFyaWFudFwiLFwiZm9udFdlaWdodFwiLFwibGluZUhlaWdodFwiXSxtYXJnaW46W1wibWFyZ2luVG9wXCIsXCJtYXJnaW5SaWdodFwiLFwibWFyZ2luQm90dG9tXCIsXCJtYXJnaW5MZWZ0XCJdLG91dGxpbmU6W1wib3V0bGluZUNvbG9yXCIsXCJvdXRsaW5lU3R5bGVcIixcIm91dGxpbmVXaWR0aFwiXSxwYWRkaW5nOltcInBhZGRpbmdUb3BcIixcInBhZGRpbmdSaWdodFwiLFwicGFkZGluZ0JvdHRvbVwiLFwicGFkZGluZ0xlZnRcIl19LGk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLFwiZGl2XCIpLGo9e3RoaW46XCIxcHhcIixtZWRpdW06XCIzcHhcIix0aGljazpcIjVweFwifSxrPXtib3JkZXJCb3R0b21XaWR0aDpqLGJvcmRlckxlZnRXaWR0aDpqLGJvcmRlclJpZ2h0V2lkdGg6aixib3JkZXJUb3BXaWR0aDpqLGZvbnRTaXplOntcInh4LXNtYWxsXCI6XCI2MCVcIixcIngtc21hbGxcIjpcIjc1JVwiLHNtYWxsOlwiODklXCIsbWVkaXVtOlwiMTAwJVwiLGxhcmdlOlwiMTIwJVwiLFwieC1sYXJnZVwiOlwiMTUwJVwiLFwieHgtbGFyZ2VcIjpcIjIwMCVcIn0sZm9udFdlaWdodDp7bm9ybWFsOlwiNDAwXCIsYm9sZDpcIjcwMFwifSxvdXRsaW5lV2lkdGg6aix0ZXh0U2hhZG93Ontub25lOlwiMHB4IDBweCAwcHggdHJhbnNwYXJlbnRcIn0sYm94U2hhZG93Ontub25lOlwiMHB4IDBweCAwcHggMHB4IHRyYW5zcGFyZW50XCJ9fTthLmNvbnZlcnRUb0FycmF5Rm9ybT1mLGEubm9ybWFsaXplS2V5ZnJhbWVzPWd9KGMpLGZ1bmN0aW9uKGEpe3ZhciBiPXt9O2EuaXNEZXByZWNhdGVkPWZ1bmN0aW9uKGEsYyxkLGUpe3ZhciBmPWU/XCJhcmVcIjpcImlzXCIsZz1uZXcgRGF0ZSxoPW5ldyBEYXRlKGMpO3JldHVybiBoLnNldE1vbnRoKGguZ2V0TW9udGgoKSszKSwhKGc8aCYmKGEgaW4gYnx8Y29uc29sZS53YXJuKFwiV2ViIEFuaW1hdGlvbnM6IFwiK2ErXCIgXCIrZitcIiBkZXByZWNhdGVkIGFuZCB3aWxsIHN0b3Agd29ya2luZyBvbiBcIitoLnRvRGF0ZVN0cmluZygpK1wiLiBcIitkKSxiW2FdPSEwLDEpKX0sYS5kZXByZWNhdGVkPWZ1bmN0aW9uKGIsYyxkLGUpe3ZhciBmPWU/XCJhcmVcIjpcImlzXCI7aWYoYS5pc0RlcHJlY2F0ZWQoYixjLGQsZSkpdGhyb3cgbmV3IEVycm9yKGIrXCIgXCIrZitcIiBubyBsb25nZXIgc3VwcG9ydGVkLiBcIitkKX19KGMpLGZ1bmN0aW9uKCl7aWYoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFuaW1hdGUpe3ZhciBhPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hbmltYXRlKFtdLDApLGI9ITA7aWYoYSYmKGI9ITEsXCJwbGF5fGN1cnJlbnRUaW1lfHBhdXNlfHJldmVyc2V8cGxheWJhY2tSYXRlfGNhbmNlbHxmaW5pc2h8c3RhcnRUaW1lfHBsYXlTdGF0ZVwiLnNwbGl0KFwifFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGMpe3ZvaWQgMD09PWFbY10mJihiPSEwKX0pKSwhYilyZXR1cm59IWZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKGEpe2Zvcih2YXIgYj17fSxjPTA7YzxhLmxlbmd0aDtjKyspZm9yKHZhciBkIGluIGFbY10paWYoXCJvZmZzZXRcIiE9ZCYmXCJlYXNpbmdcIiE9ZCYmXCJjb21wb3NpdGVcIiE9ZCl7dmFyIGU9e29mZnNldDphW2NdLm9mZnNldCxlYXNpbmc6YVtjXS5lYXNpbmcsdmFsdWU6YVtjXVtkXX07YltkXT1iW2RdfHxbXSxiW2RdLnB1c2goZSl9Zm9yKHZhciBmIGluIGIpe3ZhciBnPWJbZl07aWYoMCE9Z1swXS5vZmZzZXR8fDEhPWdbZy5sZW5ndGgtMV0ub2Zmc2V0KXRocm93e3R5cGU6RE9NRXhjZXB0aW9uLk5PVF9TVVBQT1JURURfRVJSLG5hbWU6XCJOb3RTdXBwb3J0ZWRFcnJvclwiLG1lc3NhZ2U6XCJQYXJ0aWFsIGtleWZyYW1lcyBhcmUgbm90IHN1cHBvcnRlZFwifX1yZXR1cm4gYn1mdW5jdGlvbiBlKGMpe3ZhciBkPVtdO2Zvcih2YXIgZSBpbiBjKWZvcih2YXIgZj1jW2VdLGc9MDtnPGYubGVuZ3RoLTE7ZysrKXt2YXIgaD1nLGk9ZysxLGo9ZltoXS5vZmZzZXQsaz1mW2ldLm9mZnNldCxsPWosbT1rOzA9PWcmJihsPS0xLzAsMD09ayYmKGk9aCkpLGc9PWYubGVuZ3RoLTImJihtPTEvMCwxPT1qJiYoaD1pKSksZC5wdXNoKHthcHBseUZyb206bCxhcHBseVRvOm0sc3RhcnRPZmZzZXQ6ZltoXS5vZmZzZXQsZW5kT2Zmc2V0OmZbaV0ub2Zmc2V0LGVhc2luZ0Z1bmN0aW9uOmEucGFyc2VFYXNpbmdGdW5jdGlvbihmW2hdLmVhc2luZykscHJvcGVydHk6ZSxpbnRlcnBvbGF0aW9uOmIucHJvcGVydHlJbnRlcnBvbGF0aW9uKGUsZltoXS52YWx1ZSxmW2ldLnZhbHVlKX0pfXJldHVybiBkLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5zdGFydE9mZnNldC1iLnN0YXJ0T2Zmc2V0fSksZH1iLmNvbnZlcnRFZmZlY3RJbnB1dD1mdW5jdGlvbihjKXt2YXIgZj1hLm5vcm1hbGl6ZUtleWZyYW1lcyhjKSxnPWQoZiksaD1lKGcpO3JldHVybiBmdW5jdGlvbihhLGMpe2lmKG51bGwhPWMpaC5maWx0ZXIoZnVuY3Rpb24oYSl7cmV0dXJuIGM+PWEuYXBwbHlGcm9tJiZjPGEuYXBwbHlUb30pLmZvckVhY2goZnVuY3Rpb24oZCl7dmFyIGU9Yy1kLnN0YXJ0T2Zmc2V0LGY9ZC5lbmRPZmZzZXQtZC5zdGFydE9mZnNldCxnPTA9PWY/MDpkLmVhc2luZ0Z1bmN0aW9uKGUvZik7Yi5hcHBseShhLGQucHJvcGVydHksZC5pbnRlcnBvbGF0aW9uKGcpKX0pO2Vsc2UgZm9yKHZhciBkIGluIGcpXCJvZmZzZXRcIiE9ZCYmXCJlYXNpbmdcIiE9ZCYmXCJjb21wb3NpdGVcIiE9ZCYmYi5jbGVhcihhLGQpfX19KGMsZCksZnVuY3Rpb24oYSxiLGMpe2Z1bmN0aW9uIGQoYSl7cmV0dXJuIGEucmVwbGFjZSgvLSguKS9nLGZ1bmN0aW9uKGEsYil7cmV0dXJuIGIudG9VcHBlckNhc2UoKX0pfWZ1bmN0aW9uIGUoYSxiLGMpe2hbY109aFtjXXx8W10saFtjXS5wdXNoKFthLGJdKX1mdW5jdGlvbiBmKGEsYixjKXtmb3IodmFyIGY9MDtmPGMubGVuZ3RoO2YrKyl7ZShhLGIsZChjW2ZdKSl9fWZ1bmN0aW9uIGcoYyxlLGYpe3ZhciBnPWM7Ly0vLnRlc3QoYykmJiFhLmlzRGVwcmVjYXRlZChcIkh5cGhlbmF0ZWQgcHJvcGVydHkgbmFtZXNcIixcIjIwMTYtMDMtMjJcIixcIlVzZSBjYW1lbENhc2UgaW5zdGVhZC5cIiwhMCkmJihnPWQoYykpLFwiaW5pdGlhbFwiIT1lJiZcImluaXRpYWxcIiE9Znx8KFwiaW5pdGlhbFwiPT1lJiYoZT1pW2ddKSxcImluaXRpYWxcIj09ZiYmKGY9aVtnXSkpO2Zvcih2YXIgaj1lPT1mP1tdOmhbZ10saz0wO2omJms8ai5sZW5ndGg7aysrKXt2YXIgbD1qW2tdWzBdKGUpLG09altrXVswXShmKTtpZih2b2lkIDAhPT1sJiZ2b2lkIDAhPT1tKXt2YXIgbj1qW2tdWzFdKGwsbSk7aWYobil7dmFyIG89Yi5JbnRlcnBvbGF0aW9uLmFwcGx5KG51bGwsbik7cmV0dXJuIGZ1bmN0aW9uKGEpe3JldHVybiAwPT1hP2U6MT09YT9mOm8oYSl9fX19cmV0dXJuIGIuSW50ZXJwb2xhdGlvbighMSwhMCxmdW5jdGlvbihhKXtyZXR1cm4gYT9mOmV9KX12YXIgaD17fTtiLmFkZFByb3BlcnRpZXNIYW5kbGVyPWY7dmFyIGk9e2JhY2tncm91bmRDb2xvcjpcInRyYW5zcGFyZW50XCIsYmFja2dyb3VuZFBvc2l0aW9uOlwiMCUgMCVcIixib3JkZXJCb3R0b21Db2xvcjpcImN1cnJlbnRDb2xvclwiLGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6XCIwcHhcIixib3JkZXJCb3R0b21SaWdodFJhZGl1czpcIjBweFwiLGJvcmRlckJvdHRvbVdpZHRoOlwiM3B4XCIsYm9yZGVyTGVmdENvbG9yOlwiY3VycmVudENvbG9yXCIsYm9yZGVyTGVmdFdpZHRoOlwiM3B4XCIsYm9yZGVyUmlnaHRDb2xvcjpcImN1cnJlbnRDb2xvclwiLGJvcmRlclJpZ2h0V2lkdGg6XCIzcHhcIixib3JkZXJTcGFjaW5nOlwiMnB4XCIsYm9yZGVyVG9wQ29sb3I6XCJjdXJyZW50Q29sb3JcIixib3JkZXJUb3BMZWZ0UmFkaXVzOlwiMHB4XCIsYm9yZGVyVG9wUmlnaHRSYWRpdXM6XCIwcHhcIixib3JkZXJUb3BXaWR0aDpcIjNweFwiLGJvdHRvbTpcImF1dG9cIixjbGlwOlwicmVjdCgwcHgsIDBweCwgMHB4LCAwcHgpXCIsY29sb3I6XCJibGFja1wiLGZvbnRTaXplOlwiMTAwJVwiLGZvbnRXZWlnaHQ6XCI0MDBcIixoZWlnaHQ6XCJhdXRvXCIsbGVmdDpcImF1dG9cIixsZXR0ZXJTcGFjaW5nOlwibm9ybWFsXCIsbGluZUhlaWdodDpcIjEyMCVcIixtYXJnaW5Cb3R0b206XCIwcHhcIixtYXJnaW5MZWZ0OlwiMHB4XCIsbWFyZ2luUmlnaHQ6XCIwcHhcIixtYXJnaW5Ub3A6XCIwcHhcIixtYXhIZWlnaHQ6XCJub25lXCIsbWF4V2lkdGg6XCJub25lXCIsbWluSGVpZ2h0OlwiMHB4XCIsbWluV2lkdGg6XCIwcHhcIixvcGFjaXR5OlwiMS4wXCIsb3V0bGluZUNvbG9yOlwiaW52ZXJ0XCIsb3V0bGluZU9mZnNldDpcIjBweFwiLG91dGxpbmVXaWR0aDpcIjNweFwiLHBhZGRpbmdCb3R0b206XCIwcHhcIixwYWRkaW5nTGVmdDpcIjBweFwiLHBhZGRpbmdSaWdodDpcIjBweFwiLHBhZGRpbmdUb3A6XCIwcHhcIixyaWdodDpcImF1dG9cIixzdHJva2VEYXNoYXJyYXk6XCJub25lXCIsc3Ryb2tlRGFzaG9mZnNldDpcIjBweFwiLHRleHRJbmRlbnQ6XCIwcHhcIix0ZXh0U2hhZG93OlwiMHB4IDBweCAwcHggdHJhbnNwYXJlbnRcIix0b3A6XCJhdXRvXCIsdHJhbnNmb3JtOlwiXCIsdmVydGljYWxBbGlnbjpcIjBweFwiLHZpc2liaWxpdHk6XCJ2aXNpYmxlXCIsd2lkdGg6XCJhdXRvXCIsd29yZFNwYWNpbmc6XCJub3JtYWxcIix6SW5kZXg6XCJhdXRvXCJ9O2IucHJvcGVydHlJbnRlcnBvbGF0aW9uPWd9KGMsZCksZnVuY3Rpb24oYSxiLGMpe2Z1bmN0aW9uIGQoYil7dmFyIGM9YS5jYWxjdWxhdGVBY3RpdmVEdXJhdGlvbihiKSxkPWZ1bmN0aW9uKGQpe3JldHVybiBhLmNhbGN1bGF0ZUl0ZXJhdGlvblByb2dyZXNzKGMsZCxiKX07cmV0dXJuIGQuX3RvdGFsRHVyYXRpb249Yi5kZWxheStjK2IuZW5kRGVsYXksZH1iLktleWZyYW1lRWZmZWN0PWZ1bmN0aW9uKGMsZSxmLGcpe3ZhciBoLGk9ZChhLm5vcm1hbGl6ZVRpbWluZ0lucHV0KGYpKSxqPWIuY29udmVydEVmZmVjdElucHV0KGUpLGs9ZnVuY3Rpb24oKXtqKGMsaCl9O3JldHVybiBrLl91cGRhdGU9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPT0oaD1pKGEpKX0say5fY2xlYXI9ZnVuY3Rpb24oKXtqKGMsbnVsbCl9LGsuX2hhc1NhbWVUYXJnZXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIGM9PT1hfSxrLl90YXJnZXQ9YyxrLl90b3RhbER1cmF0aW9uPWkuX3RvdGFsRHVyYXRpb24say5faWQ9ZyxrfX0oYyxkKSxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSxiLGMpe2MuZW51bWVyYWJsZT0hMCxjLmNvbmZpZ3VyYWJsZT0hMCxPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxiLGMpfWZ1bmN0aW9uIGQoYSl7dGhpcy5fc3Vycm9nYXRlU3R5bGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLFwiZGl2XCIpLnN0eWxlLHRoaXMuX3N0eWxlPWEuc3R5bGUsdGhpcy5fbGVuZ3RoPTAsdGhpcy5faXNBbmltYXRlZFByb3BlcnR5PXt9O2Zvcih2YXIgYj0wO2I8dGhpcy5fc3R5bGUubGVuZ3RoO2IrKyl7dmFyIGM9dGhpcy5fc3R5bGVbYl07dGhpcy5fc3Vycm9nYXRlU3R5bGVbY109dGhpcy5fc3R5bGVbY119dGhpcy5fdXBkYXRlSW5kaWNlcygpfWZ1bmN0aW9uIGUoYSl7aWYoIWEuX3dlYkFuaW1hdGlvbnNQYXRjaGVkU3R5bGUpe3ZhciBiPW5ldyBkKGEpO3RyeXtjKGEsXCJzdHlsZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYn19KX1jYXRjaChiKXthLnN0eWxlLl9zZXQ9ZnVuY3Rpb24oYixjKXthLnN0eWxlW2JdPWN9LGEuc3R5bGUuX2NsZWFyPWZ1bmN0aW9uKGIpe2Euc3R5bGVbYl09XCJcIn19YS5fd2ViQW5pbWF0aW9uc1BhdGNoZWRTdHlsZT1hLnN0eWxlfX12YXIgZj17Y3NzVGV4dDoxLGxlbmd0aDoxLHBhcmVudFJ1bGU6MX0sZz17Z2V0UHJvcGVydHlDU1NWYWx1ZToxLGdldFByb3BlcnR5UHJpb3JpdHk6MSxnZXRQcm9wZXJ0eVZhbHVlOjEsaXRlbToxLHJlbW92ZVByb3BlcnR5OjEsc2V0UHJvcGVydHk6MX0saD17cmVtb3ZlUHJvcGVydHk6MSxzZXRQcm9wZXJ0eToxfTtkLnByb3RvdHlwZT17Z2V0IGNzc1RleHQoKXtyZXR1cm4gdGhpcy5fc3Vycm9nYXRlU3R5bGUuY3NzVGV4dH0sc2V0IGNzc1RleHQoYSl7Zm9yKHZhciBiPXt9LGM9MDtjPHRoaXMuX3N1cnJvZ2F0ZVN0eWxlLmxlbmd0aDtjKyspYlt0aGlzLl9zdXJyb2dhdGVTdHlsZVtjXV09ITA7dGhpcy5fc3Vycm9nYXRlU3R5bGUuY3NzVGV4dD1hLHRoaXMuX3VwZGF0ZUluZGljZXMoKTtmb3IodmFyIGM9MDtjPHRoaXMuX3N1cnJvZ2F0ZVN0eWxlLmxlbmd0aDtjKyspYlt0aGlzLl9zdXJyb2dhdGVTdHlsZVtjXV09ITA7Zm9yKHZhciBkIGluIGIpdGhpcy5faXNBbmltYXRlZFByb3BlcnR5W2RdfHx0aGlzLl9zdHlsZS5zZXRQcm9wZXJ0eShkLHRoaXMuX3N1cnJvZ2F0ZVN0eWxlLmdldFByb3BlcnR5VmFsdWUoZCkpfSxnZXQgbGVuZ3RoKCl7cmV0dXJuIHRoaXMuX3N1cnJvZ2F0ZVN0eWxlLmxlbmd0aH0sZ2V0IHBhcmVudFJ1bGUoKXtyZXR1cm4gdGhpcy5fc3R5bGUucGFyZW50UnVsZX0sX3VwZGF0ZUluZGljZXM6ZnVuY3Rpb24oKXtmb3IoO3RoaXMuX2xlbmd0aDx0aGlzLl9zdXJyb2dhdGVTdHlsZS5sZW5ndGg7KU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLHRoaXMuX2xlbmd0aCx7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITEsZ2V0OmZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zdXJyb2dhdGVTdHlsZVthXX19KHRoaXMuX2xlbmd0aCl9KSx0aGlzLl9sZW5ndGgrKztmb3IoO3RoaXMuX2xlbmd0aD50aGlzLl9zdXJyb2dhdGVTdHlsZS5sZW5ndGg7KXRoaXMuX2xlbmd0aC0tLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLHRoaXMuX2xlbmd0aCx7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITEsdmFsdWU6dm9pZCAwfSl9LF9zZXQ6ZnVuY3Rpb24oYSxiKXt0aGlzLl9zdHlsZVthXT1iLHRoaXMuX2lzQW5pbWF0ZWRQcm9wZXJ0eVthXT0hMH0sX2NsZWFyOmZ1bmN0aW9uKGEpe3RoaXMuX3N0eWxlW2FdPXRoaXMuX3N1cnJvZ2F0ZVN0eWxlW2FdLGRlbGV0ZSB0aGlzLl9pc0FuaW1hdGVkUHJvcGVydHlbYV19fTtmb3IodmFyIGkgaW4gZylkLnByb3RvdHlwZVtpXT1mdW5jdGlvbihhLGIpe3JldHVybiBmdW5jdGlvbigpe3ZhciBjPXRoaXMuX3N1cnJvZ2F0ZVN0eWxlW2FdLmFwcGx5KHRoaXMuX3N1cnJvZ2F0ZVN0eWxlLGFyZ3VtZW50cyk7cmV0dXJuIGImJih0aGlzLl9pc0FuaW1hdGVkUHJvcGVydHlbYXJndW1lbnRzWzBdXXx8dGhpcy5fc3R5bGVbYV0uYXBwbHkodGhpcy5fc3R5bGUsYXJndW1lbnRzKSx0aGlzLl91cGRhdGVJbmRpY2VzKCkpLGN9fShpLGkgaW4gaCk7Zm9yKHZhciBqIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSlqIGluIGZ8fGogaW4gZ3x8ZnVuY3Rpb24oYSl7YyhkLnByb3RvdHlwZSxhLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3Vycm9nYXRlU3R5bGVbYV19LHNldDpmdW5jdGlvbihiKXt0aGlzLl9zdXJyb2dhdGVTdHlsZVthXT1iLHRoaXMuX3VwZGF0ZUluZGljZXMoKSx0aGlzLl9pc0FuaW1hdGVkUHJvcGVydHlbYV18fCh0aGlzLl9zdHlsZVthXT1iKX19KX0oaik7YS5hcHBseT1mdW5jdGlvbihiLGMsZCl7ZShiKSxiLnN0eWxlLl9zZXQoYS5wcm9wZXJ0eU5hbWUoYyksZCl9LGEuY2xlYXI9ZnVuY3Rpb24oYixjKXtiLl93ZWJBbmltYXRpb25zUGF0Y2hlZFN0eWxlJiZiLnN0eWxlLl9jbGVhcihhLnByb3BlcnR5TmFtZShjKSl9fShkKSxmdW5jdGlvbihhKXt3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuYW5pbWF0ZT1mdW5jdGlvbihiLGMpe3ZhciBkPVwiXCI7cmV0dXJuIGMmJmMuaWQmJihkPWMuaWQpLGEudGltZWxpbmUuX3BsYXkoYS5LZXlmcmFtZUVmZmVjdCh0aGlzLGIsYyxkKSl9fShkKSxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSxiLGQpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhJiZcIm51bWJlclwiPT10eXBlb2YgYilyZXR1cm4gYSooMS1kKStiKmQ7aWYoXCJib29sZWFuXCI9PXR5cGVvZiBhJiZcImJvb2xlYW5cIj09dHlwZW9mIGIpcmV0dXJuIGQ8LjU/YTpiO2lmKGEubGVuZ3RoPT1iLmxlbmd0aCl7Zm9yKHZhciBlPVtdLGY9MDtmPGEubGVuZ3RoO2YrKyllLnB1c2goYyhhW2ZdLGJbZl0sZCkpO3JldHVybiBlfXRocm93XCJNaXNtYXRjaGVkIGludGVycG9sYXRpb24gYXJndW1lbnRzIFwiK2ErXCI6XCIrYn1hLkludGVycG9sYXRpb249ZnVuY3Rpb24oYSxiLGQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gZChjKGEsYixlKSl9fX0oZCksZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEsYixjKXtyZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4oYSxjKSxiKX1mdW5jdGlvbiBkKGIsZCxlKXt2YXIgZj1hLmRvdChiLGQpO2Y9YyhmLC0xLDEpO3ZhciBnPVtdO2lmKDE9PT1mKWc9YjtlbHNlIGZvcih2YXIgaD1NYXRoLmFjb3MoZiksaT0xKk1hdGguc2luKGUqaCkvTWF0aC5zcXJ0KDEtZipmKSxqPTA7ajw0O2orKylnLnB1c2goYltqXSooTWF0aC5jb3MoZSpoKS1mKmkpK2Rbal0qaSk7cmV0dXJuIGd9dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEsYil7Zm9yKHZhciBjPVtbMCwwLDAsMF0sWzAsMCwwLDBdLFswLDAsMCwwXSxbMCwwLDAsMF1dLGQ9MDtkPDQ7ZCsrKWZvcih2YXIgZT0wO2U8NDtlKyspZm9yKHZhciBmPTA7Zjw0O2YrKyljW2RdW2VdKz1iW2RdW2ZdKmFbZl1bZV07cmV0dXJuIGN9ZnVuY3Rpb24gYihhKXtyZXR1cm4gMD09YVswXVsyXSYmMD09YVswXVszXSYmMD09YVsxXVsyXSYmMD09YVsxXVszXSYmMD09YVsyXVswXSYmMD09YVsyXVsxXSYmMT09YVsyXVsyXSYmMD09YVsyXVszXSYmMD09YVszXVsyXSYmMT09YVszXVszXX1mdW5jdGlvbiBjKGMsZCxlLGYsZyl7Zm9yKHZhciBoPVtbMSwwLDAsMF0sWzAsMSwwLDBdLFswLDAsMSwwXSxbMCwwLDAsMV1dLGk9MDtpPDQ7aSsrKWhbaV1bM109Z1tpXTtmb3IodmFyIGk9MDtpPDM7aSsrKWZvcih2YXIgaj0wO2o8MztqKyspaFszXVtpXSs9Y1tqXSpoW2pdW2ldO3ZhciBrPWZbMF0sbD1mWzFdLG09ZlsyXSxuPWZbM10sbz1bWzEsMCwwLDBdLFswLDEsMCwwXSxbMCwwLDEsMF0sWzAsMCwwLDFdXTtvWzBdWzBdPTEtMioobCpsK20qbSksb1swXVsxXT0yKihrKmwtbSpuKSxvWzBdWzJdPTIqKGsqbStsKm4pLG9bMV1bMF09MiooaypsK20qbiksb1sxXVsxXT0xLTIqKGsqayttKm0pLG9bMV1bMl09MioobCptLWsqbiksb1syXVswXT0yKihrKm0tbCpuKSxvWzJdWzFdPTIqKGwqbStrKm4pLG9bMl1bMl09MS0yKihrKmsrbCpsKSxoPWEoaCxvKTt2YXIgcD1bWzEsMCwwLDBdLFswLDEsMCwwXSxbMCwwLDEsMF0sWzAsMCwwLDFdXTtlWzJdJiYocFsyXVsxXT1lWzJdLGg9YShoLHApKSxlWzFdJiYocFsyXVsxXT0wLHBbMl1bMF09ZVswXSxoPWEoaCxwKSksZVswXSYmKHBbMl1bMF09MCxwWzFdWzBdPWVbMF0saD1hKGgscCkpO2Zvcih2YXIgaT0wO2k8MztpKyspZm9yKHZhciBqPTA7ajwzO2orKyloW2ldW2pdKj1kW2ldO3JldHVybiBiKGgpP1toWzBdWzBdLGhbMF1bMV0saFsxXVswXSxoWzFdWzFdLGhbM11bMF0saFszXVsxXV06aFswXS5jb25jYXQoaFsxXSxoWzJdLGhbM10pfXJldHVybiBjfSgpO2EuY29tcG9zZU1hdHJpeD1lLGEucXVhdD1kfShkKSxmdW5jdGlvbihhLGIsYyl7YS5zZXF1ZW5jZU51bWJlcj0wO3ZhciBkPWZ1bmN0aW9uKGEsYixjKXt0aGlzLnRhcmdldD1hLHRoaXMuY3VycmVudFRpbWU9Yix0aGlzLnRpbWVsaW5lVGltZT1jLHRoaXMudHlwZT1cImZpbmlzaFwiLHRoaXMuYnViYmxlcz0hMSx0aGlzLmNhbmNlbGFibGU9ITEsdGhpcy5jdXJyZW50VGFyZ2V0PWEsdGhpcy5kZWZhdWx0UHJldmVudGVkPSExLHRoaXMuZXZlbnRQaGFzZT1FdmVudC5BVF9UQVJHRVQsdGhpcy50aW1lU3RhbXA9RGF0ZS5ub3coKX07Yi5BbmltYXRpb249ZnVuY3Rpb24oYil7dGhpcy5pZD1cIlwiLGImJmIuX2lkJiYodGhpcy5pZD1iLl9pZCksdGhpcy5fc2VxdWVuY2VOdW1iZXI9YS5zZXF1ZW5jZU51bWJlcisrLHRoaXMuX2N1cnJlbnRUaW1lPTAsdGhpcy5fc3RhcnRUaW1lPW51bGwsdGhpcy5fcGF1c2VkPSExLHRoaXMuX3BsYXliYWNrUmF0ZT0xLHRoaXMuX2luVGltZWxpbmU9ITAsdGhpcy5fZmluaXNoZWRGbGFnPSEwLHRoaXMub25maW5pc2g9bnVsbCx0aGlzLl9maW5pc2hIYW5kbGVycz1bXSx0aGlzLl9lZmZlY3Q9Yix0aGlzLl9pbkVmZmVjdD10aGlzLl9lZmZlY3QuX3VwZGF0ZSgwKSx0aGlzLl9pZGxlPSEwLHRoaXMuX2N1cnJlbnRUaW1lUGVuZGluZz0hMX0sYi5BbmltYXRpb24ucHJvdG90eXBlPXtfZW5zdXJlQWxpdmU6ZnVuY3Rpb24oKXt0aGlzLnBsYXliYWNrUmF0ZTwwJiYwPT09dGhpcy5jdXJyZW50VGltZT90aGlzLl9pbkVmZmVjdD10aGlzLl9lZmZlY3QuX3VwZGF0ZSgtMSk6dGhpcy5faW5FZmZlY3Q9dGhpcy5fZWZmZWN0Ll91cGRhdGUodGhpcy5jdXJyZW50VGltZSksdGhpcy5faW5UaW1lbGluZXx8IXRoaXMuX2luRWZmZWN0JiZ0aGlzLl9maW5pc2hlZEZsYWd8fCh0aGlzLl9pblRpbWVsaW5lPSEwLGIudGltZWxpbmUuX2FuaW1hdGlvbnMucHVzaCh0aGlzKSl9LF90aWNrQ3VycmVudFRpbWU6ZnVuY3Rpb24oYSxiKXthIT10aGlzLl9jdXJyZW50VGltZSYmKHRoaXMuX2N1cnJlbnRUaW1lPWEsdGhpcy5faXNGaW5pc2hlZCYmIWImJih0aGlzLl9jdXJyZW50VGltZT10aGlzLl9wbGF5YmFja1JhdGU+MD90aGlzLl90b3RhbER1cmF0aW9uOjApLHRoaXMuX2Vuc3VyZUFsaXZlKCkpfSxnZXQgY3VycmVudFRpbWUoKXtyZXR1cm4gdGhpcy5faWRsZXx8dGhpcy5fY3VycmVudFRpbWVQZW5kaW5nP251bGw6dGhpcy5fY3VycmVudFRpbWV9LHNldCBjdXJyZW50VGltZShhKXthPSthLGlzTmFOKGEpfHwoYi5yZXN0YXJ0KCksdGhpcy5fcGF1c2VkfHxudWxsPT10aGlzLl9zdGFydFRpbWV8fCh0aGlzLl9zdGFydFRpbWU9dGhpcy5fdGltZWxpbmUuY3VycmVudFRpbWUtYS90aGlzLl9wbGF5YmFja1JhdGUpLHRoaXMuX2N1cnJlbnRUaW1lUGVuZGluZz0hMSx0aGlzLl9jdXJyZW50VGltZSE9YSYmKHRoaXMuX2lkbGUmJih0aGlzLl9pZGxlPSExLHRoaXMuX3BhdXNlZD0hMCksdGhpcy5fdGlja0N1cnJlbnRUaW1lKGEsITApLGIuYXBwbHlEaXJ0aWVkQW5pbWF0aW9uKHRoaXMpKSl9LGdldCBzdGFydFRpbWUoKXtyZXR1cm4gdGhpcy5fc3RhcnRUaW1lfSxzZXQgc3RhcnRUaW1lKGEpe2E9K2EsaXNOYU4oYSl8fHRoaXMuX3BhdXNlZHx8dGhpcy5faWRsZXx8KHRoaXMuX3N0YXJ0VGltZT1hLHRoaXMuX3RpY2tDdXJyZW50VGltZSgodGhpcy5fdGltZWxpbmUuY3VycmVudFRpbWUtdGhpcy5fc3RhcnRUaW1lKSp0aGlzLnBsYXliYWNrUmF0ZSksYi5hcHBseURpcnRpZWRBbmltYXRpb24odGhpcykpfSxnZXQgcGxheWJhY2tSYXRlKCl7cmV0dXJuIHRoaXMuX3BsYXliYWNrUmF0ZX0sc2V0IHBsYXliYWNrUmF0ZShhKXtpZihhIT10aGlzLl9wbGF5YmFja1JhdGUpe3ZhciBjPXRoaXMuY3VycmVudFRpbWU7dGhpcy5fcGxheWJhY2tSYXRlPWEsdGhpcy5fc3RhcnRUaW1lPW51bGwsXCJwYXVzZWRcIiE9dGhpcy5wbGF5U3RhdGUmJlwiaWRsZVwiIT10aGlzLnBsYXlTdGF0ZSYmKHRoaXMuX2ZpbmlzaGVkRmxhZz0hMSx0aGlzLl9pZGxlPSExLHRoaXMuX2Vuc3VyZUFsaXZlKCksYi5hcHBseURpcnRpZWRBbmltYXRpb24odGhpcykpLG51bGwhPWMmJih0aGlzLmN1cnJlbnRUaW1lPWMpfX0sZ2V0IF9pc0ZpbmlzaGVkKCl7cmV0dXJuIXRoaXMuX2lkbGUmJih0aGlzLl9wbGF5YmFja1JhdGU+MCYmdGhpcy5fY3VycmVudFRpbWU+PXRoaXMuX3RvdGFsRHVyYXRpb258fHRoaXMuX3BsYXliYWNrUmF0ZTwwJiZ0aGlzLl9jdXJyZW50VGltZTw9MCl9LGdldCBfdG90YWxEdXJhdGlvbigpe3JldHVybiB0aGlzLl9lZmZlY3QuX3RvdGFsRHVyYXRpb259LGdldCBwbGF5U3RhdGUoKXtyZXR1cm4gdGhpcy5faWRsZT9cImlkbGVcIjpudWxsPT10aGlzLl9zdGFydFRpbWUmJiF0aGlzLl9wYXVzZWQmJjAhPXRoaXMucGxheWJhY2tSYXRlfHx0aGlzLl9jdXJyZW50VGltZVBlbmRpbmc/XCJwZW5kaW5nXCI6dGhpcy5fcGF1c2VkP1wicGF1c2VkXCI6dGhpcy5faXNGaW5pc2hlZD9cImZpbmlzaGVkXCI6XCJydW5uaW5nXCJ9LF9yZXdpbmQ6ZnVuY3Rpb24oKXtpZih0aGlzLl9wbGF5YmFja1JhdGU+PTApdGhpcy5fY3VycmVudFRpbWU9MDtlbHNle2lmKCEodGhpcy5fdG90YWxEdXJhdGlvbjwxLzApKXRocm93IG5ldyBET01FeGNlcHRpb24oXCJVbmFibGUgdG8gcmV3aW5kIG5lZ2F0aXZlIHBsYXliYWNrIHJhdGUgYW5pbWF0aW9uIHdpdGggaW5maW5pdGUgZHVyYXRpb25cIixcIkludmFsaWRTdGF0ZUVycm9yXCIpO3RoaXMuX2N1cnJlbnRUaW1lPXRoaXMuX3RvdGFsRHVyYXRpb259fSxwbGF5OmZ1bmN0aW9uKCl7dGhpcy5fcGF1c2VkPSExLCh0aGlzLl9pc0ZpbmlzaGVkfHx0aGlzLl9pZGxlKSYmKHRoaXMuX3Jld2luZCgpLHRoaXMuX3N0YXJ0VGltZT1udWxsKSx0aGlzLl9maW5pc2hlZEZsYWc9ITEsdGhpcy5faWRsZT0hMSx0aGlzLl9lbnN1cmVBbGl2ZSgpLGIuYXBwbHlEaXJ0aWVkQW5pbWF0aW9uKHRoaXMpfSxwYXVzZTpmdW5jdGlvbigpe3RoaXMuX2lzRmluaXNoZWR8fHRoaXMuX3BhdXNlZHx8dGhpcy5faWRsZT90aGlzLl9pZGxlJiYodGhpcy5fcmV3aW5kKCksdGhpcy5faWRsZT0hMSk6dGhpcy5fY3VycmVudFRpbWVQZW5kaW5nPSEwLHRoaXMuX3N0YXJ0VGltZT1udWxsLHRoaXMuX3BhdXNlZD0hMH0sZmluaXNoOmZ1bmN0aW9uKCl7dGhpcy5faWRsZXx8KHRoaXMuY3VycmVudFRpbWU9dGhpcy5fcGxheWJhY2tSYXRlPjA/dGhpcy5fdG90YWxEdXJhdGlvbjowLHRoaXMuX3N0YXJ0VGltZT10aGlzLl90b3RhbER1cmF0aW9uLXRoaXMuY3VycmVudFRpbWUsdGhpcy5fY3VycmVudFRpbWVQZW5kaW5nPSExLGIuYXBwbHlEaXJ0aWVkQW5pbWF0aW9uKHRoaXMpKX0sY2FuY2VsOmZ1bmN0aW9uKCl7dGhpcy5faW5FZmZlY3QmJih0aGlzLl9pbkVmZmVjdD0hMSx0aGlzLl9pZGxlPSEwLHRoaXMuX3BhdXNlZD0hMSx0aGlzLl9pc0ZpbmlzaGVkPSEwLHRoaXMuX2ZpbmlzaGVkRmxhZz0hMCx0aGlzLl9jdXJyZW50VGltZT0wLHRoaXMuX3N0YXJ0VGltZT1udWxsLHRoaXMuX2VmZmVjdC5fdXBkYXRlKG51bGwpLGIuYXBwbHlEaXJ0aWVkQW5pbWF0aW9uKHRoaXMpKX0scmV2ZXJzZTpmdW5jdGlvbigpe3RoaXMucGxheWJhY2tSYXRlKj0tMSx0aGlzLnBsYXkoKX0sYWRkRXZlbnRMaXN0ZW5lcjpmdW5jdGlvbihhLGIpe1wiZnVuY3Rpb25cIj09dHlwZW9mIGImJlwiZmluaXNoXCI9PWEmJnRoaXMuX2ZpbmlzaEhhbmRsZXJzLnB1c2goYil9LHJlbW92ZUV2ZW50TGlzdGVuZXI6ZnVuY3Rpb24oYSxiKXtpZihcImZpbmlzaFwiPT1hKXt2YXIgYz10aGlzLl9maW5pc2hIYW5kbGVycy5pbmRleE9mKGIpO2M+PTAmJnRoaXMuX2ZpbmlzaEhhbmRsZXJzLnNwbGljZShjLDEpfX0sX2ZpcmVFdmVudHM6ZnVuY3Rpb24oYSl7aWYodGhpcy5faXNGaW5pc2hlZCl7aWYoIXRoaXMuX2ZpbmlzaGVkRmxhZyl7dmFyIGI9bmV3IGQodGhpcyx0aGlzLl9jdXJyZW50VGltZSxhKSxjPXRoaXMuX2ZpbmlzaEhhbmRsZXJzLmNvbmNhdCh0aGlzLm9uZmluaXNoP1t0aGlzLm9uZmluaXNoXTpbXSk7c2V0VGltZW91dChmdW5jdGlvbigpe2MuZm9yRWFjaChmdW5jdGlvbihhKXthLmNhbGwoYi50YXJnZXQsYil9KX0sMCksdGhpcy5fZmluaXNoZWRGbGFnPSEwfX1lbHNlIHRoaXMuX2ZpbmlzaGVkRmxhZz0hMX0sX3RpY2s6ZnVuY3Rpb24oYSxiKXt0aGlzLl9pZGxlfHx0aGlzLl9wYXVzZWR8fChudWxsPT10aGlzLl9zdGFydFRpbWU/YiYmKHRoaXMuc3RhcnRUaW1lPWEtdGhpcy5fY3VycmVudFRpbWUvdGhpcy5wbGF5YmFja1JhdGUpOnRoaXMuX2lzRmluaXNoZWR8fHRoaXMuX3RpY2tDdXJyZW50VGltZSgoYS10aGlzLl9zdGFydFRpbWUpKnRoaXMucGxheWJhY2tSYXRlKSksYiYmKHRoaXMuX2N1cnJlbnRUaW1lUGVuZGluZz0hMSx0aGlzLl9maXJlRXZlbnRzKGEpKX0sZ2V0IF9uZWVkc1RpY2soKXtyZXR1cm4gdGhpcy5wbGF5U3RhdGUgaW57cGVuZGluZzoxLHJ1bm5pbmc6MX18fCF0aGlzLl9maW5pc2hlZEZsYWd9LF90YXJnZXRBbmltYXRpb25zOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5fZWZmZWN0Ll90YXJnZXQ7cmV0dXJuIGEuX2FjdGl2ZUFuaW1hdGlvbnN8fChhLl9hY3RpdmVBbmltYXRpb25zPVtdKSxhLl9hY3RpdmVBbmltYXRpb25zfSxfbWFya1RhcmdldDpmdW5jdGlvbigpe3ZhciBhPXRoaXMuX3RhcmdldEFuaW1hdGlvbnMoKTstMT09PWEuaW5kZXhPZih0aGlzKSYmYS5wdXNoKHRoaXMpfSxfdW5tYXJrVGFyZ2V0OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5fdGFyZ2V0QW5pbWF0aW9ucygpLGI9YS5pbmRleE9mKHRoaXMpOy0xIT09YiYmYS5zcGxpY2UoYiwxKX19fShjLGQpLGZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKGEpe3ZhciBiPWo7aj1bXSxhPHEuY3VycmVudFRpbWUmJihhPXEuY3VycmVudFRpbWUpLHEuX2FuaW1hdGlvbnMuc29ydChlKSxxLl9hbmltYXRpb25zPWgoYSwhMCxxLl9hbmltYXRpb25zKVswXSxiLmZvckVhY2goZnVuY3Rpb24oYil7YlsxXShhKX0pLGcoKSxsPXZvaWQgMH1mdW5jdGlvbiBlKGEsYil7cmV0dXJuIGEuX3NlcXVlbmNlTnVtYmVyLWIuX3NlcXVlbmNlTnVtYmVyfWZ1bmN0aW9uIGYoKXt0aGlzLl9hbmltYXRpb25zPVtdLHRoaXMuY3VycmVudFRpbWU9d2luZG93LnBlcmZvcm1hbmNlJiZwZXJmb3JtYW5jZS5ub3c/cGVyZm9ybWFuY2Uubm93KCk6MH1mdW5jdGlvbiBnKCl7by5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EoKX0pLG8ubGVuZ3RoPTB9ZnVuY3Rpb24gaChhLGMsZCl7cD0hMCxuPSExLGIudGltZWxpbmUuY3VycmVudFRpbWU9YSxtPSExO3ZhciBlPVtdLGY9W10sZz1bXSxoPVtdO3JldHVybiBkLmZvckVhY2goZnVuY3Rpb24oYil7Yi5fdGljayhhLGMpLGIuX2luRWZmZWN0PyhmLnB1c2goYi5fZWZmZWN0KSxiLl9tYXJrVGFyZ2V0KCkpOihlLnB1c2goYi5fZWZmZWN0KSxiLl91bm1hcmtUYXJnZXQoKSksYi5fbmVlZHNUaWNrJiYobT0hMCk7dmFyIGQ9Yi5faW5FZmZlY3R8fGIuX25lZWRzVGljaztiLl9pblRpbWVsaW5lPWQsZD9nLnB1c2goYik6aC5wdXNoKGIpfSksby5wdXNoLmFwcGx5KG8sZSksby5wdXNoLmFwcGx5KG8sZiksbSYmcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7fSkscD0hMSxbZyxoXX12YXIgaT13aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLGo9W10saz0wO3dpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU9ZnVuY3Rpb24oYSl7dmFyIGI9aysrO3JldHVybiAwPT1qLmxlbmd0aCYmaShkKSxqLnB1c2goW2IsYV0pLGJ9LHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZT1mdW5jdGlvbihhKXtqLmZvckVhY2goZnVuY3Rpb24oYil7YlswXT09YSYmKGJbMV09ZnVuY3Rpb24oKXt9KX0pfSxmLnByb3RvdHlwZT17X3BsYXk6ZnVuY3Rpb24oYyl7Yy5fdGltaW5nPWEubm9ybWFsaXplVGltaW5nSW5wdXQoYy50aW1pbmcpO3ZhciBkPW5ldyBiLkFuaW1hdGlvbihjKTtyZXR1cm4gZC5faWRsZT0hMSxkLl90aW1lbGluZT10aGlzLHRoaXMuX2FuaW1hdGlvbnMucHVzaChkKSxiLnJlc3RhcnQoKSxiLmFwcGx5RGlydGllZEFuaW1hdGlvbihkKSxkfX07dmFyIGw9dm9pZCAwLG09ITEsbj0hMTtiLnJlc3RhcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gbXx8KG09ITAscmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7fSksbj0hMCksbn0sYi5hcHBseURpcnRpZWRBbmltYXRpb249ZnVuY3Rpb24oYSl7aWYoIXApe2EuX21hcmtUYXJnZXQoKTt2YXIgYz1hLl90YXJnZXRBbmltYXRpb25zKCk7Yy5zb3J0KGUpLGgoYi50aW1lbGluZS5jdXJyZW50VGltZSwhMSxjLnNsaWNlKCkpWzFdLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGI9cS5fYW5pbWF0aW9ucy5pbmRleE9mKGEpOy0xIT09YiYmcS5fYW5pbWF0aW9ucy5zcGxpY2UoYiwxKX0pLGcoKX19O3ZhciBvPVtdLHA9ITEscT1uZXcgZjtiLnRpbWVsaW5lPXF9KGMsZCksZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEsYil7Zm9yKHZhciBjPTAsZD0wO2Q8YS5sZW5ndGg7ZCsrKWMrPWFbZF0qYltkXTtyZXR1cm4gY31mdW5jdGlvbiBkKGEsYil7cmV0dXJuW2FbMF0qYlswXSthWzRdKmJbMV0rYVs4XSpiWzJdK2FbMTJdKmJbM10sYVsxXSpiWzBdK2FbNV0qYlsxXSthWzldKmJbMl0rYVsxM10qYlszXSxhWzJdKmJbMF0rYVs2XSpiWzFdK2FbMTBdKmJbMl0rYVsxNF0qYlszXSxhWzNdKmJbMF0rYVs3XSpiWzFdK2FbMTFdKmJbMl0rYVsxNV0qYlszXSxhWzBdKmJbNF0rYVs0XSpiWzVdK2FbOF0qYls2XSthWzEyXSpiWzddLGFbMV0qYls0XSthWzVdKmJbNV0rYVs5XSpiWzZdK2FbMTNdKmJbN10sYVsyXSpiWzRdK2FbNl0qYls1XSthWzEwXSpiWzZdK2FbMTRdKmJbN10sYVszXSpiWzRdK2FbN10qYls1XSthWzExXSpiWzZdK2FbMTVdKmJbN10sYVswXSpiWzhdK2FbNF0qYls5XSthWzhdKmJbMTBdK2FbMTJdKmJbMTFdLGFbMV0qYls4XSthWzVdKmJbOV0rYVs5XSpiWzEwXSthWzEzXSpiWzExXSxhWzJdKmJbOF0rYVs2XSpiWzldK2FbMTBdKmJbMTBdK2FbMTRdKmJbMTFdLGFbM10qYls4XSthWzddKmJbOV0rYVsxMV0qYlsxMF0rYVsxNV0qYlsxMV0sYVswXSpiWzEyXSthWzRdKmJbMTNdK2FbOF0qYlsxNF0rYVsxMl0qYlsxNV0sYVsxXSpiWzEyXSthWzVdKmJbMTNdK2FbOV0qYlsxNF0rYVsxM10qYlsxNV0sYVsyXSpiWzEyXSthWzZdKmJbMTNdK2FbMTBdKmJbMTRdK2FbMTRdKmJbMTVdLGFbM10qYlsxMl0rYVs3XSpiWzEzXSthWzExXSpiWzE0XSthWzE1XSpiWzE1XV19ZnVuY3Rpb24gZShhKXt2YXIgYj1hLnJhZHx8MDtyZXR1cm4oKGEuZGVnfHwwKS8zNjArKGEuZ3JhZHx8MCkvNDAwKyhhLnR1cm58fDApKSooMipNYXRoLlBJKStifWZ1bmN0aW9uIGYoYSl7c3dpdGNoKGEudCl7Y2FzZVwicm90YXRleFwiOnZhciBiPWUoYS5kWzBdKTtyZXR1cm5bMSwwLDAsMCwwLE1hdGguY29zKGIpLE1hdGguc2luKGIpLDAsMCwtTWF0aC5zaW4oYiksTWF0aC5jb3MoYiksMCwwLDAsMCwxXTtjYXNlXCJyb3RhdGV5XCI6dmFyIGI9ZShhLmRbMF0pO3JldHVybltNYXRoLmNvcyhiKSwwLC1NYXRoLnNpbihiKSwwLDAsMSwwLDAsTWF0aC5zaW4oYiksMCxNYXRoLmNvcyhiKSwwLDAsMCwwLDFdO2Nhc2VcInJvdGF0ZVwiOmNhc2VcInJvdGF0ZXpcIjp2YXIgYj1lKGEuZFswXSk7cmV0dXJuW01hdGguY29zKGIpLE1hdGguc2luKGIpLDAsMCwtTWF0aC5zaW4oYiksTWF0aC5jb3MoYiksMCwwLDAsMCwxLDAsMCwwLDAsMV07Y2FzZVwicm90YXRlM2RcIjp2YXIgYz1hLmRbMF0sZD1hLmRbMV0sZj1hLmRbMl0sYj1lKGEuZFszXSksZz1jKmMrZCpkK2YqZjtpZigwPT09ZyljPTEsZD0wLGY9MDtlbHNlIGlmKDEhPT1nKXt2YXIgaD1NYXRoLnNxcnQoZyk7Yy89aCxkLz1oLGYvPWh9dmFyIGk9TWF0aC5zaW4oYi8yKSxqPWkqTWF0aC5jb3MoYi8yKSxrPWkqaTtyZXR1cm5bMS0yKihkKmQrZipmKSprLDIqKGMqZCprK2YqaiksMiooYypmKmstZCpqKSwwLDIqKGMqZCprLWYqaiksMS0yKihjKmMrZipmKSprLDIqKGQqZiprK2MqaiksMCwyKihjKmYqaytkKmopLDIqKGQqZiprLWMqaiksMS0yKihjKmMrZCpkKSprLDAsMCwwLDAsMV07Y2FzZVwic2NhbGVcIjpyZXR1cm5bYS5kWzBdLDAsMCwwLDAsYS5kWzFdLDAsMCwwLDAsMSwwLDAsMCwwLDFdO2Nhc2VcInNjYWxleFwiOnJldHVyblthLmRbMF0sMCwwLDAsMCwxLDAsMCwwLDAsMSwwLDAsMCwwLDFdO2Nhc2VcInNjYWxleVwiOnJldHVyblsxLDAsMCwwLDAsYS5kWzBdLDAsMCwwLDAsMSwwLDAsMCwwLDFdO2Nhc2VcInNjYWxlelwiOnJldHVyblsxLDAsMCwwLDAsMSwwLDAsMCwwLGEuZFswXSwwLDAsMCwwLDFdO2Nhc2VcInNjYWxlM2RcIjpyZXR1cm5bYS5kWzBdLDAsMCwwLDAsYS5kWzFdLDAsMCwwLDAsYS5kWzJdLDAsMCwwLDAsMV07Y2FzZVwic2tld1wiOnZhciBsPWUoYS5kWzBdKSxtPWUoYS5kWzFdKTtyZXR1cm5bMSxNYXRoLnRhbihtKSwwLDAsTWF0aC50YW4obCksMSwwLDAsMCwwLDEsMCwwLDAsMCwxXTtjYXNlXCJza2V3eFwiOnZhciBiPWUoYS5kWzBdKTtyZXR1cm5bMSwwLDAsMCxNYXRoLnRhbihiKSwxLDAsMCwwLDAsMSwwLDAsMCwwLDFdO2Nhc2VcInNrZXd5XCI6dmFyIGI9ZShhLmRbMF0pO3JldHVyblsxLE1hdGgudGFuKGIpLDAsMCwwLDEsMCwwLDAsMCwxLDAsMCwwLDAsMV07Y2FzZVwidHJhbnNsYXRlXCI6dmFyIGM9YS5kWzBdLnB4fHwwLGQ9YS5kWzFdLnB4fHwwO3JldHVyblsxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCxjLGQsMCwxXTtjYXNlXCJ0cmFuc2xhdGV4XCI6dmFyIGM9YS5kWzBdLnB4fHwwO3JldHVyblsxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCxjLDAsMCwxXTtjYXNlXCJ0cmFuc2xhdGV5XCI6dmFyIGQ9YS5kWzBdLnB4fHwwO3JldHVyblsxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLGQsMCwxXTtjYXNlXCJ0cmFuc2xhdGV6XCI6dmFyIGY9YS5kWzBdLnB4fHwwO3JldHVyblsxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsZiwxXTtjYXNlXCJ0cmFuc2xhdGUzZFwiOnZhciBjPWEuZFswXS5weHx8MCxkPWEuZFsxXS5weHx8MCxmPWEuZFsyXS5weHx8MDtyZXR1cm5bMSwwLDAsMCwwLDEsMCwwLDAsMCwxLDAsYyxkLGYsMV07Y2FzZVwicGVyc3BlY3RpdmVcIjpyZXR1cm5bMSwwLDAsMCwwLDEsMCwwLDAsMCwxLGEuZFswXS5weD8tMS9hLmRbMF0ucHg6MCwwLDAsMCwxXTtjYXNlXCJtYXRyaXhcIjpyZXR1cm5bYS5kWzBdLGEuZFsxXSwwLDAsYS5kWzJdLGEuZFszXSwwLDAsMCwwLDEsMCxhLmRbNF0sYS5kWzVdLDAsMV07Y2FzZVwibWF0cml4M2RcIjpyZXR1cm4gYS5kfX1mdW5jdGlvbiBnKGEpe3JldHVybiAwPT09YS5sZW5ndGg/WzEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLDAsMCwwLDFdOmEubWFwKGYpLnJlZHVjZShkKX1mdW5jdGlvbiBoKGEpe3JldHVybltpKGcoYSkpXX12YXIgaT1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoYSl7cmV0dXJuIGFbMF1bMF0qYVsxXVsxXSphWzJdWzJdK2FbMV1bMF0qYVsyXVsxXSphWzBdWzJdK2FbMl1bMF0qYVswXVsxXSphWzFdWzJdLWFbMF1bMl0qYVsxXVsxXSphWzJdWzBdLWFbMV1bMl0qYVsyXVsxXSphWzBdWzBdLWFbMl1bMl0qYVswXVsxXSphWzFdWzBdfWZ1bmN0aW9uIGIoYil7Zm9yKHZhciBjPTEvYShiKSxkPWJbMF1bMF0sZT1iWzBdWzFdLGY9YlswXVsyXSxnPWJbMV1bMF0saD1iWzFdWzFdLGk9YlsxXVsyXSxqPWJbMl1bMF0saz1iWzJdWzFdLGw9YlsyXVsyXSxtPVtbKGgqbC1pKmspKmMsKGYqay1lKmwpKmMsKGUqaS1mKmgpKmMsMF0sWyhpKmotZypsKSpjLChkKmwtZipqKSpjLChmKmctZCppKSpjLDBdLFsoZyprLWgqaikqYywoaiplLWQqaykqYywoZCpoLWUqZykqYywwXV0sbj1bXSxvPTA7bzwzO28rKyl7Zm9yKHZhciBwPTAscT0wO3E8MztxKyspcCs9YlszXVtxXSptW3FdW29dO24ucHVzaChwKX1yZXR1cm4gbi5wdXNoKDEpLG0ucHVzaChuKSxtfWZ1bmN0aW9uIGQoYSl7cmV0dXJuW1thWzBdWzBdLGFbMV1bMF0sYVsyXVswXSxhWzNdWzBdXSxbYVswXVsxXSxhWzFdWzFdLGFbMl1bMV0sYVszXVsxXV0sW2FbMF1bMl0sYVsxXVsyXSxhWzJdWzJdLGFbM11bMl1dLFthWzBdWzNdLGFbMV1bM10sYVsyXVszXSxhWzNdWzNdXV19ZnVuY3Rpb24gZShhLGIpe2Zvcih2YXIgYz1bXSxkPTA7ZDw0O2QrKyl7Zm9yKHZhciBlPTAsZj0wO2Y8NDtmKyspZSs9YVtmXSpiW2ZdW2RdO2MucHVzaChlKX1yZXR1cm4gY31mdW5jdGlvbiBmKGEpe3ZhciBiPWcoYSk7cmV0dXJuW2FbMF0vYixhWzFdL2IsYVsyXS9iXX1mdW5jdGlvbiBnKGEpe3JldHVybiBNYXRoLnNxcnQoYVswXSphWzBdK2FbMV0qYVsxXSthWzJdKmFbMl0pfWZ1bmN0aW9uIGgoYSxiLGMsZCl7cmV0dXJuW2MqYVswXStkKmJbMF0sYyphWzFdK2QqYlsxXSxjKmFbMl0rZCpiWzJdXX1mdW5jdGlvbiBpKGEsYil7cmV0dXJuW2FbMV0qYlsyXS1hWzJdKmJbMV0sYVsyXSpiWzBdLWFbMF0qYlsyXSxhWzBdKmJbMV0tYVsxXSpiWzBdXX1mdW5jdGlvbiBqKGope3ZhciBrPVtqLnNsaWNlKDAsNCksai5zbGljZSg0LDgpLGouc2xpY2UoOCwxMiksai5zbGljZSgxMiwxNildO2lmKDEhPT1rWzNdWzNdKXJldHVybiBudWxsO2Zvcih2YXIgbD1bXSxtPTA7bTw0O20rKylsLnB1c2goa1ttXS5zbGljZSgpKTtmb3IodmFyIG09MDttPDM7bSsrKWxbbV1bM109MDtpZigwPT09YShsKSlyZXR1cm4gbnVsbDt2YXIgbixvPVtdO2tbMF1bM118fGtbMV1bM118fGtbMl1bM10/KG8ucHVzaChrWzBdWzNdKSxvLnB1c2goa1sxXVszXSksby5wdXNoKGtbMl1bM10pLG8ucHVzaChrWzNdWzNdKSxuPWUobyxkKGIobCkpKSk6bj1bMCwwLDAsMV07dmFyIHA9a1szXS5zbGljZSgwLDMpLHE9W107cS5wdXNoKGtbMF0uc2xpY2UoMCwzKSk7dmFyIHI9W107ci5wdXNoKGcocVswXSkpLHFbMF09ZihxWzBdKTt2YXIgcz1bXTtxLnB1c2goa1sxXS5zbGljZSgwLDMpKSxzLnB1c2goYyhxWzBdLHFbMV0pKSxxWzFdPWgocVsxXSxxWzBdLDEsLXNbMF0pLHIucHVzaChnKHFbMV0pKSxxWzFdPWYocVsxXSksc1swXS89clsxXSxxLnB1c2goa1syXS5zbGljZSgwLDMpKSxzLnB1c2goYyhxWzBdLHFbMl0pKSxxWzJdPWgocVsyXSxxWzBdLDEsLXNbMV0pLHMucHVzaChjKHFbMV0scVsyXSkpLHFbMl09aChxWzJdLHFbMV0sMSwtc1syXSksci5wdXNoKGcocVsyXSkpLHFbMl09ZihxWzJdKSxzWzFdLz1yWzJdLHNbMl0vPXJbMl07dmFyIHQ9aShxWzFdLHFbMl0pO2lmKGMocVswXSx0KTwwKWZvcih2YXIgbT0wO208MzttKyspclttXSo9LTEscVttXVswXSo9LTEscVttXVsxXSo9LTEscVttXVsyXSo9LTE7dmFyIHUsdix3PXFbMF1bMF0rcVsxXVsxXStxWzJdWzJdKzE7cmV0dXJuIHc+MWUtND8odT0uNS9NYXRoLnNxcnQodyksdj1bKHFbMl1bMV0tcVsxXVsyXSkqdSwocVswXVsyXS1xWzJdWzBdKSp1LChxWzFdWzBdLXFbMF1bMV0pKnUsLjI1L3VdKTpxWzBdWzBdPnFbMV1bMV0mJnFbMF1bMF0+cVsyXVsyXT8odT0yKk1hdGguc3FydCgxK3FbMF1bMF0tcVsxXVsxXS1xWzJdWzJdKSx2PVsuMjUqdSwocVswXVsxXStxWzFdWzBdKS91LChxWzBdWzJdK3FbMl1bMF0pL3UsKHFbMl1bMV0tcVsxXVsyXSkvdV0pOnFbMV1bMV0+cVsyXVsyXT8odT0yKk1hdGguc3FydCgxK3FbMV1bMV0tcVswXVswXS1xWzJdWzJdKSx2PVsocVswXVsxXStxWzFdWzBdKS91LC4yNSp1LChxWzFdWzJdK3FbMl1bMV0pL3UsKHFbMF1bMl0tcVsyXVswXSkvdV0pOih1PTIqTWF0aC5zcXJ0KDErcVsyXVsyXS1xWzBdWzBdLXFbMV1bMV0pLHY9WyhxWzBdWzJdK3FbMl1bMF0pL3UsKHFbMV1bMl0rcVsyXVsxXSkvdSwuMjUqdSwocVsxXVswXS1xWzBdWzFdKS91XSksW3AscixzLHYsbl19cmV0dXJuIGp9KCk7YS5kb3Q9YyxhLm1ha2VNYXRyaXhEZWNvbXBvc2l0aW9uPWh9KGQpLGZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYSxiKXt2YXIgYz1hLmV4ZWMoYik7aWYoYylyZXR1cm4gYz1hLmlnbm9yZUNhc2U/Y1swXS50b0xvd2VyQ2FzZSgpOmNbMF0sW2MsYi5zdWJzdHIoYy5sZW5ndGgpXX1mdW5jdGlvbiBjKGEsYil7Yj1iLnJlcGxhY2UoL15cXHMqLyxcIlwiKTt2YXIgYz1hKGIpO2lmKGMpcmV0dXJuW2NbMF0sY1sxXS5yZXBsYWNlKC9eXFxzKi8sXCJcIildfWZ1bmN0aW9uIGQoYSxkLGUpe2E9Yy5iaW5kKG51bGwsYSk7Zm9yKHZhciBmPVtdOzspe3ZhciBnPWEoZSk7aWYoIWcpcmV0dXJuW2YsZV07aWYoZi5wdXNoKGdbMF0pLGU9Z1sxXSwhKGc9YihkLGUpKXx8XCJcIj09Z1sxXSlyZXR1cm5bZixlXTtlPWdbMV19fWZ1bmN0aW9uIGUoYSxiKXtmb3IodmFyIGM9MCxkPTA7ZDxiLmxlbmd0aCYmKCEvXFxzfCwvLnRlc3QoYltkXSl8fDAhPWMpO2QrKylpZihcIihcIj09YltkXSljKys7ZWxzZSBpZihcIilcIj09YltkXSYmKGMtLSwwPT1jJiZkKyssYzw9MCkpYnJlYWs7dmFyIGU9YShiLnN1YnN0cigwLGQpKTtyZXR1cm4gdm9pZCAwPT1lP3ZvaWQgMDpbZSxiLnN1YnN0cihkKV19ZnVuY3Rpb24gZihhLGIpe2Zvcih2YXIgYz1hLGQ9YjtjJiZkOyljPmQ/YyU9ZDpkJT1jO3JldHVybiBjPWEqYi8oYytkKX1mdW5jdGlvbiBnKGEpe3JldHVybiBmdW5jdGlvbihiKXt2YXIgYz1hKGIpO3JldHVybiBjJiYoY1swXT12b2lkIDApLGN9fWZ1bmN0aW9uIGgoYSxiKXtyZXR1cm4gZnVuY3Rpb24oYyl7cmV0dXJuIGEoYyl8fFtiLGNdfX1mdW5jdGlvbiBpKGIsYyl7Zm9yKHZhciBkPVtdLGU9MDtlPGIubGVuZ3RoO2UrKyl7dmFyIGY9YS5jb25zdW1lVHJpbW1lZChiW2VdLGMpO2lmKCFmfHxcIlwiPT1mWzBdKXJldHVybjt2b2lkIDAhPT1mWzBdJiZkLnB1c2goZlswXSksYz1mWzFdfWlmKFwiXCI9PWMpcmV0dXJuIGR9ZnVuY3Rpb24gaihhLGIsYyxkLGUpe2Zvcih2YXIgZz1bXSxoPVtdLGk9W10saj1mKGQubGVuZ3RoLGUubGVuZ3RoKSxrPTA7azxqO2srKyl7dmFyIGw9YihkW2slZC5sZW5ndGhdLGVbayVlLmxlbmd0aF0pO2lmKCFsKXJldHVybjtnLnB1c2gobFswXSksaC5wdXNoKGxbMV0pLGkucHVzaChsWzJdKX1yZXR1cm5bZyxoLGZ1bmN0aW9uKGIpe3ZhciBkPWIubWFwKGZ1bmN0aW9uKGEsYil7cmV0dXJuIGlbYl0oYSl9KS5qb2luKGMpO3JldHVybiBhP2EoZCk6ZH1dfWZ1bmN0aW9uIGsoYSxiLGMpe2Zvcih2YXIgZD1bXSxlPVtdLGY9W10sZz0wLGg9MDtoPGMubGVuZ3RoO2grKylpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBjW2hdKXt2YXIgaT1jW2hdKGFbZ10sYltnKytdKTtkLnB1c2goaVswXSksZS5wdXNoKGlbMV0pLGYucHVzaChpWzJdKX1lbHNlIWZ1bmN0aW9uKGEpe2QucHVzaCghMSksZS5wdXNoKCExKSxmLnB1c2goZnVuY3Rpb24oKXtyZXR1cm4gY1thXX0pfShoKTtyZXR1cm5bZCxlLGZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1cIlwiLGM9MDtjPGEubGVuZ3RoO2MrKyliKz1mW2NdKGFbY10pO3JldHVybiBifV19YS5jb25zdW1lVG9rZW49YixhLmNvbnN1bWVUcmltbWVkPWMsYS5jb25zdW1lUmVwZWF0ZWQ9ZCxhLmNvbnN1bWVQYXJlbnRoZXNpc2VkPWUsYS5pZ25vcmU9ZyxhLm9wdGlvbmFsPWgsYS5jb25zdW1lTGlzdD1pLGEubWVyZ2VOZXN0ZWRSZXBlYXRlZD1qLmJpbmQobnVsbCxudWxsKSxhLm1lcmdlV3JhcHBlZE5lc3RlZFJlcGVhdGVkPWosYS5tZXJnZUxpc3Q9a30oZCksZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihiKXtmdW5jdGlvbiBjKGIpe3ZhciBjPWEuY29uc3VtZVRva2VuKC9eaW5zZXQvaSxiKTtpZihjKXJldHVybiBkLmluc2V0PSEwLGM7dmFyIGM9YS5jb25zdW1lTGVuZ3RoT3JQZXJjZW50KGIpO2lmKGMpcmV0dXJuIGQubGVuZ3Rocy5wdXNoKGNbMF0pLGM7dmFyIGM9YS5jb25zdW1lQ29sb3IoYik7cmV0dXJuIGM/KGQuY29sb3I9Y1swXSxjKTp2b2lkIDB9dmFyIGQ9e2luc2V0OiExLGxlbmd0aHM6W10sY29sb3I6bnVsbH0sZT1hLmNvbnN1bWVSZXBlYXRlZChjLC9eLyxiKTtpZihlJiZlWzBdLmxlbmd0aClyZXR1cm5bZCxlWzFdXX1mdW5jdGlvbiBjKGMpe3ZhciBkPWEuY29uc3VtZVJlcGVhdGVkKGIsL14sLyxjKTtpZihkJiZcIlwiPT1kWzFdKXJldHVybiBkWzBdfWZ1bmN0aW9uIGQoYixjKXtmb3IoO2IubGVuZ3Rocy5sZW5ndGg8TWF0aC5tYXgoYi5sZW5ndGhzLmxlbmd0aCxjLmxlbmd0aHMubGVuZ3RoKTspYi5sZW5ndGhzLnB1c2goe3B4OjB9KTtmb3IoO2MubGVuZ3Rocy5sZW5ndGg8TWF0aC5tYXgoYi5sZW5ndGhzLmxlbmd0aCxjLmxlbmd0aHMubGVuZ3RoKTspYy5sZW5ndGhzLnB1c2goe3B4OjB9KTtpZihiLmluc2V0PT1jLmluc2V0JiYhIWIuY29sb3I9PSEhYy5jb2xvcil7Zm9yKHZhciBkLGU9W10sZj1bW10sMF0sZz1bW10sMF0saD0wO2g8Yi5sZW5ndGhzLmxlbmd0aDtoKyspe3ZhciBpPWEubWVyZ2VEaW1lbnNpb25zKGIubGVuZ3Roc1toXSxjLmxlbmd0aHNbaF0sMj09aCk7ZlswXS5wdXNoKGlbMF0pLGdbMF0ucHVzaChpWzFdKSxlLnB1c2goaVsyXSl9aWYoYi5jb2xvciYmYy5jb2xvcil7dmFyIGo9YS5tZXJnZUNvbG9ycyhiLmNvbG9yLGMuY29sb3IpO2ZbMV09alswXSxnWzFdPWpbMV0sZD1qWzJdfXJldHVybltmLGcsZnVuY3Rpb24oYSl7Zm9yKHZhciBjPWIuaW5zZXQ/XCJpbnNldCBcIjpcIiBcIixmPTA7ZjxlLmxlbmd0aDtmKyspYys9ZVtmXShhWzBdW2ZdKStcIiBcIjtyZXR1cm4gZCYmKGMrPWQoYVsxXSkpLGN9XX19ZnVuY3Rpb24gZShiLGMsZCxlKXtmdW5jdGlvbiBmKGEpe3JldHVybntpbnNldDphLGNvbG9yOlswLDAsMCwwXSxsZW5ndGhzOlt7cHg6MH0se3B4OjB9LHtweDowfSx7cHg6MH1dfX1mb3IodmFyIGc9W10saD1bXSxpPTA7aTxkLmxlbmd0aHx8aTxlLmxlbmd0aDtpKyspe3ZhciBqPWRbaV18fGYoZVtpXS5pbnNldCksaz1lW2ldfHxmKGRbaV0uaW5zZXQpO2cucHVzaChqKSxoLnB1c2goayl9cmV0dXJuIGEubWVyZ2VOZXN0ZWRSZXBlYXRlZChiLGMsZyxoKX12YXIgZj1lLmJpbmQobnVsbCxkLFwiLCBcIik7YS5hZGRQcm9wZXJ0aWVzSGFuZGxlcihjLGYsW1wiYm94LXNoYWRvd1wiLFwidGV4dC1zaGFkb3dcIl0pfShkKSxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSl7cmV0dXJuIGEudG9GaXhlZCgzKS5yZXBsYWNlKC8wKyQvLFwiXCIpLnJlcGxhY2UoL1xcLiQvLFwiXCIpfWZ1bmN0aW9uIGQoYSxiLGMpe3JldHVybiBNYXRoLm1pbihiLE1hdGgubWF4KGEsYykpfWZ1bmN0aW9uIGUoYSl7aWYoL15cXHMqWy0rXT8oXFxkKlxcLik/XFxkK1xccyokLy50ZXN0KGEpKXJldHVybiBOdW1iZXIoYSl9ZnVuY3Rpb24gZihhLGIpe3JldHVyblthLGIsY119ZnVuY3Rpb24gZyhhLGIpe2lmKDAhPWEpcmV0dXJuIGkoMCwxLzApKGEsYil9ZnVuY3Rpb24gaChhLGIpe3JldHVyblthLGIsZnVuY3Rpb24oYSl7cmV0dXJuIE1hdGgucm91bmQoZCgxLDEvMCxhKSl9XX1mdW5jdGlvbiBpKGEsYil7cmV0dXJuIGZ1bmN0aW9uKGUsZil7cmV0dXJuW2UsZixmdW5jdGlvbihlKXtyZXR1cm4gYyhkKGEsYixlKSl9XX19ZnVuY3Rpb24gaihhKXt2YXIgYj1hLnRyaW0oKS5zcGxpdCgvXFxzKltcXHMsXVxccyovKTtpZigwIT09Yi5sZW5ndGgpe2Zvcih2YXIgYz1bXSxkPTA7ZDxiLmxlbmd0aDtkKyspe3ZhciBmPWUoYltkXSk7aWYodm9pZCAwPT09ZilyZXR1cm47Yy5wdXNoKGYpfXJldHVybiBjfX1mdW5jdGlvbiBrKGEsYil7aWYoYS5sZW5ndGg9PWIubGVuZ3RoKXJldHVyblthLGIsZnVuY3Rpb24oYSl7cmV0dXJuIGEubWFwKGMpLmpvaW4oXCIgXCIpfV19ZnVuY3Rpb24gbChhLGIpe3JldHVyblthLGIsTWF0aC5yb3VuZF19YS5jbGFtcD1kLGEuYWRkUHJvcGVydGllc0hhbmRsZXIoaixrLFtcInN0cm9rZS1kYXNoYXJyYXlcIl0pLGEuYWRkUHJvcGVydGllc0hhbmRsZXIoZSxpKDAsMS8wKSxbXCJib3JkZXItaW1hZ2Utd2lkdGhcIixcImxpbmUtaGVpZ2h0XCJdKSxhLmFkZFByb3BlcnRpZXNIYW5kbGVyKGUsaSgwLDEpLFtcIm9wYWNpdHlcIixcInNoYXBlLWltYWdlLXRocmVzaG9sZFwiXSksYS5hZGRQcm9wZXJ0aWVzSGFuZGxlcihlLGcsW1wiZmxleC1ncm93XCIsXCJmbGV4LXNocmlua1wiXSksYS5hZGRQcm9wZXJ0aWVzSGFuZGxlcihlLGgsW1wib3JwaGFuc1wiLFwid2lkb3dzXCJdKSxhLmFkZFByb3BlcnRpZXNIYW5kbGVyKGUsbCxbXCJ6LWluZGV4XCJdKSxhLnBhcnNlTnVtYmVyPWUsYS5wYXJzZU51bWJlckxpc3Q9aixhLm1lcmdlTnVtYmVycz1mLGEubnVtYmVyVG9TdHJpbmc9Y30oZCksZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEsYil7aWYoXCJ2aXNpYmxlXCI9PWF8fFwidmlzaWJsZVwiPT1iKXJldHVyblswLDEsZnVuY3Rpb24oYyl7cmV0dXJuIGM8PTA/YTpjPj0xP2I6XCJ2aXNpYmxlXCJ9XX1hLmFkZFByb3BlcnRpZXNIYW5kbGVyKFN0cmluZyxjLFtcInZpc2liaWxpdHlcIl0pfShkKSxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSl7YT1hLnRyaW0oKSxmLmZpbGxTdHlsZT1cIiMwMDBcIixmLmZpbGxTdHlsZT1hO3ZhciBiPWYuZmlsbFN0eWxlO2lmKGYuZmlsbFN0eWxlPVwiI2ZmZlwiLGYuZmlsbFN0eWxlPWEsYj09Zi5maWxsU3R5bGUpe2YuZmlsbFJlY3QoMCwwLDEsMSk7dmFyIGM9Zi5nZXRJbWFnZURhdGEoMCwwLDEsMSkuZGF0YTtmLmNsZWFyUmVjdCgwLDAsMSwxKTt2YXIgZD1jWzNdLzI1NTtyZXR1cm5bY1swXSpkLGNbMV0qZCxjWzJdKmQsZF19fWZ1bmN0aW9uIGQoYixjKXtyZXR1cm5bYixjLGZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSl7cmV0dXJuIE1hdGgubWF4KDAsTWF0aC5taW4oMjU1LGEpKX1pZihiWzNdKWZvcih2YXIgZD0wO2Q8MztkKyspYltkXT1NYXRoLnJvdW5kKGMoYltkXS9iWzNdKSk7cmV0dXJuIGJbM109YS5udW1iZXJUb1N0cmluZyhhLmNsYW1wKDAsMSxiWzNdKSksXCJyZ2JhKFwiK2Iuam9pbihcIixcIikrXCIpXCJ9XX12YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsXCJjYW52YXNcIik7ZS53aWR0aD1lLmhlaWdodD0xO3ZhciBmPWUuZ2V0Q29udGV4dChcIjJkXCIpO2EuYWRkUHJvcGVydGllc0hhbmRsZXIoYyxkLFtcImJhY2tncm91bmQtY29sb3JcIixcImJvcmRlci1ib3R0b20tY29sb3JcIixcImJvcmRlci1sZWZ0LWNvbG9yXCIsXCJib3JkZXItcmlnaHQtY29sb3JcIixcImJvcmRlci10b3AtY29sb3JcIixcImNvbG9yXCIsXCJmaWxsXCIsXCJmbG9vZC1jb2xvclwiLFwibGlnaHRpbmctY29sb3JcIixcIm91dGxpbmUtY29sb3JcIixcInN0b3AtY29sb3JcIixcInN0cm9rZVwiLFwidGV4dC1kZWNvcmF0aW9uLWNvbG9yXCJdKSxhLmNvbnN1bWVDb2xvcj1hLmNvbnN1bWVQYXJlbnRoZXNpc2VkLmJpbmQobnVsbCxjKSxhLm1lcmdlQ29sb3JzPWR9KGQpLGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhLGIpe2lmKFwiMFwiPT0oYj1iLnRyaW0oKS50b0xvd2VyQ2FzZSgpKSYmXCJweFwiLnNlYXJjaChhKT49MClyZXR1cm57cHg6MH07aWYoL15bXihdKiR8XmNhbGMvLnRlc3QoYikpe2I9Yi5yZXBsYWNlKC9jYWxjXFwoL2csXCIoXCIpO3ZhciBjPXt9O2I9Yi5yZXBsYWNlKGEsZnVuY3Rpb24oYSl7cmV0dXJuIGNbYV09bnVsbCxcIlVcIithfSk7Zm9yKHZhciBkPVwiVShcIithLnNvdXJjZStcIilcIixlPWIucmVwbGFjZSgvWy0rXT8oXFxkKlxcLik/XFxkKy9nLFwiTlwiKS5yZXBsYWNlKG5ldyBSZWdFeHAoXCJOXCIrZCxcImdcIiksXCJEXCIpLnJlcGxhY2UoL1xcc1srLV1cXHMvZyxcIk9cIikucmVwbGFjZSgvXFxzL2csXCJcIiksZj1bL05cXCooRCkvZywvKE58RClbKlxcL11OL2csLyhOfEQpT1xcMS9nLC9cXCgoTnxEKVxcKS9nXSxnPTA7ZzxmLmxlbmd0aDspZltnXS50ZXN0KGUpPyhlPWUucmVwbGFjZShmW2ddLFwiJDFcIiksZz0wKTpnKys7aWYoXCJEXCI9PWUpe2Zvcih2YXIgaCBpbiBjKXt2YXIgaT1ldmFsKGIucmVwbGFjZShuZXcgUmVnRXhwKFwiVVwiK2gsXCJnXCIpLFwiXCIpLnJlcGxhY2UobmV3IFJlZ0V4cChkLFwiZ1wiKSxcIiowXCIpKTtpZighaXNGaW5pdGUoaSkpcmV0dXJuO2NbaF09aX1yZXR1cm4gY319fWZ1bmN0aW9uIGQoYSxiKXtyZXR1cm4gZShhLGIsITApfWZ1bmN0aW9uIGUoYixjLGQpe3ZhciBlLGY9W107Zm9yKGUgaW4gYilmLnB1c2goZSk7Zm9yKGUgaW4gYylmLmluZGV4T2YoZSk8MCYmZi5wdXNoKGUpO3JldHVybiBiPWYubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBiW2FdfHwwfSksYz1mLm1hcChmdW5jdGlvbihhKXtyZXR1cm4gY1thXXx8MH0pLFtiLGMsZnVuY3Rpb24oYil7dmFyIGM9Yi5tYXAoZnVuY3Rpb24oYyxlKXtyZXR1cm4gMT09Yi5sZW5ndGgmJmQmJihjPU1hdGgubWF4KGMsMCkpLGEubnVtYmVyVG9TdHJpbmcoYykrZltlXX0pLmpvaW4oXCIgKyBcIik7cmV0dXJuIGIubGVuZ3RoPjE/XCJjYWxjKFwiK2MrXCIpXCI6Y31dfXZhciBmPVwicHh8ZW18ZXh8Y2h8cmVtfHZ3fHZofHZtaW58dm1heHxjbXxtbXxpbnxwdHxwY1wiLGc9Yy5iaW5kKG51bGwsbmV3IFJlZ0V4cChmLFwiZ1wiKSksaD1jLmJpbmQobnVsbCxuZXcgUmVnRXhwKGYrXCJ8JVwiLFwiZ1wiKSksaT1jLmJpbmQobnVsbCwvZGVnfHJhZHxncmFkfHR1cm4vZyk7YS5wYXJzZUxlbmd0aD1nLGEucGFyc2VMZW5ndGhPclBlcmNlbnQ9aCxhLmNvbnN1bWVMZW5ndGhPclBlcmNlbnQ9YS5jb25zdW1lUGFyZW50aGVzaXNlZC5iaW5kKG51bGwsaCksYS5wYXJzZUFuZ2xlPWksYS5tZXJnZURpbWVuc2lvbnM9ZTt2YXIgaj1hLmNvbnN1bWVQYXJlbnRoZXNpc2VkLmJpbmQobnVsbCxnKSxrPWEuY29uc3VtZVJlcGVhdGVkLmJpbmQodm9pZCAwLGosL14vKSxsPWEuY29uc3VtZVJlcGVhdGVkLmJpbmQodm9pZCAwLGssL14sLyk7YS5jb25zdW1lU2l6ZVBhaXJMaXN0PWw7dmFyIG09ZnVuY3Rpb24oYSl7dmFyIGI9bChhKTtpZihiJiZcIlwiPT1iWzFdKXJldHVybiBiWzBdfSxuPWEubWVyZ2VOZXN0ZWRSZXBlYXRlZC5iaW5kKHZvaWQgMCxkLFwiIFwiKSxvPWEubWVyZ2VOZXN0ZWRSZXBlYXRlZC5iaW5kKHZvaWQgMCxuLFwiLFwiKTthLm1lcmdlTm9uTmVnYXRpdmVTaXplUGFpcj1uLGEuYWRkUHJvcGVydGllc0hhbmRsZXIobSxvLFtcImJhY2tncm91bmQtc2l6ZVwiXSksYS5hZGRQcm9wZXJ0aWVzSGFuZGxlcihoLGQsW1wiYm9yZGVyLWJvdHRvbS13aWR0aFwiLFwiYm9yZGVyLWltYWdlLXdpZHRoXCIsXCJib3JkZXItbGVmdC13aWR0aFwiLFwiYm9yZGVyLXJpZ2h0LXdpZHRoXCIsXCJib3JkZXItdG9wLXdpZHRoXCIsXCJmbGV4LWJhc2lzXCIsXCJmb250LXNpemVcIixcImhlaWdodFwiLFwibGluZS1oZWlnaHRcIixcIm1heC1oZWlnaHRcIixcIm1heC13aWR0aFwiLFwib3V0bGluZS13aWR0aFwiLFwid2lkdGhcIl0pLGEuYWRkUHJvcGVydGllc0hhbmRsZXIoaCxlLFtcImJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXNcIixcImJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzXCIsXCJib3JkZXItdG9wLWxlZnQtcmFkaXVzXCIsXCJib3JkZXItdG9wLXJpZ2h0LXJhZGl1c1wiLFwiYm90dG9tXCIsXCJsZWZ0XCIsXCJsZXR0ZXItc3BhY2luZ1wiLFwibWFyZ2luLWJvdHRvbVwiLFwibWFyZ2luLWxlZnRcIixcIm1hcmdpbi1yaWdodFwiLFwibWFyZ2luLXRvcFwiLFwibWluLWhlaWdodFwiLFwibWluLXdpZHRoXCIsXCJvdXRsaW5lLW9mZnNldFwiLFwicGFkZGluZy1ib3R0b21cIixcInBhZGRpbmctbGVmdFwiLFwicGFkZGluZy1yaWdodFwiLFwicGFkZGluZy10b3BcIixcInBlcnNwZWN0aXZlXCIsXCJyaWdodFwiLFwic2hhcGUtbWFyZ2luXCIsXCJzdHJva2UtZGFzaG9mZnNldFwiLFwidGV4dC1pbmRlbnRcIixcInRvcFwiLFwidmVydGljYWwtYWxpZ25cIixcIndvcmQtc3BhY2luZ1wiXSl9KGQsZiksZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGIpe3JldHVybiBhLmNvbnN1bWVMZW5ndGhPclBlcmNlbnQoYil8fGEuY29uc3VtZVRva2VuKC9eYXV0by8sYil9ZnVuY3Rpb24gZChiKXt2YXIgZD1hLmNvbnN1bWVMaXN0KFthLmlnbm9yZShhLmNvbnN1bWVUb2tlbi5iaW5kKG51bGwsL15yZWN0LykpLGEuaWdub3JlKGEuY29uc3VtZVRva2VuLmJpbmQobnVsbCwvXlxcKC8pKSxhLmNvbnN1bWVSZXBlYXRlZC5iaW5kKG51bGwsYywvXiwvKSxhLmlnbm9yZShhLmNvbnN1bWVUb2tlbi5iaW5kKG51bGwsL15cXCkvKSldLGIpO2lmKGQmJjQ9PWRbMF0ubGVuZ3RoKXJldHVybiBkWzBdfWZ1bmN0aW9uIGUoYixjKXtyZXR1cm5cImF1dG9cIj09Ynx8XCJhdXRvXCI9PWM/WyEwLCExLGZ1bmN0aW9uKGQpe3ZhciBlPWQ/YjpjO2lmKFwiYXV0b1wiPT1lKXJldHVyblwiYXV0b1wiO3ZhciBmPWEubWVyZ2VEaW1lbnNpb25zKGUsZSk7cmV0dXJuIGZbMl0oZlswXSl9XTphLm1lcmdlRGltZW5zaW9ucyhiLGMpfWZ1bmN0aW9uIGYoYSl7cmV0dXJuXCJyZWN0KFwiK2ErXCIpXCJ9dmFyIGc9YS5tZXJnZVdyYXBwZWROZXN0ZWRSZXBlYXRlZC5iaW5kKG51bGwsZixlLFwiLCBcIik7YS5wYXJzZUJveD1kLGEubWVyZ2VCb3hlcz1nLGEuYWRkUHJvcGVydGllc0hhbmRsZXIoZCxnLFtcImNsaXBcIl0pfShkKSxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe3ZhciBjPTA7cmV0dXJuIGEubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBhPT09az9iW2MrK106YX0pfX1mdW5jdGlvbiBkKGEpe3JldHVybiBhfWZ1bmN0aW9uIGUoYil7aWYoXCJub25lXCI9PShiPWIudG9Mb3dlckNhc2UoKS50cmltKCkpKXJldHVybltdO2Zvcih2YXIgYyxkPS9cXHMqKFxcdyspXFwoKFteKV0qKVxcKS9nLGU9W10sZj0wO2M9ZC5leGVjKGIpOyl7aWYoYy5pbmRleCE9ZilyZXR1cm47Zj1jLmluZGV4K2NbMF0ubGVuZ3RoO3ZhciBnPWNbMV0saD1uW2ddO2lmKCFoKXJldHVybjt2YXIgaT1jWzJdLnNwbGl0KFwiLFwiKSxqPWhbMF07aWYoai5sZW5ndGg8aS5sZW5ndGgpcmV0dXJuO2Zvcih2YXIgaz1bXSxvPTA7bzxqLmxlbmd0aDtvKyspe3ZhciBwLHE9aVtvXSxyPWpbb107aWYodm9pZCAwPT09KHA9cT97QTpmdW5jdGlvbihiKXtyZXR1cm5cIjBcIj09Yi50cmltKCk/bTphLnBhcnNlQW5nbGUoYil9LE46YS5wYXJzZU51bWJlcixUOmEucGFyc2VMZW5ndGhPclBlcmNlbnQsTDphLnBhcnNlTGVuZ3RofVtyLnRvVXBwZXJDYXNlKCldKHEpOnthOm0sbjprWzBdLHQ6bH1bcl0pKXJldHVybjtrLnB1c2gocCl9aWYoZS5wdXNoKHt0OmcsZDprfSksZC5sYXN0SW5kZXg9PWIubGVuZ3RoKXJldHVybiBlfX1mdW5jdGlvbiBmKGEpe3JldHVybiBhLnRvRml4ZWQoNikucmVwbGFjZShcIi4wMDAwMDBcIixcIlwiKX1mdW5jdGlvbiBnKGIsYyl7aWYoYi5kZWNvbXBvc2l0aW9uUGFpciE9PWMpe2IuZGVjb21wb3NpdGlvblBhaXI9Yzt2YXIgZD1hLm1ha2VNYXRyaXhEZWNvbXBvc2l0aW9uKGIpfWlmKGMuZGVjb21wb3NpdGlvblBhaXIhPT1iKXtjLmRlY29tcG9zaXRpb25QYWlyPWI7dmFyIGU9YS5tYWtlTWF0cml4RGVjb21wb3NpdGlvbihjKX1yZXR1cm4gbnVsbD09ZFswXXx8bnVsbD09ZVswXT9bWyExXSxbITBdLGZ1bmN0aW9uKGEpe3JldHVybiBhP2NbMF0uZDpiWzBdLmR9XTooZFswXS5wdXNoKDApLGVbMF0ucHVzaCgxKSxbZCxlLGZ1bmN0aW9uKGIpe3ZhciBjPWEucXVhdChkWzBdWzNdLGVbMF1bM10sYls1XSk7cmV0dXJuIGEuY29tcG9zZU1hdHJpeChiWzBdLGJbMV0sYlsyXSxjLGJbNF0pLm1hcChmKS5qb2luKFwiLFwiKX1dKX1mdW5jdGlvbiBoKGEpe3JldHVybiBhLnJlcGxhY2UoL1t4eV0vLFwiXCIpfWZ1bmN0aW9uIGkoYSl7cmV0dXJuIGEucmVwbGFjZSgvKHh8eXx6fDNkKT8kLyxcIjNkXCIpfWZ1bmN0aW9uIGooYixjKXt2YXIgZD1hLm1ha2VNYXRyaXhEZWNvbXBvc2l0aW9uJiYhMCxlPSExO2lmKCFiLmxlbmd0aHx8IWMubGVuZ3RoKXtiLmxlbmd0aHx8KGU9ITAsYj1jLGM9W10pO2Zvcih2YXIgZj0wO2Y8Yi5sZW5ndGg7ZisrKXt2YXIgaj1iW2ZdLnQsaz1iW2ZdLmQsbD1cInNjYWxlXCI9PWouc3Vic3RyKDAsNSk/MTowO2MucHVzaCh7dDpqLGQ6ay5tYXAoZnVuY3Rpb24oYSl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGEpcmV0dXJuIGw7dmFyIGI9e307Zm9yKHZhciBjIGluIGEpYltjXT1sO3JldHVybiBifSl9KX19dmFyIG09ZnVuY3Rpb24oYSxiKXtyZXR1cm5cInBlcnNwZWN0aXZlXCI9PWEmJlwicGVyc3BlY3RpdmVcIj09Ynx8KFwibWF0cml4XCI9PWF8fFwibWF0cml4M2RcIj09YSkmJihcIm1hdHJpeFwiPT1ifHxcIm1hdHJpeDNkXCI9PWIpfSxvPVtdLHA9W10scT1bXTtpZihiLmxlbmd0aCE9Yy5sZW5ndGgpe2lmKCFkKXJldHVybjt2YXIgcj1nKGIsYyk7bz1bclswXV0scD1bclsxXV0scT1bW1wibWF0cml4XCIsW3JbMl1dXV19ZWxzZSBmb3IodmFyIGY9MDtmPGIubGVuZ3RoO2YrKyl7dmFyIGoscz1iW2ZdLnQsdD1jW2ZdLnQsdT1iW2ZdLmQsdj1jW2ZdLmQsdz1uW3NdLHg9blt0XTtpZihtKHMsdCkpe2lmKCFkKXJldHVybjt2YXIgcj1nKFtiW2ZdXSxbY1tmXV0pO28ucHVzaChyWzBdKSxwLnB1c2goclsxXSkscS5wdXNoKFtcIm1hdHJpeFwiLFtyWzJdXV0pfWVsc2V7aWYocz09dClqPXM7ZWxzZSBpZih3WzJdJiZ4WzJdJiZoKHMpPT1oKHQpKWo9aChzKSx1PXdbMl0odSksdj14WzJdKHYpO2Vsc2V7aWYoIXdbMV18fCF4WzFdfHxpKHMpIT1pKHQpKXtpZighZClyZXR1cm47dmFyIHI9ZyhiLGMpO289W3JbMF1dLHA9W3JbMV1dLHE9W1tcIm1hdHJpeFwiLFtyWzJdXV1dO2JyZWFrfWo9aShzKSx1PXdbMV0odSksdj14WzFdKHYpfWZvcih2YXIgeT1bXSx6PVtdLEE9W10sQj0wO0I8dS5sZW5ndGg7QisrKXt2YXIgQz1cIm51bWJlclwiPT10eXBlb2YgdVtCXT9hLm1lcmdlTnVtYmVyczphLm1lcmdlRGltZW5zaW9ucyxyPUModVtCXSx2W0JdKTt5W0JdPXJbMF0seltCXT1yWzFdLEEucHVzaChyWzJdKX1vLnB1c2goeSkscC5wdXNoKHopLHEucHVzaChbaixBXSl9fWlmKGUpe3ZhciBEPW87bz1wLHA9RH1yZXR1cm5bbyxwLGZ1bmN0aW9uKGEpe3JldHVybiBhLm1hcChmdW5jdGlvbihhLGIpe3ZhciBjPWEubWFwKGZ1bmN0aW9uKGEsYyl7cmV0dXJuIHFbYl1bMV1bY10oYSl9KS5qb2luKFwiLFwiKTtyZXR1cm5cIm1hdHJpeFwiPT1xW2JdWzBdJiYxNj09Yy5zcGxpdChcIixcIikubGVuZ3RoJiYocVtiXVswXT1cIm1hdHJpeDNkXCIpLHFbYl1bMF0rXCIoXCIrYytcIilcIn0pLmpvaW4oXCIgXCIpfV19dmFyIGs9bnVsbCxsPXtweDowfSxtPXtkZWc6MH0sbj17bWF0cml4OltcIk5OTk5OTlwiLFtrLGssMCwwLGssaywwLDAsMCwwLDEsMCxrLGssMCwxXSxkXSxtYXRyaXgzZDpbXCJOTk5OTk5OTk5OTk5OTk5OXCIsZF0scm90YXRlOltcIkFcIl0scm90YXRleDpbXCJBXCJdLHJvdGF0ZXk6W1wiQVwiXSxyb3RhdGV6OltcIkFcIl0scm90YXRlM2Q6W1wiTk5OQVwiXSxwZXJzcGVjdGl2ZTpbXCJMXCJdLHNjYWxlOltcIk5uXCIsYyhbayxrLDFdKSxkXSxzY2FsZXg6W1wiTlwiLGMoW2ssMSwxXSksYyhbaywxXSldLHNjYWxleTpbXCJOXCIsYyhbMSxrLDFdKSxjKFsxLGtdKV0sc2NhbGV6OltcIk5cIixjKFsxLDEsa10pXSxzY2FsZTNkOltcIk5OTlwiLGRdLHNrZXc6W1wiQWFcIixudWxsLGRdLHNrZXd4OltcIkFcIixudWxsLGMoW2ssbV0pXSxza2V3eTpbXCJBXCIsbnVsbCxjKFttLGtdKV0sdHJhbnNsYXRlOltcIlR0XCIsYyhbayxrLGxdKSxkXSx0cmFuc2xhdGV4OltcIlRcIixjKFtrLGwsbF0pLGMoW2ssbF0pXSx0cmFuc2xhdGV5OltcIlRcIixjKFtsLGssbF0pLGMoW2wsa10pXSx0cmFuc2xhdGV6OltcIkxcIixjKFtsLGwsa10pXSx0cmFuc2xhdGUzZDpbXCJUVExcIixkXX07YS5hZGRQcm9wZXJ0aWVzSGFuZGxlcihlLGosW1widHJhbnNmb3JtXCJdKX0oZCksZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihhKXt2YXIgYj1OdW1iZXIoYSk7aWYoIShpc05hTihiKXx8YjwxMDB8fGI+OTAwfHxiJTEwMCE9MCkpcmV0dXJuIGJ9ZnVuY3Rpb24gYyhiKXtyZXR1cm4gYj0xMDAqTWF0aC5yb3VuZChiLzEwMCksYj1hLmNsYW1wKDEwMCw5MDAsYiksNDAwPT09Yj9cIm5vcm1hbFwiOjcwMD09PWI/XCJib2xkXCI6U3RyaW5nKGIpfWZ1bmN0aW9uIGQoYSxiKXtyZXR1cm5bYSxiLGNdfWEuYWRkUHJvcGVydGllc0hhbmRsZXIoYixkLFtcImZvbnQtd2VpZ2h0XCJdKX0oZCksZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihhKXt2YXIgYj17fTtmb3IodmFyIGMgaW4gYSliW2NdPS1hW2NdO3JldHVybiBifWZ1bmN0aW9uIGMoYil7cmV0dXJuIGEuY29uc3VtZVRva2VuKC9eKGxlZnR8Y2VudGVyfHJpZ2h0fHRvcHxib3R0b20pXFxiL2ksYil8fGEuY29uc3VtZUxlbmd0aE9yUGVyY2VudChiKX1mdW5jdGlvbiBkKGIsZCl7dmFyIGU9YS5jb25zdW1lUmVwZWF0ZWQoYywvXi8sZCk7aWYoZSYmXCJcIj09ZVsxXSl7dmFyIGY9ZVswXTtpZihmWzBdPWZbMF18fFwiY2VudGVyXCIsZlsxXT1mWzFdfHxcImNlbnRlclwiLDM9PWImJihmWzJdPWZbMl18fHtweDowfSksZi5sZW5ndGg9PWIpe2lmKC90b3B8Ym90dG9tLy50ZXN0KGZbMF0pfHwvbGVmdHxyaWdodC8udGVzdChmWzFdKSl7dmFyIGg9ZlswXTtmWzBdPWZbMV0sZlsxXT1ofWlmKC9sZWZ0fHJpZ2h0fGNlbnRlcnxPYmplY3QvLnRlc3QoZlswXSkmJi90b3B8Ym90dG9tfGNlbnRlcnxPYmplY3QvLnRlc3QoZlsxXSkpcmV0dXJuIGYubWFwKGZ1bmN0aW9uKGEpe3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiBhP2E6Z1thXX0pfX19ZnVuY3Rpb24gZShkKXt2YXIgZT1hLmNvbnN1bWVSZXBlYXRlZChjLC9eLyxkKTtpZihlKXtmb3IodmFyIGY9ZVswXSxoPVt7XCIlXCI6NTB9LHtcIiVcIjo1MH1dLGk9MCxqPSExLGs9MDtrPGYubGVuZ3RoO2srKyl7dmFyIGw9ZltrXTtcInN0cmluZ1wiPT10eXBlb2YgbD8oaj0vYm90dG9tfHJpZ2h0Ly50ZXN0KGwpLGk9e2xlZnQ6MCxyaWdodDowLGNlbnRlcjppLHRvcDoxLGJvdHRvbToxfVtsXSxoW2ldPWdbbF0sXCJjZW50ZXJcIj09bCYmaSsrKTooaiYmKGw9YihsKSxsW1wiJVwiXT0obFtcIiVcIl18fDApKzEwMCksaFtpXT1sLGkrKyxqPSExKX1yZXR1cm5baCxlWzFdXX19ZnVuY3Rpb24gZihiKXt2YXIgYz1hLmNvbnN1bWVSZXBlYXRlZChlLC9eLC8sYik7aWYoYyYmXCJcIj09Y1sxXSlyZXR1cm4gY1swXX12YXIgZz17bGVmdDp7XCIlXCI6MH0sY2VudGVyOntcIiVcIjo1MH0scmlnaHQ6e1wiJVwiOjEwMH0sdG9wOntcIiVcIjowfSxib3R0b206e1wiJVwiOjEwMH19LGg9YS5tZXJnZU5lc3RlZFJlcGVhdGVkLmJpbmQobnVsbCxhLm1lcmdlRGltZW5zaW9ucyxcIiBcIik7YS5hZGRQcm9wZXJ0aWVzSGFuZGxlcihkLmJpbmQobnVsbCwzKSxoLFtcInRyYW5zZm9ybS1vcmlnaW5cIl0pLGEuYWRkUHJvcGVydGllc0hhbmRsZXIoZC5iaW5kKG51bGwsMiksaCxbXCJwZXJzcGVjdGl2ZS1vcmlnaW5cIl0pLGEuY29uc3VtZVBvc2l0aW9uPWUsYS5tZXJnZU9mZnNldExpc3Q9aDt2YXIgaT1hLm1lcmdlTmVzdGVkUmVwZWF0ZWQuYmluZChudWxsLGgsXCIsIFwiKTthLmFkZFByb3BlcnRpZXNIYW5kbGVyKGYsaSxbXCJiYWNrZ3JvdW5kLXBvc2l0aW9uXCIsXCJvYmplY3QtcG9zaXRpb25cIl0pfShkKSxmdW5jdGlvbihhKXtmdW5jdGlvbiBiKGIpe3ZhciBjPWEuY29uc3VtZVRva2VuKC9eY2lyY2xlLyxiKTtpZihjJiZjWzBdKXJldHVybltcImNpcmNsZVwiXS5jb25jYXQoYS5jb25zdW1lTGlzdChbYS5pZ25vcmUoYS5jb25zdW1lVG9rZW4uYmluZCh2b2lkIDAsL15cXCgvKSksZCxhLmlnbm9yZShhLmNvbnN1bWVUb2tlbi5iaW5kKHZvaWQgMCwvXmF0LykpLGEuY29uc3VtZVBvc2l0aW9uLGEuaWdub3JlKGEuY29uc3VtZVRva2VuLmJpbmQodm9pZCAwLC9eXFwpLykpXSxjWzFdKSk7dmFyIGY9YS5jb25zdW1lVG9rZW4oL15lbGxpcHNlLyxiKTtpZihmJiZmWzBdKXJldHVybltcImVsbGlwc2VcIl0uY29uY2F0KGEuY29uc3VtZUxpc3QoW2EuaWdub3JlKGEuY29uc3VtZVRva2VuLmJpbmQodm9pZCAwLC9eXFwoLykpLGUsYS5pZ25vcmUoYS5jb25zdW1lVG9rZW4uYmluZCh2b2lkIDAsL15hdC8pKSxhLmNvbnN1bWVQb3NpdGlvbixhLmlnbm9yZShhLmNvbnN1bWVUb2tlbi5iaW5kKHZvaWQgMCwvXlxcKS8pKV0sZlsxXSkpO3ZhciBnPWEuY29uc3VtZVRva2VuKC9ecG9seWdvbi8sYik7cmV0dXJuIGcmJmdbMF0/W1wicG9seWdvblwiXS5jb25jYXQoYS5jb25zdW1lTGlzdChbYS5pZ25vcmUoYS5jb25zdW1lVG9rZW4uYmluZCh2b2lkIDAsL15cXCgvKSksYS5vcHRpb25hbChhLmNvbnN1bWVUb2tlbi5iaW5kKHZvaWQgMCwvXm5vbnplcm9cXHMqLHxeZXZlbm9kZFxccyosLyksXCJub256ZXJvLFwiKSxhLmNvbnN1bWVTaXplUGFpckxpc3QsYS5pZ25vcmUoYS5jb25zdW1lVG9rZW4uYmluZCh2b2lkIDAsL15cXCkvKSldLGdbMV0pKTp2b2lkIDB9ZnVuY3Rpb24gYyhiLGMpe2lmKGJbMF09PT1jWzBdKXJldHVyblwiY2lyY2xlXCI9PWJbMF0/YS5tZXJnZUxpc3QoYi5zbGljZSgxKSxjLnNsaWNlKDEpLFtcImNpcmNsZShcIixhLm1lcmdlRGltZW5zaW9ucyxcIiBhdCBcIixhLm1lcmdlT2Zmc2V0TGlzdCxcIilcIl0pOlwiZWxsaXBzZVwiPT1iWzBdP2EubWVyZ2VMaXN0KGIuc2xpY2UoMSksYy5zbGljZSgxKSxbXCJlbGxpcHNlKFwiLGEubWVyZ2VOb25OZWdhdGl2ZVNpemVQYWlyLFwiIGF0IFwiLGEubWVyZ2VPZmZzZXRMaXN0LFwiKVwiXSk6XCJwb2x5Z29uXCI9PWJbMF0mJmJbMV09PWNbMV0/YS5tZXJnZUxpc3QoYi5zbGljZSgyKSxjLnNsaWNlKDIpLFtcInBvbHlnb24oXCIsYlsxXSxnLFwiKVwiXSk6dm9pZCAwfXZhciBkPWEuY29uc3VtZVBhcmVudGhlc2lzZWQuYmluZChudWxsLGEucGFyc2VMZW5ndGhPclBlcmNlbnQpLGU9YS5jb25zdW1lUmVwZWF0ZWQuYmluZCh2b2lkIDAsZCwvXi8pLGY9YS5tZXJnZU5lc3RlZFJlcGVhdGVkLmJpbmQodm9pZCAwLGEubWVyZ2VEaW1lbnNpb25zLFwiIFwiKSxnPWEubWVyZ2VOZXN0ZWRSZXBlYXRlZC5iaW5kKHZvaWQgMCxmLFwiLFwiKTthLmFkZFByb3BlcnRpZXNIYW5kbGVyKGIsYyxbXCJzaGFwZS1vdXRzaWRlXCJdKX0oZCksZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEsYil7Yi5jb25jYXQoW2FdKS5mb3JFYWNoKGZ1bmN0aW9uKGIpe2IgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlJiYoZFthXT1iKX0pfXZhciBkPXt9O2MoXCJ0cmFuc2Zvcm1cIixbXCJ3ZWJraXRUcmFuc2Zvcm1cIixcIm1zVHJhbnNmb3JtXCJdKSxjKFwidHJhbnNmb3JtT3JpZ2luXCIsW1wid2Via2l0VHJhbnNmb3JtT3JpZ2luXCJdKSxjKFwicGVyc3BlY3RpdmVcIixbXCJ3ZWJraXRQZXJzcGVjdGl2ZVwiXSksYyhcInBlcnNwZWN0aXZlT3JpZ2luXCIsW1wid2Via2l0UGVyc3BlY3RpdmVPcmlnaW5cIl0pLGEucHJvcGVydHlOYW1lPWZ1bmN0aW9uKGEpe3JldHVybiBkW2FdfHxhfX0oZCl9KCksZnVuY3Rpb24oKXtpZih2b2lkIDA9PT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLmFuaW1hdGUoW10pLm9uY2FuY2VsKXt2YXIgYTtpZih3aW5kb3cucGVyZm9ybWFuY2UmJnBlcmZvcm1hbmNlLm5vdyl2YXIgYT1mdW5jdGlvbigpe3JldHVybiBwZXJmb3JtYW5jZS5ub3coKX07ZWxzZSB2YXIgYT1mdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfTt2YXIgYj1mdW5jdGlvbihhLGIsYyl7dGhpcy50YXJnZXQ9YSx0aGlzLmN1cnJlbnRUaW1lPWIsdGhpcy50aW1lbGluZVRpbWU9Yyx0aGlzLnR5cGU9XCJjYW5jZWxcIix0aGlzLmJ1YmJsZXM9ITEsdGhpcy5jYW5jZWxhYmxlPSExLHRoaXMuY3VycmVudFRhcmdldD1hLHRoaXMuZGVmYXVsdFByZXZlbnRlZD0hMSx0aGlzLmV2ZW50UGhhc2U9RXZlbnQuQVRfVEFSR0VULHRoaXMudGltZVN0YW1wPURhdGUubm93KCl9LGM9d2luZG93LkVsZW1lbnQucHJvdG90eXBlLmFuaW1hdGU7d2luZG93LkVsZW1lbnQucHJvdG90eXBlLmFuaW1hdGU9ZnVuY3Rpb24oZCxlKXt2YXIgZj1jLmNhbGwodGhpcyxkLGUpO2YuX2NhbmNlbEhhbmRsZXJzPVtdLGYub25jYW5jZWw9bnVsbDt2YXIgZz1mLmNhbmNlbDtmLmNhbmNlbD1mdW5jdGlvbigpe2cuY2FsbCh0aGlzKTt2YXIgYz1uZXcgYih0aGlzLG51bGwsYSgpKSxkPXRoaXMuX2NhbmNlbEhhbmRsZXJzLmNvbmNhdCh0aGlzLm9uY2FuY2VsP1t0aGlzLm9uY2FuY2VsXTpbXSk7c2V0VGltZW91dChmdW5jdGlvbigpe2QuZm9yRWFjaChmdW5jdGlvbihhKXthLmNhbGwoYy50YXJnZXQsYyl9KX0sMCl9O3ZhciBoPWYuYWRkRXZlbnRMaXN0ZW5lcjtmLmFkZEV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24oYSxiKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBiJiZcImNhbmNlbFwiPT1hP3RoaXMuX2NhbmNlbEhhbmRsZXJzLnB1c2goYik6aC5jYWxsKHRoaXMsYSxiKX07dmFyIGk9Zi5yZW1vdmVFdmVudExpc3RlbmVyO3JldHVybiBmLnJlbW92ZUV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24oYSxiKXtpZihcImNhbmNlbFwiPT1hKXt2YXIgYz10aGlzLl9jYW5jZWxIYW5kbGVycy5pbmRleE9mKGIpO2M+PTAmJnRoaXMuX2NhbmNlbEhhbmRsZXJzLnNwbGljZShjLDEpfWVsc2UgaS5jYWxsKHRoaXMsYSxiKX0sZn19fSgpLGZ1bmN0aW9uKGEpe3ZhciBiPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxjPW51bGwsZD0hMTt0cnl7dmFyIGU9Z2V0Q29tcHV0ZWRTdHlsZShiKS5nZXRQcm9wZXJ0eVZhbHVlKFwib3BhY2l0eVwiKSxmPVwiMFwiPT1lP1wiMVwiOlwiMFwiO2M9Yi5hbmltYXRlKHtvcGFjaXR5OltmLGZdfSx7ZHVyYXRpb246MX0pLGMuY3VycmVudFRpbWU9MCxkPWdldENvbXB1dGVkU3R5bGUoYikuZ2V0UHJvcGVydHlWYWx1ZShcIm9wYWNpdHlcIik9PWZ9Y2F0Y2goYSl7fWZpbmFsbHl7YyYmYy5jYW5jZWwoKX1pZighZCl7dmFyIGc9d2luZG93LkVsZW1lbnQucHJvdG90eXBlLmFuaW1hdGU7d2luZG93LkVsZW1lbnQucHJvdG90eXBlLmFuaW1hdGU9ZnVuY3Rpb24oYixjKXtyZXR1cm4gd2luZG93LlN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yJiZBcnJheS5wcm90b3R5cGUuZnJvbSYmYltTeW1ib2wuaXRlcmF0b3JdJiYoYj1BcnJheS5mcm9tKGIpKSxBcnJheS5pc0FycmF5KGIpfHxudWxsPT09Ynx8KGI9YS5jb252ZXJ0VG9BcnJheUZvcm0oYikpLGcuY2FsbCh0aGlzLGIsYyl9fX0oYyksYi50cnVlPWF9KHt9LGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViLWFuaW1hdGlvbnMubWluLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgMjAxNyBGbG9yaWFuIEtsYW1wZmVyXG4vLyBMaWNlbnNlZCB1bmRlciBNSVRcblxuLy8gY29uc3QgSlNfRkVBVFVSRVMgPSBbXG4vLyAgICdmbi9hcnJheS9mb3ItZWFjaCcsXG4vLyAgICdmbi9mdW5jdGlvbi9iaW5kJyxcbi8vICAgJ2ZuL251bWJlci9jb25zdHJ1Y3RvcicsXG4vLyAgICdmbi9vYmplY3QvYXNzaWduJyxcbi8vICAgJ2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHknLFxuLy8gICAnZm4vb2JqZWN0L2tleXMnLFxuLy8gXTtcblxuLy8gY29uc3QgTU9ERVJOSVpSX1RFU1RTID0gW1xuLy8gICAnY3VzdG9tZXZlbnQnLFxuLy8gXTtcblxuY2xhc3MgTWl4IHt9XG5cbmNvbnN0IFN5bWJvbCA9IGdsb2JhbC5TeW1ib2wgfHwgKHggPT4gYF8ke3h9YCk7XG5cbmNvbnN0IGRlZiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eS5iaW5kKE9iamVjdCk7XG5cbmNvbnN0IFJPT1QgPSBTeW1ib2woJ3Jvb3QnKTtcbmNvbnN0IFNUQVRFID0gU3ltYm9sKCdzdGF0ZScpO1xuXG5mdW5jdGlvbiBjcmVhdGVFdmVudChldmVudE5hbWUsIGRhdGEgPSB7fSkge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCBkYXRhKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnN0IGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgdHJ1ZSwgdHJ1ZSwgZGF0YS5kZXRhaWwpO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXR1cFByb3BlcnR5KGtleSwgc2lkZUVmZmVjdCkge1xuICBkZWYodGhpcywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6ICgpID0+IHRoaXNbU1RBVEVdW2tleV0sXG4gICAgc2V0OiAodmFsdWUpID0+IHtcbiAgICAgIGlmIChzaWRlRWZmZWN0ICE9IG51bGwpIHtcbiAgICAgICAgc2lkZUVmZmVjdCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldFN0YXRlKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG4gIH0pO1xufVxuXG4vLyBUT0RPOiBzdHVkeSBob3cgbmF0aXZlIGVsZW1lbnRzIGRlYWwgd2l0aCBhdHRyaWJ1dGVzL3Byb3Blcml0ZXNcbmZ1bmN0aW9uIHNldHVwUHJvcGVydGllcygpIHtcbiAgY29uc3Qgc2lkZUVmZmVjdHMgPSB0aGlzLnNpZGVFZmZlY3RzKCk7XG5cbiAgT2JqZWN0LmtleXModGhpc1tTVEFURV0pLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdGhpc1trZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3Qgc2lkZUVmZmVjdCA9IHNpZGVFZmZlY3RzW2tleV07XG4gICAgICBzZXR1cFByb3BlcnR5LmNhbGwodGhpcywga2V5LCBzaWRlRWZmZWN0KTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCAoQyA9IE1peCkgPT4gY2xhc3MgZXh0ZW5kcyBDIHtcbiAgZ2V0IGNvbXBvbmVudE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50TmFtZSgpO1xuICB9XG5cbiAgZ2V0Q29tcG9uZW50TmFtZSgpIHtcbiAgICB0aHJvdyBFcnJvcignQ29tcG9uZW50IG5lZWRzIHRvIGhhdmUgYSBuYW1lLCBlLmcuIGBteS10YWdgLiBPdmVycmlkZSBgZ2V0Q29tcG9uZW50TmFtZWAnKTtcbiAgfVxuXG4gIHNldHVwQ29tcG9uZW50KGVsLCBzdGF0ZSkge1xuICAgIGRlZih0aGlzLCBTVEFURSwgeyB2YWx1ZTogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kZWZhdWx0cygpLCBzdGF0ZSkgfSk7XG4gICAgc2V0dXBQcm9wZXJ0aWVzLmNhbGwodGhpcyk7XG4gICAgZGVmKHRoaXMsIFJPT1QsIHsgdmFsdWU6IHRoaXMuc2V0dXBET00oZWwpIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0dXBET00oZWwpIHtcbiAgICByZXR1cm4gZWw7XG4gIH1cblxuICBnZXQgcm9vdCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSb290KCk7XG4gIH1cblxuICBnZXQgZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RWwoKTtcbiAgfVxuXG4gIGdldFJvb3QoKSB7XG4gICAgcmV0dXJuIHRoaXNbUk9PVF07XG4gIH1cblxuICBnZXRFbCgpIHtcbiAgICByZXR1cm4gdGhpc1tST09UXTtcbiAgfVxuXG4gIGZpcmVFdmVudChldmVudE5hbWUsIGRhdGEpIHtcbiAgICBjb25zdCBldmVudE5hbWVOUyA9IGAke3RoaXMuY29tcG9uZW50TmFtZX0tJHtldmVudE5hbWV9YDtcbiAgICB0aGlzLmVsLmRpc3BhdGNoRXZlbnQoY3JlYXRlRXZlbnQoZXZlbnROYW1lTlMsIGRhdGEpKTtcbiAgfVxuXG4gIGRlZmF1bHRzKCkge1xuICAgIC8vIFRPRE86IHByb2R1Y3Rpb24gYnVpbGRzIHdpdGggcHJlcHJvY2Vzcz9cbiAgICBjb25zb2xlLndhcm4oJ2RlZmF1bHRzIG5vdCBwcm92aWRlZCcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBzaWRlRWZmZWN0cygpIHtcbiAgICAvLyBUT0RPOiBwcm9kdWN0aW9uIGJ1aWxkcyB3aXRoIHByZXByb2Nlc3M/XG4gICAgY29uc29sZS53YXJuKCdzaWRlRWZmZWN0cyBub3QgcHJvdmlkZWQnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgc2V0U3RhdGUoa2V5T3JNYXAsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBrZXlPck1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGVLVihrZXlPck1hcCwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGtleU9yTWFwID09PSAnb2JqZWN0Jykge1xuICAgICAgdGhpcy5zZXRTdGF0ZU1hcChrZXlPck1hcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKCdzZXRTdGF0ZSBuZWVkcyBhcmd1bWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIHNldFN0YXRlS1Yoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXNbU1RBVEVdW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHNldFN0YXRlTWFwKG1hcCkge1xuICAgIE9iamVjdC5rZXlzKHRoaXNbU1RBVEVdKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIHRoaXMuc2V0U3RhdGVLVihrZXksIG1hcFtrZXldKTtcbiAgICB9KTtcbiAgfVxufTtcbiIsIi8vIENvcHlyaWdodCAoYykgMjAxNyBGbG9yaWFuIEtsYW1wZmVyXG4vLyBMaWNlbnNlZCB1bmRlciBNSVRcblxuLyoqXG4gICogQHBhcmFtIHQgY3VycmVudCB0aW1lXG4gICogQHBhcmFtIGIgc3RhcnQgdmFsdWVcbiAgKiBAcGFyYW0gYyBjaGFuZ2UgaW4gdmFsdWVcbiAgKiBAcGFyYW0gZCBkdXJhdGlvblxuICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICovXG5mdW5jdGlvbiBsaW5lYXJUd2Vlbih0LCBiLCBjLCBkKSB7XG4gIHJldHVybiAoKGMgKiB0KSAvIGQpICsgYjtcbn1cblxuZnVuY3Rpb24gcGFnZURpc3QocDEsIHAyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoKChwMS5wYWdlWCAtIHAyLnBhZ2VYKSAqKiAyKSArICgocDEucGFnZVkgLSBwMi5wYWdlWSkgKiogMikpO1xufVxuXG5mdW5jdGlvbiBjb250YWlucyh0YXJnZXQsIGNsYXNzTmFtZSkge1xuICBsZXQgdCA9IHRhcmdldDtcbiAgd2hpbGUgKHQgIT0gbnVsbCkge1xuICAgIGlmICh0LmNsYXNzTGlzdCAmJiB0LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdCA9IHQucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCB7IGxpbmVhclR3ZWVuLCBwYWdlRGlzdCwgY29udGFpbnMgfTtcbiIsIi8vIENvcHlyaWdodCAoYykgMjAxNyBGbG9yaWFuIEtsYW1wZmVyXG4vLyBMaWNlbnNlZCB1bmRlciBNSVRcblxuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzLCBpbXBvcnQvbm8tdW5yZXNvbHZlZCwgaW1wb3J0L2V4dGVuc2lvbnMgKi9cblxuaW1wb3J0IGNvbXBvbmVudENvcmUgZnJvbSAneS1jb21wb25lbnQvc3JjL2NvbXBvbmVudC1jb3JlJztcblxuaW1wb3J0IHsgbGluZWFyVHdlZW4sIHBhZ2VEaXN0IH0gZnJvbSAnLi4vY29tbW9uJztcblxuLy8gY29uc3QgSlNfRkVBVFVSRVMgPSBbXG4vLyAgICdmbi9hcnJheS9mb3ItZWFjaCcsXG4vLyAgICdmbi9mdW5jdGlvbi9iaW5kJyxcbi8vICAgJ2ZuL251bWJlci9jb25zdHJ1Y3RvcicsXG4vLyAgICdmbi9vYmplY3QvYXNzaWduJyxcbi8vICAgJ2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHknLFxuLy8gICAnZm4vb2JqZWN0L2tleXMnLFxuLy8gICAnZm4vYXJyYXkvcmVkdWNlJyxcbi8vIF07XG4vL1xuLy8gY29uc3QgTU9ERVJOSVpSX1RFU1RTID0gW1xuLy8gICAnY3VzdG9tZXZlbnQnLFxuLy8gICAnZXZlbnRsaXN0ZW5lcicsXG4vLyAgICdxdWVyeXNlbGVjdG9yJyxcbi8vICAgJ3JlcXVlc3RhbmltYXRpb25mcmFtZScsXG4vLyAgICdjbGFzc2xpc3QnLFxuLy8gICAnb3BhY2l0eScsXG4vLyAgICdjc3N0cmFuc2Zvcm1zJyxcbi8vICAgJ2Nzc3BvaW50ZXJldmVudHMnLFxuLy8gXTtcblxuY29uc3QgU3ltYm9sID0gZ2xvYmFsLlN5bWJvbCB8fCAoeCA9PiBgXyR7eH1gKTtcblxuY29uc3QgSURMRSA9IFN5bWJvbCgnaWRsZScpO1xuY29uc3QgVE9VQ0hJTkcgPSBTeW1ib2woJ3RvdWNoaW5nJyk7XG5jb25zdCBTVEFSVF9BTklNQVRJTkcgPSBTeW1ib2woJ3N0YXJ0QW5pbWF0aW5nJyk7XG5jb25zdCBBTklNQVRJTkcgPSBTeW1ib2woJ2FuaW1hdGluZycpO1xuXG5jb25zdCBWRUxPQ0lUWV9USFJFU0hPTEQgPSAwLjI7XG5jb25zdCBWRUxPQ0lUWV9MSU5FQVJfQ09NQklOQVRJT04gPSAwLjg7XG5cbmNvbnN0IGRlZiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eS5iaW5kKE9iamVjdCk7XG5cbmV4cG9ydCBkZWZhdWx0IEMgPT4gY2xhc3MgZXh0ZW5kcyBjb21wb25lbnRDb3JlKEMpIHtcblxuICAvLyBAb3ZlcnJpZGVcbiAgZ2V0Q29tcG9uZW50TmFtZSgpIHtcbiAgICByZXR1cm4gJ3ktZHJhd2VyJztcbiAgfVxuXG4gIC8vIEBvdmVycmlkZVxuICBkZWZhdWx0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3BlbmVkOiBmYWxzZSxcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogMjAwLFxuICAgICAgcGVyc2lzdGVudDogZmFsc2UsXG4gICAgfTtcbiAgfVxuXG4gIC8vIEBvdmVycmlkZVxuICBzaWRlRWZmZWN0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3BlbmVkOiAobykgPT4ge1xuICAgICAgICBpZiAobyA9PT0gdHJ1ZSkgdGhpcy5vcGVuKCk7XG4gICAgICAgIGVsc2UgdGhpcy5jbG9zZSgpO1xuICAgICAgfSxcbiAgICAgIHBlcnNpc3RlbnQ6IChkKSA9PiB7XG4gICAgICAgIGlmIChkID09PSB0cnVlKSB0aGlzLnBlcnNpc3QoKTtcbiAgICAgICAgZWxzZSB0aGlzLnVucGVyc2lzdCgpO1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgLy8gQG92ZXJyaWRlXG4gIHNldHVwQ29tcG9uZW50KGVsLCBwcm9wcykge1xuICAgIHN1cGVyLnNldHVwQ29tcG9uZW50KGVsLCBwcm9wcyk7XG5cbiAgICB0aGlzLmNhY2hlRE9NRWxlbWVudHMoKTtcbiAgICB0aGlzLmRlZlByb3BlcnRpZXMoKTtcbiAgICB0aGlzLmJpbmRDYWxsYmFja3MoKTtcblxuICAgIHRoaXMuanVtcFRvKHRoaXMub3BlbmVkKTtcbiAgICBpZiAoIXRoaXMucGVyc2lzdGVudCkgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgIGlmICh0aGlzLnBlcnNpc3RlbnQpIHRoaXMuc2NyaW0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY2FjaGVET01FbGVtZW50cygpIHtcbiAgICBkZWYodGhpcywgJ3NjcmltJywgeyB2YWx1ZTogdGhpcy5yb290LnF1ZXJ5U2VsZWN0b3IoJy55LWRyYXdlci1zY3JpbScpIH0pO1xuICAgIGRlZih0aGlzLCAnY29udGVudCcsIHsgdmFsdWU6IHRoaXMucm9vdC5xdWVyeVNlbGVjdG9yKCcueS1kcmF3ZXItY29udGVudCcpIH0pO1xuICB9XG5cbiAgZGVmUHJvcGVydGllcygpIHtcbiAgICBkZWYodGhpcywgJ3N0YXJ0WCcsIHsgdmFsdWU6IDAsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgIGRlZih0aGlzLCAnc3RhcnRZJywgeyB2YWx1ZTogMCwgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgZGVmKHRoaXMsICdwYWdlWCcsIHsgdmFsdWU6IDAsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgIGRlZih0aGlzLCAncGFnZVknLCB7IHZhbHVlOiAwLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgICBkZWYodGhpcywgJ2xhc3RQYWdlWCcsIHsgdmFsdWU6IDAsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgIGRlZih0aGlzLCAnbGFzdFBhZ2VZJywgeyB2YWx1ZTogMCwgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgZGVmKHRoaXMsICdpc1Njcm9sbGluZycsIHsgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgZGVmKHRoaXMsICdzdGFydGVkTW92aW5nJywgeyB2YWx1ZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgIGRlZih0aGlzLCAnbG9vcFN0YXRlJywgeyB2YWx1ZTogSURMRSwgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgZGVmKHRoaXMsICd2ZWxvY2l0eScsIHsgdmFsdWU6IDAsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgIGRlZih0aGlzLCAnc3RhcnRUcmFuc2xhdGVYJywgeyB2YWx1ZTogMCwgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgZGVmKHRoaXMsICd0cmFuc2xhdGVYJywgeyB2YWx1ZTogMCwgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgZGVmKHRoaXMsICdhbmltYXRpb25GcmFtZVJlcXVlc3RlZCcsIHsgdmFsdWU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgICBkZWYodGhpcywgJ3RvdWNoaW5nJywgeyB2YWx1ZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgIGRlZih0aGlzLCAnbGFzdFRpbWUnLCB7IHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgIGRlZih0aGlzLCAnc2xpZGVyV2lkdGgnLCB7IHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgIGRlZih0aGlzLCAnYW5pbWF0aW9uJywgeyB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICB9XG5cbiAgYmluZENhbGxiYWNrcygpIHtcbiAgICBkZWYodGhpcywgJ3RvdWNoU3RhcnRDYWxsYmFjaycsIHsgdmFsdWU6IHRoaXMudG91Y2hTdGFydENhbGxiYWNrLmJpbmQodGhpcykgfSk7XG4gICAgZGVmKHRoaXMsICd0b3VjaE1vdmVDYWxsYmFjaycsIHsgdmFsdWU6IHRoaXMudG91Y2hNb3ZlQ2FsbGJhY2suYmluZCh0aGlzKSB9KTtcbiAgICBkZWYodGhpcywgJ3RvdWNoRW5kQ2FsbGJhY2snLCB7IHZhbHVlOiB0aGlzLnRvdWNoRW5kQ2FsbGJhY2suYmluZCh0aGlzKSB9KTtcbiAgICBkZWYodGhpcywgJ3NjcmltQ2xpY2tDYWxsYmFjaycsIHsgdmFsdWU6IHRoaXMuc2NyaW1DbGlja0NhbGxiYWNrLmJpbmQodGhpcykgfSk7XG4gICAgZGVmKHRoaXMsICdhbmltYXRpb25GcmFtZUNhbGxiYWNrJywgeyB2YWx1ZTogdGhpcy5hbmltYXRpb25GcmFtZUNhbGxiYWNrLmJpbmQodGhpcykgfSk7XG4gIH1cblxuICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy50b3VjaFN0YXJ0Q2FsbGJhY2ssIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy50b3VjaE1vdmVDYWxsYmFjaywgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMudG91Y2hFbmRDYWxsYmFjaywgeyBwYXNzaXZlOiBmYWxzZSB9KTtcblxuICAgIHRoaXMuc2NyaW0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnNjcmltQ2xpY2tDYWxsYmFjayk7XG4gIH1cblxuICByZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy50b3VjaFN0YXJ0Q2FsbGJhY2ssIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy50b3VjaE1vdmVDYWxsYmFjaywgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMudG91Y2hFbmRDYWxsYmFjaywgeyBwYXNzaXZlOiBmYWxzZSB9KTtcblxuICAgIHRoaXMuc2NyaW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnNjcmltQ2xpY2tDYWxsYmFjayk7XG4gIH1cblxuICByZXF1ZXN0QW5pbWF0aW9uTG9vcCgpIHtcbiAgICBpZiAoIXRoaXMuYW5pbWF0aW9uRnJhbWVSZXF1ZXN0ZWQpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uRnJhbWVSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWVDYWxsYmFjayk7XG4gICAgfVxuICB9XG5cbiAgZ2V0TmVhcmVzdFRvdWNoKHRvdWNoZXMpIHtcbiAgICBpZiAodG91Y2hlcy5sZW5ndGggPT09IDEpIHJldHVybiB0b3VjaGVzWzBdO1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUucmVkdWNlLmNhbGwodG91Y2hlcywgKGFjYywgdG91Y2gpID0+IHtcbiAgICAgIGNvbnN0IGRpc3QgPSBwYWdlRGlzdCh0aGlzLCB0b3VjaCk7XG4gICAgICByZXR1cm4gKGRpc3QgPCBhY2MuZGlzdCkgPyB7XG4gICAgICAgIGRpc3QsXG4gICAgICAgIHRvdWNoLFxuICAgICAgfSA6IGFjYztcbiAgICB9LCB7XG4gICAgICBkaXN0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICB0b3VjaDogbnVsbCxcbiAgICB9KS50b3VjaDtcbiAgfVxuXG4gIHRvdWNoU3RhcnRDYWxsYmFjayhlKSB7XG4gICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuaXNTY3JvbGxpbmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGNvbnN0IHRvdWNoID0gZS50b3VjaGVzWzBdO1xuICAgICAgdGhpcy5zdGFydFggPSB0b3VjaC5wYWdlWDtcbiAgICAgIHRoaXMuc3RhcnRZID0gdG91Y2gucGFnZVk7XG4gICAgICB0aGlzLnBhZ2VYID0gdG91Y2gucGFnZVg7XG4gICAgICB0aGlzLnBhZ2VZID0gdG91Y2gucGFnZVk7XG4gICAgICB0aGlzLmxhc3RQYWdlWCA9IHRvdWNoLnBhZ2VYO1xuICAgICAgdGhpcy5sYXN0UGFnZVkgPSB0b3VjaC5wYWdlWTtcblxuICAgICAgaWYgKHRoaXMub3BlbmVkIHx8ICh0aGlzLnBhZ2VYIDwgd2luZG93LmlubmVyV2lkdGggLyAzKSkge1xuICAgICAgICB0aGlzLnByZXBJbnRlcmFjdGlvbigpO1xuICAgICAgICB0aGlzLnRvdWNoaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sb29wU3RhdGUgPSBUT1VDSElORztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0b3VjaE1vdmVDYWxsYmFjayhlKSB7XG4gICAgaWYgKHRoaXMudG91Y2hpbmcpIHtcbiAgICAgIGNvbnN0IHRvdWNoID0gdGhpcy5nZXROZWFyZXN0VG91Y2goZS50b3VjaGVzKTtcbiAgICAgIHRoaXMucGFnZVggPSB0b3VjaC5wYWdlWDtcbiAgICAgIHRoaXMucGFnZVkgPSB0b3VjaC5wYWdlWTtcblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLmlzU2Nyb2xsaW5nID09PSAndW5kZWZpbmVkJyAmJiB0aGlzLnN0YXJ0ZWRNb3ZpbmcpIHtcbiAgICAgICAgdGhpcy5pc1Njcm9sbGluZyA9IE1hdGguYWJzKHRoaXMuc3RhcnRZIC0gdGhpcy5wYWdlWSkgPiBNYXRoLmFicyh0aGlzLnN0YXJ0WCAtIHRoaXMucGFnZVgpO1xuICAgICAgICBpZiAoIXRoaXMuaXNTY3JvbGxpbmcpIHtcbiAgICAgICAgICB0aGlzLmxvb3BTdGF0ZSA9IFRPVUNISU5HO1xuICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkxvb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc1Njcm9sbGluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdGhpcy5zdGFydGVkTW92aW5nID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVNZW51T3BlbigpIHtcbiAgICBpZiAodGhpcy52ZWxvY2l0eSA+IFZFTE9DSVRZX1RIUkVTSE9MRCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSgnb3BlbmVkJywgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnZlbG9jaXR5IDwgLVZFTE9DSVRZX1RIUkVTSE9MRCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSgnb3BlbmVkJywgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50cmFuc2xhdGVYID49IHRoaXMuc2xpZGVyV2lkdGggLyAyKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKCdvcGVuZWQnLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRTdGF0ZSgnb3BlbmVkJywgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIHRvdWNoRW5kQ2FsbGJhY2soZSkge1xuICAgIGlmICh0aGlzLnRvdWNoaW5nKSB7XG4gICAgICBpZiAodGhpcy5pc1Njcm9sbGluZyB8fCBlLnRvdWNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnN0YXJ0ZWRNb3ZpbmcpIHtcbiAgICAgICAgdGhpcy51cGRhdGVNZW51T3BlbigpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcGVuZWQpIHtcbiAgICAgICAgdGhpcy5zY3JpbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2FsbCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNjcmltLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb29wU3RhdGUgPSBTVEFSVF9BTklNQVRJTkc7XG4gICAgICB0aGlzLnN0YXJ0ZWRNb3ZpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMudG91Y2hpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBzY3JpbUNsaWNrQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5jbG9zZSgpO1xuICB9XG5cbiAgcHJlcEludGVyYWN0aW9uKCkge1xuICAgIHRoaXMuY29udGVudC5zdHlsZS53aWxsQ2hhbmdlID0gJ3RyYW5zZm9ybSc7XG4gICAgdGhpcy5zY3JpbS5zdHlsZS53aWxsQ2hhbmdlID0gJ29wYWNpdHknO1xuICAgIHRoaXMuY29udGVudC5jbGFzc0xpc3QucmVtb3ZlKCd5LWRyYXdlci1vcGVuZWQnKTtcbiAgICB0aGlzLnNsaWRlcldpZHRoID0gdGhpcy5nZXRNb3ZhYmxlU2xpZGVyV2lkdGgoKTtcbiAgfVxuXG4gIGdldE1vdmFibGVTbGlkZXJXaWR0aCgpIHtcbiAgICAvLyBTaW5jZSBwYXJ0IG9mIHRoZSBzbGlkZXIgY291bGQgYmUgdmlzaWJsZSxcbiAgICAvLyB0aGUgd2lkdGggdGhhdCBpcyBcIm1vdmFibGVcIiBpcyBsZXNzIHRoYW4gdGhlIGNvbXBsZXRlIHNsaWRlciB3aWR0aFxuICAgIC8vIGFuZCBnaXZlbiBieVxuICAgIHJldHVybiAtdGhpcy5jb250ZW50Lm9mZnNldExlZnQ7XG4gIH1cblxuICBhbmltYXRlVG8ob3BlbmVkKSB7XG4gICAgdGhpcy5wcmVwSW50ZXJhY3Rpb24oKTtcbiAgICB0aGlzLnNldFN0YXRlKCdvcGVuZWQnLCBvcGVuZWQpO1xuICAgIHRoaXMubG9vcFN0YXRlID0gU1RBUlRfQU5JTUFUSU5HO1xuICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkxvb3AoKTtcbiAgfVxuXG4gIGp1bXBUbyhvcGVuZWQpIHtcbiAgICB0aGlzLnByZXBJbnRlcmFjdGlvbigpO1xuICAgIHRoaXMuc2V0U3RhdGUoJ29wZW5lZCcsIG9wZW5lZCk7XG4gICAgdGhpcy5sb29wU3RhdGUgPSBJRExFO1xuICAgIHRoaXMuc3RhcnRUcmFuc2xhdGVYID0gb3BlbmVkICogdGhpcy5zbGlkZXJXaWR0aDtcbiAgICB0aGlzLmVuZEFuaW1hdGluZygpO1xuICAgIHRoaXMudXBkYXRlRE9NKHRoaXMuc3RhcnRUcmFuc2xhdGVYLCB0aGlzLnNsaWRlcldpZHRoKTtcbiAgfVxuXG4gIHVwZGF0ZVRyYW5zbGF0ZVgoKSB7XG4gICAgY29uc3QgZGVsdGFYID0gdGhpcy5wYWdlWCAtIHRoaXMuc3RhcnRYO1xuICAgIHRoaXMudHJhbnNsYXRlWCA9IHRoaXMuc3RhcnRUcmFuc2xhdGVYICsgZGVsdGFYO1xuICAgIHRoaXMudHJhbnNsYXRlWCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuc2xpZGVyV2lkdGgsIHRoaXMudHJhbnNsYXRlWCkpO1xuICAgIHJldHVybiBkZWx0YVg7XG4gIH1cblxuICBhbmltYXRpb25GcmFtZUNhbGxiYWNrKHRpbWUpIHtcbiAgICBzd2l0Y2ggKHRoaXMubG9vcFN0YXRlKSB7XG4gICAgICBjYXNlIFRPVUNISU5HOiB7XG4gICAgICAgIHRoaXMudG91Y2hpbmdGcmFtZSh0aW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgU1RBUlRfQU5JTUFUSU5HOiB7XG4gICAgICAgIHRoaXMuc3RhcnRBbmltYXRpbmdGcmFtZSh0aW1lKTtcbiAgICAgICAgdGhpcy5sb29wU3RhdGUgPSBBTklNQVRJTkc7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uRnJhbWVDYWxsYmFjayh0aW1lKTsgLy8ganVtcCB0byBuZXh0IGNhc2UgYmxvY2tcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgQU5JTUFUSU5HOiB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW5nRnJhbWUodGltZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRvdWNoaW5nRnJhbWUodGltZSkge1xuICAgIGNvbnN0IHRpbWVEaWZmID0gdGltZSAtIHRoaXMubGFzdFRpbWU7XG5cbiAgICBpZiAodGltZURpZmYgPiAwKSB7XG4gICAgICBjb25zdCBwYWdlWERpZmYgPSB0aGlzLnBhZ2VYIC0gdGhpcy5sYXN0UGFnZVg7XG4gICAgICB0aGlzLnZlbG9jaXR5ID0gKFZFTE9DSVRZX0xJTkVBUl9DT01CSU5BVElPTiAqIChwYWdlWERpZmYgLyB0aW1lRGlmZikpICtcbiAgICAgICAgICAgICAgICAgICAgICAoKDEgLSBWRUxPQ0lUWV9MSU5FQVJfQ09NQklOQVRJT04pICogdGhpcy52ZWxvY2l0eSk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVUcmFuc2xhdGVYKCk7XG4gICAgdGhpcy51cGRhdGVET00odGhpcy50cmFuc2xhdGVYLCB0aGlzLnNsaWRlcldpZHRoKTtcblxuICAgIHRoaXMubGFzdFRpbWUgPSB0aW1lO1xuICAgIHRoaXMubGFzdFBhZ2VYID0gdGhpcy5wYWdlWDtcbiAgICB0aGlzLmxhc3RQYWdlWSA9IHRoaXMucGFnZVk7XG5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25GcmFtZUNhbGxiYWNrKTtcbiAgfVxuXG4gIHN0YXJ0QW5pbWF0aW5nRnJhbWUodGltZSkge1xuICAgIHRoaXMudXBkYXRlVHJhbnNsYXRlWCgpO1xuXG4gICAgLy8gc3RvcmUgYWxsIGFuaW1hdGlvbiByZWxhdGVkIGRhdGEgaW4gdGhpcyBvYmplY3QsXG4gICAgLy8gZGVsZXRlIGFmdGVyIGFuaW1hdGlvbiBpcyBjb21wbGV0ZWRcbiAgICBjb25zdCBhbmltYXRpb24gPSB7fTtcbiAgICBhbmltYXRpb24uc3RhcnRYID0gdGhpcy50cmFuc2xhdGVYO1xuICAgIGFuaW1hdGlvbi5lbmRYID0gKHRoaXMub3BlbmVkID8gMSA6IDApICogdGhpcy5zbGlkZXJXaWR0aDtcbiAgICBhbmltYXRpb24uY2hhbmdlSW5WYWx1ZSA9IGFuaW1hdGlvbi5lbmRYIC0gYW5pbWF0aW9uLnN0YXJ0WDtcbiAgICBhbmltYXRpb24uc3RhcnRUaW1lID0gdGltZTtcbiAgICB0aGlzLmFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcbiAgfVxuXG4gIGFuaW1hdGluZ0ZyYW1lKHRpbWUpIHtcbiAgICBjb25zdCB0aW1lSW5BbmltYXRpb24gPSB0aW1lIC0gdGhpcy5hbmltYXRpb24uc3RhcnRUaW1lO1xuXG4gICAgaWYgKHRpbWVJbkFuaW1hdGlvbiA8IHRoaXMudHJhbnNpdGlvbkR1cmF0aW9uKSB7XG4gICAgICB0aGlzLmFuaW1hdGluZ0NvbnQodGltZUluQW5pbWF0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hbmltYXRpbmdFbmQoKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZURPTSh0aGlzLnN0YXJ0VHJhbnNsYXRlWCwgdGhpcy5zbGlkZXJXaWR0aCk7XG4gIH1cblxuICBhbmltYXRpbmdDb250KHRpbWVJbkFuaW1hdGlvbikge1xuICAgIGNvbnN0IHN0YXJ0VmFsdWUgPSB0aGlzLmFuaW1hdGlvbi5zdGFydFg7XG4gICAgY29uc3QgY2hhbmdlSW5WYWx1ZSA9IHRoaXMuYW5pbWF0aW9uLmNoYW5nZUluVmFsdWU7XG4gICAgdGhpcy5zdGFydFRyYW5zbGF0ZVggPSBsaW5lYXJUd2Vlbih0aW1lSW5BbmltYXRpb24sIHN0YXJ0VmFsdWUsIGNoYW5nZUluVmFsdWUsXG4gICAgICB0aGlzLnRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWVDYWxsYmFjayk7XG4gIH1cblxuICBhbmltYXRpbmdFbmQoKSB7XG4gICAgLy8gZW5kIGFuaW1hdGlvblxuICAgIHRoaXMuc3RhcnRUcmFuc2xhdGVYID0gdGhpcy5hbmltYXRpb24uZW5kWDtcbiAgICBkZWxldGUgdGhpcy5hbmltYXRpb247XG4gICAgdGhpcy5lbmRBbmltYXRpbmcoKTtcbiAgfVxuXG4gIGVuZEFuaW1hdGluZygpIHtcbiAgICB0aGlzLmFuaW1hdGlvbkZyYW1lUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgdGhpcy5sb29wU3RhdGUgPSBJRExFO1xuICAgIHRoaXMudmVsb2NpdHkgPSAwO1xuXG4gICAgaWYgKHRoaXMub3BlbmVkKSB7XG4gICAgICAvLyBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93WSA9ICdoaWRkZW4nO1xuICAgICAgdGhpcy5zY3JpbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2FsbCc7XG4gICAgICB0aGlzLmNvbnRlbnQuY2xhc3NMaXN0LmFkZCgneS1kcmF3ZXItb3BlbmVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3dZID0gJyc7XG4gICAgICB0aGlzLnNjcmltLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRlbnQuc3R5bGUud2lsbENoYW5nZSA9ICcnO1xuICAgIHRoaXMuc2NyaW0uc3R5bGUud2lsbENoYW5nZSA9ICcnO1xuXG4gICAgdGhpcy5maXJlRXZlbnQoJ3RyYW5zaXRpb25lZCcpO1xuICB9XG5cbiAgdXBkYXRlRE9NKHRyYW5zbGF0ZVgsIHNsaWRlcldpZHRoKSB7XG4gICAgdGhpcy5jb250ZW50LnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVYKCR7dHJhbnNsYXRlWH1weClgO1xuICAgIHRoaXMuc2NyaW0uc3R5bGUub3BhY2l0eSA9IHRyYW5zbGF0ZVggLyBzbGlkZXJXaWR0aDtcbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIHRoaXMuYW5pbWF0ZVRvKGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG9wZW4oKSB7XG4gICAgdGhpcy5hbmltYXRlVG8odHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0b2dnbGUoKSB7XG4gICAgaWYgKHRoaXMub3BlbmVkKSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3BlbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHBlcnNpc3QoKSB7XG4gICAgdGhpcy5zY3JpbS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnNldFN0YXRlKCdwZXJzaXN0ZW50JywgdHJ1ZSk7XG4gIH1cblxuICB1bnBlcnNpc3QoKSB7XG4gICAgdGhpcy5zY3JpbS5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgIHRoaXMuc2V0U3RhdGUoJ3BlcnNpc3RlbnQnLCBmYWxzZSk7XG4gIH1cbn07XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTcgRmxvcmlhbiBLbGFtcGZlclxuLy8gTGljZW5zZWQgdW5kZXIgTUlUXG5cbi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llcywgaW1wb3J0L25vLXVucmVzb2x2ZWQsIGltcG9ydC9leHRlbnNpb25zICovXG5pbXBvcnQgZHJhd2VyQ29yZSBmcm9tICcuLi9jb3JlJztcblxuY29uc3Qgc3R5bGUgPSBgXG48c3R5bGU+XG5AbWVkaWEgc2NyZWVuIHtcbiAgLnktZHJhd2VyLXNjcmltIHtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgdG9wOiAwO1xuICAgIHJpZ2h0OiAwO1xuICAgIGJvdHRvbTogMDtcbiAgICBsZWZ0OiAwO1xuICAgIG9wYWNpdHk6IDA7XG4gICAgei1pbmRleDogMDtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsMCwwKTtcbiAgICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50O1xuXG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjY3KTtcbiAgfVxuXG4gIC55LWRyYXdlci1jb250ZW50IHtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgbGVmdDogMDtcbiAgICBib3R0b206IDA7XG4gICAgdG9wOiAwO1xuICAgIHotaW5kZXg6IDE7XG4gICAgb3ZlcmZsb3cteDogaGlkZGVuO1xuICAgIG92ZXJmbG93LXk6IGF1dG87XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLDAsMCk7XG4gICAgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoO1xuICAgIGNvbnRhaW46IHN0cmljdDtcblxuICAgIGxlZnQ6IC0xOHJlbTtcbiAgICB3aWR0aDogMThyZW07XG4gICAgYmFja2dyb3VuZDogI2U4ZThlODtcbiAgfVxuXG4gIC55LWRyYXdlci1jb250ZW50LnktZHJhd2VyLW9wZW5lZCB7XG4gICAgbGVmdDogMCFpbXBvcnRhbnQ7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLDAsMCkhaW1wb3J0YW50O1xuICB9XG59XG5cbkBtZWRpYSBwcmludCB7XG4gIC55LWRyYXdlci1zY3JpbSB7XG4gICAgZGlzcGxheTogbm9uZSFpbXBvcnRhbnQ7XG4gIH1cblxuICAueS1kcmF3ZXItY29udGVudCB7XG4gICAgdHJhbnNmb3JtOiBub25lIWltcG9ydGFudDtcbiAgfVxufVxuXG48L3N0eWxlPmA7XG5cblxuZnVuY3Rpb24gZnJhZ21lbnRGcm9tU3RyaW5nKHN0ckhUTUwpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVJhbmdlKCkuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KHN0ckhUTUwpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEcmF3ZXIgZXh0ZW5kcyBkcmF3ZXJDb3JlKCkge1xuICBjb25zdHJ1Y3RvcihlbCwgcHJvcHMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2V0dXBDb21wb25lbnQoZWwsIHByb3BzKTtcbiAgfVxuXG4gIC8vIEBvdmVycmlkZVxuICBzZXR1cERPTShlbCkge1xuICAgIGlmICghZWwpIHRocm93IEVycm9yKCdObyBlbGVtZW50IHByb3ZpZGVkJyk7XG5cbiAgICBjb25zdCBzY3JpbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHNjcmltLmNsYXNzTGlzdC5hZGQoJ3ktZHJhd2VyLXNjcmltJyk7XG5cbiAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCd5LWRyYXdlci1jb250ZW50Jyk7XG4gICAgd2hpbGUgKGVsLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWwuY2hpbGRyZW5bMF0pO1xuICAgIH1cblxuICAgIGVsLmFwcGVuZENoaWxkKHNjcmltKTtcbiAgICBlbC5hcHBlbmRDaGlsZChjb250ZW50KTtcblxuICAgIGNvbnN0IHJlZiA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzdHlsZScpWzBdO1xuICAgIHJlZi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShmcmFnbWVudEZyb21TdHJpbmcoc3R5bGUpLCByZWYpO1xuXG4gICAgcmV0dXJuIGVsO1xuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBJbm5lclN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbm5lclN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5uZXJTdWJzY3JpYmVyKHBhcmVudCwgb3V0ZXJWYWx1ZSwgb3V0ZXJJbmRleCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMub3V0ZXJWYWx1ZSA9IG91dGVyVmFsdWU7XG4gICAgICAgIHRoaXMub3V0ZXJJbmRleCA9IG91dGVySW5kZXg7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBJbm5lclN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lm5vdGlmeU5leHQodGhpcy5vdXRlclZhbHVlLCB2YWx1ZSwgdGhpcy5vdXRlckluZGV4LCB0aGlzLmluZGV4KyssIHRoaXMpO1xuICAgIH07XG4gICAgSW5uZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQubm90aWZ5RXJyb3IoZXJyb3IsIHRoaXMpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICBJbm5lclN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQubm90aWZ5Q29tcGxldGUodGhpcyk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIHJldHVybiBJbm5lclN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLklubmVyU3Vic2NyaWJlciA9IElubmVyU3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlubmVyU3Vic2NyaWJlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL09ic2VydmFibGUnKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIHB1c2gtYmFzZWQgZXZlbnQgb3IgdmFsdWUgdGhhdCBhbiB7QGxpbmsgT2JzZXJ2YWJsZX0gY2FuIGVtaXQuXG4gKiBUaGlzIGNsYXNzIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIG9wZXJhdG9ycyB0aGF0IG1hbmFnZSBub3RpZmljYXRpb25zLFxuICogbGlrZSB7QGxpbmsgbWF0ZXJpYWxpemV9LCB7QGxpbmsgZGVtYXRlcmlhbGl6ZX0sIHtAbGluayBvYnNlcnZlT259LCBhbmRcbiAqIG90aGVycy4gQmVzaWRlcyB3cmFwcGluZyB0aGUgYWN0dWFsIGRlbGl2ZXJlZCB2YWx1ZSwgaXQgYWxzbyBhbm5vdGF0ZXMgaXRcbiAqIHdpdGggbWV0YWRhdGEgb2YsIGZvciBpbnN0YW5jZSwgd2hhdCB0eXBlIG9mIHB1c2ggbWVzc2FnZSBpdCBpcyAoYG5leHRgLFxuICogYGVycm9yYCwgb3IgYGNvbXBsZXRlYCkuXG4gKlxuICogQHNlZSB7QGxpbmsgbWF0ZXJpYWxpemV9XG4gKiBAc2VlIHtAbGluayBkZW1hdGVyaWFsaXplfVxuICogQHNlZSB7QGxpbmsgb2JzZXJ2ZU9ufVxuICpcbiAqIEBjbGFzcyBOb3RpZmljYXRpb248VD5cbiAqL1xudmFyIE5vdGlmaWNhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm90aWZpY2F0aW9uKGtpbmQsIHZhbHVlLCBlcnJvcikge1xuICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGtpbmQgPT09ICdOJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsaXZlcnMgdG8gdGhlIGdpdmVuIGBvYnNlcnZlcmAgdGhlIHZhbHVlIHdyYXBwZWQgYnkgdGhpcyBOb3RpZmljYXRpb24uXG4gICAgICogQHBhcmFtIHtPYnNlcnZlcn0gb2JzZXJ2ZXJcbiAgICAgKiBAcmV0dXJuXG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5raW5kKSB7XG4gICAgICAgICAgICBjYXNlICdOJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIubmV4dCAmJiBvYnNlcnZlci5uZXh0KHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLmVycm9yICYmIG9ic2VydmVyLmVycm9yKHRoaXMuZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLmNvbXBsZXRlICYmIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdpdmVuIHNvbWUge0BsaW5rIE9ic2VydmVyfSBjYWxsYmFja3MsIGRlbGl2ZXIgdGhlIHZhbHVlIHJlcHJlc2VudGVkIGJ5IHRoZVxuICAgICAqIGN1cnJlbnQgTm90aWZpY2F0aW9uIHRvIHRoZSBjb3JyZWN0bHkgY29ycmVzcG9uZGluZyBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBUKTogdm9pZH0gbmV4dCBBbiBPYnNlcnZlciBgbmV4dGAgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihlcnI6IGFueSk6IHZvaWR9IFtlcnJvcl0gQW4gT2JzZXJ2ZXIgYGVycm9yYCBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFtjb21wbGV0ZV0gQW4gT2JzZXJ2ZXIgYGNvbXBsZXRlYCBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJuIHthbnl9XG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uLnByb3RvdHlwZS5kbyA9IGZ1bmN0aW9uIChuZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdmFyIGtpbmQgPSB0aGlzLmtpbmQ7XG4gICAgICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQgJiYgbmV4dCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvciAmJiBlcnJvcih0aGlzLmVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZSAmJiBjb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUYWtlcyBhbiBPYnNlcnZlciBvciBpdHMgaW5kaXZpZHVhbCBjYWxsYmFjayBmdW5jdGlvbnMsIGFuZCBjYWxscyBgb2JzZXJ2ZWBcbiAgICAgKiBvciBgZG9gIG1ldGhvZHMgYWNjb3JkaW5nbHkuXG4gICAgICogQHBhcmFtIHtPYnNlcnZlcnxmdW5jdGlvbih2YWx1ZTogVCk6IHZvaWR9IG5leHRPck9ic2VydmVyIEFuIE9ic2VydmVyIG9yXG4gICAgICogdGhlIGBuZXh0YCBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGVycjogYW55KTogdm9pZH0gW2Vycm9yXSBBbiBPYnNlcnZlciBgZXJyb3JgIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gW2NvbXBsZXRlXSBBbiBPYnNlcnZlciBgY29tcGxldGVgIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm4ge2FueX1cbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb24ucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uIChuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIGlmIChuZXh0T3JPYnNlcnZlciAmJiB0eXBlb2YgbmV4dE9yT2JzZXJ2ZXIubmV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JzZXJ2ZShuZXh0T3JPYnNlcnZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kbyhuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHNpbXBsZSBPYnNlcnZhYmxlIHRoYXQganVzdCBkZWxpdmVycyB0aGUgbm90aWZpY2F0aW9uIHJlcHJlc2VudGVkXG4gICAgICogYnkgdGhpcyBOb3RpZmljYXRpb24gaW5zdGFuY2UuXG4gICAgICogQHJldHVybiB7YW55fVxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbi5wcm90b3R5cGUudG9PYnNlcnZhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIga2luZCA9IHRoaXMua2luZDtcbiAgICAgICAgc3dpdGNoIChraW5kKSB7XG4gICAgICAgICAgICBjYXNlICdOJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUub2YodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdFJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUudGhyb3codGhpcy5lcnJvcik7XG4gICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuZW1wdHkoKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgbm90aWZpY2F0aW9uIGtpbmQgdmFsdWUnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgc2hvcnRjdXQgdG8gY3JlYXRlIGEgTm90aWZpY2F0aW9uIGluc3RhbmNlIG9mIHRoZSB0eXBlIGBuZXh0YCBmcm9tIGFcbiAgICAgKiBnaXZlbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge1R9IHZhbHVlIFRoZSBgbmV4dGAgdmFsdWUuXG4gICAgICogQHJldHVybiB7Tm90aWZpY2F0aW9uPFQ+fSBUaGUgXCJuZXh0XCIgTm90aWZpY2F0aW9uIHJlcHJlc2VudGluZyB0aGVcbiAgICAgKiBhcmd1bWVudC5cbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb24uY3JlYXRlTmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOb3RpZmljYXRpb24oJ04nLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudW5kZWZpbmVkVmFsdWVOb3RpZmljYXRpb247XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIHNob3J0Y3V0IHRvIGNyZWF0ZSBhIE5vdGlmaWNhdGlvbiBpbnN0YW5jZSBvZiB0aGUgdHlwZSBgZXJyb3JgIGZyb20gYVxuICAgICAqIGdpdmVuIGVycm9yLlxuICAgICAqIEBwYXJhbSB7YW55fSBbZXJyXSBUaGUgYGVycm9yYCBlcnJvci5cbiAgICAgKiBAcmV0dXJuIHtOb3RpZmljYXRpb248VD59IFRoZSBcImVycm9yXCIgTm90aWZpY2F0aW9uIHJlcHJlc2VudGluZyB0aGVcbiAgICAgKiBhcmd1bWVudC5cbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb24uY3JlYXRlRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm90aWZpY2F0aW9uKCdFJywgdW5kZWZpbmVkLCBlcnIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBzaG9ydGN1dCB0byBjcmVhdGUgYSBOb3RpZmljYXRpb24gaW5zdGFuY2Ugb2YgdGhlIHR5cGUgYGNvbXBsZXRlYC5cbiAgICAgKiBAcmV0dXJuIHtOb3RpZmljYXRpb248YW55Pn0gVGhlIHZhbHVlbGVzcyBcImNvbXBsZXRlXCIgTm90aWZpY2F0aW9uLlxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbi5jcmVhdGVDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGVOb3RpZmljYXRpb247XG4gICAgfTtcbiAgICBOb3RpZmljYXRpb24uY29tcGxldGVOb3RpZmljYXRpb24gPSBuZXcgTm90aWZpY2F0aW9uKCdDJyk7XG4gICAgTm90aWZpY2F0aW9uLnVuZGVmaW5lZFZhbHVlTm90aWZpY2F0aW9uID0gbmV3IE5vdGlmaWNhdGlvbignTicsIHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIE5vdGlmaWNhdGlvbjtcbn0oKSk7XG5leHBvcnRzLk5vdGlmaWNhdGlvbiA9IE5vdGlmaWNhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5vdGlmaWNhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuL3V0aWwvcm9vdCcpO1xudmFyIHRvU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi91dGlsL3RvU3Vic2NyaWJlcicpO1xudmFyIG9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vc3ltYm9sL29ic2VydmFibGUnKTtcbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhbnkgc2V0IG9mIHZhbHVlcyBvdmVyIGFueSBhbW91bnQgb2YgdGltZS4gVGhpcyB0aGUgbW9zdCBiYXNpYyBidWlsZGluZyBibG9ja1xuICogb2YgUnhKUy5cbiAqXG4gKiBAY2xhc3MgT2JzZXJ2YWJsZTxUPlxuICovXG52YXIgT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3Vic2NyaWJlIHRoZSBmdW5jdGlvbiB0aGF0IGlzICBjYWxsZWQgd2hlbiB0aGUgT2JzZXJ2YWJsZSBpc1xuICAgICAqIGluaXRpYWxseSBzdWJzY3JpYmVkIHRvLiBUaGlzIGZ1bmN0aW9uIGlzIGdpdmVuIGEgU3Vic2NyaWJlciwgdG8gd2hpY2ggbmV3IHZhbHVlc1xuICAgICAqIGNhbiBiZSBgbmV4dGBlZCwgb3IgYW4gYGVycm9yYCBtZXRob2QgY2FuIGJlIGNhbGxlZCB0byByYWlzZSBhbiBlcnJvciwgb3JcbiAgICAgKiBgY29tcGxldGVgIGNhbiBiZSBjYWxsZWQgdG8gbm90aWZ5IG9mIGEgc3VjY2Vzc2Z1bCBjb21wbGV0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE9ic2VydmFibGUoc3Vic2NyaWJlKSB7XG4gICAgICAgIHRoaXMuX2lzU2NhbGFyID0gZmFsc2U7XG4gICAgICAgIGlmIChzdWJzY3JpYmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE9ic2VydmFibGUsIHdpdGggdGhpcyBPYnNlcnZhYmxlIGFzIHRoZSBzb3VyY2UsIGFuZCB0aGUgcGFzc2VkXG4gICAgICogb3BlcmF0b3IgZGVmaW5lZCBhcyB0aGUgbmV3IG9ic2VydmFibGUncyBvcGVyYXRvci5cbiAgICAgKiBAbWV0aG9kIGxpZnRcbiAgICAgKiBAcGFyYW0ge09wZXJhdG9yfSBvcGVyYXRvciB0aGUgb3BlcmF0b3IgZGVmaW5pbmcgdGhlIG9wZXJhdGlvbiB0byB0YWtlIG9uIHRoZSBvYnNlcnZhYmxlXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gYSBuZXcgb2JzZXJ2YWJsZSB3aXRoIHRoZSBPcGVyYXRvciBhcHBsaWVkXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUubGlmdCA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgICAgICB2YXIgb2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKCk7XG4gICAgICAgIG9ic2VydmFibGUuc291cmNlID0gdGhpcztcbiAgICAgICAgb2JzZXJ2YWJsZS5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZTtcbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChvYnNlcnZlck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBvcGVyYXRvciA9IHRoaXMub3BlcmF0b3I7XG4gICAgICAgIHZhciBzaW5rID0gdG9TdWJzY3JpYmVyXzEudG9TdWJzY3JpYmVyKG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICBpZiAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgIG9wZXJhdG9yLmNhbGwoc2luaywgdGhpcy5zb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2luay5hZGQodGhpcy5fdHJ5U3Vic2NyaWJlKHNpbmspKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2luay5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgIHNpbmsuc3luY0Vycm9yVGhyb3dhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc2luay5zeW5jRXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBzaW5rLnN5bmNFcnJvclZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaW5rO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3RyeVN1YnNjcmliZSA9IGZ1bmN0aW9uIChzaW5rKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3Vic2NyaWJlKHNpbmspO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHNpbmsuc3luY0Vycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgICAgIHNpbmsuc3luY0Vycm9yVmFsdWUgPSBlcnI7XG4gICAgICAgICAgICBzaW5rLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBtZXRob2QgZm9yRWFjaFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHQgYSBoYW5kbGVyIGZvciBlYWNoIHZhbHVlIGVtaXR0ZWQgYnkgdGhlIG9ic2VydmFibGVcbiAgICAgKiBAcGFyYW0ge1Byb21pc2VDb25zdHJ1Y3Rvcn0gW1Byb21pc2VDdG9yXSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHVzZWQgdG8gaW5zdGFudGlhdGUgdGhlIFByb21pc2VcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCBlaXRoZXIgcmVzb2x2ZXMgb24gb2JzZXJ2YWJsZSBjb21wbGV0aW9uIG9yXG4gICAgICogIHJlamVjdHMgd2l0aCB0aGUgaGFuZGxlZCBlcnJvclxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAobmV4dCwgUHJvbWlzZUN0b3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFQcm9taXNlQ3Rvcikge1xuICAgICAgICAgICAgaWYgKHJvb3RfMS5yb290LlJ4ICYmIHJvb3RfMS5yb290LlJ4LmNvbmZpZyAmJiByb290XzEucm9vdC5SeC5jb25maWcuUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIFByb21pc2VDdG9yID0gcm9vdF8xLnJvb3QuUnguY29uZmlnLlByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyb290XzEucm9vdC5Qcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgUHJvbWlzZUN0b3IgPSByb290XzEucm9vdC5Qcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghUHJvbWlzZUN0b3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gUHJvbWlzZSBpbXBsIGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlQ3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAvLyBNdXN0IGJlIGRlY2xhcmVkIGluIGEgc2VwYXJhdGUgc3RhdGVtZW50IHRvIGF2b2lkIGEgUmVmZXJuY2VFcnJvciB3aGVuXG4gICAgICAgICAgICAvLyBhY2Nlc3Npbmcgc3Vic2NyaXB0aW9uIGJlbG93IGluIHRoZSBjbG9zdXJlIGR1ZSB0byBUZW1wb3JhbCBEZWFkIFpvbmUuXG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gX3RoaXMuc3Vic2NyaWJlKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBzdWJzY3JpcHRpb24sIHRoZW4gd2UgY2FuIHN1cm1pc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG5leHQgaGFuZGxpbmcgaXMgYXN5bmNocm9ub3VzLiBBbnkgZXJyb3JzIHRocm93blxuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGJlIHJlamVjdGVkIGV4cGxpY2l0bHkgYW5kIHVuc3Vic2NyaWJlIG11c3QgYmVcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbGVkIG1hbnVhbGx5XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBOTyBzdWJzY3JpcHRpb24sIHRoZW4gd2UncmUgZ2V0dGluZyBhIG5leHRlZFxuICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZSBzeW5jaHJvbm91c2x5IGR1cmluZyBzdWJzY3JpcHRpb24uIFdlIGNhbiBqdXN0IGNhbGwgaXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGl0IGVycm9ycywgT2JzZXJ2YWJsZSdzIGBzdWJzY3JpYmVgIHdpbGwgZW5zdXJlIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyB1bnN1YnNjcmlwdGlvbiBsb2dpYyBpcyBjYWxsZWQsIHRoZW4gc3luY2hyb25vdXNseSByZXRocm93IHRoZSBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWZ0ZXIgdGhhdCwgUHJvbWlzZSB3aWxsIHRyYXAgdGhlIGVycm9yIGFuZCBzZW5kIGl0XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvd24gdGhlIHJlamVjdGlvbiBwYXRoLlxuICAgICAgICAgICAgICAgICAgICBuZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZWplY3QsIHJlc29sdmUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQW4gaW50ZXJvcCBwb2ludCBkZWZpbmVkIGJ5IHRoZSBlczctb2JzZXJ2YWJsZSBzcGVjIGh0dHBzOi8vZ2l0aHViLmNvbS96ZW5wYXJzaW5nL2VzLW9ic2VydmFibGVcbiAgICAgKiBAbWV0aG9kIFN5bWJvbC5vYnNlcnZhYmxlXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gdGhpcyBpbnN0YW5jZSBvZiB0aGUgb2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlW29ic2VydmFibGVfMS5vYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvLyBIQUNLOiBTaW5jZSBUeXBlU2NyaXB0IGluaGVyaXRzIHN0YXRpYyBwcm9wZXJ0aWVzIHRvbywgd2UgaGF2ZSB0b1xuICAgIC8vIGZpZ2h0IGFnYWluc3QgVHlwZVNjcmlwdCBoZXJlIHNvIFN1YmplY3QgY2FuIGhhdmUgYSBkaWZmZXJlbnQgc3RhdGljIGNyZWF0ZSBzaWduYXR1cmVcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbGQgT2JzZXJ2YWJsZSBieSBjYWxsaW5nIHRoZSBPYnNlcnZhYmxlIGNvbnN0cnVjdG9yXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YnNjcmliZT8gdGhlIHN1YnNjcmliZXIgZnVuY3Rpb24gdG8gYmUgcGFzc2VkIHRvIHRoZSBPYnNlcnZhYmxlIGNvbnN0cnVjdG9yXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gYSBuZXcgY29sZCBvYnNlcnZhYmxlXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShzdWJzY3JpYmUpO1xuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmFibGU7XG59KCkpO1xuZXhwb3J0cy5PYnNlcnZhYmxlID0gT2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmVtcHR5ID0ge1xuICAgIGNsb3NlZDogdHJ1ZSxcbiAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHsgfSxcbiAgICBlcnJvcjogZnVuY3Rpb24gKGVycikgeyB0aHJvdyBlcnI7IH0sXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHsgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIE91dGVyU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE91dGVyU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPdXRlclN1YnNjcmliZXIoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBPdXRlclN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGlubmVyVmFsdWUpO1xuICAgIH07XG4gICAgT3V0ZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnJvcik7XG4gICAgfTtcbiAgICBPdXRlclN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBPdXRlclN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLk91dGVyU3Vic2NyaWJlciA9IE91dGVyU3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU91dGVyU3Vic2NyaWJlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vT2JzZXJ2YWJsZScpO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vU3Vic2NyaWJlcicpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpcHRpb24nKTtcbnZhciBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xID0gcmVxdWlyZSgnLi91dGlsL09iamVjdFVuc3Vic2NyaWJlZEVycm9yJyk7XG52YXIgU3ViamVjdFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi9TdWJqZWN0U3Vic2NyaXB0aW9uJyk7XG52YXIgcnhTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuL3N5bWJvbC9yeFN1YnNjcmliZXInKTtcbi8qKlxuICogQGNsYXNzIFN1YmplY3RTdWJzY3JpYmVyPFQ+XG4gKi9cbnZhciBTdWJqZWN0U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YmplY3RTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YmplY3RTdWJzY3JpYmVyKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gU3ViamVjdFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLlN1YmplY3RTdWJzY3JpYmVyID0gU3ViamVjdFN1YnNjcmliZXI7XG4vKipcbiAqIEBjbGFzcyBTdWJqZWN0PFQ+XG4gKi9cbnZhciBTdWJqZWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3ViamVjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJqZWN0KCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNFcnJvciA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRocm93bkVycm9yID0gbnVsbDtcbiAgICB9XG4gICAgU3ViamVjdC5wcm90b3R5cGVbcnhTdWJzY3JpYmVyXzEucnhTdWJzY3JpYmVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdWJqZWN0U3Vic2NyaWJlcih0aGlzKTtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcbiAgICAgICAgdmFyIHN1YmplY3QgPSBuZXcgQW5vbnltb3VzU3ViamVjdCh0aGlzLCB0aGlzKTtcbiAgICAgICAgc3ViamVjdC5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICByZXR1cm4gc3ViamVjdDtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMS5PYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVycztcbiAgICAgICAgICAgIHZhciBsZW4gPSBvYnNlcnZlcnMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGNvcHkgPSBvYnNlcnZlcnMuc2xpY2UoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb3B5W2ldLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMS5PYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICB0aGlzLnRocm93bkVycm9yID0gZXJyO1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVycztcbiAgICAgICAgdmFyIGxlbiA9IG9ic2VydmVycy5sZW5ndGg7XG4gICAgICAgIHZhciBjb3B5ID0gb2JzZXJ2ZXJzLnNsaWNlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvcHlbaV0uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9ic2VydmVycy5sZW5ndGggPSAwO1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVycztcbiAgICAgICAgdmFyIGxlbiA9IG9ic2VydmVycy5sZW5ndGg7XG4gICAgICAgIHZhciBjb3B5ID0gb2JzZXJ2ZXJzLnNsaWNlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvcHlbaV0uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9ic2VydmVycy5sZW5ndGggPSAwO1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IG51bGw7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5fdHJ5U3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMS5PYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuX3RyeVN1YnNjcmliZS5jYWxsKHRoaXMsIHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMS5PYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaGFzRXJyb3IpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IodGhpcy50aHJvd25FcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3ViamVjdFN1YnNjcmlwdGlvbl8xLlN1YmplY3RTdWJzY3JpcHRpb24odGhpcywgc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLmFzT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUoKTtcbiAgICAgICAgb2JzZXJ2YWJsZS5zb3VyY2UgPSB0aGlzO1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZTtcbiAgICB9O1xuICAgIFN1YmplY3QuY3JlYXRlID0gZnVuY3Rpb24gKGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNTdWJqZWN0KGRlc3RpbmF0aW9uLCBzb3VyY2UpO1xuICAgIH07XG4gICAgcmV0dXJuIFN1YmplY3Q7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLlN1YmplY3QgPSBTdWJqZWN0O1xuLyoqXG4gKiBAY2xhc3MgQW5vbnltb3VzU3ViamVjdDxUPlxuICovXG52YXIgQW5vbnltb3VzU3ViamVjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFub255bW91c1N1YmplY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQW5vbnltb3VzU3ViamVjdChkZXN0aW5hdGlvbiwgc291cmNlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmIChkZXN0aW5hdGlvbiAmJiBkZXN0aW5hdGlvbi5uZXh0KSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmIChkZXN0aW5hdGlvbiAmJiBkZXN0aW5hdGlvbi5lcnJvcikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uICYmIGRlc3RpbmF0aW9uLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFub255bW91c1N1YmplY3QucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQW5vbnltb3VzU3ViamVjdDtcbn0oU3ViamVjdCkpO1xuZXhwb3J0cy5Bbm9ueW1vdXNTdWJqZWN0ID0gQW5vbnltb3VzU3ViamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YmplY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4vU3Vic2NyaXB0aW9uJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFN1YmplY3RTdWJzY3JpcHRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJqZWN0U3Vic2NyaXB0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YmplY3RTdWJzY3JpcHRpb24oc3ViamVjdCwgc3Vic2NyaWJlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdWJqZWN0ID0gc3ViamVjdDtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyID0gc3Vic2NyaWJlcjtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgU3ViamVjdFN1YnNjcmlwdGlvbi5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHN1YmplY3QgPSB0aGlzLnN1YmplY3Q7XG4gICAgICAgIHZhciBvYnNlcnZlcnMgPSBzdWJqZWN0Lm9ic2VydmVycztcbiAgICAgICAgdGhpcy5zdWJqZWN0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFvYnNlcnZlcnMgfHwgb2JzZXJ2ZXJzLmxlbmd0aCA9PT0gMCB8fCBzdWJqZWN0LmlzU3RvcHBlZCB8fCBzdWJqZWN0LmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdWJzY3JpYmVySW5kZXggPSBvYnNlcnZlcnMuaW5kZXhPZih0aGlzLnN1YnNjcmliZXIpO1xuICAgICAgICBpZiAoc3Vic2NyaWJlckluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXJzLnNwbGljZShzdWJzY3JpYmVySW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3ViamVjdFN1YnNjcmlwdGlvbjtcbn0oU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKSk7XG5leHBvcnRzLlN1YmplY3RTdWJzY3JpcHRpb24gPSBTdWJqZWN0U3Vic2NyaXB0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3ViamVjdFN1YnNjcmlwdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGlzRnVuY3Rpb25fMSA9IHJlcXVpcmUoJy4vdXRpbC9pc0Z1bmN0aW9uJyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YnNjcmlwdGlvbicpO1xudmFyIE9ic2VydmVyXzEgPSByZXF1aXJlKCcuL09ic2VydmVyJyk7XG52YXIgcnhTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuL3N5bWJvbC9yeFN1YnNjcmliZXInKTtcbi8qKlxuICogSW1wbGVtZW50cyB0aGUge0BsaW5rIE9ic2VydmVyfSBpbnRlcmZhY2UgYW5kIGV4dGVuZHMgdGhlXG4gKiB7QGxpbmsgU3Vic2NyaXB0aW9ufSBjbGFzcy4gV2hpbGUgdGhlIHtAbGluayBPYnNlcnZlcn0gaXMgdGhlIHB1YmxpYyBBUEkgZm9yXG4gKiBjb25zdW1pbmcgdGhlIHZhbHVlcyBvZiBhbiB7QGxpbmsgT2JzZXJ2YWJsZX0sIGFsbCBPYnNlcnZlcnMgZ2V0IGNvbnZlcnRlZCB0b1xuICogYSBTdWJzY3JpYmVyLCBpbiBvcmRlciB0byBwcm92aWRlIFN1YnNjcmlwdGlvbi1saWtlIGNhcGFiaWxpdGllcyBzdWNoIGFzXG4gKiBgdW5zdWJzY3JpYmVgLiBTdWJzY3JpYmVyIGlzIGEgY29tbW9uIHR5cGUgaW4gUnhKUywgYW5kIGNydWNpYWwgZm9yXG4gKiBpbXBsZW1lbnRpbmcgb3BlcmF0b3JzLCBidXQgaXQgaXMgcmFyZWx5IHVzZWQgYXMgYSBwdWJsaWMgQVBJLlxuICpcbiAqIEBjbGFzcyBTdWJzY3JpYmVyPFQ+XG4gKi9cbnZhciBTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09ic2VydmVyfGZ1bmN0aW9uKHZhbHVlOiBUKTogdm9pZH0gW2Rlc3RpbmF0aW9uT3JOZXh0XSBBIHBhcnRpYWxseVxuICAgICAqIGRlZmluZWQgT2JzZXJ2ZXIgb3IgYSBgbmV4dGAgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihlOiA/YW55KTogdm9pZH0gW2Vycm9yXSBUaGUgYGVycm9yYCBjYWxsYmFjayBvZiBhblxuICAgICAqIE9ic2VydmVyLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gW2NvbXBsZXRlXSBUaGUgYGNvbXBsZXRlYCBjYWxsYmFjayBvZiBhblxuICAgICAqIE9ic2VydmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN1YnNjcmliZXIoZGVzdGluYXRpb25Pck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zeW5jRXJyb3JWYWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3luY0Vycm9yVGhyb3duID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3luY0Vycm9yVGhyb3dhYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBPYnNlcnZlcl8xLmVtcHR5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGlmICghZGVzdGluYXRpb25Pck5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IE9ic2VydmVyXzEuZW1wdHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlc3RpbmF0aW9uT3JOZXh0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzdGluYXRpb25Pck5leHQgaW5zdGFuY2VvZiBTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb25Pck5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmFkZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3luY0Vycm9yVGhyb3dhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBuZXcgU2FmZVN1YnNjcmliZXIodGhpcywgZGVzdGluYXRpb25Pck5leHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zeW5jRXJyb3JUaHJvd2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBuZXcgU2FmZVN1YnNjcmliZXIodGhpcywgZGVzdGluYXRpb25Pck5leHQsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGVbcnhTdWJzY3JpYmVyXzEucnhTdWJzY3JpYmVyXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG4gICAgLyoqXG4gICAgICogQSBzdGF0aWMgZmFjdG9yeSBmb3IgYSBTdWJzY3JpYmVyLCBnaXZlbiBhIChwb3RlbnRpYWxseSBwYXJ0aWFsKSBkZWZpbml0aW9uXG4gICAgICogb2YgYW4gT2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbih4OiA/VCk6IHZvaWR9IFtuZXh0XSBUaGUgYG5leHRgIGNhbGxiYWNrIG9mIGFuIE9ic2VydmVyLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZTogP2FueSk6IHZvaWR9IFtlcnJvcl0gVGhlIGBlcnJvcmAgY2FsbGJhY2sgb2YgYW5cbiAgICAgKiBPYnNlcnZlci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFtjb21wbGV0ZV0gVGhlIGBjb21wbGV0ZWAgY2FsbGJhY2sgb2YgYW5cbiAgICAgKiBPYnNlcnZlci5cbiAgICAgKiBAcmV0dXJuIHtTdWJzY3JpYmVyPFQ+fSBBIFN1YnNjcmliZXIgd3JhcHBpbmcgdGhlIChwYXJ0aWFsbHkgZGVmaW5lZClcbiAgICAgKiBPYnNlcnZlciByZXByZXNlbnRlZCBieSB0aGUgZ2l2ZW4gYXJndW1lbnRzLlxuICAgICAqL1xuICAgIFN1YnNjcmliZXIuY3JlYXRlID0gZnVuY3Rpb24gKG5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIgc3Vic2NyaWJlciA9IG5ldyBTdWJzY3JpYmVyKG5leHQsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgICAgIHN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIHtAbGluayBPYnNlcnZlcn0gY2FsbGJhY2sgdG8gcmVjZWl2ZSBub3RpZmljYXRpb25zIG9mIHR5cGUgYG5leHRgIGZyb21cbiAgICAgKiB0aGUgT2JzZXJ2YWJsZSwgd2l0aCBhIHZhbHVlLiBUaGUgT2JzZXJ2YWJsZSBtYXkgY2FsbCB0aGlzIG1ldGhvZCAwIG9yIG1vcmVcbiAgICAgKiB0aW1lcy5cbiAgICAgKiBAcGFyYW0ge1R9IFt2YWx1ZV0gVGhlIGBuZXh0YCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGNhbGxiYWNrIHRvIHJlY2VpdmUgbm90aWZpY2F0aW9ucyBvZiB0eXBlIGBlcnJvcmAgZnJvbVxuICAgICAqIHRoZSBPYnNlcnZhYmxlLCB3aXRoIGFuIGF0dGFjaGVkIHtAbGluayBFcnJvcn0uIE5vdGlmaWVzIHRoZSBPYnNlcnZlciB0aGF0XG4gICAgICogdGhlIE9ic2VydmFibGUgaGFzIGV4cGVyaWVuY2VkIGFuIGVycm9yIGNvbmRpdGlvbi5cbiAgICAgKiBAcGFyYW0ge2FueX0gW2Vycl0gVGhlIGBlcnJvcmAgZXhjZXB0aW9uLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGNhbGxiYWNrIHRvIHJlY2VpdmUgYSB2YWx1ZWxlc3Mgbm90aWZpY2F0aW9uIG9mIHR5cGVcbiAgICAgKiBgY29tcGxldGVgIGZyb20gdGhlIE9ic2VydmFibGUuIE5vdGlmaWVzIHRoZSBPYnNlcnZlciB0aGF0IHRoZSBPYnNlcnZhYmxlXG4gICAgICogaGFzIGZpbmlzaGVkIHNlbmRpbmcgcHVzaC1iYXNlZCBub3RpZmljYXRpb25zLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudW5zdWJzY3JpYmUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZUFuZFJlY3ljbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIF9wYXJlbnQgPSBfYS5fcGFyZW50LCBfcGFyZW50cyA9IF9hLl9wYXJlbnRzO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYXJlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgICAgICB0aGlzLl9wYXJlbnRzID0gX3BhcmVudHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIFN1YnNjcmliZXI7XG59KFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbikpO1xuZXhwb3J0cy5TdWJzY3JpYmVyID0gU3Vic2NyaWJlcjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU2FmZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTYWZlU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTYWZlU3Vic2NyaWJlcihfcGFyZW50U3Vic2NyaWJlciwgb2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcGFyZW50U3Vic2NyaWJlciA9IF9wYXJlbnRTdWJzY3JpYmVyO1xuICAgICAgICB2YXIgbmV4dDtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24ob2JzZXJ2ZXJPck5leHQpKSB7XG4gICAgICAgICAgICBuZXh0ID0gb2JzZXJ2ZXJPck5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JzZXJ2ZXJPck5leHQpIHtcbiAgICAgICAgICAgIG5leHQgPSBvYnNlcnZlck9yTmV4dC5uZXh0O1xuICAgICAgICAgICAgZXJyb3IgPSBvYnNlcnZlck9yTmV4dC5lcnJvcjtcbiAgICAgICAgICAgIGNvbXBsZXRlID0gb2JzZXJ2ZXJPck5leHQuY29tcGxldGU7XG4gICAgICAgICAgICBpZiAob2JzZXJ2ZXJPck5leHQgIT09IE9ic2VydmVyXzEuZW1wdHkpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gT2JqZWN0LmNyZWF0ZShvYnNlcnZlck9yTmV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKGNvbnRleHQudW5zdWJzY3JpYmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkKGNvbnRleHQudW5zdWJzY3JpYmUuYmluZChjb250ZXh0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRleHQudW5zdWJzY3JpYmUgPSB0aGlzLnVuc3Vic2NyaWJlLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX25leHQgPSBuZXh0O1xuICAgICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLl9jb21wbGV0ZSA9IGNvbXBsZXRlO1xuICAgIH1cbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkICYmIHRoaXMuX25leHQpIHtcbiAgICAgICAgICAgIHZhciBfcGFyZW50U3Vic2NyaWJlciA9IHRoaXMuX3BhcmVudFN1YnNjcmliZXI7XG4gICAgICAgICAgICBpZiAoIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclVuc3ViKHRoaXMuX25leHQsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnRTdWJzY3JpYmVyLCB0aGlzLl9uZXh0LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgICAgIGlmICh0aGlzLl9lcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICghX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclVuc3ViKHRoaXMuX2Vycm9yLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JTZXRFcnJvcihfcGFyZW50U3Vic2NyaWJlciwgdGhpcy5fZXJyb3IsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclZhbHVlID0gZXJyO1xuICAgICAgICAgICAgICAgIF9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHZhciBfcGFyZW50U3Vic2NyaWJlciA9IHRoaXMuX3BhcmVudFN1YnNjcmliZXI7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JVbnN1Yih0aGlzLl9jb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnRTdWJzY3JpYmVyLCB0aGlzLl9jb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fX3RyeU9yVW5zdWIgPSBmdW5jdGlvbiAoZm4sIHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMuX2NvbnRleHQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fX3RyeU9yU2V0RXJyb3IgPSBmdW5jdGlvbiAocGFyZW50LCBmbiwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcy5fY29udGV4dCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHBhcmVudC5zeW5jRXJyb3JWYWx1ZSA9IGVycjtcbiAgICAgICAgICAgIHBhcmVudC5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhcmVudFN1YnNjcmliZXIgPSBudWxsO1xuICAgICAgICBfcGFyZW50U3Vic2NyaWJlci51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFNhZmVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJzY3JpYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGlzQXJyYXlfMSA9IHJlcXVpcmUoJy4vdXRpbC9pc0FycmF5Jyk7XG52YXIgaXNPYmplY3RfMSA9IHJlcXVpcmUoJy4vdXRpbC9pc09iamVjdCcpO1xudmFyIGlzRnVuY3Rpb25fMSA9IHJlcXVpcmUoJy4vdXRpbC9pc0Z1bmN0aW9uJyk7XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4vdXRpbC90cnlDYXRjaCcpO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBVbnN1YnNjcmlwdGlvbkVycm9yXzEgPSByZXF1aXJlKCcuL3V0aWwvVW5zdWJzY3JpcHRpb25FcnJvcicpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgZGlzcG9zYWJsZSByZXNvdXJjZSwgc3VjaCBhcyB0aGUgZXhlY3V0aW9uIG9mIGFuIE9ic2VydmFibGUuIEFcbiAqIFN1YnNjcmlwdGlvbiBoYXMgb25lIGltcG9ydGFudCBtZXRob2QsIGB1bnN1YnNjcmliZWAsIHRoYXQgdGFrZXMgbm8gYXJndW1lbnRcbiAqIGFuZCBqdXN0IGRpc3Bvc2VzIHRoZSByZXNvdXJjZSBoZWxkIGJ5IHRoZSBzdWJzY3JpcHRpb24uXG4gKlxuICogQWRkaXRpb25hbGx5LCBzdWJzY3JpcHRpb25zIG1heSBiZSBncm91cGVkIHRvZ2V0aGVyIHRocm91Z2ggdGhlIGBhZGQoKWBcbiAqIG1ldGhvZCwgd2hpY2ggd2lsbCBhdHRhY2ggYSBjaGlsZCBTdWJzY3JpcHRpb24gdG8gdGhlIGN1cnJlbnQgU3Vic2NyaXB0aW9uLlxuICogV2hlbiBhIFN1YnNjcmlwdGlvbiBpcyB1bnN1YnNjcmliZWQsIGFsbCBpdHMgY2hpbGRyZW4gKGFuZCBpdHMgZ3JhbmRjaGlsZHJlbilcbiAqIHdpbGwgYmUgdW5zdWJzY3JpYmVkIGFzIHdlbGwuXG4gKlxuICogQGNsYXNzIFN1YnNjcmlwdGlvblxuICovXG52YXIgU3Vic2NyaXB0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFt1bnN1YnNjcmliZV0gQSBmdW5jdGlvbiBkZXNjcmliaW5nIGhvdyB0b1xuICAgICAqIHBlcmZvcm0gdGhlIGRpc3Bvc2FsIG9mIHJlc291cmNlcyB3aGVuIHRoZSBgdW5zdWJzY3JpYmVgIG1ldGhvZCBpcyBjYWxsZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uKHVuc3Vic2NyaWJlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciB0aGlzIFN1YnNjcmlwdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHVuc3Vic2NyaWJlZC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYXJlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IG51bGw7XG4gICAgICAgIGlmICh1bnN1YnNjcmliZSkge1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUgPSB1bnN1YnNjcmliZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyB0aGUgcmVzb3VyY2VzIGhlbGQgYnkgdGhlIHN1YnNjcmlwdGlvbi4gTWF5LCBmb3IgaW5zdGFuY2UsIGNhbmNlbFxuICAgICAqIGFuIG9uZ29pbmcgT2JzZXJ2YWJsZSBleGVjdXRpb24gb3IgY2FuY2VsIGFueSBvdGhlciB0eXBlIG9mIHdvcmsgdGhhdFxuICAgICAqIHN0YXJ0ZWQgd2hlbiB0aGUgU3Vic2NyaXB0aW9uIHdhcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhhc0Vycm9ycyA9IGZhbHNlO1xuICAgICAgICB2YXIgZXJyb3JzO1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLCBfcGFyZW50ID0gX2EuX3BhcmVudCwgX3BhcmVudHMgPSBfYS5fcGFyZW50cywgX3Vuc3Vic2NyaWJlID0gX2EuX3Vuc3Vic2NyaWJlLCBfc3Vic2NyaXB0aW9ucyA9IF9hLl9zdWJzY3JpcHRpb25zO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhcmVudHMgPSBudWxsO1xuICAgICAgICAvLyBudWxsIG91dCBfc3Vic2NyaXB0aW9ucyBmaXJzdCBzbyBhbnkgY2hpbGQgc3Vic2NyaXB0aW9ucyB0aGF0IGF0dGVtcHRcbiAgICAgICAgLy8gdG8gcmVtb3ZlIHRoZW1zZWx2ZXMgZnJvbSB0aGlzIHN1YnNjcmlwdGlvbiB3aWxsIG5vb3BcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IG51bGw7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICB2YXIgbGVuID0gX3BhcmVudHMgPyBfcGFyZW50cy5sZW5ndGggOiAwO1xuICAgICAgICAvLyBpZiB0aGlzLl9wYXJlbnQgaXMgbnVsbCwgdGhlbiBzbyBpcyB0aGlzLl9wYXJlbnRzLCBhbmQgd2VcbiAgICAgICAgLy8gZG9uJ3QgaGF2ZSB0byByZW1vdmUgb3Vyc2VsdmVzIGZyb20gYW55IHBhcmVudCBzdWJzY3JpcHRpb25zLlxuICAgICAgICB3aGlsZSAoX3BhcmVudCkge1xuICAgICAgICAgICAgX3BhcmVudC5yZW1vdmUodGhpcyk7XG4gICAgICAgICAgICAvLyBpZiB0aGlzLl9wYXJlbnRzIGlzIG51bGwgb3IgaW5kZXggPj0gbGVuLFxuICAgICAgICAgICAgLy8gdGhlbiBfcGFyZW50IGlzIHNldCB0byBudWxsLCBhbmQgdGhlIGxvb3AgZXhpdHNcbiAgICAgICAgICAgIF9wYXJlbnQgPSArK2luZGV4IDwgbGVuICYmIF9wYXJlbnRzW2luZGV4XSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihfdW5zdWJzY3JpYmUpKSB7XG4gICAgICAgICAgICB2YXIgdHJpYWwgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKF91bnN1YnNjcmliZSkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGlmICh0cmlhbCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIGhhc0Vycm9ycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzIHx8IChlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUgaW5zdGFuY2VvZiBVbnN1YnNjcmlwdGlvbkVycm9yXzEuVW5zdWJzY3JpcHRpb25FcnJvciA/XG4gICAgICAgICAgICAgICAgICAgIGZsYXR0ZW5VbnN1YnNjcmlwdGlvbkVycm9ycyhlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUuZXJyb3JzKSA6IFtlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheV8xLmlzQXJyYXkoX3N1YnNjcmlwdGlvbnMpKSB7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgbGVuID0gX3N1YnNjcmlwdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViID0gX3N1YnNjcmlwdGlvbnNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdF8xLmlzT2JqZWN0KHN1YikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyaWFsID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChzdWIudW5zdWJzY3JpYmUpLmNhbGwoc3ViKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyaWFsID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNFcnJvcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBVbnN1YnNjcmlwdGlvbkVycm9yXzEuVW5zdWJzY3JpcHRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoZmxhdHRlblVuc3Vic2NyaXB0aW9uRXJyb3JzKGVyci5lcnJvcnMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0Vycm9ycykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3Vic2NyaXB0aW9uRXJyb3JfMS5VbnN1YnNjcmlwdGlvbkVycm9yKGVycm9ycyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSB0ZWFyIGRvd24gdG8gYmUgY2FsbGVkIGR1cmluZyB0aGUgdW5zdWJzY3JpYmUoKSBvZiB0aGlzXG4gICAgICogU3Vic2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogSWYgdGhlIHRlYXIgZG93biBiZWluZyBhZGRlZCBpcyBhIHN1YnNjcmlwdGlvbiB0aGF0IGlzIGFscmVhZHlcbiAgICAgKiB1bnN1YnNjcmliZWQsIGlzIHRoZSBzYW1lIHJlZmVyZW5jZSBgYWRkYCBpcyBiZWluZyBjYWxsZWQgb24sIG9yIGlzXG4gICAgICogYFN1YnNjcmlwdGlvbi5FTVBUWWAsIGl0IHdpbGwgbm90IGJlIGFkZGVkLlxuICAgICAqXG4gICAgICogSWYgdGhpcyBzdWJzY3JpcHRpb24gaXMgYWxyZWFkeSBpbiBhbiBgY2xvc2VkYCBzdGF0ZSwgdGhlIHBhc3NlZFxuICAgICAqIHRlYXIgZG93biBsb2dpYyB3aWxsIGJlIGV4ZWN1dGVkIGltbWVkaWF0ZWx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtUZWFyZG93bkxvZ2ljfSB0ZWFyZG93biBUaGUgYWRkaXRpb25hbCBsb2dpYyB0byBleGVjdXRlIG9uXG4gICAgICogdGVhcmRvd24uXG4gICAgICogQHJldHVybiB7U3Vic2NyaXB0aW9ufSBSZXR1cm5zIHRoZSBTdWJzY3JpcHRpb24gdXNlZCBvciBjcmVhdGVkIHRvIGJlXG4gICAgICogYWRkZWQgdG8gdGhlIGlubmVyIHN1YnNjcmlwdGlvbnMgbGlzdC4gVGhpcyBTdWJzY3JpcHRpb24gY2FuIGJlIHVzZWQgd2l0aFxuICAgICAqIGByZW1vdmUoKWAgdG8gcmVtb3ZlIHRoZSBwYXNzZWQgdGVhcmRvd24gbG9naWMgZnJvbSB0aGUgaW5uZXIgc3Vic2NyaXB0aW9uc1xuICAgICAqIGxpc3QuXG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodGVhcmRvd24pIHtcbiAgICAgICAgaWYgKCF0ZWFyZG93biB8fCAodGVhcmRvd24gPT09IFN1YnNjcmlwdGlvbi5FTVBUWSkpIHtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRlYXJkb3duID09PSB0aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGVhcmRvd247XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHRlYXJkb3duKSB7XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbih0ZWFyZG93bik7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uY2xvc2VkIHx8IHR5cGVvZiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdWJzY3JpcHRpb24uX2FkZFBhcmVudCAhPT0gJ2Z1bmN0aW9uJyAvKiBxdWFjayBxdWFjayAqLykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5fc3Vic2NyaXB0aW9ucyA9IFt0bXBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlY29nbml6ZWQgdGVhcmRvd24gJyArIHRlYXJkb3duICsgJyBhZGRlZCB0byBTdWJzY3JpcHRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSB0aGlzLl9zdWJzY3JpcHRpb25zIHx8ICh0aGlzLl9zdWJzY3JpcHRpb25zID0gW10pO1xuICAgICAgICBzdWJzY3JpcHRpb25zLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uLl9hZGRQYXJlbnQodGhpcyk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgU3Vic2NyaXB0aW9uIGZyb20gdGhlIGludGVybmFsIGxpc3Qgb2Ygc3Vic2NyaXB0aW9ucyB0aGF0IHdpbGxcbiAgICAgKiB1bnN1YnNjcmliZSBkdXJpbmcgdGhlIHVuc3Vic2NyaWJlIHByb2Nlc3Mgb2YgdGhpcyBTdWJzY3JpcHRpb24uXG4gICAgICogQHBhcmFtIHtTdWJzY3JpcHRpb259IHN1YnNjcmlwdGlvbiBUaGUgc3Vic2NyaXB0aW9uIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnM7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uSW5kZXggPSBzdWJzY3JpcHRpb25zLmluZGV4T2Yoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25JbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zLnNwbGljZShzdWJzY3JpcHRpb25JbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuX2FkZFBhcmVudCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgX3BhcmVudCA9IF9hLl9wYXJlbnQsIF9wYXJlbnRzID0gX2EuX3BhcmVudHM7XG4gICAgICAgIGlmICghX3BhcmVudCB8fCBfcGFyZW50ID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBwYXJlbnQsIG9yIHRoZSBuZXcgcGFyZW50IGlzIHRoZSBzYW1lIGFzIHRoZVxuICAgICAgICAgICAgLy8gY3VycmVudCBwYXJlbnQsIHRoZW4gc2V0IHRoaXMuX3BhcmVudCB0byB0aGUgbmV3IHBhcmVudC5cbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghX3BhcmVudHMpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYWxyZWFkeSBvbmUgcGFyZW50LCBidXQgbm90IG11bHRpcGxlLCBhbGxvY2F0ZSBhbiBBcnJheSB0b1xuICAgICAgICAgICAgLy8gc3RvcmUgdGhlIHJlc3Qgb2YgdGhlIHBhcmVudCBTdWJzY3JpcHRpb25zLlxuICAgICAgICAgICAgdGhpcy5fcGFyZW50cyA9IFtwYXJlbnRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9wYXJlbnRzLmluZGV4T2YocGFyZW50KSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgYWRkIHRoZSBuZXcgcGFyZW50IHRvIHRoZSBfcGFyZW50cyBsaXN0IGlmIGl0J3Mgbm90IGFscmVhZHkgdGhlcmUuXG4gICAgICAgICAgICBfcGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5FTVBUWSA9IChmdW5jdGlvbiAoZW1wdHkpIHtcbiAgICAgICAgZW1wdHkuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH0obmV3IFN1YnNjcmlwdGlvbigpKSk7XG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvbjtcbn0oKSk7XG5leHBvcnRzLlN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbjtcbmZ1bmN0aW9uIGZsYXR0ZW5VbnN1YnNjcmlwdGlvbkVycm9ycyhlcnJvcnMpIHtcbiAgICByZXR1cm4gZXJyb3JzLnJlZHVjZShmdW5jdGlvbiAoZXJycywgZXJyKSB7IHJldHVybiBlcnJzLmNvbmNhdCgoZXJyIGluc3RhbmNlb2YgVW5zdWJzY3JpcHRpb25FcnJvcl8xLlVuc3Vic2NyaXB0aW9uRXJyb3IpID8gZXJyLmVycm9ycyA6IGVycik7IH0sIFtdKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YnNjcmlwdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZGVmZXJfMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvZGVmZXInKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmRlZmVyID0gZGVmZXJfMS5kZWZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBhamF4XzEgPSByZXF1aXJlKCcuLi8uLi8uLi9vYnNlcnZhYmxlL2RvbS9hamF4Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5hamF4ID0gYWpheF8xLmFqYXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hamF4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBmcm9tXzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL2Zyb20nKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmZyb20gPSBmcm9tXzEuZnJvbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyb20uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGZyb21FdmVudF8xID0gcmVxdWlyZSgnLi4vLi4vb2JzZXJ2YWJsZS9mcm9tRXZlbnQnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmZyb21FdmVudCA9IGZyb21FdmVudF8xLmZyb21FdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyb21FdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgbWVyZ2VfMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvbWVyZ2UnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLm1lcmdlID0gbWVyZ2VfMS5tZXJnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBvZl8xID0gcmVxdWlyZSgnLi4vLi4vb2JzZXJ2YWJsZS9vZicpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUub2YgPSBvZl8xLm9mO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHRocm93XzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL3Rocm93Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS50aHJvdyA9IHRocm93XzEuX3Rocm93O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhyb3cuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHRpbWVyXzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL3RpbWVyJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS50aW1lciA9IHRpbWVyXzEudGltZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgY2F0Y2hfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2NhdGNoJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuY2F0Y2ggPSBjYXRjaF8xLl9jYXRjaDtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5fY2F0Y2ggPSBjYXRjaF8xLl9jYXRjaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhdGNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBjb25jYXRNYXBfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2NvbmNhdE1hcCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmNvbmNhdE1hcCA9IGNvbmNhdE1hcF8xLmNvbmNhdE1hcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdE1hcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZGVib3VuY2VUaW1lXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9kZWJvdW5jZVRpbWUnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5kZWJvdW5jZVRpbWUgPSBkZWJvdW5jZVRpbWVfMS5kZWJvdW5jZVRpbWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWJvdW5jZVRpbWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGRlbGF5XzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9kZWxheScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmRlbGF5ID0gZGVsYXlfMS5kZWxheTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlbGF5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvZGlzdGluY3RVbnRpbEtleUNoYW5nZWQnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCA9IGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkXzEuZGlzdGluY3RVbnRpbEtleUNoYW5nZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZG9fMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2RvJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZG8gPSBkb18xLl9kbztcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5fZG8gPSBkb18xLl9kbztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBmaWx0ZXJfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2ZpbHRlcicpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmZpbHRlciA9IGZpbHRlcl8xLmZpbHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbHRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgbWFwXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9tYXAnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5tYXAgPSBtYXBfMS5tYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIG1lcmdlTWFwXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9tZXJnZU1hcCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLm1lcmdlTWFwID0gbWVyZ2VNYXBfMS5tZXJnZU1hcDtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5mbGF0TWFwID0gbWVyZ2VNYXBfMS5tZXJnZU1hcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlTWFwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBwYXJ0aXRpb25fMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3BhcnRpdGlvbicpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnBhcnRpdGlvbiA9IHBhcnRpdGlvbl8xLnBhcnRpdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnRpdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgcmV0cnlXaGVuXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9yZXRyeVdoZW4nKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5yZXRyeVdoZW4gPSByZXRyeVdoZW5fMS5yZXRyeVdoZW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXRyeVdoZW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHNoYXJlXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9zaGFyZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnNoYXJlID0gc2hhcmVfMS5zaGFyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYXJlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBzdGFydFdpdGhfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3N0YXJ0V2l0aCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnN0YXJ0V2l0aCA9IHN0YXJ0V2l0aF8xLnN0YXJ0V2l0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXJ0V2l0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgc3dpdGNoXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9zd2l0Y2gnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5zd2l0Y2ggPSBzd2l0Y2hfMS5fc3dpdGNoO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLl9zd2l0Y2ggPSBzd2l0Y2hfMS5fc3dpdGNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dpdGNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBzd2l0Y2hNYXBfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3N3aXRjaE1hcCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnN3aXRjaE1hcCA9IHN3aXRjaE1hcF8xLnN3aXRjaE1hcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN3aXRjaE1hcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgdGFrZV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvdGFrZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnRha2UgPSB0YWtlXzEudGFrZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRha2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHRha2VVbnRpbF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvdGFrZVVudGlsJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUudGFrZVVudGlsID0gdGFrZVVudGlsXzEudGFrZVVudGlsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFrZVVudGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB0aHJvdHRsZVRpbWVfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3Rocm90dGxlVGltZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnRocm90dGxlVGltZSA9IHRocm90dGxlVGltZV8xLnRocm90dGxlVGltZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRocm90dGxlVGltZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgd2l0aExhdGVzdEZyb21fMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3dpdGhMYXRlc3RGcm9tJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUud2l0aExhdGVzdEZyb20gPSB3aXRoTGF0ZXN0RnJvbV8xLndpdGhMYXRlc3RGcm9tO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2l0aExhdGVzdEZyb20uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHppcF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvemlwJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuemlwID0gemlwXzEuemlwUHJvdG87XG4vLyMgc291cmNlTWFwcGluZ1VSTD16aXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgU2NhbGFyT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9TY2FsYXJPYnNlcnZhYmxlJyk7XG52YXIgRW1wdHlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0VtcHR5T2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBBcnJheUxpa2VPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJyYXlMaWtlT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcnJheUxpa2VPYnNlcnZhYmxlKGFycmF5TGlrZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmFycmF5TGlrZSA9IGFycmF5TGlrZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIGlmICghc2NoZWR1bGVyICYmIGFycmF5TGlrZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2NhbGFyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBhcnJheUxpa2VbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgQXJyYXlMaWtlT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoYXJyYXlMaWtlLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5TGlrZS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlPYnNlcnZhYmxlXzEuRW1wdHlPYnNlcnZhYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNjYWxhck9ic2VydmFibGVfMS5TY2FsYXJPYnNlcnZhYmxlKGFycmF5TGlrZVswXSwgc2NoZWR1bGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlMaWtlT2JzZXJ2YWJsZShhcnJheUxpa2UsIHNjaGVkdWxlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFycmF5TGlrZU9ic2VydmFibGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIGFycmF5TGlrZSA9IHN0YXRlLmFycmF5TGlrZSwgaW5kZXggPSBzdGF0ZS5pbmRleCwgbGVuZ3RoID0gc3RhdGUubGVuZ3RoLCBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlcjtcbiAgICAgICAgaWYgKHN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIubmV4dChhcnJheUxpa2VbaW5kZXhdKTtcbiAgICAgICAgc3RhdGUuaW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgIHRoaXMuc2NoZWR1bGUoc3RhdGUpO1xuICAgIH07XG4gICAgQXJyYXlMaWtlT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGFycmF5TGlrZSA9IF9hLmFycmF5TGlrZSwgc2NoZWR1bGVyID0gX2Euc2NoZWR1bGVyO1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXlMaWtlLmxlbmd0aDtcbiAgICAgICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShBcnJheUxpa2VPYnNlcnZhYmxlLmRpc3BhdGNoLCAwLCB7XG4gICAgICAgICAgICAgICAgYXJyYXlMaWtlOiBhcnJheUxpa2UsIGluZGV4OiBpbmRleCwgbGVuZ3RoOiBsZW5ndGgsIHN1YnNjcmliZXI6IHN1YnNjcmliZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGggJiYgIXN1YnNjcmliZXIuY2xvc2VkOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoYXJyYXlMaWtlW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFycmF5TGlrZU9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkFycmF5TGlrZU9ic2VydmFibGUgPSBBcnJheUxpa2VPYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXJyYXlMaWtlT2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBTY2FsYXJPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL1NjYWxhck9ic2VydmFibGUnKTtcbnZhciBFbXB0eU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vRW1wdHlPYnNlcnZhYmxlJyk7XG52YXIgaXNTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNTY2hlZHVsZXInKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgQXJyYXlPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJyYXlPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFycmF5T2JzZXJ2YWJsZShhcnJheSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICBpZiAoIXNjaGVkdWxlciAmJiBhcnJheS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2NhbGFyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBhcnJheVswXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBcnJheU9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGFycmF5LCBzY2hlZHVsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheU9ic2VydmFibGUoYXJyYXksIHNjaGVkdWxlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBzb21lIHZhbHVlcyB5b3Ugc3BlY2lmeSBhcyBhcmd1bWVudHMsXG4gICAgICogaW1tZWRpYXRlbHkgb25lIGFmdGVyIHRoZSBvdGhlciwgYW5kIHRoZW4gZW1pdHMgYSBjb21wbGV0ZSBub3RpZmljYXRpb24uXG4gICAgICpcbiAgICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RW1pdHMgdGhlIGFyZ3VtZW50cyB5b3UgcHJvdmlkZSwgdGhlbiBjb21wbGV0ZXMuXG4gICAgICogPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy9vZi5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICAgKlxuICAgICAqIFRoaXMgc3RhdGljIG9wZXJhdG9yIGlzIHVzZWZ1bCBmb3IgY3JlYXRpbmcgYSBzaW1wbGUgT2JzZXJ2YWJsZSB0aGF0IG9ubHlcbiAgICAgKiBlbWl0cyB0aGUgYXJndW1lbnRzIGdpdmVuLCBhbmQgdGhlIGNvbXBsZXRlIG5vdGlmaWNhdGlvbiB0aGVyZWFmdGVyLiBJdCBjYW5cbiAgICAgKiBiZSB1c2VkIGZvciBjb21wb3Npbmcgd2l0aCBvdGhlciBPYnNlcnZhYmxlcywgc3VjaCBhcyB3aXRoIHtAbGluayBjb25jYXR9LlxuICAgICAqIEJ5IGRlZmF1bHQsIGl0IHVzZXMgYSBgbnVsbGAgSVNjaGVkdWxlciwgd2hpY2ggbWVhbnMgdGhlIGBuZXh0YFxuICAgICAqIG5vdGlmaWNhdGlvbnMgYXJlIHNlbnQgc3luY2hyb25vdXNseSwgYWx0aG91Z2ggd2l0aCBhIGRpZmZlcmVudCBJU2NoZWR1bGVyXG4gICAgICogaXQgaXMgcG9zc2libGUgdG8gZGV0ZXJtaW5lIHdoZW4gdGhvc2Ugbm90aWZpY2F0aW9ucyB3aWxsIGJlIGRlbGl2ZXJlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgMTAsIDIwLCAzMCwgdGhlbiAnYScsICdiJywgJ2MnLCB0aGVuIHN0YXJ0IHRpY2tpbmcgZXZlcnkgc2Vjb25kLjwvY2FwdGlvbj5cbiAgICAgKiB2YXIgbnVtYmVycyA9IFJ4Lk9ic2VydmFibGUub2YoMTAsIDIwLCAzMCk7XG4gICAgICogdmFyIGxldHRlcnMgPSBSeC5PYnNlcnZhYmxlLm9mKCdhJywgJ2InLCAnYycpO1xuICAgICAqIHZhciBpbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gICAgICogdmFyIHJlc3VsdCA9IG51bWJlcnMuY29uY2F0KGxldHRlcnMpLmNvbmNhdChpbnRlcnZhbCk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGNyZWF0ZX1cbiAgICAgKiBAc2VlIHtAbGluayBlbXB0eX1cbiAgICAgKiBAc2VlIHtAbGluayBuZXZlcn1cbiAgICAgKiBAc2VlIHtAbGluayB0aHJvd31cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Li4uVH0gdmFsdWVzIEFyZ3VtZW50cyB0aGF0IHJlcHJlc2VudCBgbmV4dGAgdmFsdWVzIHRvIGJlIGVtaXR0ZWQuXG4gICAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIEEge0BsaW5rIElTY2hlZHVsZXJ9IHRvIHVzZSBmb3Igc2NoZWR1bGluZ1xuICAgICAqIHRoZSBlbWlzc2lvbnMgb2YgdGhlIGBuZXh0YCBub3RpZmljYXRpb25zLlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBlYWNoIGdpdmVuIGlucHV0IHZhbHVlLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIG9mXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBBcnJheU9ic2VydmFibGUub2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJyYXlbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihzY2hlZHVsZXIpKSB7XG4gICAgICAgICAgICBhcnJheS5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjaGVkdWxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlPYnNlcnZhYmxlKGFycmF5LCBzY2hlZHVsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTY2FsYXJPYnNlcnZhYmxlXzEuU2NhbGFyT2JzZXJ2YWJsZShhcnJheVswXSwgc2NoZWR1bGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlPYnNlcnZhYmxlXzEuRW1wdHlPYnNlcnZhYmxlKHNjaGVkdWxlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFycmF5T2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgYXJyYXkgPSBzdGF0ZS5hcnJheSwgaW5kZXggPSBzdGF0ZS5pbmRleCwgY291bnQgPSBzdGF0ZS5jb3VudCwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXI7XG4gICAgICAgIGlmIChpbmRleCA+PSBjb3VudCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIubmV4dChhcnJheVtpbmRleF0pO1xuICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5pbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZShzdGF0ZSk7XG4gICAgfTtcbiAgICBBcnJheU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgICAgICB2YXIgY291bnQgPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShBcnJheU9ic2VydmFibGUuZGlzcGF0Y2gsIDAsIHtcbiAgICAgICAgICAgICAgICBhcnJheTogYXJyYXksIGluZGV4OiBpbmRleCwgY291bnQ6IGNvdW50LCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQgJiYgIXN1YnNjcmliZXIuY2xvc2VkOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoYXJyYXlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQXJyYXlPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5BcnJheU9ic2VydmFibGUgPSBBcnJheU9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BcnJheU9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9TdWJqZWN0Jyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmlwdGlvbicpO1xuLyoqXG4gKiBAY2xhc3MgQ29ubmVjdGFibGVPYnNlcnZhYmxlPFQ+XG4gKi9cbnZhciBDb25uZWN0YWJsZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb25uZWN0YWJsZU9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29ubmVjdGFibGVPYnNlcnZhYmxlKHNvdXJjZSwgc3ViamVjdEZhY3RvcnkpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnN1YmplY3RGYWN0b3J5ID0gc3ViamVjdEZhY3Rvcnk7XG4gICAgICAgIHRoaXMuX3JlZkNvdW50ID0gMDtcbiAgICB9XG4gICAgQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3ViamVjdCgpLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICB9O1xuICAgIENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUuZ2V0U3ViamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN1YmplY3QgPSB0aGlzLl9zdWJqZWN0O1xuICAgICAgICBpZiAoIXN1YmplY3QgfHwgc3ViamVjdC5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YmplY3QgPSB0aGlzLnN1YmplY3RGYWN0b3J5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1YmplY3Q7XG4gICAgfTtcbiAgICBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25uZWN0aW9uID0gdGhpcy5fY29ubmVjdGlvbjtcbiAgICAgICAgaWYgKCFjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uID0gdGhpcy5fY29ubmVjdGlvbiA9IG5ldyBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uYWRkKHRoaXMuc291cmNlXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZShuZXcgQ29ubmVjdGFibGVTdWJzY3JpYmVyKHRoaXMuZ2V0U3ViamVjdCgpLCB0aGlzKSkpO1xuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbiA9IFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgIH07XG4gICAgQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5yZWZDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlmdChuZXcgUmVmQ291bnRPcGVyYXRvcih0aGlzKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29ubmVjdGFibGVPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5Db25uZWN0YWJsZU9ic2VydmFibGUgPSBDb25uZWN0YWJsZU9ic2VydmFibGU7XG5leHBvcnRzLmNvbm5lY3RhYmxlT2JzZXJ2YWJsZURlc2NyaXB0b3IgPSB7XG4gICAgb3BlcmF0b3I6IHsgdmFsdWU6IG51bGwgfSxcbiAgICBfcmVmQ291bnQ6IHsgdmFsdWU6IDAsIHdyaXRhYmxlOiB0cnVlIH0sXG4gICAgX3N1YmplY3Q6IHsgdmFsdWU6IG51bGwsIHdyaXRhYmxlOiB0cnVlIH0sXG4gICAgX2Nvbm5lY3Rpb246IHsgdmFsdWU6IG51bGwsIHdyaXRhYmxlOiB0cnVlIH0sXG4gICAgX3N1YnNjcmliZTogeyB2YWx1ZTogQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlIH0sXG4gICAgZ2V0U3ViamVjdDogeyB2YWx1ZTogQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5nZXRTdWJqZWN0IH0sXG4gICAgY29ubmVjdDogeyB2YWx1ZTogQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5jb25uZWN0IH0sXG4gICAgcmVmQ291bnQ6IHsgdmFsdWU6IENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUucmVmQ291bnQgfVxufTtcbnZhciBDb25uZWN0YWJsZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb25uZWN0YWJsZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29ubmVjdGFibGVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjb25uZWN0YWJsZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuY29ubmVjdGFibGUgPSBjb25uZWN0YWJsZTtcbiAgICB9XG4gICAgQ29ubmVjdGFibGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlKCk7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2Vycm9yLmNhbGwodGhpcywgZXJyKTtcbiAgICB9O1xuICAgIENvbm5lY3RhYmxlU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl91bnN1YnNjcmliZSgpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgQ29ubmVjdGFibGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25uZWN0YWJsZSA9IHRoaXMuY29ubmVjdGFibGU7XG4gICAgICAgIGlmIChjb25uZWN0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0YWJsZSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbiA9IGNvbm5lY3RhYmxlLl9jb25uZWN0aW9uO1xuICAgICAgICAgICAgY29ubmVjdGFibGUuX3JlZkNvdW50ID0gMDtcbiAgICAgICAgICAgIGNvbm5lY3RhYmxlLl9zdWJqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbm5lY3RhYmxlLl9jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ29ubmVjdGFibGVTdWJzY3JpYmVyO1xufShTdWJqZWN0XzEuU3ViamVjdFN1YnNjcmliZXIpKTtcbnZhciBSZWZDb3VudE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWZDb3VudE9wZXJhdG9yKGNvbm5lY3RhYmxlKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGFibGUgPSBjb25uZWN0YWJsZTtcbiAgICB9XG4gICAgUmVmQ291bnRPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgdmFyIGNvbm5lY3RhYmxlID0gdGhpcy5jb25uZWN0YWJsZTtcbiAgICAgICAgY29ubmVjdGFibGUuX3JlZkNvdW50Kys7XG4gICAgICAgIHZhciByZWZDb3VudGVyID0gbmV3IFJlZkNvdW50U3Vic2NyaWJlcihzdWJzY3JpYmVyLCBjb25uZWN0YWJsZSk7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBzb3VyY2Uuc3Vic2NyaWJlKHJlZkNvdW50ZXIpO1xuICAgICAgICBpZiAoIXJlZkNvdW50ZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICByZWZDb3VudGVyLmNvbm5lY3Rpb24gPSBjb25uZWN0YWJsZS5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICB9O1xuICAgIHJldHVybiBSZWZDb3VudE9wZXJhdG9yO1xufSgpKTtcbnZhciBSZWZDb3VudFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWZDb3VudFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVmQ291bnRTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjb25uZWN0YWJsZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuY29ubmVjdGFibGUgPSBjb25uZWN0YWJsZTtcbiAgICB9XG4gICAgUmVmQ291bnRTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25uZWN0YWJsZSA9IHRoaXMuY29ubmVjdGFibGU7XG4gICAgICAgIGlmICghY29ubmVjdGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0YWJsZSA9IG51bGw7XG4gICAgICAgIHZhciByZWZDb3VudCA9IGNvbm5lY3RhYmxlLl9yZWZDb3VudDtcbiAgICAgICAgaWYgKHJlZkNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGFibGUuX3JlZkNvdW50ID0gcmVmQ291bnQgLSAxO1xuICAgICAgICBpZiAocmVmQ291bnQgPiAxKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vL1xuICAgICAgICAvLyBDb21wYXJlIHRoZSBsb2NhbCBSZWZDb3VudFN1YnNjcmliZXIncyBjb25uZWN0aW9uIFN1YnNjcmlwdGlvbiB0byB0aGVcbiAgICAgICAgLy8gY29ubmVjdGlvbiBTdWJzY3JpcHRpb24gb24gdGhlIHNoYXJlZCBDb25uZWN0YWJsZU9ic2VydmFibGUuIEluIGNhc2VzXG4gICAgICAgIC8vIHdoZXJlIHRoZSBDb25uZWN0YWJsZU9ic2VydmFibGUgc291cmNlIHN5bmNocm9ub3VzbHkgZW1pdHMgdmFsdWVzLCBhbmRcbiAgICAgICAgLy8gdGhlIFJlZkNvdW50U3Vic2NyaWJlcidzIGRvd25zdHJlYW0gT2JzZXJ2ZXJzIHN5bmNocm9ub3VzbHkgdW5zdWJzY3JpYmUsXG4gICAgICAgIC8vIGV4ZWN1dGlvbiBjb250aW51ZXMgdG8gaGVyZSBiZWZvcmUgdGhlIFJlZkNvdW50T3BlcmF0b3IgaGFzIGEgY2hhbmNlIHRvXG4gICAgICAgIC8vIHN1cHBseSB0aGUgUmVmQ291bnRTdWJzY3JpYmVyIHdpdGggdGhlIHNoYXJlZCBjb25uZWN0aW9uIFN1YnNjcmlwdGlvbi5cbiAgICAgICAgLy8gRm9yIGV4YW1wbGU6XG4gICAgICAgIC8vIGBgYFxuICAgICAgICAvLyBPYnNlcnZhYmxlLnJhbmdlKDAsIDEwKVxuICAgICAgICAvLyAgIC5wdWJsaXNoKClcbiAgICAgICAgLy8gICAucmVmQ291bnQoKVxuICAgICAgICAvLyAgIC50YWtlKDUpXG4gICAgICAgIC8vICAgLnN1YnNjcmliZSgpO1xuICAgICAgICAvLyBgYGBcbiAgICAgICAgLy8gSW4gb3JkZXIgdG8gYWNjb3VudCBmb3IgdGhpcyBjYXNlLCBSZWZDb3VudFN1YnNjcmliZXIgc2hvdWxkIG9ubHkgZGlzcG9zZVxuICAgICAgICAvLyB0aGUgQ29ubmVjdGFibGVPYnNlcnZhYmxlJ3Mgc2hhcmVkIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uIGlmIHRoZVxuICAgICAgICAvLyBjb25uZWN0aW9uIFN1YnNjcmlwdGlvbiBleGlzdHMsICphbmQqIGVpdGhlcjpcbiAgICAgICAgLy8gICBhLiBSZWZDb3VudFN1YnNjcmliZXIgZG9lc24ndCBoYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBzaGFyZWQgY29ubmVjdGlvblxuICAgICAgICAvLyAgICAgIFN1YnNjcmlwdGlvbiB5ZXQsIG9yLFxuICAgICAgICAvLyAgIGIuIFJlZkNvdW50U3Vic2NyaWJlcidzIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uIHJlZmVyZW5jZSBpcyBpZGVudGljYWxcbiAgICAgICAgLy8gICAgICB0byB0aGUgc2hhcmVkIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uXG4gICAgICAgIC8vL1xuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IHRoaXMuY29ubmVjdGlvbjtcbiAgICAgICAgdmFyIHNoYXJlZENvbm5lY3Rpb24gPSBjb25uZWN0YWJsZS5fY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgaWYgKHNoYXJlZENvbm5lY3Rpb24gJiYgKCFjb25uZWN0aW9uIHx8IHNoYXJlZENvbm5lY3Rpb24gPT09IGNvbm5lY3Rpb24pKSB7XG4gICAgICAgICAgICBzaGFyZWRDb25uZWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSZWZDb3VudFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db25uZWN0YWJsZU9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBEZWZlck9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWZlck9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVmZXJPYnNlcnZhYmxlKG9ic2VydmFibGVGYWN0b3J5KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm9ic2VydmFibGVGYWN0b3J5ID0gb2JzZXJ2YWJsZUZhY3Rvcnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSB0aGF0LCBvbiBzdWJzY3JpYmUsIGNhbGxzIGFuIE9ic2VydmFibGUgZmFjdG9yeSB0b1xuICAgICAqIG1ha2UgYW4gT2JzZXJ2YWJsZSBmb3IgZWFjaCBuZXcgT2JzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q3JlYXRlcyB0aGUgT2JzZXJ2YWJsZSBsYXppbHksIHRoYXQgaXMsIG9ubHkgd2hlbiBpdFxuICAgICAqIGlzIHN1YnNjcmliZWQuXG4gICAgICogPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy9kZWZlci5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICAgKlxuICAgICAqIGBkZWZlcmAgYWxsb3dzIHlvdSB0byBjcmVhdGUgdGhlIE9ic2VydmFibGUgb25seSB3aGVuIHRoZSBPYnNlcnZlclxuICAgICAqIHN1YnNjcmliZXMsIGFuZCBjcmVhdGUgYSBmcmVzaCBPYnNlcnZhYmxlIGZvciBlYWNoIE9ic2VydmVyLiBJdCB3YWl0cyB1bnRpbFxuICAgICAqIGFuIE9ic2VydmVyIHN1YnNjcmliZXMgdG8gaXQsIGFuZCB0aGVuIGl0IGdlbmVyYXRlcyBhbiBPYnNlcnZhYmxlLFxuICAgICAqIHR5cGljYWxseSB3aXRoIGFuIE9ic2VydmFibGUgZmFjdG9yeSBmdW5jdGlvbi4gSXQgZG9lcyB0aGlzIGFmcmVzaCBmb3IgZWFjaFxuICAgICAqIHN1YnNjcmliZXIsIHNvIGFsdGhvdWdoIGVhY2ggc3Vic2NyaWJlciBtYXkgdGhpbmsgaXQgaXMgc3Vic2NyaWJpbmcgdG8gdGhlXG4gICAgICogc2FtZSBPYnNlcnZhYmxlLCBpbiBmYWN0IGVhY2ggc3Vic2NyaWJlciBnZXRzIGl0cyBvd24gaW5kaXZpZHVhbFxuICAgICAqIE9ic2VydmFibGUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TdWJzY3JpYmUgdG8gZWl0aGVyIGFuIE9ic2VydmFibGUgb2YgY2xpY2tzIG9yIGFuIE9ic2VydmFibGUgb2YgaW50ZXJ2YWwsIGF0IHJhbmRvbTwvY2FwdGlvbj5cbiAgICAgKiB2YXIgY2xpY2tzT3JJbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAqICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcbiAgICAgKiAgICAgcmV0dXJuIFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAgICAgKiAgIH0gZWxzZSB7XG4gICAgICogICAgIHJldHVybiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIGNsaWNrc09ySW50ZXJ2YWwuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nIGJlaGF2aW9yOlxuICAgICAqIC8vIElmIHRoZSByZXN1bHQgb2YgTWF0aC5yYW5kb20oKSBpcyBncmVhdGVyIHRoYW4gMC41IGl0IHdpbGwgbGlzdGVuXG4gICAgICogLy8gZm9yIGNsaWNrcyBhbnl3aGVyZSBvbiB0aGUgXCJkb2N1bWVudFwiOyB3aGVuIGRvY3VtZW50IGlzIGNsaWNrZWQgaXRcbiAgICAgKiAvLyB3aWxsIGxvZyBhIE1vdXNlRXZlbnQgb2JqZWN0IHRvIHRoZSBjb25zb2xlLiBJZiB0aGUgcmVzdWx0IGlzIGxlc3NcbiAgICAgKiAvLyB0aGFuIDAuNSBpdCB3aWxsIGVtaXQgYXNjZW5kaW5nIG51bWJlcnMsIG9uZSBldmVyeSBzZWNvbmQoMTAwMG1zKS5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGNyZWF0ZX1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogU3Vic2NyaWJhYmxlT3JQcm9taXNlfSBvYnNlcnZhYmxlRmFjdG9yeSBUaGUgT2JzZXJ2YWJsZVxuICAgICAqIGZhY3RvcnkgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIE9ic2VydmVyIHRoYXQgc3Vic2NyaWJlcyB0byB0aGUgb3V0cHV0XG4gICAgICogT2JzZXJ2YWJsZS4gTWF5IGFsc28gcmV0dXJuIGEgUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBjb252ZXJ0ZWQgb24gdGhlIGZseVxuICAgICAqIHRvIGFuIE9ic2VydmFibGUuXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB3aG9zZSBPYnNlcnZlcnMnIHN1YnNjcmlwdGlvbnMgdHJpZ2dlclxuICAgICAqIGFuIGludm9jYXRpb24gb2YgdGhlIGdpdmVuIE9ic2VydmFibGUgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAbmFtZSBkZWZlclxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgRGVmZXJPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChvYnNlcnZhYmxlRmFjdG9yeSkge1xuICAgICAgICByZXR1cm4gbmV3IERlZmVyT2JzZXJ2YWJsZShvYnNlcnZhYmxlRmFjdG9yeSk7XG4gICAgfTtcbiAgICBEZWZlck9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICByZXR1cm4gbmV3IERlZmVyU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm9ic2VydmFibGVGYWN0b3J5KTtcbiAgICB9O1xuICAgIHJldHVybiBEZWZlck9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkRlZmVyT2JzZXJ2YWJsZSA9IERlZmVyT2JzZXJ2YWJsZTtcbnZhciBEZWZlclN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWZlclN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVmZXJTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBmYWN0b3J5KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5mYWN0b3J5ID0gZmFjdG9yeTtcbiAgICAgICAgdGhpcy50cnlEZWZlcigpO1xuICAgIH1cbiAgICBEZWZlclN1YnNjcmliZXIucHJvdG90eXBlLnRyeURlZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fY2FsbEZhY3RvcnkoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWZlclN1YnNjcmliZXIucHJvdG90eXBlLl9jYWxsRmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZmFjdG9yeSgpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHJlc3VsdCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGVmZXJTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURlZmVyT2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgRW1wdHlPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRW1wdHlPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVtcHR5T2JzZXJ2YWJsZShzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBubyBpdGVtcyB0byB0aGUgT2JzZXJ2ZXIgYW5kIGltbWVkaWF0ZWx5XG4gICAgICogZW1pdHMgYSBjb21wbGV0ZSBub3RpZmljYXRpb24uXG4gICAgICpcbiAgICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SnVzdCBlbWl0cyAnY29tcGxldGUnLCBhbmQgbm90aGluZyBlbHNlLlxuICAgICAqIDwvc3Bhbj5cbiAgICAgKlxuICAgICAqIDxpbWcgc3JjPVwiLi9pbWcvZW1wdHkucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gICAgICpcbiAgICAgKiBUaGlzIHN0YXRpYyBvcGVyYXRvciBpcyB1c2VmdWwgZm9yIGNyZWF0aW5nIGEgc2ltcGxlIE9ic2VydmFibGUgdGhhdCBvbmx5XG4gICAgICogZW1pdHMgdGhlIGNvbXBsZXRlIG5vdGlmaWNhdGlvbi4gSXQgY2FuIGJlIHVzZWQgZm9yIGNvbXBvc2luZyB3aXRoIG90aGVyXG4gICAgICogT2JzZXJ2YWJsZXMsIHN1Y2ggYXMgaW4gYSB7QGxpbmsgbWVyZ2VNYXB9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCB0aGUgbnVtYmVyIDcsIHRoZW4gY29tcGxldGUuPC9jYXB0aW9uPlxuICAgICAqIHZhciByZXN1bHQgPSBSeC5PYnNlcnZhYmxlLmVtcHR5KCkuc3RhcnRXaXRoKDcpO1xuICAgICAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5NYXAgYW5kIGZsYXR0ZW4gb25seSBvZGQgbnVtYmVycyB0byB0aGUgc2VxdWVuY2UgJ2EnLCAnYicsICdjJzwvY2FwdGlvbj5cbiAgICAgKiB2YXIgaW50ZXJ2YWwgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICAgICAqIHZhciByZXN1bHQgPSBpbnRlcnZhbC5tZXJnZU1hcCh4ID0+XG4gICAgICogICB4ICUgMiA9PT0gMSA/IFJ4Lk9ic2VydmFibGUub2YoJ2EnLCAnYicsICdjJykgOiBSeC5PYnNlcnZhYmxlLmVtcHR5KClcbiAgICAgKiApO1xuICAgICAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiAvLyBSZXN1bHRzIGluIHRoZSBmb2xsb3dpbmcgdG8gdGhlIGNvbnNvbGU6XG4gICAgICogLy8geCBpcyBlcXVhbCB0byB0aGUgY291bnQgb24gdGhlIGludGVydmFsIGVnKDAsMSwyLDMsLi4uKVxuICAgICAqIC8vIHggd2lsbCBvY2N1ciBldmVyeSAxMDAwbXNcbiAgICAgKiAvLyBpZiB4ICUgMiBpcyBlcXVhbCB0byAxIHByaW50IGFiY1xuICAgICAqIC8vIGlmIHggJSAyIGlzIG5vdCBlcXVhbCB0byAxIG5vdGhpbmcgd2lsbCBiZSBvdXRwdXRcbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGNyZWF0ZX1cbiAgICAgKiBAc2VlIHtAbGluayBuZXZlcn1cbiAgICAgKiBAc2VlIHtAbGluayBvZn1cbiAgICAgKiBAc2VlIHtAbGluayB0aHJvd31cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBBIHtAbGluayBJU2NoZWR1bGVyfSB0byB1c2UgZm9yIHNjaGVkdWxpbmdcbiAgICAgKiB0aGUgZW1pc3Npb24gb2YgdGhlIGNvbXBsZXRlIG5vdGlmaWNhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBcImVtcHR5XCIgT2JzZXJ2YWJsZTogZW1pdHMgb25seSB0aGUgY29tcGxldGVcbiAgICAgKiBub3RpZmljYXRpb24uXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgZW1wdHlcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIEVtcHR5T2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoc2NoZWR1bGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW1wdHlPYnNlcnZhYmxlKHNjaGVkdWxlcik7XG4gICAgfTtcbiAgICBFbXB0eU9ic2VydmFibGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHZhciBzdWJzY3JpYmVyID0gYXJnLnN1YnNjcmliZXI7XG4gICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICB9O1xuICAgIEVtcHR5T2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShFbXB0eU9ic2VydmFibGUuZGlzcGF0Y2gsIDAsIHsgc3Vic2NyaWJlcjogc3Vic2NyaWJlciB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEVtcHR5T2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuRW1wdHlPYnNlcnZhYmxlID0gRW1wdHlPYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RW1wdHlPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBFcnJvck9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFcnJvck9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXJyb3JPYnNlcnZhYmxlKGVycm9yLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG5vIGl0ZW1zIHRvIHRoZSBPYnNlcnZlciBhbmQgaW1tZWRpYXRlbHlcbiAgICAgKiBlbWl0cyBhbiBlcnJvciBub3RpZmljYXRpb24uXG4gICAgICpcbiAgICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SnVzdCBlbWl0cyAnZXJyb3InLCBhbmQgbm90aGluZyBlbHNlLlxuICAgICAqIDwvc3Bhbj5cbiAgICAgKlxuICAgICAqIDxpbWcgc3JjPVwiLi9pbWcvdGhyb3cucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gICAgICpcbiAgICAgKiBUaGlzIHN0YXRpYyBvcGVyYXRvciBpcyB1c2VmdWwgZm9yIGNyZWF0aW5nIGEgc2ltcGxlIE9ic2VydmFibGUgdGhhdCBvbmx5XG4gICAgICogZW1pdHMgdGhlIGVycm9yIG5vdGlmaWNhdGlvbi4gSXQgY2FuIGJlIHVzZWQgZm9yIGNvbXBvc2luZyB3aXRoIG90aGVyXG4gICAgICogT2JzZXJ2YWJsZXMsIHN1Y2ggYXMgaW4gYSB7QGxpbmsgbWVyZ2VNYXB9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCB0aGUgbnVtYmVyIDcsIHRoZW4gZW1pdCBhbiBlcnJvci48L2NhcHRpb24+XG4gICAgICogdmFyIHJlc3VsdCA9IFJ4Lk9ic2VydmFibGUudGhyb3cobmV3IEVycm9yKCdvb3BzIScpKS5zdGFydFdpdGgoNyk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpLCBlID0+IGNvbnNvbGUuZXJyb3IoZSkpO1xuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+TWFwIGFuZCBmbGF0dGVuIG51bWJlcnMgdG8gdGhlIHNlcXVlbmNlICdhJywgJ2InLCAnYycsIGJ1dCB0aHJvdyBhbiBlcnJvciBmb3IgMTM8L2NhcHRpb24+XG4gICAgICogdmFyIGludGVydmFsID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAgICAgKiB2YXIgcmVzdWx0ID0gaW50ZXJ2YWwubWVyZ2VNYXAoeCA9PlxuICAgICAqICAgeCA9PT0gMTMgP1xuICAgICAqICAgICBSeC5PYnNlcnZhYmxlLnRocm93KCdUaGlydGVlbnMgYXJlIGJhZCcpIDpcbiAgICAgKiAgICAgUnguT2JzZXJ2YWJsZS5vZignYScsICdiJywgJ2MnKVxuICAgICAqICk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpLCBlID0+IGNvbnNvbGUuZXJyb3IoZSkpO1xuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgY3JlYXRlfVxuICAgICAqIEBzZWUge0BsaW5rIGVtcHR5fVxuICAgICAqIEBzZWUge0BsaW5rIG5ldmVyfVxuICAgICAqIEBzZWUge0BsaW5rIG9mfVxuICAgICAqXG4gICAgICogQHBhcmFtIHthbnl9IGVycm9yIFRoZSBwYXJ0aWN1bGFyIEVycm9yIHRvIHBhc3MgdG8gdGhlIGVycm9yIG5vdGlmaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gQSB7QGxpbmsgSVNjaGVkdWxlcn0gdG8gdXNlIGZvciBzY2hlZHVsaW5nXG4gICAgICogdGhlIGVtaXNzaW9uIG9mIHRoZSBlcnJvciBub3RpZmljYXRpb24uXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gZXJyb3IgT2JzZXJ2YWJsZTogZW1pdHMgb25seSB0aGUgZXJyb3Igbm90aWZpY2F0aW9uXG4gICAgICogdXNpbmcgdGhlIGdpdmVuIGVycm9yIGFyZ3VtZW50LlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIHRocm93XG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBFcnJvck9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGVycm9yLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvck9ic2VydmFibGUoZXJyb3IsIHNjaGVkdWxlcik7XG4gICAgfTtcbiAgICBFcnJvck9ic2VydmFibGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHZhciBlcnJvciA9IGFyZy5lcnJvciwgc3Vic2NyaWJlciA9IGFyZy5zdWJzY3JpYmVyO1xuICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycm9yKTtcbiAgICB9O1xuICAgIEVycm9yT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHRoaXMuZXJyb3I7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShFcnJvck9ic2VydmFibGUuZGlzcGF0Y2gsIDAsIHtcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsIHN1YnNjcmliZXI6IHN1YnNjcmliZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBFcnJvck9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkVycm9yT2JzZXJ2YWJsZSA9IEVycm9yT2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVycm9yT2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciB0cnlDYXRjaF8xID0gcmVxdWlyZSgnLi4vdXRpbC90cnlDYXRjaCcpO1xudmFyIGlzRnVuY3Rpb25fMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNGdW5jdGlvbicpO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuLi91dGlsL2Vycm9yT2JqZWN0Jyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpcHRpb24nKTtcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5mdW5jdGlvbiBpc05vZGVTdHlsZUV2ZW50RW1pdHRlcihzb3VyY2VPYmopIHtcbiAgICByZXR1cm4gISFzb3VyY2VPYmogJiYgdHlwZW9mIHNvdXJjZU9iai5hZGRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc291cmNlT2JqLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gaXNKUXVlcnlTdHlsZUV2ZW50RW1pdHRlcihzb3VyY2VPYmopIHtcbiAgICByZXR1cm4gISFzb3VyY2VPYmogJiYgdHlwZW9mIHNvdXJjZU9iai5vbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc291cmNlT2JqLm9mZiA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGlzTm9kZUxpc3Qoc291cmNlT2JqKSB7XG4gICAgcmV0dXJuICEhc291cmNlT2JqICYmIHRvU3RyaW5nLmNhbGwoc291cmNlT2JqKSA9PT0gJ1tvYmplY3QgTm9kZUxpc3RdJztcbn1cbmZ1bmN0aW9uIGlzSFRNTENvbGxlY3Rpb24oc291cmNlT2JqKSB7XG4gICAgcmV0dXJuICEhc291cmNlT2JqICYmIHRvU3RyaW5nLmNhbGwoc291cmNlT2JqKSA9PT0gJ1tvYmplY3QgSFRNTENvbGxlY3Rpb25dJztcbn1cbmZ1bmN0aW9uIGlzRXZlbnRUYXJnZXQoc291cmNlT2JqKSB7XG4gICAgcmV0dXJuICEhc291cmNlT2JqICYmIHR5cGVvZiBzb3VyY2VPYmouYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc291cmNlT2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbic7XG59XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEZyb21FdmVudE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGcm9tRXZlbnRPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZyb21FdmVudE9ic2VydmFibGUoc291cmNlT2JqLCBldmVudE5hbWUsIHNlbGVjdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnNvdXJjZU9iaiA9IHNvdXJjZU9iajtcbiAgICAgICAgdGhpcy5ldmVudE5hbWUgPSBldmVudE5hbWU7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBldmVudHMgb2YgYSBzcGVjaWZpYyB0eXBlIGNvbWluZyBmcm9tIHRoZVxuICAgICAqIGdpdmVuIGV2ZW50IHRhcmdldC5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5DcmVhdGVzIGFuIE9ic2VydmFibGUgZnJvbSBET00gZXZlbnRzLCBvciBOb2RlXG4gICAgICogRXZlbnRFbWl0dGVyIGV2ZW50cyBvciBvdGhlcnMuPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy9mcm9tRXZlbnQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gICAgICpcbiAgICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgYnkgYXR0YWNoaW5nIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGFuIFwiZXZlbnQgdGFyZ2V0XCIsXG4gICAgICogd2hpY2ggbWF5IGJlIGFuIG9iamVjdCB3aXRoIGBhZGRFdmVudExpc3RlbmVyYCBhbmQgYHJlbW92ZUV2ZW50TGlzdGVuZXJgLFxuICAgICAqIGEgTm9kZS5qcyBFdmVudEVtaXR0ZXIsIGEgalF1ZXJ5IHN0eWxlIEV2ZW50RW1pdHRlciwgYSBOb2RlTGlzdCBmcm9tIHRoZVxuICAgICAqIERPTSwgb3IgYW4gSFRNTENvbGxlY3Rpb24gZnJvbSB0aGUgRE9NLiBUaGUgZXZlbnQgaGFuZGxlciBpcyBhdHRhY2hlZCB3aGVuXG4gICAgICogdGhlIG91dHB1dCBPYnNlcnZhYmxlIGlzIHN1YnNjcmliZWQsIGFuZCByZW1vdmVkIHdoZW4gdGhlIFN1YnNjcmlwdGlvbiBpc1xuICAgICAqIHVuc3Vic2NyaWJlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXRzIGNsaWNrcyBoYXBwZW5pbmcgb24gdGhlIERPTSBkb2N1bWVudDwvY2FwdGlvbj5cbiAgICAgKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICAgICAqIGNsaWNrcy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiAvLyBSZXN1bHRzIGluOlxuICAgICAqIC8vIE1vdXNlRXZlbnQgb2JqZWN0IGxvZ2dlZCB0byBjb25zb2xlIGV2ZXJ5dGltZSBhIGNsaWNrXG4gICAgICogLy8gb2NjdXJzIG9uIHRoZSBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGZyb219XG4gICAgICogQHNlZSB7QGxpbmsgZnJvbUV2ZW50UGF0dGVybn1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnRUYXJnZXRMaWtlfSB0YXJnZXQgVGhlIERPTUVsZW1lbnQsIGV2ZW50IHRhcmdldCwgTm9kZS5qc1xuICAgICAqIEV2ZW50RW1pdHRlciwgTm9kZUxpc3Qgb3IgSFRNTENvbGxlY3Rpb24gdG8gYXR0YWNoIHRoZSBldmVudCBoYW5kbGVyIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgb2YgaW50ZXJlc3QsIGJlaW5nIGVtaXR0ZWQgYnkgdGhlXG4gICAgICogYHRhcmdldGAuXG4gICAgICogQHBhcmFtIHtFdmVudExpc3RlbmVyT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMgdG8gcGFzcyB0aHJvdWdoIHRvIGFkZEV2ZW50TGlzdGVuZXJcbiAgICAgKiBAcGFyYW0ge1NlbGVjdG9yTWV0aG9kU2lnbmF0dXJlPFQ+fSBbc2VsZWN0b3JdIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvXG4gICAgICogcG9zdC1wcm9jZXNzIHJlc3VsdHMuIEl0IHRha2VzIHRoZSBhcmd1bWVudHMgZnJvbSB0aGUgZXZlbnQgaGFuZGxlciBhbmRcbiAgICAgKiBzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHZhbHVlLlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGU8VD59XG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgZnJvbUV2ZW50XG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBGcm9tRXZlbnRPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50TmFtZSwgb3B0aW9ucywgc2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBzZWxlY3RvciA9IG9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRnJvbUV2ZW50T2JzZXJ2YWJsZSh0YXJnZXQsIGV2ZW50TmFtZSwgc2VsZWN0b3IsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgRnJvbUV2ZW50T2JzZXJ2YWJsZS5zZXR1cFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChzb3VyY2VPYmosIGV2ZW50TmFtZSwgaGFuZGxlciwgc3Vic2NyaWJlciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdW5zdWJzY3JpYmU7XG4gICAgICAgIGlmIChpc05vZGVMaXN0KHNvdXJjZU9iaikgfHwgaXNIVE1MQ29sbGVjdGlvbihzb3VyY2VPYmopKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlT2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgRnJvbUV2ZW50T2JzZXJ2YWJsZS5zZXR1cFN1YnNjcmlwdGlvbihzb3VyY2VPYmpbaV0sIGV2ZW50TmFtZSwgaGFuZGxlciwgc3Vic2NyaWJlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNFdmVudFRhcmdldChzb3VyY2VPYmopKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlXzEgPSBzb3VyY2VPYmo7XG4gICAgICAgICAgICBzb3VyY2VPYmouYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzb3VyY2VfMS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNKUXVlcnlTdHlsZUV2ZW50RW1pdHRlcihzb3VyY2VPYmopKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlXzIgPSBzb3VyY2VPYmo7XG4gICAgICAgICAgICBzb3VyY2VPYmoub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc291cmNlXzIub2ZmKGV2ZW50TmFtZSwgaGFuZGxlcik7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNOb2RlU3R5bGVFdmVudEVtaXR0ZXIoc291cmNlT2JqKSkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZV8zID0gc291cmNlT2JqO1xuICAgICAgICAgICAgc291cmNlT2JqLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNvdXJjZV8zLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGV2ZW50IHRhcmdldCcpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIuYWRkKG5ldyBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24odW5zdWJzY3JpYmUpKTtcbiAgICB9O1xuICAgIEZyb21FdmVudE9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgc291cmNlT2JqID0gdGhpcy5zb3VyY2VPYmo7XG4gICAgICAgIHZhciBldmVudE5hbWUgPSB0aGlzLmV2ZW50TmFtZTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3I7XG4gICAgICAgIHZhciBoYW5kbGVyID0gc2VsZWN0b3IgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2goc2VsZWN0b3IpLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gc3Vic2NyaWJlci5uZXh0KGUpOyB9O1xuICAgICAgICBGcm9tRXZlbnRPYnNlcnZhYmxlLnNldHVwU3Vic2NyaXB0aW9uKHNvdXJjZU9iaiwgZXZlbnROYW1lLCBoYW5kbGVyLCBzdWJzY3JpYmVyLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIHJldHVybiBGcm9tRXZlbnRPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5Gcm9tRXZlbnRPYnNlcnZhYmxlID0gRnJvbUV2ZW50T2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZyb21FdmVudE9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBpc0FycmF5XzEgPSByZXF1aXJlKCcuLi91dGlsL2lzQXJyYXknKTtcbnZhciBpc0FycmF5TGlrZV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0FycmF5TGlrZScpO1xudmFyIGlzUHJvbWlzZV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc1Byb21pc2UnKTtcbnZhciBQcm9taXNlT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9Qcm9taXNlT2JzZXJ2YWJsZScpO1xudmFyIEl0ZXJhdG9yT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9JdGVyYXRvck9ic2VydmFibGUnKTtcbnZhciBBcnJheU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vQXJyYXlPYnNlcnZhYmxlJyk7XG52YXIgQXJyYXlMaWtlT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9BcnJheUxpa2VPYnNlcnZhYmxlJyk7XG52YXIgaXRlcmF0b3JfMSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9pdGVyYXRvcicpO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBvYnNlcnZlT25fMSA9IHJlcXVpcmUoJy4uL29wZXJhdG9yL29ic2VydmVPbicpO1xudmFyIG9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9vYnNlcnZhYmxlJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEZyb21PYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRnJvbU9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRnJvbU9ic2VydmFibGUoaXNoLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbnVsbCk7XG4gICAgICAgIHRoaXMuaXNoID0gaXNoO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIGZyb20gYW4gQXJyYXksIGFuIGFycmF5LWxpa2Ugb2JqZWN0LCBhIFByb21pc2UsIGFuXG4gICAgICogaXRlcmFibGUgb2JqZWN0LCBvciBhbiBPYnNlcnZhYmxlLWxpa2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNvbnZlcnRzIGFsbW9zdCBhbnl0aGluZyB0byBhbiBPYnNlcnZhYmxlLjwvc3Bhbj5cbiAgICAgKlxuICAgICAqIDxpbWcgc3JjPVwiLi9pbWcvZnJvbS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICAgKlxuICAgICAqIENvbnZlcnQgdmFyaW91cyBvdGhlciBvYmplY3RzIGFuZCBkYXRhIHR5cGVzIGludG8gT2JzZXJ2YWJsZXMuIGBmcm9tYFxuICAgICAqIGNvbnZlcnRzIGEgUHJvbWlzZSBvciBhbiBhcnJheS1saWtlIG9yIGFuXG4gICAgICogW2l0ZXJhYmxlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9JdGVyYXRpb25fcHJvdG9jb2xzI2l0ZXJhYmxlKVxuICAgICAqIG9iamVjdCBpbnRvIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgaXRlbXMgaW4gdGhhdCBwcm9taXNlIG9yIGFycmF5IG9yXG4gICAgICogaXRlcmFibGUuIEEgU3RyaW5nLCBpbiB0aGlzIGNvbnRleHQsIGlzIHRyZWF0ZWQgYXMgYW4gYXJyYXkgb2YgY2hhcmFjdGVycy5cbiAgICAgKiBPYnNlcnZhYmxlLWxpa2Ugb2JqZWN0cyAoY29udGFpbnMgYSBmdW5jdGlvbiBuYW1lZCB3aXRoIHRoZSBFUzIwMTUgU3ltYm9sXG4gICAgICogZm9yIE9ic2VydmFibGUpIGNhbiBhbHNvIGJlIGNvbnZlcnRlZCB0aHJvdWdoIHRoaXMgb3BlcmF0b3IuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db252ZXJ0cyBhbiBhcnJheSB0byBhbiBPYnNlcnZhYmxlPC9jYXB0aW9uPlxuICAgICAqIHZhciBhcnJheSA9IFsxMCwgMjAsIDMwXTtcbiAgICAgKiB2YXIgcmVzdWx0ID0gUnguT2JzZXJ2YWJsZS5mcm9tKGFycmF5KTtcbiAgICAgKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICAgICAqIC8vIDEwIDIwIDMwXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db252ZXJ0IGFuIGluZmluaXRlIGl0ZXJhYmxlIChmcm9tIGEgZ2VuZXJhdG9yKSB0byBhbiBPYnNlcnZhYmxlPC9jYXB0aW9uPlxuICAgICAqIGZ1bmN0aW9uKiBnZW5lcmF0ZURvdWJsZXMoc2VlZCkge1xuICAgICAqICAgdmFyIGkgPSBzZWVkO1xuICAgICAqICAgd2hpbGUgKHRydWUpIHtcbiAgICAgKiAgICAgeWllbGQgaTtcbiAgICAgKiAgICAgaSA9IDIgKiBpOyAvLyBkb3VibGUgaXRcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgaXRlcmF0b3IgPSBnZW5lcmF0ZURvdWJsZXMoMyk7XG4gICAgICogdmFyIHJlc3VsdCA9IFJ4Lk9ic2VydmFibGUuZnJvbShpdGVyYXRvcikudGFrZSgxMCk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIC8vIFJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZzpcbiAgICAgKiAvLyAzIDYgMTIgMjQgNDggOTYgMTkyIDM4NCA3NjggMTUzNlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgY3JlYXRlfVxuICAgICAqIEBzZWUge0BsaW5rIGZyb21FdmVudH1cbiAgICAgKiBAc2VlIHtAbGluayBmcm9tRXZlbnRQYXR0ZXJufVxuICAgICAqIEBzZWUge0BsaW5rIGZyb21Qcm9taXNlfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYnNlcnZhYmxlSW5wdXQ8VD59IGlzaCBBIHN1YnNjcmliYWJsZSBvYmplY3QsIGEgUHJvbWlzZSwgYW5cbiAgICAgKiBPYnNlcnZhYmxlLWxpa2UsIGFuIEFycmF5LCBhbiBpdGVyYWJsZSBvciBhbiBhcnJheS1saWtlIG9iamVjdCB0byBiZVxuICAgICAqIGNvbnZlcnRlZC5cbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gVGhlIHNjaGVkdWxlciBvbiB3aGljaCB0byBzY2hlZHVsZSB0aGVcbiAgICAgKiBlbWlzc2lvbnMgb2YgdmFsdWVzLlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IFRoZSBPYnNlcnZhYmxlIHdob3NlIHZhbHVlcyBhcmUgb3JpZ2luYWxseSBmcm9tIHRoZVxuICAgICAqIGlucHV0IG9iamVjdCB0aGF0IHdhcyBjb252ZXJ0ZWQuXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgZnJvbVxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgRnJvbU9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGlzaCwgc2NoZWR1bGVyKSB7XG4gICAgICAgIGlmIChpc2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpc2hbb2JzZXJ2YWJsZV8xLm9ic2VydmFibGVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzaCBpbnN0YW5jZW9mIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlICYmICFzY2hlZHVsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGcm9tT2JzZXJ2YWJsZShpc2gsIHNjaGVkdWxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0FycmF5XzEuaXNBcnJheShpc2gpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheU9ic2VydmFibGVfMS5BcnJheU9ic2VydmFibGUoaXNoLCBzY2hlZHVsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNQcm9taXNlXzEuaXNQcm9taXNlKGlzaCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2VPYnNlcnZhYmxlXzEuUHJvbWlzZU9ic2VydmFibGUoaXNoLCBzY2hlZHVsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGlzaFtpdGVyYXRvcl8xLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaXNoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3JPYnNlcnZhYmxlXzEuSXRlcmF0b3JPYnNlcnZhYmxlKGlzaCwgc2NoZWR1bGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlXzEuaXNBcnJheUxpa2UoaXNoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlMaWtlT2JzZXJ2YWJsZV8xLkFycmF5TGlrZU9ic2VydmFibGUoaXNoLCBzY2hlZHVsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKGlzaCAhPT0gbnVsbCAmJiB0eXBlb2YgaXNoIHx8IGlzaCkgKyAnIGlzIG5vdCBvYnNlcnZhYmxlJyk7XG4gICAgfTtcbiAgICBGcm9tT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBpc2ggPSB0aGlzLmlzaDtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICBpZiAoc2NoZWR1bGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBpc2hbb2JzZXJ2YWJsZV8xLm9ic2VydmFibGVdKCkuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzaFtvYnNlcnZhYmxlXzEub2JzZXJ2YWJsZV0oKS5zdWJzY3JpYmUobmV3IG9ic2VydmVPbl8xLk9ic2VydmVPblN1YnNjcmliZXIoc3Vic2NyaWJlciwgc2NoZWR1bGVyLCAwKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBGcm9tT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuRnJvbU9ic2VydmFibGUgPSBGcm9tT2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZyb21PYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9yb290Jyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIGl0ZXJhdG9yXzEgPSByZXF1aXJlKCcuLi9zeW1ib2wvaXRlcmF0b3InKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgSXRlcmF0b3JPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSXRlcmF0b3JPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEl0ZXJhdG9yT2JzZXJ2YWJsZShpdGVyYXRvciwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgaWYgKGl0ZXJhdG9yID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXRlcmF0b3IgY2Fubm90IGJlIG51bGwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pdGVyYXRvciA9IGdldEl0ZXJhdG9yKGl0ZXJhdG9yKTtcbiAgICB9XG4gICAgSXRlcmF0b3JPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChpdGVyYXRvciwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3JPYnNlcnZhYmxlKGl0ZXJhdG9yLCBzY2hlZHVsZXIpO1xuICAgIH07XG4gICAgSXRlcmF0b3JPYnNlcnZhYmxlLmRpc3BhdGNoID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHN0YXRlLmluZGV4LCBoYXNFcnJvciA9IHN0YXRlLmhhc0Vycm9yLCBpdGVyYXRvciA9IHN0YXRlLml0ZXJhdG9yLCBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlcjtcbiAgICAgICAgaWYgKGhhc0Vycm9yKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKHN0YXRlLmVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpYmVyLm5leHQocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgc3RhdGUuaW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvci5yZXR1cm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjaGVkdWxlKHN0YXRlKTtcbiAgICB9O1xuICAgIEl0ZXJhdG9yT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGl0ZXJhdG9yID0gX2EuaXRlcmF0b3IsIHNjaGVkdWxlciA9IF9hLnNjaGVkdWxlcjtcbiAgICAgICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShJdGVyYXRvck9ic2VydmFibGUuZGlzcGF0Y2gsIDAsIHtcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsIGl0ZXJhdG9yOiBpdGVyYXRvciwgc3Vic2NyaWJlcjogc3Vic2NyaWJlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvci5yZXR1cm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSXRlcmF0b3JPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5JdGVyYXRvck9ic2VydmFibGUgPSBJdGVyYXRvck9ic2VydmFibGU7XG52YXIgU3RyaW5nSXRlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0cmluZ0l0ZXJhdG9yKHN0ciwgaWR4LCBsZW4pIHtcbiAgICAgICAgaWYgKGlkeCA9PT0gdm9pZCAwKSB7IGlkeCA9IDA7IH1cbiAgICAgICAgaWYgKGxlbiA9PT0gdm9pZCAwKSB7IGxlbiA9IHN0ci5sZW5ndGg7IH1cbiAgICAgICAgdGhpcy5zdHIgPSBzdHI7XG4gICAgICAgIHRoaXMuaWR4ID0gaWR4O1xuICAgICAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICB9XG4gICAgU3RyaW5nSXRlcmF0b3IucHJvdG90eXBlW2l0ZXJhdG9yXzEuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMpOyB9O1xuICAgIFN0cmluZ0l0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZHggPCB0aGlzLmxlbiA/IHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuc3RyLmNoYXJBdCh0aGlzLmlkeCsrKVxuICAgICAgICB9IDoge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBTdHJpbmdJdGVyYXRvcjtcbn0oKSk7XG52YXIgQXJyYXlJdGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXJyYXlJdGVyYXRvcihhcnIsIGlkeCwgbGVuKSB7XG4gICAgICAgIGlmIChpZHggPT09IHZvaWQgMCkgeyBpZHggPSAwOyB9XG4gICAgICAgIGlmIChsZW4gPT09IHZvaWQgMCkgeyBsZW4gPSB0b0xlbmd0aChhcnIpOyB9XG4gICAgICAgIHRoaXMuYXJyID0gYXJyO1xuICAgICAgICB0aGlzLmlkeCA9IGlkeDtcbiAgICAgICAgdGhpcy5sZW4gPSBsZW47XG4gICAgfVxuICAgIEFycmF5SXRlcmF0b3IucHJvdG90eXBlW2l0ZXJhdG9yXzEuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcbiAgICBBcnJheUl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZHggPCB0aGlzLmxlbiA/IHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuYXJyW3RoaXMuaWR4KytdXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEFycmF5SXRlcmF0b3I7XG59KCkpO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3Iob2JqKSB7XG4gICAgdmFyIGkgPSBvYmpbaXRlcmF0b3JfMS5pdGVyYXRvcl07XG4gICAgaWYgKCFpICYmIHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyaW5nSXRlcmF0b3Iob2JqKTtcbiAgICB9XG4gICAgaWYgKCFpICYmIG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5SXRlcmF0b3Iob2JqKTtcbiAgICB9XG4gICAgaWYgKCFpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29iamVjdCBpcyBub3QgaXRlcmFibGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIG9ialtpdGVyYXRvcl8xLml0ZXJhdG9yXSgpO1xufVxudmFyIG1heFNhZmVJbnRlZ2VyID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcbmZ1bmN0aW9uIHRvTGVuZ3RoKG8pIHtcbiAgICB2YXIgbGVuID0gK28ubGVuZ3RoO1xuICAgIGlmIChpc05hTihsZW4pKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAobGVuID09PSAwIHx8ICFudW1iZXJJc0Zpbml0ZShsZW4pKSB7XG4gICAgICAgIHJldHVybiBsZW47XG4gICAgfVxuICAgIGxlbiA9IHNpZ24obGVuKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobGVuKSk7XG4gICAgaWYgKGxlbiA8PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAobGVuID4gbWF4U2FmZUludGVnZXIpIHtcbiAgICAgICAgcmV0dXJuIG1heFNhZmVJbnRlZ2VyO1xuICAgIH1cbiAgICByZXR1cm4gbGVuO1xufVxuZnVuY3Rpb24gbnVtYmVySXNGaW5pdGUodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiByb290XzEucm9vdC5pc0Zpbml0ZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBzaWduKHZhbHVlKSB7XG4gICAgdmFyIHZhbHVlQXNOdW1iZXIgPSArdmFsdWU7XG4gICAgaWYgKHZhbHVlQXNOdW1iZXIgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlQXNOdW1iZXI7XG4gICAgfVxuICAgIGlmIChpc05hTih2YWx1ZUFzTnVtYmVyKSkge1xuICAgICAgICByZXR1cm4gdmFsdWVBc051bWJlcjtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlQXNOdW1iZXIgPCAwID8gLTEgOiAxO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SXRlcmF0b3JPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9yb290Jyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBQcm9taXNlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByb21pc2VPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByb21pc2VPYnNlcnZhYmxlKHByb21pc2UsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgUHJvbWlzZSB0byBhbiBPYnNlcnZhYmxlLlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGp1c3QgZW1pdHMgdGhlIFByb21pc2Unc1xuICAgICAqIHJlc29sdmVkIHZhbHVlLCB0aGVuIGNvbXBsZXRlcy48L3NwYW4+XG4gICAgICpcbiAgICAgKiBDb252ZXJ0cyBhbiBFUzIwMTUgUHJvbWlzZSBvciBhIFByb21pc2VzL0ErIHNwZWMgY29tcGxpYW50IFByb21pc2UgdG8gYW5cbiAgICAgKiBPYnNlcnZhYmxlLiBJZiB0aGUgUHJvbWlzZSByZXNvbHZlcyB3aXRoIGEgdmFsdWUsIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZVxuICAgICAqIGVtaXRzIHRoYXQgcmVzb2x2ZWQgdmFsdWUgYXMgYSBgbmV4dGAsIGFuZCB0aGVuIGNvbXBsZXRlcy4gSWYgdGhlIFByb21pc2VcbiAgICAgKiBpcyByZWplY3RlZCwgdGhlbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgZW1pdHMgdGhlIGNvcnJlc3BvbmRpbmcgRXJyb3IuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db252ZXJ0IHRoZSBQcm9taXNlIHJldHVybmVkIGJ5IEZldGNoIHRvIGFuIE9ic2VydmFibGU8L2NhcHRpb24+XG4gICAgICogdmFyIHJlc3VsdCA9IFJ4Lk9ic2VydmFibGUuZnJvbVByb21pc2UoZmV0Y2goJ2h0dHA6Ly9teXNlcnZlci5jb20vJykpO1xuICAgICAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSwgZSA9PiBjb25zb2xlLmVycm9yKGUpKTtcbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGJpbmRDYWxsYmFja31cbiAgICAgKiBAc2VlIHtAbGluayBmcm9tfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQcm9taXNlPFQ+fSBwcm9taXNlIFRoZSBwcm9taXNlIHRvIGJlIGNvbnZlcnRlZC5cbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gQW4gb3B0aW9uYWwgSVNjaGVkdWxlciB0byB1c2UgZm9yIHNjaGVkdWxpbmdcbiAgICAgKiB0aGUgZGVsaXZlcnkgb2YgdGhlIHJlc29sdmVkIHZhbHVlIChvciB0aGUgcmVqZWN0aW9uKS5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHdoaWNoIHdyYXBzIHRoZSBQcm9taXNlLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGZyb21Qcm9taXNlXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBQcm9taXNlT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAocHJvbWlzZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZU9ic2VydmFibGUocHJvbWlzZSwgc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIFByb21pc2VPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLnByb21pc2U7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgaWYgKHNjaGVkdWxlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNTY2FsYXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lzU2NhbGFyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4obnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGUgdGhlIHByb21pc2UgdHJhcCwgdGhyb3cgdW5oYW5kbGVkIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICByb290XzEucm9vdC5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgdGhyb3cgZXJyOyB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1NjYWxhcikge1xuICAgICAgICAgICAgICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaE5leHQsIDAsIHsgdmFsdWU6IHRoaXMudmFsdWUsIHN1YnNjcmliZXI6IHN1YnNjcmliZXIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faXNTY2FsYXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hOZXh0LCAwLCB7IHZhbHVlOiB2YWx1ZSwgc3Vic2NyaWJlcjogc3Vic2NyaWJlciB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaEVycm9yLCAwLCB7IGVycjogZXJyLCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNjYXBlIHRoZSBwcm9taXNlIHRyYXAsIHRocm93IHVuaGFuZGxlZCBlcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgcm9vdF8xLnJvb3Quc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHRocm93IGVycjsgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBQcm9taXNlT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuUHJvbWlzZU9ic2VydmFibGUgPSBQcm9taXNlT2JzZXJ2YWJsZTtcbmZ1bmN0aW9uIGRpc3BhdGNoTmV4dChhcmcpIHtcbiAgICB2YXIgdmFsdWUgPSBhcmcudmFsdWUsIHN1YnNjcmliZXIgPSBhcmcuc3Vic2NyaWJlcjtcbiAgICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkaXNwYXRjaEVycm9yKGFyZykge1xuICAgIHZhciBlcnIgPSBhcmcuZXJyLCBzdWJzY3JpYmVyID0gYXJnLnN1YnNjcmliZXI7XG4gICAgaWYgKCFzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJvbWlzZU9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIFNjYWxhck9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTY2FsYXJPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNjYWxhck9ic2VydmFibGUodmFsdWUsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5faXNTY2FsYXIgPSB0cnVlO1xuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1NjYWxhciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIFNjYWxhck9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKHZhbHVlLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTY2FsYXJPYnNlcnZhYmxlKHZhbHVlLCBzY2hlZHVsZXIpO1xuICAgIH07XG4gICAgU2NhbGFyT2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgZG9uZSA9IHN0YXRlLmRvbmUsIHZhbHVlID0gc3RhdGUudmFsdWUsIHN1YnNjcmliZXIgPSBzdGF0ZS5zdWJzY3JpYmVyO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmRvbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlKHN0YXRlKTtcbiAgICB9O1xuICAgIFNjYWxhck9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIGlmIChzY2hlZHVsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoU2NhbGFyT2JzZXJ2YWJsZS5kaXNwYXRjaCwgMCwge1xuICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlLCB2YWx1ZTogdmFsdWUsIHN1YnNjcmliZXI6IHN1YnNjcmliZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTY2FsYXJPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5TY2FsYXJPYnNlcnZhYmxlID0gU2NhbGFyT2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNjYWxhck9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBpc051bWVyaWNfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNOdW1lcmljJyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi9zY2hlZHVsZXIvYXN5bmMnKTtcbnZhciBpc1NjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc1NjaGVkdWxlcicpO1xudmFyIGlzRGF0ZV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0RhdGUnKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgVGltZXJPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZXJPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVyT2JzZXJ2YWJsZShkdWVUaW1lLCBwZXJpb2QsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoZHVlVGltZSA9PT0gdm9pZCAwKSB7IGR1ZVRpbWUgPSAwOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnBlcmlvZCA9IC0xO1xuICAgICAgICB0aGlzLmR1ZVRpbWUgPSAwO1xuICAgICAgICBpZiAoaXNOdW1lcmljXzEuaXNOdW1lcmljKHBlcmlvZCkpIHtcbiAgICAgICAgICAgIHRoaXMucGVyaW9kID0gTnVtYmVyKHBlcmlvZCkgPCAxICYmIDEgfHwgTnVtYmVyKHBlcmlvZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihwZXJpb2QpKSB7XG4gICAgICAgICAgICBzY2hlZHVsZXIgPSBwZXJpb2Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1NjaGVkdWxlcl8xLmlzU2NoZWR1bGVyKHNjaGVkdWxlcikpIHtcbiAgICAgICAgICAgIHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuZHVlVGltZSA9IGlzRGF0ZV8xLmlzRGF0ZShkdWVUaW1lKSA/XG4gICAgICAgICAgICAoK2R1ZVRpbWUgLSB0aGlzLnNjaGVkdWxlci5ub3coKSkgOlxuICAgICAgICAgICAgZHVlVGltZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgc3RhcnRzIGVtaXR0aW5nIGFmdGVyIGFuIGBpbml0aWFsRGVsYXlgIGFuZFxuICAgICAqIGVtaXRzIGV2ZXIgaW5jcmVhc2luZyBudW1iZXJzIGFmdGVyIGVhY2ggYHBlcmlvZGAgb2YgdGltZSB0aGVyZWFmdGVyLlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0cyBsaWtlIHtAbGluayBpbnRlcnZhbH0sIGJ1dCB5b3UgY2FuIHNwZWNpZnkgd2hlblxuICAgICAqIHNob3VsZCB0aGUgZW1pc3Npb25zIHN0YXJ0Ljwvc3Bhbj5cbiAgICAgKlxuICAgICAqIDxpbWcgc3JjPVwiLi9pbWcvdGltZXIucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gICAgICpcbiAgICAgKiBgdGltZXJgIHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGFuIGluZmluaXRlIHNlcXVlbmNlIG9mIGFzY2VuZGluZ1xuICAgICAqIGludGVnZXJzLCB3aXRoIGEgY29uc3RhbnQgaW50ZXJ2YWwgb2YgdGltZSwgYHBlcmlvZGAgb2YgeW91ciBjaG9vc2luZ1xuICAgICAqIGJldHdlZW4gdGhvc2UgZW1pc3Npb25zLiBUaGUgZmlyc3QgZW1pc3Npb24gaGFwcGVucyBhZnRlciB0aGUgc3BlY2lmaWVkXG4gICAgICogYGluaXRpYWxEZWxheWAuIFRoZSBpbml0aWFsIGRlbGF5IG1heSBiZSBhIHtAbGluayBEYXRlfS4gQnkgZGVmYXVsdCwgdGhpc1xuICAgICAqIG9wZXJhdG9yIHVzZXMgdGhlIGBhc3luY2AgSVNjaGVkdWxlciB0byBwcm92aWRlIGEgbm90aW9uIG9mIHRpbWUsIGJ1dCB5b3VcbiAgICAgKiBtYXkgcGFzcyBhbnkgSVNjaGVkdWxlciB0byBpdC4gSWYgYHBlcmlvZGAgaXMgbm90IHNwZWNpZmllZCwgdGhlIG91dHB1dFxuICAgICAqIE9ic2VydmFibGUgZW1pdHMgb25seSBvbmUgdmFsdWUsIGAwYC4gT3RoZXJ3aXNlLCBpdCBlbWl0cyBhbiBpbmZpbml0ZVxuICAgICAqIHNlcXVlbmNlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdHMgYXNjZW5kaW5nIG51bWJlcnMsIG9uZSBldmVyeSBzZWNvbmQgKDEwMDBtcyksIHN0YXJ0aW5nIGFmdGVyIDMgc2Vjb25kczwvY2FwdGlvbj5cbiAgICAgKiB2YXIgbnVtYmVycyA9IFJ4Lk9ic2VydmFibGUudGltZXIoMzAwMCwgMTAwMCk7XG4gICAgICogbnVtYmVycy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0cyBvbmUgbnVtYmVyIGFmdGVyIGZpdmUgc2Vjb25kczwvY2FwdGlvbj5cbiAgICAgKiB2YXIgbnVtYmVycyA9IFJ4Lk9ic2VydmFibGUudGltZXIoNTAwMCk7XG4gICAgICogbnVtYmVycy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBpbnRlcnZhbH1cbiAgICAgKiBAc2VlIHtAbGluayBkZWxheX1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfERhdGV9IGluaXRpYWxEZWxheSBUaGUgaW5pdGlhbCBkZWxheSB0aW1lIHRvIHdhaXQgYmVmb3JlXG4gICAgICogZW1pdHRpbmcgdGhlIGZpcnN0IHZhbHVlIG9mIGAwYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BlcmlvZF0gVGhlIHBlcmlvZCBvZiB0aW1lIGJldHdlZW4gZW1pc3Npb25zIG9mIHRoZVxuICAgICAqIHN1YnNlcXVlbnQgbnVtYmVycy5cbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1hc3luY10gVGhlIElTY2hlZHVsZXIgdG8gdXNlIGZvciBzY2hlZHVsaW5nXG4gICAgICogdGhlIGVtaXNzaW9uIG9mIHZhbHVlcywgYW5kIHByb3ZpZGluZyBhIG5vdGlvbiBvZiBcInRpbWVcIi5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYSBgMGAgYWZ0ZXIgdGhlXG4gICAgICogYGluaXRpYWxEZWxheWAgYW5kIGV2ZXIgaW5jcmVhc2luZyBudW1iZXJzIGFmdGVyIGVhY2ggYHBlcmlvZGAgb2YgdGltZVxuICAgICAqIHRoZXJlYWZ0ZXIuXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgdGltZXJcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIFRpbWVyT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoaW5pdGlhbERlbGF5LCBwZXJpb2QsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoaW5pdGlhbERlbGF5ID09PSB2b2lkIDApIHsgaW5pdGlhbERlbGF5ID0gMDsgfVxuICAgICAgICByZXR1cm4gbmV3IFRpbWVyT2JzZXJ2YWJsZShpbml0aWFsRGVsYXksIHBlcmlvZCwgc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIFRpbWVyT2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleCwgcGVyaW9kID0gc3RhdGUucGVyaW9kLCBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlcjtcbiAgICAgICAgdmFyIGFjdGlvbiA9IHRoaXM7XG4gICAgICAgIHN1YnNjcmliZXIubmV4dChpbmRleCk7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBlcmlvZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuaW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgIGFjdGlvbi5zY2hlZHVsZShzdGF0ZSwgcGVyaW9kKTtcbiAgICB9O1xuICAgIFRpbWVyT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHBlcmlvZCA9IF9hLnBlcmlvZCwgZHVlVGltZSA9IF9hLmR1ZVRpbWUsIHNjaGVkdWxlciA9IF9hLnNjaGVkdWxlcjtcbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShUaW1lck9ic2VydmFibGUuZGlzcGF0Y2gsIGR1ZVRpbWUsIHtcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCwgcGVyaW9kOiBwZXJpb2QsIHN1YnNjcmliZXI6IHN1YnNjcmliZXJcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZXJPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5UaW1lck9ic2VydmFibGUgPSBUaW1lck9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaW1lck9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRGVmZXJPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0RlZmVyT2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5kZWZlciA9IERlZmVyT2JzZXJ2YWJsZV8xLkRlZmVyT2JzZXJ2YWJsZS5jcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcm9vdCcpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi8uLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vLi4vU3Vic2NyaWJlcicpO1xudmFyIG1hcF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvbWFwJyk7XG5mdW5jdGlvbiBnZXRDT1JTUmVxdWVzdCgpIHtcbiAgICBpZiAocm9vdF8xLnJvb3QuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByb290XzEucm9vdC5YTUxIdHRwUmVxdWVzdCgpO1xuICAgIH1cbiAgICBlbHNlIGlmICghIXJvb3RfMS5yb290LlhEb21haW5SZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgcm9vdF8xLnJvb3QuWERvbWFpblJlcXVlc3QoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ09SUyBpcyBub3Qgc3VwcG9ydGVkIGJ5IHlvdXIgYnJvd3NlcicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFhNTEh0dHBSZXF1ZXN0KCkge1xuICAgIGlmIChyb290XzEucm9vdC5YTUxIdHRwUmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gbmV3IHJvb3RfMS5yb290LlhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcHJvZ0lkID0gdm9pZCAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHByb2dJZHMgPSBbJ01zeG1sMi5YTUxIVFRQJywgJ01pY3Jvc29mdC5YTUxIVFRQJywgJ01zeG1sMi5YTUxIVFRQLjQuMCddO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwcm9nSWQgPSBwcm9nSWRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3IHJvb3RfMS5yb290LkFjdGl2ZVhPYmplY3QocHJvZ0lkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IHJvb3RfMS5yb290LkFjdGl2ZVhPYmplY3QocHJvZ0lkKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdYTUxIdHRwUmVxdWVzdCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHlvdXIgYnJvd3NlcicpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYWpheEdldCh1cmwsIGhlYWRlcnMpIHtcbiAgICBpZiAoaGVhZGVycyA9PT0gdm9pZCAwKSB7IGhlYWRlcnMgPSBudWxsOyB9XG4gICAgcmV0dXJuIG5ldyBBamF4T2JzZXJ2YWJsZSh7IG1ldGhvZDogJ0dFVCcsIHVybDogdXJsLCBoZWFkZXJzOiBoZWFkZXJzIH0pO1xufVxuZXhwb3J0cy5hamF4R2V0ID0gYWpheEdldDtcbjtcbmZ1bmN0aW9uIGFqYXhQb3N0KHVybCwgYm9keSwgaGVhZGVycykge1xuICAgIHJldHVybiBuZXcgQWpheE9ic2VydmFibGUoeyBtZXRob2Q6ICdQT1NUJywgdXJsOiB1cmwsIGJvZHk6IGJvZHksIGhlYWRlcnM6IGhlYWRlcnMgfSk7XG59XG5leHBvcnRzLmFqYXhQb3N0ID0gYWpheFBvc3Q7XG47XG5mdW5jdGlvbiBhamF4RGVsZXRlKHVybCwgaGVhZGVycykge1xuICAgIHJldHVybiBuZXcgQWpheE9ic2VydmFibGUoeyBtZXRob2Q6ICdERUxFVEUnLCB1cmw6IHVybCwgaGVhZGVyczogaGVhZGVycyB9KTtcbn1cbmV4cG9ydHMuYWpheERlbGV0ZSA9IGFqYXhEZWxldGU7XG47XG5mdW5jdGlvbiBhamF4UHV0KHVybCwgYm9keSwgaGVhZGVycykge1xuICAgIHJldHVybiBuZXcgQWpheE9ic2VydmFibGUoeyBtZXRob2Q6ICdQVVQnLCB1cmw6IHVybCwgYm9keTogYm9keSwgaGVhZGVyczogaGVhZGVycyB9KTtcbn1cbmV4cG9ydHMuYWpheFB1dCA9IGFqYXhQdXQ7XG47XG5mdW5jdGlvbiBhamF4UGF0Y2godXJsLCBib2R5LCBoZWFkZXJzKSB7XG4gICAgcmV0dXJuIG5ldyBBamF4T2JzZXJ2YWJsZSh7IG1ldGhvZDogJ1BBVENIJywgdXJsOiB1cmwsIGJvZHk6IGJvZHksIGhlYWRlcnM6IGhlYWRlcnMgfSk7XG59XG5leHBvcnRzLmFqYXhQYXRjaCA9IGFqYXhQYXRjaDtcbjtcbmZ1bmN0aW9uIGFqYXhHZXRKU09OKHVybCwgaGVhZGVycykge1xuICAgIHJldHVybiBuZXcgQWpheE9ic2VydmFibGUoeyBtZXRob2Q6ICdHRVQnLCB1cmw6IHVybCwgcmVzcG9uc2VUeXBlOiAnanNvbicsIGhlYWRlcnM6IGhlYWRlcnMgfSlcbiAgICAgICAgLmxpZnQobmV3IG1hcF8xLk1hcE9wZXJhdG9yKGZ1bmN0aW9uICh4LCBpbmRleCkgeyByZXR1cm4geC5yZXNwb25zZTsgfSwgbnVsbCkpO1xufVxuZXhwb3J0cy5hamF4R2V0SlNPTiA9IGFqYXhHZXRKU09OO1xuO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBBamF4T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFqYXhPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFqYXhPYnNlcnZhYmxlKHVybE9yUmVxdWVzdCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSB7XG4gICAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICAgIGNyZWF0ZVhIUjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyb3NzRG9tYWluID8gZ2V0Q09SU1JlcXVlc3QuY2FsbCh0aGlzKSA6IGdldFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3Jvc3NEb21haW46IGZhbHNlLFxuICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgdGltZW91dDogMFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIHVybE9yUmVxdWVzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlcXVlc3QudXJsID0gdXJsT3JSZXF1ZXN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiB1cmxPclJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodXJsT3JSZXF1ZXN0Lmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RbcHJvcF0gPSB1cmxPclJlcXVlc3RbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgfVxuICAgIEFqYXhPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBamF4U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnJlcXVlc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYnNlcnZhYmxlIGZvciBhbiBBamF4IHJlcXVlc3Qgd2l0aCBlaXRoZXIgYSByZXF1ZXN0IG9iamVjdCB3aXRoXG4gICAgICogdXJsLCBoZWFkZXJzLCBldGMgb3IgYSBzdHJpbmcgZm9yIGEgVVJMLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBzb3VyY2UgPSBSeC5PYnNlcnZhYmxlLmFqYXgoJy9wcm9kdWN0cycpO1xuICAgICAqIHNvdXJjZSA9IFJ4Lk9ic2VydmFibGUuYWpheCh7IHVybDogJ3Byb2R1Y3RzJywgbWV0aG9kOiAnR0VUJyB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gcmVxdWVzdCBDYW4gYmUgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gICAgICogICBBIHN0cmluZyBvZiB0aGUgVVJMIHRvIG1ha2UgdGhlIEFqYXggY2FsbC5cbiAgICAgKiAgIEFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllc1xuICAgICAqICAgLSB1cmw6IFVSTCBvZiB0aGUgcmVxdWVzdFxuICAgICAqICAgLSBib2R5OiBUaGUgYm9keSBvZiB0aGUgcmVxdWVzdFxuICAgICAqICAgLSBtZXRob2Q6IE1ldGhvZCBvZiB0aGUgcmVxdWVzdCwgc3VjaCBhcyBHRVQsIFBPU1QsIFBVVCwgUEFUQ0gsIERFTEVURVxuICAgICAqICAgLSBhc3luYzogV2hldGhlciB0aGUgcmVxdWVzdCBpcyBhc3luY1xuICAgICAqICAgLSBoZWFkZXJzOiBPcHRpb25hbCBoZWFkZXJzXG4gICAgICogICAtIGNyb3NzRG9tYWluOiB0cnVlIGlmIGEgY3Jvc3MgZG9tYWluIHJlcXVlc3QsIGVsc2UgZmFsc2VcbiAgICAgKiAgIC0gY3JlYXRlWEhSOiBhIGZ1bmN0aW9uIHRvIG92ZXJyaWRlIGlmIHlvdSBuZWVkIHRvIHVzZSBhbiBhbHRlcm5hdGVcbiAgICAgKiAgIFhNTEh0dHBSZXF1ZXN0IGltcGxlbWVudGF0aW9uLlxuICAgICAqICAgLSByZXN1bHRTZWxlY3RvcjogYSBmdW5jdGlvbiB0byB1c2UgdG8gYWx0ZXIgdGhlIG91dHB1dCB2YWx1ZSB0eXBlIG9mXG4gICAgICogICB0aGUgT2JzZXJ2YWJsZS4gR2V0cyB7QGxpbmsgQWpheFJlc3BvbnNlfSBhcyBhbiBhcmd1bWVudC5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIFhNTEh0dHBSZXF1ZXN0LlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGFqYXhcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICovXG4gICAgQWpheE9ic2VydmFibGUuY3JlYXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNyZWF0ZSA9IGZ1bmN0aW9uICh1cmxPclJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWpheE9ic2VydmFibGUodXJsT3JSZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgY3JlYXRlLmdldCA9IGFqYXhHZXQ7XG4gICAgICAgIGNyZWF0ZS5wb3N0ID0gYWpheFBvc3Q7XG4gICAgICAgIGNyZWF0ZS5kZWxldGUgPSBhamF4RGVsZXRlO1xuICAgICAgICBjcmVhdGUucHV0ID0gYWpheFB1dDtcbiAgICAgICAgY3JlYXRlLnBhdGNoID0gYWpheFBhdGNoO1xuICAgICAgICBjcmVhdGUuZ2V0SlNPTiA9IGFqYXhHZXRKU09OO1xuICAgICAgICByZXR1cm4gY3JlYXRlO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIEFqYXhPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5BamF4T2JzZXJ2YWJsZSA9IEFqYXhPYnNlcnZhYmxlO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBBamF4U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFqYXhTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFqYXhTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCByZXF1ZXN0KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHZhciBoZWFkZXJzID0gcmVxdWVzdC5oZWFkZXJzID0gcmVxdWVzdC5oZWFkZXJzIHx8IHt9O1xuICAgICAgICAvLyBmb3JjZSBDT1JTIGlmIHJlcXVlc3RlZFxuICAgICAgICBpZiAoIXJlcXVlc3QuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbJ1gtUmVxdWVzdGVkLVdpdGgnXSkge1xuICAgICAgICAgICAgaGVhZGVyc1snWC1SZXF1ZXN0ZWQtV2l0aCddID0gJ1hNTEh0dHBSZXF1ZXN0JztcbiAgICAgICAgfVxuICAgICAgICAvLyBlbnN1cmUgY29udGVudCB0eXBlIGlzIHNldFxuICAgICAgICBpZiAoISgnQ29udGVudC1UeXBlJyBpbiBoZWFkZXJzKSAmJiAhKHJvb3RfMS5yb290LkZvcm1EYXRhICYmIHJlcXVlc3QuYm9keSBpbnN0YW5jZW9mIHJvb3RfMS5yb290LkZvcm1EYXRhKSAmJiB0eXBlb2YgcmVxdWVzdC5ib2R5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04JztcbiAgICAgICAgfVxuICAgICAgICAvLyBwcm9wZXJseSBzZXJpYWxpemUgYm9keVxuICAgICAgICByZXF1ZXN0LmJvZHkgPSB0aGlzLnNlcmlhbGl6ZUJvZHkocmVxdWVzdC5ib2R5LCByZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKTtcbiAgICAgICAgdGhpcy5zZW5kKCk7XG4gICAgfVxuICAgIEFqYXhTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgeGhyID0gX2EueGhyLCByZXF1ZXN0ID0gX2EucmVxdWVzdCwgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbjtcbiAgICAgICAgdmFyIHJlc3BvbnNlID0gbmV3IEFqYXhSZXNwb25zZShlLCB4aHIsIHJlcXVlc3QpO1xuICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHJlc3BvbnNlKTtcbiAgICB9O1xuICAgIEFqYXhTdWJzY3JpYmVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCByZXF1ZXN0ID0gX2EucmVxdWVzdCwgX2IgPSBfYS5yZXF1ZXN0LCB1c2VyID0gX2IudXNlciwgbWV0aG9kID0gX2IubWV0aG9kLCB1cmwgPSBfYi51cmwsIGFzeW5jID0gX2IuYXN5bmMsIHBhc3N3b3JkID0gX2IucGFzc3dvcmQsIGhlYWRlcnMgPSBfYi5oZWFkZXJzLCBib2R5ID0gX2IuYm9keTtcbiAgICAgICAgdmFyIGNyZWF0ZVhIUiA9IHJlcXVlc3QuY3JlYXRlWEhSO1xuICAgICAgICB2YXIgeGhyID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChjcmVhdGVYSFIpLmNhbGwocmVxdWVzdCk7XG4gICAgICAgIGlmICh4aHIgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMueGhyID0geGhyO1xuICAgICAgICAgICAgLy8gc2V0IHVwIHRoZSBldmVudHMgYmVmb3JlIG9wZW4gWEhSXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3QvVXNpbmdfWE1MSHR0cFJlcXVlc3RcbiAgICAgICAgICAgIC8vIFlvdSBuZWVkIHRvIGFkZCB0aGUgZXZlbnQgbGlzdGVuZXJzIGJlZm9yZSBjYWxsaW5nIG9wZW4oKSBvbiB0aGUgcmVxdWVzdC5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSB0aGUgcHJvZ3Jlc3MgZXZlbnRzIHdpbGwgbm90IGZpcmUuXG4gICAgICAgICAgICB0aGlzLnNldHVwRXZlbnRzKHhociwgcmVxdWVzdCk7XG4gICAgICAgICAgICAvLyBvcGVuIFhIUlxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh4aHIub3BlbikuY2FsbCh4aHIsIG1ldGhvZCwgdXJsLCBhc3luYywgdXNlciwgcGFzc3dvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh4aHIub3BlbikuY2FsbCh4aHIsIG1ldGhvZCwgdXJsLCBhc3luYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGltZW91dCwgcmVzcG9uc2VUeXBlIGFuZCB3aXRoQ3JlZGVudGlhbHMgY2FuIGJlIHNldCBvbmNlIHRoZSBYSFIgaXMgb3BlblxuICAgICAgICAgICAgeGhyLnRpbWVvdXQgPSByZXF1ZXN0LnRpbWVvdXQ7XG4gICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gcmVxdWVzdC5yZXNwb25zZVR5cGU7XG4gICAgICAgICAgICBpZiAoJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG4gICAgICAgICAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9ICEhcmVxdWVzdC53aXRoQ3JlZGVudGlhbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgaGVhZGVyc1xuICAgICAgICAgICAgdGhpcy5zZXRIZWFkZXJzKHhociwgaGVhZGVycyk7XG4gICAgICAgICAgICAvLyBmaW5hbGx5IHNlbmQgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgIHJlc3VsdCA9IGJvZHkgPyB0cnlDYXRjaF8xLnRyeUNhdGNoKHhoci5zZW5kKS5jYWxsKHhociwgYm9keSkgOiB0cnlDYXRjaF8xLnRyeUNhdGNoKHhoci5zZW5kKS5jYWxsKHhocik7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4aHI7XG4gICAgfTtcbiAgICBBamF4U3Vic2NyaWJlci5wcm90b3R5cGUuc2VyaWFsaXplQm9keSA9IGZ1bmN0aW9uIChib2R5LCBjb250ZW50VHlwZSkge1xuICAgICAgICBpZiAoIWJvZHkgfHwgdHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gYm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb290XzEucm9vdC5Gb3JtRGF0YSAmJiBib2R5IGluc3RhbmNlb2Ygcm9vdF8xLnJvb3QuRm9ybURhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBib2R5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50VHlwZSkge1xuICAgICAgICAgICAgdmFyIHNwbGl0SW5kZXggPSBjb250ZW50VHlwZS5pbmRleE9mKCc7Jyk7XG4gICAgICAgICAgICBpZiAoc3BsaXRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlLnN1YnN0cmluZygwLCBzcGxpdEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhib2R5KS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gKGVuY29kZVVSSShrZXkpICsgXCI9XCIgKyBlbmNvZGVVUkkoYm9keVtrZXldKSk7IH0pLmpvaW4oJyYnKTtcbiAgICAgICAgICAgIGNhc2UgJ2FwcGxpY2F0aW9uL2pzb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFqYXhTdWJzY3JpYmVyLnByb3RvdHlwZS5zZXRIZWFkZXJzID0gZnVuY3Rpb24gKHhociwgaGVhZGVycykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gaGVhZGVycykge1xuICAgICAgICAgICAgaWYgKGhlYWRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgaGVhZGVyc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQWpheFN1YnNjcmliZXIucHJvdG90eXBlLnNldHVwRXZlbnRzID0gZnVuY3Rpb24gKHhociwgcmVxdWVzdCkge1xuICAgICAgICB2YXIgcHJvZ3Jlc3NTdWJzY3JpYmVyID0gcmVxdWVzdC5wcm9ncmVzc1N1YnNjcmliZXI7XG4gICAgICAgIGZ1bmN0aW9uIHhoclRpbWVvdXQoZSkge1xuICAgICAgICAgICAgdmFyIF9hID0geGhyVGltZW91dCwgc3Vic2NyaWJlciA9IF9hLnN1YnNjcmliZXIsIHByb2dyZXNzU3Vic2NyaWJlciA9IF9hLnByb2dyZXNzU3Vic2NyaWJlciwgcmVxdWVzdCA9IF9hLnJlcXVlc3Q7XG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3NTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NTdWJzY3JpYmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihuZXcgQWpheFRpbWVvdXRFcnJvcih0aGlzLCByZXF1ZXN0KSk7IC8vVE9ETzogTWFrZSBiZXR0ZXJlci5cbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIHhoci5vbnRpbWVvdXQgPSB4aHJUaW1lb3V0O1xuICAgICAgICB4aHJUaW1lb3V0LnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICB4aHJUaW1lb3V0LnN1YnNjcmliZXIgPSB0aGlzO1xuICAgICAgICB4aHJUaW1lb3V0LnByb2dyZXNzU3Vic2NyaWJlciA9IHByb2dyZXNzU3Vic2NyaWJlcjtcbiAgICAgICAgaWYgKHhoci51cGxvYWQgJiYgJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3NTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhoclByb2dyZXNzXzE7XG4gICAgICAgICAgICAgICAgeGhyUHJvZ3Jlc3NfMSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzc1N1YnNjcmliZXIgPSB4aHJQcm9ncmVzc18xLnByb2dyZXNzU3Vic2NyaWJlcjtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NTdWJzY3JpYmVyLm5leHQoZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAocm9vdF8xLnJvb3QuWERvbWFpblJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSB4aHJQcm9ncmVzc18xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeGhyLnVwbG9hZC5vbnByb2dyZXNzID0geGhyUHJvZ3Jlc3NfMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeGhyUHJvZ3Jlc3NfMS5wcm9ncmVzc1N1YnNjcmliZXIgPSBwcm9ncmVzc1N1YnNjcmliZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgeGhyRXJyb3JfMTtcbiAgICAgICAgICAgIHhockVycm9yXzEgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IHhockVycm9yXzEsIHByb2dyZXNzU3Vic2NyaWJlciA9IF9hLnByb2dyZXNzU3Vic2NyaWJlciwgc3Vic2NyaWJlciA9IF9hLnN1YnNjcmliZXIsIHJlcXVlc3QgPSBfYS5yZXF1ZXN0O1xuICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzc1N1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NTdWJzY3JpYmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKG5ldyBBamF4RXJyb3IoJ2FqYXggZXJyb3InLCB0aGlzLCByZXF1ZXN0KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgeGhyLm9uZXJyb3IgPSB4aHJFcnJvcl8xO1xuICAgICAgICAgICAgeGhyRXJyb3JfMS5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgICAgIHhockVycm9yXzEuc3Vic2NyaWJlciA9IHRoaXM7XG4gICAgICAgICAgICB4aHJFcnJvcl8xLnByb2dyZXNzU3Vic2NyaWJlciA9IHByb2dyZXNzU3Vic2NyaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB4aHJSZWFkeVN0YXRlQ2hhbmdlKGUpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHhoclJlYWR5U3RhdGVDaGFuZ2UsIHN1YnNjcmliZXIgPSBfYS5zdWJzY3JpYmVyLCBwcm9ncmVzc1N1YnNjcmliZXIgPSBfYS5wcm9ncmVzc1N1YnNjcmliZXIsIHJlcXVlc3QgPSBfYS5yZXF1ZXN0O1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBJRTkgYnVnIChodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwKVxuICAgICAgICAgICAgICAgIHZhciBzdGF0dXNfMSA9IHRoaXMuc3RhdHVzID09PSAxMjIzID8gMjA0IDogdGhpcy5zdGF0dXM7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gKHRoaXMucmVzcG9uc2VUeXBlID09PSAndGV4dCcgPyAodGhpcy5yZXNwb25zZSB8fCB0aGlzLnJlc3BvbnNlVGV4dCkgOiB0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAvLyBmaXggc3RhdHVzIGNvZGUgd2hlbiBpdCBpcyAwICgwIHN0YXR1cyBpcyB1bmRvY3VtZW50ZWQpLlxuICAgICAgICAgICAgICAgIC8vIE9jY3VycyB3aGVuIGFjY2Vzc2luZyBmaWxlIHJlc291cmNlcyBvciBvbiBBbmRyb2lkIDQuMSBzdG9jayBicm93c2VyXG4gICAgICAgICAgICAgICAgLy8gd2hpbGUgcmV0cmlldmluZyBmaWxlcyBmcm9tIGFwcGxpY2F0aW9uIGNhY2hlLlxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXNfMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNfMSA9IHJlc3BvbnNlID8gMjAwIDogMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKDIwMCA8PSBzdGF0dXNfMSAmJiBzdGF0dXNfMSA8IDMwMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3NTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc1N1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoZSk7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzc1N1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzU3Vic2NyaWJlci5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKG5ldyBBamF4RXJyb3IoJ2FqYXggZXJyb3IgJyArIHN0YXR1c18xLCB0aGlzLCByZXF1ZXN0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHhoclJlYWR5U3RhdGVDaGFuZ2U7XG4gICAgICAgIHhoclJlYWR5U3RhdGVDaGFuZ2Uuc3Vic2NyaWJlciA9IHRoaXM7XG4gICAgICAgIHhoclJlYWR5U3RhdGVDaGFuZ2UucHJvZ3Jlc3NTdWJzY3JpYmVyID0gcHJvZ3Jlc3NTdWJzY3JpYmVyO1xuICAgICAgICB4aHJSZWFkeVN0YXRlQ2hhbmdlLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgIH07XG4gICAgQWpheFN1YnNjcmliZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBkb25lID0gX2EuZG9uZSwgeGhyID0gX2EueGhyO1xuICAgICAgICBpZiAoIWRvbmUgJiYgeGhyICYmIHhoci5yZWFkeVN0YXRlICE9PSA0ICYmIHR5cGVvZiB4aHIuYWJvcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudW5zdWJzY3JpYmUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBBamF4U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuQWpheFN1YnNjcmliZXIgPSBBamF4U3Vic2NyaWJlcjtcbi8qKlxuICogQSBub3JtYWxpemVkIEFKQVggcmVzcG9uc2UuXG4gKlxuICogQHNlZSB7QGxpbmsgYWpheH1cbiAqXG4gKiBAY2xhc3MgQWpheFJlc3BvbnNlXG4gKi9cbnZhciBBamF4UmVzcG9uc2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFqYXhSZXNwb25zZShvcmlnaW5hbEV2ZW50LCB4aHIsIHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdmVudDtcbiAgICAgICAgdGhpcy54aHIgPSB4aHI7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIHRoaXMuc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICAgICAgdGhpcy5yZXNwb25zZVR5cGUgPSB4aHIucmVzcG9uc2VUeXBlIHx8IHJlcXVlc3QucmVzcG9uc2VUeXBlO1xuICAgICAgICBzd2l0Y2ggKHRoaXMucmVzcG9uc2VUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICAgICAgICBpZiAoJ3Jlc3BvbnNlJyBpbiB4aHIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9JRSBkb2VzIG5vdCBzdXBwb3J0IGpzb24gYXMgcmVzcG9uc2VUeXBlLCBwYXJzZSBpdCBpbnRlcm5hbGx5XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSB4aHIucmVzcG9uc2VUeXBlID8geGhyLnJlc3BvbnNlIDogSlNPTi5wYXJzZSh4aHIucmVzcG9uc2UgfHwgeGhyLnJlc3BvbnNlVGV4dCB8fCAnbnVsbCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCB8fCAnbnVsbCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3htbCc6XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IHhoci5yZXNwb25zZVhNTDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gKCdyZXNwb25zZScgaW4geGhyKSA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFqYXhSZXNwb25zZTtcbn0oKSk7XG5leHBvcnRzLkFqYXhSZXNwb25zZSA9IEFqYXhSZXNwb25zZTtcbi8qKlxuICogQSBub3JtYWxpemVkIEFKQVggZXJyb3IuXG4gKlxuICogQHNlZSB7QGxpbmsgYWpheH1cbiAqXG4gKiBAY2xhc3MgQWpheEVycm9yXG4gKi9cbnZhciBBamF4RXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBamF4RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWpheEVycm9yKG1lc3NhZ2UsIHhociwgcmVxdWVzdCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy54aHIgPSB4aHI7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIHRoaXMuc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICB9XG4gICAgcmV0dXJuIEFqYXhFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuQWpheEVycm9yID0gQWpheEVycm9yO1xuLyoqXG4gKiBAc2VlIHtAbGluayBhamF4fVxuICpcbiAqIEBjbGFzcyBBamF4VGltZW91dEVycm9yXG4gKi9cbnZhciBBamF4VGltZW91dEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWpheFRpbWVvdXRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBamF4VGltZW91dEVycm9yKHhociwgcmVxdWVzdCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCAnYWpheCB0aW1lb3V0JywgeGhyLCByZXF1ZXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIEFqYXhUaW1lb3V0RXJyb3I7XG59KEFqYXhFcnJvcikpO1xuZXhwb3J0cy5BamF4VGltZW91dEVycm9yID0gQWpheFRpbWVvdXRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFqYXhPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIEFqYXhPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0FqYXhPYnNlcnZhYmxlJyk7XG5leHBvcnRzLmFqYXggPSBBamF4T2JzZXJ2YWJsZV8xLkFqYXhPYnNlcnZhYmxlLmNyZWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFqYXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRnJvbU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vRnJvbU9ic2VydmFibGUnKTtcbmV4cG9ydHMuZnJvbSA9IEZyb21PYnNlcnZhYmxlXzEuRnJvbU9ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJvbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBtZXJnZV8xID0gcmVxdWlyZSgnLi4vb3BlcmF0b3IvbWVyZ2UnKTtcbmV4cG9ydHMubWVyZ2UgPSBtZXJnZV8xLm1lcmdlU3RhdGljO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQXJyYXlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0FycmF5T2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5vZiA9IEFycmF5T2JzZXJ2YWJsZV8xLkFycmF5T2JzZXJ2YWJsZS5vZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9mLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIEVycm9yT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9FcnJvck9ic2VydmFibGUnKTtcbmV4cG9ydHMuX3Rocm93ID0gRXJyb3JPYnNlcnZhYmxlXzEuRXJyb3JPYnNlcnZhYmxlLmNyZWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRocm93LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBDYXRjaGVzIGVycm9ycyBvbiB0aGUgb2JzZXJ2YWJsZSB0byBiZSBoYW5kbGVkIGJ5IHJldHVybmluZyBhIG5ldyBvYnNlcnZhYmxlIG9yIHRocm93aW5nIGFuIGVycm9yLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY2F0Y2gucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q29udGludWVzIHdpdGggYSBkaWZmZXJlbnQgT2JzZXJ2YWJsZSB3aGVuIHRoZXJlJ3MgYW4gZXJyb3I8L2NhcHRpb24+XG4gKlxuICogT2JzZXJ2YWJsZS5vZigxLCAyLCAzLCA0LCA1KVxuICogICAubWFwKG4gPT4ge1xuICogXHQgICBpZiAobiA9PSA0KSB7XG4gKiBcdCAgICAgdGhyb3cgJ2ZvdXIhJztcbiAqICAgICB9XG4gKlx0ICAgcmV0dXJuIG47XG4gKiAgIH0pXG4gKiAgIC5jYXRjaChlcnIgPT4gT2JzZXJ2YWJsZS5vZignSScsICdJSScsICdJSUknLCAnSVYnLCAnVicpKVxuICogICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICogICAvLyAxLCAyLCAzLCBJLCBJSSwgSUlJLCBJViwgVlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlJldHJpZXMgdGhlIGNhdWdodCBzb3VyY2UgT2JzZXJ2YWJsZSBhZ2FpbiBpbiBjYXNlIG9mIGVycm9yLCBzaW1pbGFyIHRvIHJldHJ5KCkgb3BlcmF0b3I8L2NhcHRpb24+XG4gKlxuICogT2JzZXJ2YWJsZS5vZigxLCAyLCAzLCA0LCA1KVxuICogICAubWFwKG4gPT4ge1xuICogXHQgICBpZiAobiA9PT0gNCkge1xuICogXHQgICAgIHRocm93ICdmb3VyISc7XG4gKiAgICAgfVxuICogXHQgICByZXR1cm4gbjtcbiAqICAgfSlcbiAqICAgLmNhdGNoKChlcnIsIGNhdWdodCkgPT4gY2F1Z2h0KVxuICogICAudGFrZSgzMClcbiAqICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqICAgLy8gMSwgMiwgMywgMSwgMiwgMywgLi4uXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+VGhyb3dzIGEgbmV3IGVycm9yIHdoZW4gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRocm93cyBhbiBlcnJvcjwvY2FwdGlvbj5cbiAqXG4gKiBPYnNlcnZhYmxlLm9mKDEsIDIsIDMsIDQsIDUpXG4gKiAgIC5tYXAobiA9PiB7XG4gKiAgICAgaWYgKG4gPT0gNCkge1xuICogICAgICAgdGhyb3cgJ2ZvdXIhJztcbiAqICAgICB9XG4gKiAgICAgcmV0dXJuIG47XG4gKiAgIH0pXG4gKiAgIC5jYXRjaChlcnIgPT4ge1xuICogICAgIHRocm93ICdlcnJvciBpbiBzb3VyY2UuIERldGFpbHM6ICcgKyBlcnI7XG4gKiAgIH0pXG4gKiAgIC5zdWJzY3JpYmUoXG4gKiAgICAgeCA9PiBjb25zb2xlLmxvZyh4KSxcbiAqICAgICBlcnIgPT4gY29uc29sZS5sb2coZXJyKVxuICogICApO1xuICogICAvLyAxLCAyLCAzLCBlcnJvciBpbiBzb3VyY2UuIERldGFpbHM6IGZvdXIhXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc2VsZWN0b3IgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGFzIGFyZ3VtZW50cyBgZXJyYCwgd2hpY2ggaXMgdGhlIGVycm9yLCBhbmQgYGNhdWdodGAsIHdoaWNoXG4gKiAgaXMgdGhlIHNvdXJjZSBvYnNlcnZhYmxlLCBpbiBjYXNlIHlvdSdkIGxpa2UgdG8gXCJyZXRyeVwiIHRoYXQgb2JzZXJ2YWJsZSBieSByZXR1cm5pbmcgaXQgYWdhaW4uIFdoYXRldmVyIG9ic2VydmFibGVcbiAqICBpcyByZXR1cm5lZCBieSB0aGUgYHNlbGVjdG9yYCB3aWxsIGJlIHVzZWQgdG8gY29udGludWUgdGhlIG9ic2VydmFibGUgY2hhaW4uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHRoYXQgb3JpZ2luYXRlcyBmcm9tIGVpdGhlciB0aGUgc291cmNlIG9yIHRoZSBvYnNlcnZhYmxlIHJldHVybmVkIGJ5IHRoZVxuICogIGNhdGNoIGBzZWxlY3RvcmAgZnVuY3Rpb24uXG4gKiBAbWV0aG9kIGNhdGNoXG4gKiBAbmFtZSBjYXRjaFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gX2NhdGNoKHNlbGVjdG9yKSB7XG4gICAgdmFyIG9wZXJhdG9yID0gbmV3IENhdGNoT3BlcmF0b3Ioc2VsZWN0b3IpO1xuICAgIHZhciBjYXVnaHQgPSB0aGlzLmxpZnQob3BlcmF0b3IpO1xuICAgIHJldHVybiAob3BlcmF0b3IuY2F1Z2h0ID0gY2F1Z2h0KTtcbn1cbmV4cG9ydHMuX2NhdGNoID0gX2NhdGNoO1xudmFyIENhdGNoT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhdGNoT3BlcmF0b3Ioc2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgIH1cbiAgICBDYXRjaE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgQ2F0Y2hTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuc2VsZWN0b3IsIHRoaXMuY2F1Z2h0KSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2F0Y2hPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIENhdGNoU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENhdGNoU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYXRjaFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHNlbGVjdG9yLCBjYXVnaHQpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMuY2F1Z2h0ID0gY2F1Z2h0O1xuICAgIH1cbiAgICAvLyBOT1RFOiBvdmVycmlkaW5nIGBlcnJvcmAgaW5zdGVhZCBvZiBgX2Vycm9yYCBiZWNhdXNlIHdlIGRvbid0IHdhbnRcbiAgICAvLyB0byBoYXZlIHRoaXMgZmxhZyB0aGlzIHN1YnNjcmliZXIgYXMgYGlzU3RvcHBlZGAuIFdlIGNhbiBtaW1pYyB0aGVcbiAgICAvLyBiZWhhdmlvciBvZiB0aGUgUmV0cnlTdWJzY3JpYmVyIChmcm9tIHRoZSBgcmV0cnlgIG9wZXJhdG9yKSwgd2hlcmVcbiAgICAvLyB3ZSB1bnN1YnNjcmliZSBmcm9tIG91ciBzb3VyY2UgY2hhaW4sIHJlc2V0IG91ciBTdWJzY3JpYmVyIGZsYWdzLFxuICAgIC8vIHRoZW4gc3Vic2NyaWJlIHRvIHRoZSBzZWxlY3RvciByZXN1bHQuXG4gICAgQ2F0Y2hTdWJzY3JpYmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5zZWxlY3RvcihlcnIsIHRoaXMuY2F1Z2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIyKSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5lcnJvci5jYWxsKHRoaXMsIGVycjIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlQW5kUmVjeWNsZSgpO1xuICAgICAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCByZXN1bHQpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENhdGNoU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYXRjaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBtZXJnZU1hcF8xID0gcmVxdWlyZSgnLi9tZXJnZU1hcCcpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUHJvamVjdHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSB3aGljaCBpcyBtZXJnZWQgaW4gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZSwgaW4gYSBzZXJpYWxpemVkIGZhc2hpb24gd2FpdGluZyBmb3IgZWFjaCBvbmUgdG8gY29tcGxldGUgYmVmb3JlXG4gKiBtZXJnaW5nIHRoZSBuZXh0LlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5NYXBzIGVhY2ggdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSwgdGhlbiBmbGF0dGVucyBhbGwgb2ZcbiAqIHRoZXNlIGlubmVyIE9ic2VydmFibGVzIHVzaW5nIHtAbGluayBjb25jYXRBbGx9Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2NvbmNhdE1hcC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBiYXNlZCBvbiBhcHBseWluZyBhIGZ1bmN0aW9uIHRoYXQgeW91XG4gKiBzdXBwbHkgdG8gZWFjaCBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB3aGVyZSB0aGF0IGZ1bmN0aW9uXG4gKiByZXR1cm5zIGFuIChzby1jYWxsZWQgXCJpbm5lclwiKSBPYnNlcnZhYmxlLiBFYWNoIG5ldyBpbm5lciBPYnNlcnZhYmxlIGlzXG4gKiBjb25jYXRlbmF0ZWQgd2l0aCB0aGUgcHJldmlvdXMgaW5uZXIgT2JzZXJ2YWJsZS5cbiAqXG4gKiBfX1dhcm5pbmc6X18gaWYgc291cmNlIHZhbHVlcyBhcnJpdmUgZW5kbGVzc2x5IGFuZCBmYXN0ZXIgdGhhbiB0aGVpclxuICogY29ycmVzcG9uZGluZyBpbm5lciBPYnNlcnZhYmxlcyBjYW4gY29tcGxldGUsIGl0IHdpbGwgcmVzdWx0IGluIG1lbW9yeSBpc3N1ZXNcbiAqIGFzIGlubmVyIE9ic2VydmFibGVzIGFtYXNzIGluIGFuIHVuYm91bmRlZCBidWZmZXIgd2FpdGluZyBmb3IgdGhlaXIgdHVybiB0b1xuICogYmUgc3Vic2NyaWJlZCB0by5cbiAqXG4gKiBOb3RlOiBgY29uY2F0TWFwYCBpcyBlcXVpdmFsZW50IHRvIGBtZXJnZU1hcGAgd2l0aCBjb25jdXJyZW5jeSBwYXJhbWV0ZXIgc2V0XG4gKiB0byBgMWAuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Rm9yIGVhY2ggY2xpY2sgZXZlbnQsIHRpY2sgZXZlcnkgc2Vjb25kIGZyb20gMCB0byAzLCB3aXRoIG5vIGNvbmN1cnJlbmN5PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MuY29uY2F0TWFwKGV2ID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSg0KSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIFJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZzpcbiAqIC8vIChyZXN1bHRzIGFyZSBub3QgY29uY3VycmVudClcbiAqIC8vIEZvciBldmVyeSBjbGljayBvbiB0aGUgXCJkb2N1bWVudFwiIGl0IHdpbGwgZW1pdCB2YWx1ZXMgMCB0byAzIHNwYWNlZFxuICogLy8gb24gYSAxMDAwbXMgaW50ZXJ2YWxcbiAqIC8vIG9uZSBjbGljayA9IDEwMDBtcy0+IDAgLTEwMDBtcy0+IDEgLTEwMDBtcy0+IDIgLTEwMDBtcy0+IDNcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXR9XG4gKiBAc2VlIHtAbGluayBjb25jYXRBbGx9XG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXBUb31cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3RNYXB9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcH1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCA/aW5kZXg6IG51bWJlcik6IE9ic2VydmFibGVJbnB1dH0gcHJvamVjdCBBIGZ1bmN0aW9uXG4gKiB0aGF0LCB3aGVuIGFwcGxpZWQgdG8gYW4gaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgcmV0dXJucyBhblxuICogT2JzZXJ2YWJsZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSwgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpOiBhbnl9IFtyZXN1bHRTZWxlY3Rvcl1cbiAqIEEgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJhc2VkIG9uIHRoZSB2YWx1ZXNcbiAqIGFuZCB0aGUgaW5kaWNlcyBvZiB0aGUgc291cmNlIChvdXRlcikgZW1pc3Npb24gYW5kIHRoZSBpbm5lciBPYnNlcnZhYmxlXG4gKiBlbWlzc2lvbi4gVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmU6XG4gKiAtIGBvdXRlclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiAtIGBvdXRlckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIG9mIHZhbHVlcyBtZXJnZWQgZnJvbSB0aGUgcHJvamVjdGVkXG4gKiBPYnNlcnZhYmxlcyBhcyB0aGV5IHdlcmUgc3Vic2NyaWJlZCB0bywgb25lIGF0IGEgdGltZS4gT3B0aW9uYWxseSwgdGhlc2VcbiAqIHZhbHVlcyBtYXkgaGF2ZSBiZWVuIHByb2plY3RlZCBmcm9tIGEgcGFzc2VkIGBwcm9qZWN0UmVzdWx0YCBhcmd1bWVudC5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZVxuICogcHJvamVjdGlvbiBmdW5jdGlvbiAoYW5kIHRoZSBvcHRpb25hbCBgcmVzdWx0U2VsZWN0b3JgKSB0byBlYWNoIGl0ZW0gZW1pdHRlZFxuICogYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGFuZCB0YWtpbmcgdmFsdWVzIGZyb20gZWFjaCBwcm9qZWN0ZWQgaW5uZXJcbiAqIE9ic2VydmFibGUgc2VxdWVudGlhbGx5LlxuICogQG1ldGhvZCBjb25jYXRNYXBcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdE1hcChwcm9qZWN0LCByZXN1bHRTZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IG1lcmdlTWFwXzEuTWVyZ2VNYXBPcGVyYXRvcihwcm9qZWN0LCByZXN1bHRTZWxlY3RvciwgMSkpO1xufVxuZXhwb3J0cy5jb25jYXRNYXAgPSBjb25jYXRNYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25jYXRNYXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xuLyoqXG4gKiBFbWl0cyBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIG9ubHkgYWZ0ZXIgYSBwYXJ0aWN1bGFyIHRpbWUgc3BhblxuICogaGFzIHBhc3NlZCB3aXRob3V0IGFub3RoZXIgc291cmNlIGVtaXNzaW9uLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIGRlbGF5fSwgYnV0IHBhc3NlcyBvbmx5IHRoZSBtb3N0XG4gKiByZWNlbnQgdmFsdWUgZnJvbSBlYWNoIGJ1cnN0IG9mIGVtaXNzaW9ucy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9kZWJvdW5jZVRpbWUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGRlYm91bmNlVGltZWAgZGVsYXlzIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYnV0IGRyb3BzXG4gKiBwcmV2aW91cyBwZW5kaW5nIGRlbGF5ZWQgZW1pc3Npb25zIGlmIGEgbmV3IHZhbHVlIGFycml2ZXMgb24gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZS4gVGhpcyBvcGVyYXRvciBrZWVwcyB0cmFjayBvZiB0aGUgbW9zdCByZWNlbnQgdmFsdWUgZnJvbSB0aGVcbiAqIHNvdXJjZSBPYnNlcnZhYmxlLCBhbmQgZW1pdHMgdGhhdCBvbmx5IHdoZW4gYGR1ZVRpbWVgIGVub3VnaCB0aW1lIGhhcyBwYXNzZWRcbiAqIHdpdGhvdXQgYW55IG90aGVyIHZhbHVlIGFwcGVhcmluZyBvbiB0aGUgc291cmNlIE9ic2VydmFibGUuIElmIGEgbmV3IHZhbHVlXG4gKiBhcHBlYXJzIGJlZm9yZSBgZHVlVGltZWAgc2lsZW5jZSBvY2N1cnMsIHRoZSBwcmV2aW91cyB2YWx1ZSB3aWxsIGJlIGRyb3BwZWRcbiAqIGFuZCB3aWxsIG5vdCBiZSBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiBUaGlzIGlzIGEgcmF0ZS1saW1pdGluZyBvcGVyYXRvciwgYmVjYXVzZSBpdCBpcyBpbXBvc3NpYmxlIGZvciBtb3JlIHRoYW4gb25lXG4gKiB2YWx1ZSB0byBiZSBlbWl0dGVkIGluIGFueSB0aW1lIHdpbmRvdyBvZiBkdXJhdGlvbiBgZHVlVGltZWAsIGJ1dCBpdCBpcyBhbHNvXG4gKiBhIGRlbGF5LWxpa2Ugb3BlcmF0b3Igc2luY2Ugb3V0cHV0IGVtaXNzaW9ucyBkbyBub3Qgb2NjdXIgYXQgdGhlIHNhbWUgdGltZSBhc1xuICogdGhleSBkaWQgb24gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBPcHRpb25hbGx5IHRha2VzIGEge0BsaW5rIElTY2hlZHVsZXJ9IGZvclxuICogbWFuYWdpbmcgdGltZXJzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgdGhlIG1vc3QgcmVjZW50IGNsaWNrIGFmdGVyIGEgYnVyc3Qgb2YgY2xpY2tzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MuZGVib3VuY2VUaW1lKDEwMDApO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBhdWRpdFRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZX1cbiAqIEBzZWUge0BsaW5rIGRlbGF5fVxuICogQHNlZSB7QGxpbmsgc2FtcGxlVGltZX1cbiAqIEBzZWUge0BsaW5rIHRocm90dGxlVGltZX1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZHVlVGltZSBUaGUgdGltZW91dCBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgKG9yIHRoZSB0aW1lXG4gKiB1bml0IGRldGVybWluZWQgaW50ZXJuYWxseSBieSB0aGUgb3B0aW9uYWwgYHNjaGVkdWxlcmApIGZvciB0aGUgd2luZG93IG9mXG4gKiB0aW1lIHJlcXVpcmVkIHRvIHdhaXQgZm9yIGVtaXNzaW9uIHNpbGVuY2UgYmVmb3JlIGVtaXR0aW5nIHRoZSBtb3N0IHJlY2VudFxuICogc291cmNlIHZhbHVlLlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSB7QGxpbmsgSVNjaGVkdWxlcn0gdG8gdXNlIGZvclxuICogbWFuYWdpbmcgdGhlIHRpbWVycyB0aGF0IGhhbmRsZSB0aGUgdGltZW91dCBmb3IgZWFjaCB2YWx1ZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBkZWxheXMgdGhlIGVtaXNzaW9ucyBvZiB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIGJ5IHRoZSBzcGVjaWZpZWQgYGR1ZVRpbWVgLCBhbmQgbWF5IGRyb3Agc29tZSB2YWx1ZXMgaWYgdGhleSBvY2N1clxuICogdG9vIGZyZXF1ZW50bHkuXG4gKiBAbWV0aG9kIGRlYm91bmNlVGltZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2VUaW1lKGR1ZVRpbWUsIHNjaGVkdWxlcikge1xuICAgIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkgeyBzY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jOyB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgRGVib3VuY2VUaW1lT3BlcmF0b3IoZHVlVGltZSwgc2NoZWR1bGVyKSk7XG59XG5leHBvcnRzLmRlYm91bmNlVGltZSA9IGRlYm91bmNlVGltZTtcbnZhciBEZWJvdW5jZVRpbWVPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVib3VuY2VUaW1lT3BlcmF0b3IoZHVlVGltZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHRoaXMuZHVlVGltZSA9IGR1ZVRpbWU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICBEZWJvdW5jZVRpbWVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IERlYm91bmNlVGltZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5kdWVUaW1lLCB0aGlzLnNjaGVkdWxlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIERlYm91bmNlVGltZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRGVib3VuY2VUaW1lU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlYm91bmNlVGltZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVib3VuY2VUaW1lU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgZHVlVGltZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kdWVUaW1lID0gZHVlVGltZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuZGVib3VuY2VkU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0VmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIERlYm91bmNlVGltZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2xlYXJEZWJvdW5jZSgpO1xuICAgICAgICB0aGlzLmxhc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hZGQodGhpcy5kZWJvdW5jZWRTdWJzY3JpcHRpb24gPSB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaE5leHQsIHRoaXMuZHVlVGltZSwgdGhpcykpO1xuICAgIH07XG4gICAgRGVib3VuY2VUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlYm91bmNlZE5leHQoKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgRGVib3VuY2VUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuZGVib3VuY2VkTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jbGVhckRlYm91bmNlKCk7XG4gICAgICAgIGlmICh0aGlzLmhhc1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodGhpcy5sYXN0VmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5sYXN0VmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5jbGVhckRlYm91bmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVib3VuY2VkU3Vic2NyaXB0aW9uID0gdGhpcy5kZWJvdW5jZWRTdWJzY3JpcHRpb247XG4gICAgICAgIGlmIChkZWJvdW5jZWRTdWJzY3JpcHRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGRlYm91bmNlZFN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICBkZWJvdW5jZWRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuZGVib3VuY2VkU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERlYm91bmNlVGltZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5mdW5jdGlvbiBkaXNwYXRjaE5leHQoc3Vic2NyaWJlcikge1xuICAgIHN1YnNjcmliZXIuZGVib3VuY2VkTmV4dCgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVib3VuY2VUaW1lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xudmFyIGlzRGF0ZV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0RhdGUnKTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgTm90aWZpY2F0aW9uXzEgPSByZXF1aXJlKCcuLi9Ob3RpZmljYXRpb24nKTtcbi8qKlxuICogRGVsYXlzIHRoZSBlbWlzc2lvbiBvZiBpdGVtcyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBieSBhIGdpdmVuIHRpbWVvdXQgb3JcbiAqIHVudGlsIGEgZ2l2ZW4gRGF0ZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+VGltZSBzaGlmdHMgZWFjaCBpdGVtIGJ5IHNvbWUgc3BlY2lmaWVkIGFtb3VudCBvZlxuICogbWlsbGlzZWNvbmRzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2RlbGF5LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIElmIHRoZSBkZWxheSBhcmd1bWVudCBpcyBhIE51bWJlciwgdGhpcyBvcGVyYXRvciB0aW1lIHNoaWZ0cyB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIGJ5IHRoYXQgYW1vdW50IG9mIHRpbWUgZXhwcmVzc2VkIGluIG1pbGxpc2Vjb25kcy4gVGhlIHJlbGF0aXZlXG4gKiB0aW1lIGludGVydmFscyBiZXR3ZWVuIHRoZSB2YWx1ZXMgYXJlIHByZXNlcnZlZC5cbiAqXG4gKiBJZiB0aGUgZGVsYXkgYXJndW1lbnQgaXMgYSBEYXRlLCB0aGlzIG9wZXJhdG9yIHRpbWUgc2hpZnRzIHRoZSBzdGFydCBvZiB0aGVcbiAqIE9ic2VydmFibGUgZXhlY3V0aW9uIHVudGlsIHRoZSBnaXZlbiBkYXRlIG9jY3Vycy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5EZWxheSBlYWNoIGNsaWNrIGJ5IG9uZSBzZWNvbmQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGRlbGF5ZWRDbGlja3MgPSBjbGlja3MuZGVsYXkoMTAwMCk7IC8vIGVhY2ggY2xpY2sgZW1pdHRlZCBhZnRlciAxIHNlY29uZFxuICogZGVsYXllZENsaWNrcy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RGVsYXkgYWxsIGNsaWNrcyB1bnRpbCBhIGZ1dHVyZSBkYXRlIGhhcHBlbnM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGRhdGUgPSBuZXcgRGF0ZSgnTWFyY2ggMTUsIDIwNTAgMTI6MDA6MDAnKTsgLy8gaW4gdGhlIGZ1dHVyZVxuICogdmFyIGRlbGF5ZWRDbGlja3MgPSBjbGlja3MuZGVsYXkoZGF0ZSk7IC8vIGNsaWNrIGVtaXR0ZWQgb25seSBhZnRlciB0aGF0IGRhdGVcbiAqIGRlbGF5ZWRDbGlja3Muc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGRlYm91bmNlVGltZX1cbiAqIEBzZWUge0BsaW5rIGRlbGF5V2hlbn1cbiAqXG4gKiBAcGFyYW0ge251bWJlcnxEYXRlfSBkZWxheSBUaGUgZGVsYXkgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIChhIGBudW1iZXJgKSBvclxuICogYSBgRGF0ZWAgdW50aWwgd2hpY2ggdGhlIGVtaXNzaW9uIG9mIHRoZSBzb3VyY2UgaXRlbXMgaXMgZGVsYXllZC5cbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyPWFzeW5jXSBUaGUgSVNjaGVkdWxlciB0byB1c2UgZm9yXG4gKiBtYW5hZ2luZyB0aGUgdGltZXJzIHRoYXQgaGFuZGxlIHRoZSB0aW1lLXNoaWZ0IGZvciBlYWNoIGl0ZW0uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZGVsYXlzIHRoZSBlbWlzc2lvbnMgb2YgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBieSB0aGUgc3BlY2lmaWVkIHRpbWVvdXQgb3IgRGF0ZS5cbiAqIEBtZXRob2QgZGVsYXlcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGRlbGF5KGRlbGF5LCBzY2hlZHVsZXIpIHtcbiAgICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHsgc2NoZWR1bGVyID0gYXN5bmNfMS5hc3luYzsgfVxuICAgIHZhciBhYnNvbHV0ZURlbGF5ID0gaXNEYXRlXzEuaXNEYXRlKGRlbGF5KTtcbiAgICB2YXIgZGVsYXlGb3IgPSBhYnNvbHV0ZURlbGF5ID8gKCtkZWxheSAtIHNjaGVkdWxlci5ub3coKSkgOiBNYXRoLmFicyhkZWxheSk7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgRGVsYXlPcGVyYXRvcihkZWxheUZvciwgc2NoZWR1bGVyKSk7XG59XG5leHBvcnRzLmRlbGF5ID0gZGVsYXk7XG52YXIgRGVsYXlPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVsYXlPcGVyYXRvcihkZWxheSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIERlbGF5T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBEZWxheVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5kZWxheSwgdGhpcy5zY2hlZHVsZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWxheU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRGVsYXlTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVsYXlTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlbGF5U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgZGVsYXksIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lcnJvcmVkID0gZmFsc2U7XG4gICAgfVxuICAgIERlbGF5U3Vic2NyaWJlci5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgc291cmNlID0gc3RhdGUuc291cmNlO1xuICAgICAgICB2YXIgcXVldWUgPSBzb3VyY2UucXVldWU7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSBzdGF0ZS5zY2hlZHVsZXI7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHN0YXRlLmRlc3RpbmF0aW9uO1xuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCAmJiAocXVldWVbMF0udGltZSAtIHNjaGVkdWxlci5ub3coKSkgPD0gMCkge1xuICAgICAgICAgICAgcXVldWUuc2hpZnQoKS5ub3RpZmljYXRpb24ub2JzZXJ2ZShkZXN0aW5hdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBkZWxheV8xID0gTWF0aC5tYXgoMCwgcXVldWVbMF0udGltZSAtIHNjaGVkdWxlci5ub3coKSk7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlKHN0YXRlLCBkZWxheV8xKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVsYXlTdWJzY3JpYmVyLnByb3RvdHlwZS5fc2NoZWR1bGUgPSBmdW5jdGlvbiAoc2NoZWR1bGVyKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKERlbGF5U3Vic2NyaWJlci5kaXNwYXRjaCwgdGhpcy5kZWxheSwge1xuICAgICAgICAgICAgc291cmNlOiB0aGlzLCBkZXN0aW5hdGlvbjogdGhpcy5kZXN0aW5hdGlvbiwgc2NoZWR1bGVyOiBzY2hlZHVsZXJcbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgRGVsYXlTdWJzY3JpYmVyLnByb3RvdHlwZS5zY2hlZHVsZU5vdGlmaWNhdGlvbiA9IGZ1bmN0aW9uIChub3RpZmljYXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3JlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgRGVsYXlNZXNzYWdlKHNjaGVkdWxlci5ub3coKSArIHRoaXMuZGVsYXksIG5vdGlmaWNhdGlvbik7XG4gICAgICAgIHRoaXMucXVldWUucHVzaChtZXNzYWdlKTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGUoc2NoZWR1bGVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVsYXlTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlTm90aWZpY2F0aW9uKE5vdGlmaWNhdGlvbl8xLk5vdGlmaWNhdGlvbi5jcmVhdGVOZXh0KHZhbHVlKSk7XG4gICAgfTtcbiAgICBEZWxheVN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5lcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgfTtcbiAgICBEZWxheVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZU5vdGlmaWNhdGlvbihOb3RpZmljYXRpb25fMS5Ob3RpZmljYXRpb24uY3JlYXRlQ29tcGxldGUoKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVsYXlTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xudmFyIERlbGF5TWVzc2FnZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVsYXlNZXNzYWdlKHRpbWUsIG5vdGlmaWNhdGlvbikge1xuICAgICAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbiA9IG5vdGlmaWNhdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIERlbGF5TWVzc2FnZTtcbn0oKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWxheS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciB0cnlDYXRjaF8xID0gcmVxdWlyZSgnLi4vdXRpbC90cnlDYXRjaCcpO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuLi91dGlsL2Vycm9yT2JqZWN0Jyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhbGwgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgdGhhdCBhcmUgZGlzdGluY3QgYnkgY29tcGFyaXNvbiBmcm9tIHRoZSBwcmV2aW91cyBpdGVtLlxuICpcbiAqIElmIGEgY29tcGFyYXRvciBmdW5jdGlvbiBpcyBwcm92aWRlZCwgdGhlbiBpdCB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBpdGVtIHRvIHRlc3QgZm9yIHdoZXRoZXIgb3Igbm90IHRoYXQgdmFsdWUgc2hvdWxkIGJlIGVtaXR0ZWQuXG4gKlxuICogSWYgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIGlzIG5vdCBwcm92aWRlZCwgYW4gZXF1YWxpdHkgY2hlY2sgaXMgdXNlZCBieSBkZWZhdWx0LlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkEgc2ltcGxlIGV4YW1wbGUgd2l0aCBudW1iZXJzPC9jYXB0aW9uPlxuICogT2JzZXJ2YWJsZS5vZigxLCAxLCAyLCAyLCAyLCAxLCAxLCAyLCAzLCAzLCA0KVxuICogICAuZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICogICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpOyAvLyAxLCAyLCAxLCAyLCAzLCA0XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+QW4gZXhhbXBsZSB1c2luZyBhIGNvbXBhcmUgZnVuY3Rpb248L2NhcHRpb24+XG4gKiBpbnRlcmZhY2UgUGVyc29uIHtcbiAqICAgIGFnZTogbnVtYmVyLFxuICogICAgbmFtZTogc3RyaW5nXG4gKiB9XG4gKlxuICogT2JzZXJ2YWJsZS5vZjxQZXJzb24+KFxuICogICAgIHsgYWdlOiA0LCBuYW1lOiAnRm9vJ30sXG4gKiAgICAgeyBhZ2U6IDcsIG5hbWU6ICdCYXInfSxcbiAqICAgICB7IGFnZTogNSwgbmFtZTogJ0Zvbyd9KVxuICogICAgIHsgYWdlOiA2LCBuYW1lOiAnRm9vJ30pXG4gKiAgICAgLmRpc3RpbmN0VW50aWxDaGFuZ2VkKChwOiBQZXJzb24sIHE6IFBlcnNvbikgPT4gcC5uYW1lID09PSBxLm5hbWUpXG4gKiAgICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBkaXNwbGF5czpcbiAqIC8vIHsgYWdlOiA0LCBuYW1lOiAnRm9vJyB9XG4gKiAvLyB7IGFnZTogNywgbmFtZTogJ0JhcicgfVxuICogLy8geyBhZ2U6IDUsIG5hbWU6ICdGb28nIH1cbiAqXG4gKiBAc2VlIHtAbGluayBkaXN0aW5jdH1cbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjb21wYXJlXSBPcHRpb25hbCBjb21wYXJpc29uIGZ1bmN0aW9uIGNhbGxlZCB0byB0ZXN0IGlmIGFuIGl0ZW0gaXMgZGlzdGluY3QgZnJvbSB0aGUgcHJldmlvdXMgaXRlbSBpbiB0aGUgc291cmNlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdpdGggZGlzdGluY3QgdmFsdWVzLlxuICogQG1ldGhvZCBkaXN0aW5jdFVudGlsQ2hhbmdlZFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZGlzdGluY3RVbnRpbENoYW5nZWQoY29tcGFyZSwga2V5U2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBEaXN0aW5jdFVudGlsQ2hhbmdlZE9wZXJhdG9yKGNvbXBhcmUsIGtleVNlbGVjdG9yKSk7XG59XG5leHBvcnRzLmRpc3RpbmN0VW50aWxDaGFuZ2VkID0gZGlzdGluY3RVbnRpbENoYW5nZWQ7XG52YXIgRGlzdGluY3RVbnRpbENoYW5nZWRPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGlzdGluY3RVbnRpbENoYW5nZWRPcGVyYXRvcihjb21wYXJlLCBrZXlTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLmNvbXBhcmUgPSBjb21wYXJlO1xuICAgICAgICB0aGlzLmtleVNlbGVjdG9yID0ga2V5U2VsZWN0b3I7XG4gICAgfVxuICAgIERpc3RpbmN0VW50aWxDaGFuZ2VkT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBEaXN0aW5jdFVudGlsQ2hhbmdlZFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5jb21wYXJlLCB0aGlzLmtleVNlbGVjdG9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGlzdGluY3RVbnRpbENoYW5nZWRPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIERpc3RpbmN0VW50aWxDaGFuZ2VkU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpc3RpbmN0VW50aWxDaGFuZ2VkU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaXN0aW5jdFVudGlsQ2hhbmdlZFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGNvbXBhcmUsIGtleVNlbGVjdG9yKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5rZXlTZWxlY3RvciA9IGtleVNlbGVjdG9yO1xuICAgICAgICB0aGlzLmhhc0tleSA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIGNvbXBhcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcGFyZSA9IGNvbXBhcmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGlzdGluY3RVbnRpbENoYW5nZWRTdWJzY3JpYmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHggPT09IHk7XG4gICAgfTtcbiAgICBEaXN0aW5jdFVudGlsQ2hhbmdlZFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBrZXlTZWxlY3RvciA9IHRoaXMua2V5U2VsZWN0b3I7XG4gICAgICAgIHZhciBrZXkgPSB2YWx1ZTtcbiAgICAgICAgaWYgKGtleVNlbGVjdG9yKSB7XG4gICAgICAgICAgICBrZXkgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHRoaXMua2V5U2VsZWN0b3IpKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuaGFzS2V5KSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHRoaXMuY29tcGFyZSkodGhpcy5rZXksIGtleSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGFzS2V5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQm9vbGVhbihyZXN1bHQpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGlzdGluY3RVbnRpbENoYW5nZWRTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzdGluY3RVbnRpbENoYW5nZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZGlzdGluY3RVbnRpbENoYW5nZWRfMSA9IHJlcXVpcmUoJy4vZGlzdGluY3RVbnRpbENoYW5nZWQnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGFsbCBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aGF0IGFyZSBkaXN0aW5jdCBieSBjb21wYXJpc29uIGZyb20gdGhlIHByZXZpb3VzIGl0ZW0sXG4gKiB1c2luZyBhIHByb3BlcnR5IGFjY2Vzc2VkIGJ5IHVzaW5nIHRoZSBrZXkgcHJvdmlkZWQgdG8gY2hlY2sgaWYgdGhlIHR3byBpdGVtcyBhcmUgZGlzdGluY3QuXG4gKlxuICogSWYgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCB0aGVuIGl0IHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGl0ZW0gdG8gdGVzdCBmb3Igd2hldGhlciBvciBub3QgdGhhdCB2YWx1ZSBzaG91bGQgYmUgZW1pdHRlZC5cbiAqXG4gKiBJZiBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gaXMgbm90IHByb3ZpZGVkLCBhbiBlcXVhbGl0eSBjaGVjayBpcyB1c2VkIGJ5IGRlZmF1bHQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+QW4gZXhhbXBsZSBjb21wYXJpbmcgdGhlIG5hbWUgb2YgcGVyc29uczwvY2FwdGlvbj5cbiAqXG4gKiAgaW50ZXJmYWNlIFBlcnNvbiB7XG4gKiAgICAgYWdlOiBudW1iZXIsXG4gKiAgICAgbmFtZTogc3RyaW5nXG4gKiAgfVxuICpcbiAqIE9ic2VydmFibGUub2Y8UGVyc29uPihcbiAqICAgICB7IGFnZTogNCwgbmFtZTogJ0Zvbyd9LFxuICogICAgIHsgYWdlOiA3LCBuYW1lOiAnQmFyJ30sXG4gKiAgICAgeyBhZ2U6IDUsIG5hbWU6ICdGb28nfSxcbiAqICAgICB7IGFnZTogNiwgbmFtZTogJ0Zvbyd9KVxuICogICAgIC5kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCgnbmFtZScpXG4gKiAgICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBkaXNwbGF5czpcbiAqIC8vIHsgYWdlOiA0LCBuYW1lOiAnRm9vJyB9XG4gKiAvLyB7IGFnZTogNywgbmFtZTogJ0JhcicgfVxuICogLy8geyBhZ2U6IDUsIG5hbWU6ICdGb28nIH1cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5BbiBleGFtcGxlIGNvbXBhcmluZyB0aGUgZmlyc3QgbGV0dGVycyBvZiB0aGUgbmFtZTwvY2FwdGlvbj5cbiAqXG4gKiBpbnRlcmZhY2UgUGVyc29uIHtcbiAqICAgICBhZ2U6IG51bWJlcixcbiAqICAgICBuYW1lOiBzdHJpbmdcbiAqICB9XG4gKlxuICogT2JzZXJ2YWJsZS5vZjxQZXJzb24+KFxuICogICAgIHsgYWdlOiA0LCBuYW1lOiAnRm9vMSd9LFxuICogICAgIHsgYWdlOiA3LCBuYW1lOiAnQmFyJ30sXG4gKiAgICAgeyBhZ2U6IDUsIG5hbWU6ICdGb28yJ30sXG4gKiAgICAgeyBhZ2U6IDYsIG5hbWU6ICdGb28zJ30pXG4gKiAgICAgLmRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkKCduYW1lJywgKHg6IHN0cmluZywgeTogc3RyaW5nKSA9PiB4LnN1YnN0cmluZygwLCAzKSA9PT0geS5zdWJzdHJpbmcoMCwgMykpXG4gKiAgICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBkaXNwbGF5czpcbiAqIC8vIHsgYWdlOiA0LCBuYW1lOiAnRm9vMScgfVxuICogLy8geyBhZ2U6IDcsIG5hbWU6ICdCYXInIH1cbiAqIC8vIHsgYWdlOiA1LCBuYW1lOiAnRm9vMicgfVxuICpcbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0fVxuICogQHNlZSB7QGxpbmsgZGlzdGluY3RVbnRpbENoYW5nZWR9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBTdHJpbmcga2V5IGZvciBvYmplY3QgcHJvcGVydHkgbG9va3VwIG9uIGVhY2ggaXRlbS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjb21wYXJlXSBPcHRpb25hbCBjb21wYXJpc29uIGZ1bmN0aW9uIGNhbGxlZCB0byB0ZXN0IGlmIGFuIGl0ZW0gaXMgZGlzdGluY3QgZnJvbSB0aGUgcHJldmlvdXMgaXRlbSBpbiB0aGUgc291cmNlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdpdGggZGlzdGluY3QgdmFsdWVzIGJhc2VkIG9uIHRoZSBrZXkgc3BlY2lmaWVkLlxuICogQG1ldGhvZCBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZGlzdGluY3RVbnRpbEtleUNoYW5nZWQoa2V5LCBjb21wYXJlKSB7XG4gICAgcmV0dXJuIGRpc3RpbmN0VW50aWxDaGFuZ2VkXzEuZGlzdGluY3RVbnRpbENoYW5nZWQuY2FsbCh0aGlzLCBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICBpZiAoY29tcGFyZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmUoeFtrZXldLCB5W2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4W2tleV0gPT09IHlba2V5XTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGlzdGluY3RVbnRpbEtleUNoYW5nZWQgPSBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUGVyZm9ybSBhIHNpZGUgZWZmZWN0IGZvciBldmVyeSBlbWlzc2lvbiBvbiB0aGUgc291cmNlIE9ic2VydmFibGUsIGJ1dCByZXR1cm5cbiAqIGFuIE9ic2VydmFibGUgdGhhdCBpcyBpZGVudGljYWwgdG8gdGhlIHNvdXJjZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SW50ZXJjZXB0cyBlYWNoIGVtaXNzaW9uIG9uIHRoZSBzb3VyY2UgYW5kIHJ1bnMgYVxuICogZnVuY3Rpb24sIGJ1dCByZXR1cm5zIGFuIG91dHB1dCB3aGljaCBpcyBpZGVudGljYWwgdG8gdGhlIHNvdXJjZSBhcyBsb25nIGFzIGVycm9ycyBkb24ndCBvY2N1ci48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9kby5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBSZXR1cm5zIGEgbWlycm9yZWQgT2JzZXJ2YWJsZSBvZiB0aGUgc291cmNlIE9ic2VydmFibGUsIGJ1dCBtb2RpZmllZCBzbyB0aGF0XG4gKiB0aGUgcHJvdmlkZWQgT2JzZXJ2ZXIgaXMgY2FsbGVkIHRvIHBlcmZvcm0gYSBzaWRlIGVmZmVjdCBmb3IgZXZlcnkgdmFsdWUsXG4gKiBlcnJvciwgYW5kIGNvbXBsZXRpb24gZW1pdHRlZCBieSB0aGUgc291cmNlLiBBbnkgZXJyb3JzIHRoYXQgYXJlIHRocm93biBpblxuICogdGhlIGFmb3JlbWVudGlvbmVkIE9ic2VydmVyIG9yIGhhbmRsZXJzIGFyZSBzYWZlbHkgc2VudCBkb3duIHRoZSBlcnJvciBwYXRoXG4gKiBvZiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogVGhpcyBvcGVyYXRvciBpcyB1c2VmdWwgZm9yIGRlYnVnZ2luZyB5b3VyIE9ic2VydmFibGVzIGZvciB0aGUgY29ycmVjdCB2YWx1ZXNcbiAqIG9yIHBlcmZvcm1pbmcgb3RoZXIgc2lkZSBlZmZlY3RzLlxuICpcbiAqIE5vdGU6IHRoaXMgaXMgZGlmZmVyZW50IHRvIGEgYHN1YnNjcmliZWAgb24gdGhlIE9ic2VydmFibGUuIElmIHRoZSBPYnNlcnZhYmxlXG4gKiByZXR1cm5lZCBieSBgZG9gIGlzIG5vdCBzdWJzY3JpYmVkLCB0aGUgc2lkZSBlZmZlY3RzIHNwZWNpZmllZCBieSB0aGVcbiAqIE9ic2VydmVyIHdpbGwgbmV2ZXIgaGFwcGVuLiBgZG9gIHRoZXJlZm9yZSBzaW1wbHkgc3BpZXMgb24gZXhpc3RpbmdcbiAqIGV4ZWN1dGlvbiwgaXQgZG9lcyBub3QgdHJpZ2dlciBhbiBleGVjdXRpb24gdG8gaGFwcGVuIGxpa2UgYHN1YnNjcmliZWAgZG9lcy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5NYXAgZXZlcnkgZXZlcnkgY2xpY2sgdG8gdGhlIGNsaWVudFggcG9zaXRpb24gb2YgdGhhdCBjbGljaywgd2hpbGUgYWxzbyBsb2dnaW5nIHRoZSBjbGljayBldmVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcG9zaXRpb25zID0gY2xpY2tzXG4gKiAgIC5kbyhldiA9PiBjb25zb2xlLmxvZyhldikpXG4gKiAgIC5tYXAoZXYgPT4gZXYuY2xpZW50WCk7XG4gKiBwb3NpdGlvbnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIG1hcH1cbiAqIEBzZWUge0BsaW5rIHN1YnNjcmliZX1cbiAqXG4gKiBAcGFyYW0ge09ic2VydmVyfGZ1bmN0aW9ufSBbbmV4dE9yT2JzZXJ2ZXJdIEEgbm9ybWFsIE9ic2VydmVyIG9iamVjdCBvciBhXG4gKiBjYWxsYmFjayBmb3IgYG5leHRgLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2Vycm9yXSBDYWxsYmFjayBmb3IgZXJyb3JzIGluIHRoZSBzb3VyY2UuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY29tcGxldGVdIENhbGxiYWNrIGZvciB0aGUgY29tcGxldGlvbiBvZiB0aGUgc291cmNlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBpZGVudGljYWwgdG8gdGhlIHNvdXJjZSwgYnV0IHJ1bnMgdGhlXG4gKiBzcGVjaWZpZWQgT2JzZXJ2ZXIgb3IgY2FsbGJhY2socykgZm9yIGVhY2ggaXRlbS5cbiAqIEBtZXRob2QgZG9cbiAqIEBuYW1lIGRvXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBfZG8obmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IERvT3BlcmF0b3IobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkpO1xufVxuZXhwb3J0cy5fZG8gPSBfZG87XG52YXIgRG9PcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRG9PcGVyYXRvcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHRoaXMubmV4dE9yT2JzZXJ2ZXIgPSBuZXh0T3JPYnNlcnZlcjtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLmNvbXBsZXRlID0gY29tcGxldGU7XG4gICAgfVxuICAgIERvT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBEb1N1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5uZXh0T3JPYnNlcnZlciwgdGhpcy5lcnJvciwgdGhpcy5jb21wbGV0ZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIERvT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBEb1N1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEb1N1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRG9TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdmFyIHNhZmVTdWJzY3JpYmVyID0gbmV3IFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICBzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmFkZChzYWZlU3Vic2NyaWJlcik7XG4gICAgICAgIHRoaXMuc2FmZVN1YnNjcmliZXIgPSBzYWZlU3Vic2NyaWJlcjtcbiAgICB9XG4gICAgRG9TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgc2FmZVN1YnNjcmliZXIgPSB0aGlzLnNhZmVTdWJzY3JpYmVyO1xuICAgICAgICBzYWZlU3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgaWYgKHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93bikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEb1N1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIHNhZmVTdWJzY3JpYmVyID0gdGhpcy5zYWZlU3Vic2NyaWJlcjtcbiAgICAgICAgc2FmZVN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgaWYgKHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93bikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2FmZVN1YnNjcmliZXIgPSB0aGlzLnNhZmVTdWJzY3JpYmVyO1xuICAgICAgICBzYWZlU3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICBpZiAoc2FmZVN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3duKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERvU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogRmlsdGVyIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGJ5IG9ubHkgZW1pdHRpbmcgdGhvc2UgdGhhdFxuICogc2F0aXNmeSBhIHNwZWNpZmllZCBwcmVkaWNhdGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkxpa2VcbiAqIFtBcnJheS5wcm90b3R5cGUuZmlsdGVyKCldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZpbHRlciksXG4gKiBpdCBvbmx5IGVtaXRzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIGlmIGl0IHBhc3NlcyBhIGNyaXRlcmlvbiBmdW5jdGlvbi48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9maWx0ZXIucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogU2ltaWxhciB0byB0aGUgd2VsbC1rbm93biBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kLCB0aGlzIG9wZXJhdG9yXG4gKiB0YWtlcyB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIHBhc3NlcyB0aGVtIHRocm91Z2ggYSBgcHJlZGljYXRlYFxuICogZnVuY3Rpb24gYW5kIG9ubHkgZW1pdHMgdGhvc2UgdmFsdWVzIHRoYXQgeWllbGRlZCBgdHJ1ZWAuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCBvbmx5IGNsaWNrIGV2ZW50cyB3aG9zZSB0YXJnZXQgd2FzIGEgRElWIGVsZW1lbnQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGNsaWNrc09uRGl2cyA9IGNsaWNrcy5maWx0ZXIoZXYgPT4gZXYudGFyZ2V0LnRhZ05hbWUgPT09ICdESVYnKTtcbiAqIGNsaWNrc09uRGl2cy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgZGlzdGluY3R9XG4gKiBAc2VlIHtAbGluayBkaXN0aW5jdFVudGlsQ2hhbmdlZH1cbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkfVxuICogQHNlZSB7QGxpbmsgaWdub3JlRWxlbWVudHN9XG4gKiBAc2VlIHtAbGluayBwYXJ0aXRpb259XG4gKiBAc2VlIHtAbGluayBza2lwfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQsIGluZGV4OiBudW1iZXIpOiBib29sZWFufSBwcmVkaWNhdGUgQSBmdW5jdGlvbiB0aGF0XG4gKiBldmFsdWF0ZXMgZWFjaCB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gSWYgaXQgcmV0dXJucyBgdHJ1ZWAsXG4gKiB0aGUgdmFsdWUgaXMgZW1pdHRlZCwgaWYgYGZhbHNlYCB0aGUgdmFsdWUgaXMgbm90IHBhc3NlZCB0byB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlLiBUaGUgYGluZGV4YCBwYXJhbWV0ZXIgaXMgdGhlIG51bWJlciBgaWAgZm9yIHRoZSBpLXRoIHNvdXJjZVxuICogZW1pc3Npb24gdGhhdCBoYXMgaGFwcGVuZWQgc2luY2UgdGhlIHN1YnNjcmlwdGlvbiwgc3RhcnRpbmcgZnJvbSB0aGUgbnVtYmVyXG4gKiBgMGAuXG4gKiBAcGFyYW0ge2FueX0gW3RoaXNBcmddIEFuIG9wdGlvbmFsIGFyZ3VtZW50IHRvIGRldGVybWluZSB0aGUgdmFsdWUgb2YgYHRoaXNgXG4gKiBpbiB0aGUgYHByZWRpY2F0ZWAgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIG9mIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UgdGhhdCB3ZXJlXG4gKiBhbGxvd2VkIGJ5IHRoZSBgcHJlZGljYXRlYCBmdW5jdGlvbi5cbiAqIEBtZXRob2QgZmlsdGVyXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBmaWx0ZXIocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgRmlsdGVyT3BlcmF0b3IocHJlZGljYXRlLCB0aGlzQXJnKSk7XG59XG5leHBvcnRzLmZpbHRlciA9IGZpbHRlcjtcbnZhciBGaWx0ZXJPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmlsdGVyT3BlcmF0b3IocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLnRoaXNBcmcgPSB0aGlzQXJnO1xuICAgIH1cbiAgICBGaWx0ZXJPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEZpbHRlclN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5wcmVkaWNhdGUsIHRoaXMudGhpc0FyZykpO1xuICAgIH07XG4gICAgcmV0dXJuIEZpbHRlck9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRmlsdGVyU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZpbHRlclN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRmlsdGVyU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmc7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICB9XG4gICAgLy8gdGhlIHRyeSBjYXRjaCBibG9jayBiZWxvdyBpcyBsZWZ0IHNwZWNpZmljYWxseSBmb3JcbiAgICAvLyBvcHRpbWl6YXRpb24gYW5kIHBlcmYgcmVhc29ucy4gYSB0cnlDYXRjaGVyIGlzIG5vdCBuZWNlc3NhcnkgaGVyZS5cbiAgICBGaWx0ZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcmVkaWNhdGUuY2FsbCh0aGlzLnRoaXNBcmcsIHZhbHVlLCB0aGlzLmNvdW50KyspO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRmlsdGVyU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbHRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qKlxuICogQXBwbGllcyBhIGdpdmVuIGBwcm9qZWN0YCBmdW5jdGlvbiB0byBlYWNoIHZhbHVlIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSwgYW5kIGVtaXRzIHRoZSByZXN1bHRpbmcgdmFsdWVzIGFzIGFuIE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkxpa2UgW0FycmF5LnByb3RvdHlwZS5tYXAoKV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvbWFwKSxcbiAqIGl0IHBhc3NlcyBlYWNoIHNvdXJjZSB2YWx1ZSB0aHJvdWdoIGEgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb24gdG8gZ2V0XG4gKiBjb3JyZXNwb25kaW5nIG91dHB1dCB2YWx1ZXMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWFwLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFNpbWlsYXIgdG8gdGhlIHdlbGwga25vd24gYEFycmF5LnByb3RvdHlwZS5tYXBgIGZ1bmN0aW9uLCB0aGlzIG9wZXJhdG9yXG4gKiBhcHBsaWVzIGEgcHJvamVjdGlvbiB0byBlYWNoIHZhbHVlIGFuZCBlbWl0cyB0aGF0IHByb2plY3Rpb24gaW4gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5NYXAgZXZlcnkgY2xpY2sgdG8gdGhlIGNsaWVudFggcG9zaXRpb24gb2YgdGhhdCBjbGljazwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcG9zaXRpb25zID0gY2xpY2tzLm1hcChldiA9PiBldi5jbGllbnRYKTtcbiAqIHBvc2l0aW9ucy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgbWFwVG99XG4gKiBAc2VlIHtAbGluayBwbHVja31cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKTogUn0gcHJvamVjdCBUaGUgZnVuY3Rpb24gdG8gYXBwbHlcbiAqIHRvIGVhY2ggYHZhbHVlYCBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gVGhlIGBpbmRleGAgcGFyYW1ldGVyIGlzXG4gKiB0aGUgbnVtYmVyIGBpYCBmb3IgdGhlIGktdGggZW1pc3Npb24gdGhhdCBoYXMgaGFwcGVuZWQgc2luY2UgdGhlXG4gKiBzdWJzY3JpcHRpb24sIHN0YXJ0aW5nIGZyb20gdGhlIG51bWJlciBgMGAuXG4gKiBAcGFyYW0ge2FueX0gW3RoaXNBcmddIEFuIG9wdGlvbmFsIGFyZ3VtZW50IHRvIGRlZmluZSB3aGF0IGB0aGlzYCBpcyBpbiB0aGVcbiAqIGBwcm9qZWN0YCBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgdmFsdWVzIGZyb20gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSB0cmFuc2Zvcm1lZCBieSB0aGUgZ2l2ZW4gYHByb2plY3RgIGZ1bmN0aW9uLlxuICogQG1ldGhvZCBtYXBcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG1hcChwcm9qZWN0LCB0aGlzQXJnKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9qZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IGlzIG5vdCBhIGZ1bmN0aW9uLiBBcmUgeW91IGxvb2tpbmcgZm9yIGBtYXBUbygpYD8nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgTWFwT3BlcmF0b3IocHJvamVjdCwgdGhpc0FyZykpO1xufVxuZXhwb3J0cy5tYXAgPSBtYXA7XG52YXIgTWFwT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hcE9wZXJhdG9yKHByb2plY3QsIHRoaXNBcmcpIHtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy50aGlzQXJnID0gdGhpc0FyZztcbiAgICB9XG4gICAgTWFwT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBNYXBTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJvamVjdCwgdGhpcy50aGlzQXJnKSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWFwT3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5NYXBPcGVyYXRvciA9IE1hcE9wZXJhdG9yO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBNYXBTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFwU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYXBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcm9qZWN0LCB0aGlzQXJnKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmcgfHwgdGhpcztcbiAgICB9XG4gICAgLy8gTk9URTogVGhpcyBsb29rcyB1bm9wdGltaXplZCwgYnV0IGl0J3MgYWN0dWFsbHkgcHVycG9zZWZ1bGx5IE5PVFxuICAgIC8vIHVzaW5nIHRyeS9jYXRjaCBvcHRpbWl6YXRpb25zLlxuICAgIE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByb2plY3QuY2FsbCh0aGlzLnRoaXNBcmcsIHZhbHVlLCB0aGlzLmNvdW50KyspO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQocmVzdWx0KTtcbiAgICB9O1xuICAgIHJldHVybiBNYXBTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBBcnJheU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvQXJyYXlPYnNlcnZhYmxlJyk7XG52YXIgbWVyZ2VBbGxfMSA9IHJlcXVpcmUoJy4vbWVyZ2VBbGwnKTtcbnZhciBpc1NjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc1NjaGVkdWxlcicpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQ3JlYXRlcyBhbiBvdXRwdXQgT2JzZXJ2YWJsZSB3aGljaCBjb25jdXJyZW50bHkgZW1pdHMgYWxsIHZhbHVlcyBmcm9tIGV2ZXJ5XG4gKiBnaXZlbiBpbnB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5GbGF0dGVucyBtdWx0aXBsZSBPYnNlcnZhYmxlcyB0b2dldGhlciBieSBibGVuZGluZ1xuICogdGhlaXIgdmFsdWVzIGludG8gb25lIE9ic2VydmFibGUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWVyZ2UucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYG1lcmdlYCBzdWJzY3JpYmVzIHRvIGVhY2ggZ2l2ZW4gaW5wdXQgT2JzZXJ2YWJsZSAoZWl0aGVyIHRoZSBzb3VyY2Ugb3IgYW5cbiAqIE9ic2VydmFibGUgZ2l2ZW4gYXMgYXJndW1lbnQpLCBhbmQgc2ltcGx5IGZvcndhcmRzICh3aXRob3V0IGRvaW5nIGFueVxuICogdHJhbnNmb3JtYXRpb24pIGFsbCB0aGUgdmFsdWVzIGZyb20gYWxsIHRoZSBpbnB1dCBPYnNlcnZhYmxlcyB0byB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlLiBUaGUgb3V0cHV0IE9ic2VydmFibGUgb25seSBjb21wbGV0ZXMgb25jZSBhbGwgaW5wdXQgT2JzZXJ2YWJsZXNcbiAqIGhhdmUgY29tcGxldGVkLiBBbnkgZXJyb3IgZGVsaXZlcmVkIGJ5IGFuIGlucHV0IE9ic2VydmFibGUgd2lsbCBiZSBpbW1lZGlhdGVseVxuICogZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+TWVyZ2UgdG9nZXRoZXIgdHdvIE9ic2VydmFibGVzOiAxcyBpbnRlcnZhbCBhbmQgY2xpY2tzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciB0aW1lciA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgY2xpY2tzT3JUaW1lciA9IGNsaWNrcy5tZXJnZSh0aW1lcik7XG4gKiBjbGlja3NPclRpbWVyLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5NZXJnZSB0b2dldGhlciAzIE9ic2VydmFibGVzLCBidXQgb25seSAyIHJ1biBjb25jdXJyZW50bHk8L2NhcHRpb24+XG4gKiB2YXIgdGltZXIxID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDEwKTtcbiAqIHZhciB0aW1lcjIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDIwMDApLnRha2UoNik7XG4gKiB2YXIgdGltZXIzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApLnRha2UoMTApO1xuICogdmFyIGNvbmN1cnJlbnQgPSAyOyAvLyB0aGUgYXJndW1lbnRcbiAqIHZhciBtZXJnZWQgPSB0aW1lcjEubWVyZ2UodGltZXIyLCB0aW1lcjMsIGNvbmN1cnJlbnQpO1xuICogbWVyZ2VkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBtZXJnZUFsbH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXBUb31cbiAqIEBzZWUge0BsaW5rIG1lcmdlU2Nhbn1cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGVJbnB1dH0gb3RoZXIgQW4gaW5wdXQgT2JzZXJ2YWJsZSB0byBtZXJnZSB3aXRoIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIE1vcmUgdGhhbiBvbmUgaW5wdXQgT2JzZXJ2YWJsZXMgbWF5IGJlIGdpdmVuIGFzIGFyZ3VtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW50PU51bWJlci5QT1NJVElWRV9JTkZJTklUWV0gTWF4aW11bSBudW1iZXIgb2YgaW5wdXRcbiAqIE9ic2VydmFibGVzIGJlaW5nIHN1YnNjcmliZWQgdG8gY29uY3VycmVudGx5LlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9bnVsbF0gVGhlIElTY2hlZHVsZXIgdG8gdXNlIGZvciBtYW5hZ2luZ1xuICogY29uY3VycmVuY3kgb2YgaW5wdXQgT2JzZXJ2YWJsZXMuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgdGhhdCBhcmUgdGhlIHJlc3VsdCBvZlxuICogZXZlcnkgaW5wdXQgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2QgbWVyZ2VcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKCkge1xuICAgIHZhciBvYnNlcnZhYmxlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9ic2VydmFibGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5saWZ0LmNhbGwobWVyZ2VTdGF0aWMuYXBwbHkodm9pZCAwLCBbdGhpc10uY29uY2F0KG9ic2VydmFibGVzKSkpO1xufVxuZXhwb3J0cy5tZXJnZSA9IG1lcmdlO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQ3JlYXRlcyBhbiBvdXRwdXQgT2JzZXJ2YWJsZSB3aGljaCBjb25jdXJyZW50bHkgZW1pdHMgYWxsIHZhbHVlcyBmcm9tIGV2ZXJ5XG4gKiBnaXZlbiBpbnB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5GbGF0dGVucyBtdWx0aXBsZSBPYnNlcnZhYmxlcyB0b2dldGhlciBieSBibGVuZGluZ1xuICogdGhlaXIgdmFsdWVzIGludG8gb25lIE9ic2VydmFibGUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWVyZ2UucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYG1lcmdlYCBzdWJzY3JpYmVzIHRvIGVhY2ggZ2l2ZW4gaW5wdXQgT2JzZXJ2YWJsZSAoYXMgYXJndW1lbnRzKSwgYW5kIHNpbXBseVxuICogZm9yd2FyZHMgKHdpdGhvdXQgZG9pbmcgYW55IHRyYW5zZm9ybWF0aW9uKSBhbGwgdGhlIHZhbHVlcyBmcm9tIGFsbCB0aGUgaW5wdXRcbiAqIE9ic2VydmFibGVzIHRvIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS4gVGhlIG91dHB1dCBPYnNlcnZhYmxlIG9ubHkgY29tcGxldGVzXG4gKiBvbmNlIGFsbCBpbnB1dCBPYnNlcnZhYmxlcyBoYXZlIGNvbXBsZXRlZC4gQW55IGVycm9yIGRlbGl2ZXJlZCBieSBhbiBpbnB1dFxuICogT2JzZXJ2YWJsZSB3aWxsIGJlIGltbWVkaWF0ZWx5IGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1lcmdlIHRvZ2V0aGVyIHR3byBPYnNlcnZhYmxlczogMXMgaW50ZXJ2YWwgYW5kIGNsaWNrczwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgdGltZXIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICogdmFyIGNsaWNrc09yVGltZXIgPSBSeC5PYnNlcnZhYmxlLm1lcmdlKGNsaWNrcywgdGltZXIpO1xuICogY2xpY2tzT3JUaW1lci5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICogLy8gdGltZXIgd2lsbCBlbWl0IGFzY2VuZGluZyB2YWx1ZXMsIG9uZSBldmVyeSBzZWNvbmQoMTAwMG1zKSB0byBjb25zb2xlXG4gKiAvLyBjbGlja3MgbG9ncyBNb3VzZUV2ZW50cyB0byBjb25zb2xlIGV2ZXJ5dGltZSB0aGUgXCJkb2N1bWVudFwiIGlzIGNsaWNrZWRcbiAqIC8vIFNpbmNlIHRoZSB0d28gc3RyZWFtcyBhcmUgbWVyZ2VkIHlvdSBzZWUgdGhlc2UgaGFwcGVuaW5nXG4gKiAvLyBhcyB0aGV5IG9jY3VyLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1lcmdlIHRvZ2V0aGVyIDMgT2JzZXJ2YWJsZXMsIGJ1dCBvbmx5IDIgcnVuIGNvbmN1cnJlbnRseTwvY2FwdGlvbj5cbiAqIHZhciB0aW1lcjEgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLnRha2UoMTApO1xuICogdmFyIHRpbWVyMiA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMjAwMCkudGFrZSg2KTtcbiAqIHZhciB0aW1lcjMgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDUwMCkudGFrZSgxMCk7XG4gKiB2YXIgY29uY3VycmVudCA9IDI7IC8vIHRoZSBhcmd1bWVudFxuICogdmFyIG1lcmdlZCA9IFJ4Lk9ic2VydmFibGUubWVyZ2UodGltZXIxLCB0aW1lcjIsIHRpbWVyMywgY29uY3VycmVudCk7XG4gKiBtZXJnZWQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIFJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZzpcbiAqIC8vIC0gRmlyc3QgdGltZXIxIGFuZCB0aW1lcjIgd2lsbCBydW4gY29uY3VycmVudGx5XG4gKiAvLyAtIHRpbWVyMSB3aWxsIGVtaXQgYSB2YWx1ZSBldmVyeSAxMDAwbXMgZm9yIDEwIGl0ZXJhdGlvbnNcbiAqIC8vIC0gdGltZXIyIHdpbGwgZW1pdCBhIHZhbHVlIGV2ZXJ5IDIwMDBtcyBmb3IgNiBpdGVyYXRpb25zXG4gKiAvLyAtIGFmdGVyIHRpbWVyMSBoaXRzIGl0J3MgbWF4IGl0ZXJhdGlvbiwgdGltZXIyIHdpbGxcbiAqIC8vICAgY29udGludWUsIGFuZCB0aW1lcjMgd2lsbCBzdGFydCB0byBydW4gY29uY3VycmVudGx5IHdpdGggdGltZXIyXG4gKiAvLyAtIHdoZW4gdGltZXIyIGhpdHMgaXQncyBtYXggaXRlcmF0aW9uIGl0IHRlcm1pbmF0ZXMsIGFuZFxuICogLy8gICB0aW1lcjMgd2lsbCBjb250aW51ZSB0byBlbWl0IGEgdmFsdWUgZXZlcnkgNTAwbXMgdW50aWwgaXQgaXMgY29tcGxldGVcbiAqXG4gKiBAc2VlIHtAbGluayBtZXJnZUFsbH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXBUb31cbiAqIEBzZWUge0BsaW5rIG1lcmdlU2Nhbn1cbiAqXG4gKiBAcGFyYW0gey4uLk9ic2VydmFibGVJbnB1dH0gb2JzZXJ2YWJsZXMgSW5wdXQgT2JzZXJ2YWJsZXMgdG8gbWVyZ2UgdG9nZXRoZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbnQ9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSBNYXhpbXVtIG51bWJlciBvZiBpbnB1dFxuICogT2JzZXJ2YWJsZXMgYmVpbmcgc3Vic2NyaWJlZCB0byBjb25jdXJyZW50bHkuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1udWxsXSBUaGUgSVNjaGVkdWxlciB0byB1c2UgZm9yIG1hbmFnaW5nXG4gKiBjb25jdXJyZW5jeSBvZiBpbnB1dCBPYnNlcnZhYmxlcy5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyB0aGF0IGFyZSB0aGUgcmVzdWx0IG9mXG4gKiBldmVyeSBpbnB1dCBPYnNlcnZhYmxlLlxuICogQHN0YXRpYyB0cnVlXG4gKiBAbmFtZSBtZXJnZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gbWVyZ2VTdGF0aWMoKSB7XG4gICAgdmFyIG9ic2VydmFibGVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb2JzZXJ2YWJsZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBjb25jdXJyZW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHZhciBzY2hlZHVsZXIgPSBudWxsO1xuICAgIHZhciBsYXN0ID0gb2JzZXJ2YWJsZXNbb2JzZXJ2YWJsZXMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGlzU2NoZWR1bGVyXzEuaXNTY2hlZHVsZXIobGFzdCkpIHtcbiAgICAgICAgc2NoZWR1bGVyID0gb2JzZXJ2YWJsZXMucG9wKCk7XG4gICAgICAgIGlmIChvYnNlcnZhYmxlcy5sZW5ndGggPiAxICYmIHR5cGVvZiBvYnNlcnZhYmxlc1tvYnNlcnZhYmxlcy5sZW5ndGggLSAxXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvbmN1cnJlbnQgPSBvYnNlcnZhYmxlcy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbGFzdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uY3VycmVudCA9IG9ic2VydmFibGVzLnBvcCgpO1xuICAgIH1cbiAgICBpZiAoc2NoZWR1bGVyID09PSBudWxsICYmIG9ic2VydmFibGVzLmxlbmd0aCA9PT0gMSAmJiBvYnNlcnZhYmxlc1swXSBpbnN0YW5jZW9mIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSB7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcnJheU9ic2VydmFibGVfMS5BcnJheU9ic2VydmFibGUob2JzZXJ2YWJsZXMsIHNjaGVkdWxlcikubGlmdChuZXcgbWVyZ2VBbGxfMS5NZXJnZUFsbE9wZXJhdG9yKGNvbmN1cnJlbnQpKTtcbn1cbmV4cG9ydHMubWVyZ2VTdGF0aWMgPSBtZXJnZVN0YXRpYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBDb252ZXJ0cyBhIGhpZ2hlci1vcmRlciBPYnNlcnZhYmxlIGludG8gYSBmaXJzdC1vcmRlciBPYnNlcnZhYmxlIHdoaWNoXG4gKiBjb25jdXJyZW50bHkgZGVsaXZlcnMgYWxsIHZhbHVlcyB0aGF0IGFyZSBlbWl0dGVkIG9uIHRoZSBpbm5lciBPYnNlcnZhYmxlcy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RmxhdHRlbnMgYW4gT2JzZXJ2YWJsZS1vZi1PYnNlcnZhYmxlcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9tZXJnZUFsbC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgbWVyZ2VBbGxgIHN1YnNjcmliZXMgdG8gYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIE9ic2VydmFibGVzLCBhbHNvIGtub3duIGFzXG4gKiBhIGhpZ2hlci1vcmRlciBPYnNlcnZhYmxlLiBFYWNoIHRpbWUgaXQgb2JzZXJ2ZXMgb25lIG9mIHRoZXNlIGVtaXR0ZWQgaW5uZXJcbiAqIE9ic2VydmFibGVzLCBpdCBzdWJzY3JpYmVzIHRvIHRoYXQgYW5kIGRlbGl2ZXJzIGFsbCB0aGUgdmFsdWVzIGZyb20gdGhlXG4gKiBpbm5lciBPYnNlcnZhYmxlIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS4gVGhlIG91dHB1dCBPYnNlcnZhYmxlIG9ubHlcbiAqIGNvbXBsZXRlcyBvbmNlIGFsbCBpbm5lciBPYnNlcnZhYmxlcyBoYXZlIGNvbXBsZXRlZC4gQW55IGVycm9yIGRlbGl2ZXJlZCBieVxuICogYSBpbm5lciBPYnNlcnZhYmxlIHdpbGwgYmUgaW1tZWRpYXRlbHkgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+U3Bhd24gYSBuZXcgaW50ZXJ2YWwgT2JzZXJ2YWJsZSBmb3IgZWFjaCBjbGljayBldmVudCwgYW5kIGJsZW5kIHRoZWlyIG91dHB1dHMgYXMgb25lIE9ic2VydmFibGU8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGhpZ2hlck9yZGVyID0gY2xpY2tzLm1hcCgoZXYpID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkpO1xuICogdmFyIGZpcnN0T3JkZXIgPSBoaWdoZXJPcmRlci5tZXJnZUFsbCgpO1xuICogZmlyc3RPcmRlci5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q291bnQgZnJvbSAwIHRvIDkgZXZlcnkgc2Vjb25kIGZvciBlYWNoIGNsaWNrLCBidXQgb25seSBhbGxvdyAyIGNvbmN1cnJlbnQgdGltZXJzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBoaWdoZXJPcmRlciA9IGNsaWNrcy5tYXAoKGV2KSA9PiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLnRha2UoMTApKTtcbiAqIHZhciBmaXJzdE9yZGVyID0gaGlnaGVyT3JkZXIubWVyZ2VBbGwoMik7XG4gKiBmaXJzdE9yZGVyLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb21iaW5lQWxsfVxuICogQHNlZSB7QGxpbmsgY29uY2F0QWxsfVxuICogQHNlZSB7QGxpbmsgZXhoYXVzdH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXB9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcFRvfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VTY2FufVxuICogQHNlZSB7QGxpbmsgc3dpdGNofVxuICogQHNlZSB7QGxpbmsgemlwQWxsfVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uY3VycmVudD1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldIE1heGltdW0gbnVtYmVyIG9mIGlubmVyXG4gKiBPYnNlcnZhYmxlcyBiZWluZyBzdWJzY3JpYmVkIHRvIGNvbmN1cnJlbnRseS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB2YWx1ZXMgY29taW5nIGZyb20gYWxsIHRoZVxuICogaW5uZXIgT2JzZXJ2YWJsZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIG1lcmdlQWxsXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtZXJnZUFsbChjb25jdXJyZW50KSB7XG4gICAgaWYgKGNvbmN1cnJlbnQgPT09IHZvaWQgMCkgeyBjb25jdXJyZW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOyB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgTWVyZ2VBbGxPcGVyYXRvcihjb25jdXJyZW50KSk7XG59XG5leHBvcnRzLm1lcmdlQWxsID0gbWVyZ2VBbGw7XG52YXIgTWVyZ2VBbGxPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVyZ2VBbGxPcGVyYXRvcihjb25jdXJyZW50KSB7XG4gICAgICAgIHRoaXMuY29uY3VycmVudCA9IGNvbmN1cnJlbnQ7XG4gICAgfVxuICAgIE1lcmdlQWxsT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAob2JzZXJ2ZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgTWVyZ2VBbGxTdWJzY3JpYmVyKG9ic2VydmVyLCB0aGlzLmNvbmN1cnJlbnQpKTtcbiAgICB9O1xuICAgIHJldHVybiBNZXJnZUFsbE9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuTWVyZ2VBbGxPcGVyYXRvciA9IE1lcmdlQWxsT3BlcmF0b3I7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIE1lcmdlQWxsU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lcmdlQWxsU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZXJnZUFsbFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGNvbmN1cnJlbnQpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmNvbmN1cnJlbnQgPSBjb25jdXJyZW50O1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gICAgfVxuICAgIE1lcmdlQWxsU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAob2JzZXJ2YWJsZSkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPCB0aGlzLmNvbmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlKys7XG4gICAgICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIG9ic2VydmFibGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2gob2JzZXJ2YWJsZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lcmdlQWxsU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCAmJiB0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVyZ2VBbGxTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3ViKTtcbiAgICAgICAgdGhpcy5hY3RpdmUtLTtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0KGJ1ZmZlci5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCAmJiB0aGlzLmhhc0NvbXBsZXRlZCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWVyZ2VBbGxTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbmV4cG9ydHMuTWVyZ2VBbGxTdWJzY3JpYmVyID0gTWVyZ2VBbGxTdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2VBbGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBQcm9qZWN0cyBlYWNoIHNvdXJjZSB2YWx1ZSB0byBhbiBPYnNlcnZhYmxlIHdoaWNoIGlzIG1lcmdlZCBpbiB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5NYXBzIGVhY2ggdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSwgdGhlbiBmbGF0dGVucyBhbGwgb2ZcbiAqIHRoZXNlIGlubmVyIE9ic2VydmFibGVzIHVzaW5nIHtAbGluayBtZXJnZUFsbH0uPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWVyZ2VNYXAucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgYmFzZWQgb24gYXBwbHlpbmcgYSBmdW5jdGlvbiB0aGF0IHlvdVxuICogc3VwcGx5IHRvIGVhY2ggaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgd2hlcmUgdGhhdCBmdW5jdGlvblxuICogcmV0dXJucyBhbiBPYnNlcnZhYmxlLCBhbmQgdGhlbiBtZXJnaW5nIHRob3NlIHJlc3VsdGluZyBPYnNlcnZhYmxlcyBhbmRcbiAqIGVtaXR0aW5nIHRoZSByZXN1bHRzIG9mIHRoaXMgbWVyZ2VyLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1hcCBhbmQgZmxhdHRlbiBlYWNoIGxldHRlciB0byBhbiBPYnNlcnZhYmxlIHRpY2tpbmcgZXZlcnkgMSBzZWNvbmQ8L2NhcHRpb24+XG4gKiB2YXIgbGV0dGVycyA9IFJ4Lk9ic2VydmFibGUub2YoJ2EnLCAnYicsICdjJyk7XG4gKiB2YXIgcmVzdWx0ID0gbGV0dGVycy5tZXJnZU1hcCh4ID0+XG4gKiAgIFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkubWFwKGkgPT4geCtpKVxuICogKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICogLy8gYTBcbiAqIC8vIGIwXG4gKiAvLyBjMFxuICogLy8gYTFcbiAqIC8vIGIxXG4gKiAvLyBjMVxuICogLy8gY29udGludWVzIHRvIGxpc3QgYSxiLGMgd2l0aCByZXNwZWN0aXZlIGFzY2VuZGluZyBpbnRlZ2Vyc1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcH1cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3RNYXB9XG4gKiBAc2VlIHtAbGluayBtZXJnZX1cbiAqIEBzZWUge0BsaW5rIG1lcmdlQWxsfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXBUb31cbiAqIEBzZWUge0BsaW5rIG1lcmdlU2Nhbn1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcH1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCA/aW5kZXg6IG51bWJlcik6IE9ic2VydmFibGVJbnB1dH0gcHJvamVjdCBBIGZ1bmN0aW9uXG4gKiB0aGF0LCB3aGVuIGFwcGxpZWQgdG8gYW4gaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgcmV0dXJucyBhblxuICogT2JzZXJ2YWJsZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSwgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpOiBhbnl9IFtyZXN1bHRTZWxlY3Rvcl1cbiAqIEEgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJhc2VkIG9uIHRoZSB2YWx1ZXNcbiAqIGFuZCB0aGUgaW5kaWNlcyBvZiB0aGUgc291cmNlIChvdXRlcikgZW1pc3Npb24gYW5kIHRoZSBpbm5lciBPYnNlcnZhYmxlXG4gKiBlbWlzc2lvbi4gVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmU6XG4gKiAtIGBvdXRlclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiAtIGBvdXRlckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbnQ9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSBNYXhpbXVtIG51bWJlciBvZiBpbnB1dFxuICogT2JzZXJ2YWJsZXMgYmVpbmcgc3Vic2NyaWJlZCB0byBjb25jdXJyZW50bHkuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGVcbiAqIHByb2plY3Rpb24gZnVuY3Rpb24gKGFuZCB0aGUgb3B0aW9uYWwgYHJlc3VsdFNlbGVjdG9yYCkgdG8gZWFjaCBpdGVtIGVtaXR0ZWRcbiAqIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhbmQgbWVyZ2luZyB0aGUgcmVzdWx0cyBvZiB0aGUgT2JzZXJ2YWJsZXMgb2J0YWluZWRcbiAqIGZyb20gdGhpcyB0cmFuc2Zvcm1hdGlvbi5cbiAqIEBtZXRob2QgbWVyZ2VNYXBcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG1lcmdlTWFwKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yLCBjb25jdXJyZW50KSB7XG4gICAgaWYgKGNvbmN1cnJlbnQgPT09IHZvaWQgMCkgeyBjb25jdXJyZW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOyB9XG4gICAgaWYgKHR5cGVvZiByZXN1bHRTZWxlY3RvciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uY3VycmVudCA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICByZXN1bHRTZWxlY3RvciA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IE1lcmdlTWFwT3BlcmF0b3IocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IsIGNvbmN1cnJlbnQpKTtcbn1cbmV4cG9ydHMubWVyZ2VNYXAgPSBtZXJnZU1hcDtcbnZhciBNZXJnZU1hcE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXJnZU1hcE9wZXJhdG9yKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yLCBjb25jdXJyZW50KSB7XG4gICAgICAgIGlmIChjb25jdXJyZW50ID09PSB2b2lkIDApIHsgY29uY3VycmVudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsgfVxuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuY29uY3VycmVudCA9IGNvbmN1cnJlbnQ7XG4gICAgfVxuICAgIE1lcmdlTWFwT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAob2JzZXJ2ZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgTWVyZ2VNYXBTdWJzY3JpYmVyKG9ic2VydmVyLCB0aGlzLnByb2plY3QsIHRoaXMucmVzdWx0U2VsZWN0b3IsIHRoaXMuY29uY3VycmVudCkpO1xuICAgIH07XG4gICAgcmV0dXJuIE1lcmdlTWFwT3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5NZXJnZU1hcE9wZXJhdG9yID0gTWVyZ2VNYXBPcGVyYXRvcjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgTWVyZ2VNYXBTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVyZ2VNYXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lcmdlTWFwU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJvamVjdCwgcmVzdWx0U2VsZWN0b3IsIGNvbmN1cnJlbnQpIHtcbiAgICAgICAgaWYgKGNvbmN1cnJlbnQgPT09IHZvaWQgMCkgeyBjb25jdXJyZW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICB0aGlzLmNvbmN1cnJlbnQgPSBjb25jdXJyZW50O1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBNZXJnZU1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA8IHRoaXMuY29uY3VycmVudCkge1xuICAgICAgICAgICAgdGhpcy5fdHJ5TmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVyZ2VNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fdHJ5TmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByb2plY3QodmFsdWUsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmUrKztcbiAgICAgICAgdGhpcy5faW5uZXJTdWIocmVzdWx0LCB2YWx1ZSwgaW5kZXgpO1xuICAgIH07XG4gICAgTWVyZ2VNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5faW5uZXJTdWIgPSBmdW5jdGlvbiAoaXNoLCB2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBpc2gsIHZhbHVlLCBpbmRleCkpO1xuICAgIH07XG4gICAgTWVyZ2VNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlID09PSAwICYmIHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXJnZU1hcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX25vdGlmeVJlc3VsdFNlbGVjdG9yKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGlubmVyVmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXJnZU1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9ub3RpZnlSZXN1bHRTZWxlY3RvciA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnJlc3VsdFNlbGVjdG9yKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQocmVzdWx0KTtcbiAgICB9O1xuICAgIE1lcmdlTWFwU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB0aGlzLnJlbW92ZShpbm5lclN1Yik7XG4gICAgICAgIHRoaXMuYWN0aXZlLS07XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dChidWZmZXIuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hY3RpdmUgPT09IDAgJiYgdGhpcy5oYXNDb21wbGV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1lcmdlTWFwU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG5leHBvcnRzLk1lcmdlTWFwU3Vic2NyaWJlciA9IE1lcmdlTWFwU3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlTWFwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIE5vdGlmaWNhdGlvbl8xID0gcmVxdWlyZSgnLi4vTm90aWZpY2F0aW9uJyk7XG4vKipcbiAqIEBzZWUge0BsaW5rIE5vdGlmaWNhdGlvbn1cbiAqXG4gKiBAcGFyYW0gc2NoZWR1bGVyXG4gKiBAcGFyYW0gZGVsYXlcbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj58V2ViU29ja2V0U3ViamVjdDxUPnxPYnNlcnZhYmxlPFQ+fVxuICogQG1ldGhvZCBvYnNlcnZlT25cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG9ic2VydmVPbihzY2hlZHVsZXIsIGRlbGF5KSB7XG4gICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgT2JzZXJ2ZU9uT3BlcmF0b3Ioc2NoZWR1bGVyLCBkZWxheSkpO1xufVxuZXhwb3J0cy5vYnNlcnZlT24gPSBvYnNlcnZlT247XG52YXIgT2JzZXJ2ZU9uT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9ic2VydmVPbk9wZXJhdG9yKHNjaGVkdWxlciwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgfVxuICAgIE9ic2VydmVPbk9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgT2JzZXJ2ZU9uU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnNjaGVkdWxlciwgdGhpcy5kZWxheSkpO1xuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmVPbk9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuT2JzZXJ2ZU9uT3BlcmF0b3IgPSBPYnNlcnZlT25PcGVyYXRvcjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgT2JzZXJ2ZU9uU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE9ic2VydmVPblN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT2JzZXJ2ZU9uU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgc2NoZWR1bGVyLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5kZWxheSA9IGRlbGF5O1xuICAgIH1cbiAgICBPYnNlcnZlT25TdWJzY3JpYmVyLmRpc3BhdGNoID0gZnVuY3Rpb24gKGFyZykge1xuICAgICAgICB2YXIgbm90aWZpY2F0aW9uID0gYXJnLm5vdGlmaWNhdGlvbiwgZGVzdGluYXRpb24gPSBhcmcuZGVzdGluYXRpb247XG4gICAgICAgIG5vdGlmaWNhdGlvbi5vYnNlcnZlKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgT2JzZXJ2ZU9uU3Vic2NyaWJlci5wcm90b3R5cGUuc2NoZWR1bGVNZXNzYWdlID0gZnVuY3Rpb24gKG5vdGlmaWNhdGlvbikge1xuICAgICAgICB0aGlzLmFkZCh0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShPYnNlcnZlT25TdWJzY3JpYmVyLmRpc3BhdGNoLCB0aGlzLmRlbGF5LCBuZXcgT2JzZXJ2ZU9uTWVzc2FnZShub3RpZmljYXRpb24sIHRoaXMuZGVzdGluYXRpb24pKSk7XG4gICAgfTtcbiAgICBPYnNlcnZlT25TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlTWVzc2FnZShOb3RpZmljYXRpb25fMS5Ob3RpZmljYXRpb24uY3JlYXRlTmV4dCh2YWx1ZSkpO1xuICAgIH07XG4gICAgT2JzZXJ2ZU9uU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLnNjaGVkdWxlTWVzc2FnZShOb3RpZmljYXRpb25fMS5Ob3RpZmljYXRpb24uY3JlYXRlRXJyb3IoZXJyKSk7XG4gICAgfTtcbiAgICBPYnNlcnZlT25TdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVNZXNzYWdlKE5vdGlmaWNhdGlvbl8xLk5vdGlmaWNhdGlvbi5jcmVhdGVDb21wbGV0ZSgpKTtcbiAgICB9O1xuICAgIHJldHVybiBPYnNlcnZlT25TdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5PYnNlcnZlT25TdWJzY3JpYmVyID0gT2JzZXJ2ZU9uU3Vic2NyaWJlcjtcbnZhciBPYnNlcnZlT25NZXNzYWdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPYnNlcnZlT25NZXNzYWdlKG5vdGlmaWNhdGlvbiwgZGVzdGluYXRpb24pIHtcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb24gPSBub3RpZmljYXRpb247XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIE9ic2VydmVPbk1lc3NhZ2U7XG59KCkpO1xuZXhwb3J0cy5PYnNlcnZlT25NZXNzYWdlID0gT2JzZXJ2ZU9uTWVzc2FnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ic2VydmVPbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBub3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvbm90Jyk7XG52YXIgZmlsdGVyXzEgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xuLyoqXG4gKiBTcGxpdHMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGludG8gdHdvLCBvbmUgd2l0aCB2YWx1ZXMgdGhhdCBzYXRpc2Z5IGFcbiAqIHByZWRpY2F0ZSwgYW5kIGFub3RoZXIgd2l0aCB2YWx1ZXMgdGhhdCBkb24ndCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgZmlsdGVyfSwgYnV0IHJldHVybnMgdHdvIE9ic2VydmFibGVzOlxuICogb25lIGxpa2UgdGhlIG91dHB1dCBvZiB7QGxpbmsgZmlsdGVyfSwgYW5kIHRoZSBvdGhlciB3aXRoIHZhbHVlcyB0aGF0IGRpZCBub3RcbiAqIHBhc3MgdGhlIGNvbmRpdGlvbi48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9wYXJ0aXRpb24ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHBhcnRpdGlvbmAgb3V0cHV0cyBhbiBhcnJheSB3aXRoIHR3byBPYnNlcnZhYmxlcyB0aGF0IHBhcnRpdGlvbiB0aGUgdmFsdWVzXG4gKiBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aHJvdWdoIHRoZSBnaXZlbiBgcHJlZGljYXRlYCBmdW5jdGlvbi4gVGhlIGZpcnN0XG4gKiBPYnNlcnZhYmxlIGluIHRoYXQgYXJyYXkgZW1pdHMgc291cmNlIHZhbHVlcyBmb3Igd2hpY2ggdGhlIHByZWRpY2F0ZSBhcmd1bWVudFxuICogcmV0dXJucyB0cnVlLiBUaGUgc2Vjb25kIE9ic2VydmFibGUgZW1pdHMgc291cmNlIHZhbHVlcyBmb3Igd2hpY2ggdGhlXG4gKiBwcmVkaWNhdGUgcmV0dXJucyBmYWxzZS4gVGhlIGZpcnN0IGJlaGF2ZXMgbGlrZSB7QGxpbmsgZmlsdGVyfSBhbmQgdGhlIHNlY29uZFxuICogYmVoYXZlcyBsaWtlIHtAbGluayBmaWx0ZXJ9IHdpdGggdGhlIHByZWRpY2F0ZSBuZWdhdGVkLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlBhcnRpdGlvbiBjbGljayBldmVudHMgaW50byB0aG9zZSBvbiBESVYgZWxlbWVudHMgYW5kIHRob3NlIGVsc2V3aGVyZTwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcGFydHMgPSBjbGlja3MucGFydGl0aW9uKGV2ID0+IGV2LnRhcmdldC50YWdOYW1lID09PSAnRElWJyk7XG4gKiB2YXIgY2xpY2tzT25EaXZzID0gcGFydHNbMF07XG4gKiB2YXIgY2xpY2tzRWxzZXdoZXJlID0gcGFydHNbMV07XG4gKiBjbGlja3NPbkRpdnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coJ0RJViBjbGlja2VkOiAnLCB4KSk7XG4gKiBjbGlja3NFbHNld2hlcmUuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coJ090aGVyIGNsaWNrZWQ6ICcsIHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBmaWx0ZXJ9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgaW5kZXg6IG51bWJlcik6IGJvb2xlYW59IHByZWRpY2F0ZSBBIGZ1bmN0aW9uIHRoYXRcbiAqIGV2YWx1YXRlcyBlYWNoIHZhbHVlIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBJZiBpdCByZXR1cm5zIGB0cnVlYCxcbiAqIHRoZSB2YWx1ZSBpcyBlbWl0dGVkIG9uIHRoZSBmaXJzdCBPYnNlcnZhYmxlIGluIHRoZSByZXR1cm5lZCBhcnJheSwgaWZcbiAqIGBmYWxzZWAgdGhlIHZhbHVlIGlzIGVtaXR0ZWQgb24gdGhlIHNlY29uZCBPYnNlcnZhYmxlIGluIHRoZSBhcnJheS4gVGhlXG4gKiBgaW5kZXhgIHBhcmFtZXRlciBpcyB0aGUgbnVtYmVyIGBpYCBmb3IgdGhlIGktdGggc291cmNlIGVtaXNzaW9uIHRoYXQgaGFzXG4gKiBoYXBwZW5lZCBzaW5jZSB0aGUgc3Vic2NyaXB0aW9uLCBzdGFydGluZyBmcm9tIHRoZSBudW1iZXIgYDBgLlxuICogQHBhcmFtIHthbnl9IFt0aGlzQXJnXSBBbiBvcHRpb25hbCBhcmd1bWVudCB0byBkZXRlcm1pbmUgdGhlIHZhbHVlIG9mIGB0aGlzYFxuICogaW4gdGhlIGBwcmVkaWNhdGVgIGZ1bmN0aW9uLlxuICogQHJldHVybiB7W09ic2VydmFibGU8VD4sIE9ic2VydmFibGU8VD5dfSBBbiBhcnJheSB3aXRoIHR3byBPYnNlcnZhYmxlczogb25lXG4gKiB3aXRoIHZhbHVlcyB0aGF0IHBhc3NlZCB0aGUgcHJlZGljYXRlLCBhbmQgYW5vdGhlciB3aXRoIHZhbHVlcyB0aGF0IGRpZCBub3RcbiAqIHBhc3MgdGhlIHByZWRpY2F0ZS5cbiAqIEBtZXRob2QgcGFydGl0aW9uXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBwYXJ0aXRpb24ocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgZmlsdGVyXzEuZmlsdGVyLmNhbGwodGhpcywgcHJlZGljYXRlLCB0aGlzQXJnKSxcbiAgICAgICAgZmlsdGVyXzEuZmlsdGVyLmNhbGwodGhpcywgbm90XzEubm90KHByZWRpY2F0ZSwgdGhpc0FyZykpXG4gICAgXTtcbn1cbmV4cG9ydHMucGFydGl0aW9uID0gcGFydGl0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFydGl0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vU3ViamVjdCcpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IG1pcnJvcnMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBhbiBgZXJyb3JgLiBJZiB0aGUgc291cmNlIE9ic2VydmFibGVcbiAqIGNhbGxzIGBlcnJvcmAsIHRoaXMgbWV0aG9kIHdpbGwgZW1pdCB0aGUgVGhyb3dhYmxlIHRoYXQgY2F1c2VkIHRoZSBlcnJvciB0byB0aGUgT2JzZXJ2YWJsZSByZXR1cm5lZCBmcm9tIGBub3RpZmllcmAuXG4gKiBJZiB0aGF0IE9ic2VydmFibGUgY2FsbHMgYGNvbXBsZXRlYCBvciBgZXJyb3JgIHRoZW4gdGhpcyBtZXRob2Qgd2lsbCBjYWxsIGBjb21wbGV0ZWAgb3IgYGVycm9yYCBvbiB0aGUgY2hpbGRcbiAqIHN1YnNjcmlwdGlvbi4gT3RoZXJ3aXNlIHRoaXMgbWV0aG9kIHdpbGwgcmVzdWJzY3JpYmUgdG8gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvcmV0cnlXaGVuLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyb3JzOiBPYnNlcnZhYmxlKTogT2JzZXJ2YWJsZX0gbm90aWZpZXIgLSBSZWNlaXZlcyBhbiBPYnNlcnZhYmxlIG9mIG5vdGlmaWNhdGlvbnMgd2l0aCB3aGljaCBhXG4gKiB1c2VyIGNhbiBgY29tcGxldGVgIG9yIGBlcnJvcmAsIGFib3J0aW5nIHRoZSByZXRyeS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IFRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBtb2RpZmllZCB3aXRoIHJldHJ5IGxvZ2ljLlxuICogQG1ldGhvZCByZXRyeVdoZW5cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHJldHJ5V2hlbihub3RpZmllcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFJldHJ5V2hlbk9wZXJhdG9yKG5vdGlmaWVyLCB0aGlzKSk7XG59XG5leHBvcnRzLnJldHJ5V2hlbiA9IHJldHJ5V2hlbjtcbnZhciBSZXRyeVdoZW5PcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmV0cnlXaGVuT3BlcmF0b3Iobm90aWZpZXIsIHNvdXJjZSkge1xuICAgICAgICB0aGlzLm5vdGlmaWVyID0gbm90aWZpZXI7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBSZXRyeVdoZW5PcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFJldHJ5V2hlblN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5ub3RpZmllciwgdGhpcy5zb3VyY2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBSZXRyeVdoZW5PcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFJldHJ5V2hlblN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXRyeVdoZW5TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJldHJ5V2hlblN1YnNjcmliZXIoZGVzdGluYXRpb24sIG5vdGlmaWVyLCBzb3VyY2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLm5vdGlmaWVyID0gbm90aWZpZXI7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBSZXRyeVdoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIGVycm9ycyA9IHRoaXMuZXJyb3JzO1xuICAgICAgICAgICAgdmFyIHJldHJpZXMgPSB0aGlzLnJldHJpZXM7XG4gICAgICAgICAgICB2YXIgcmV0cmllc1N1YnNjcmlwdGlvbiA9IHRoaXMucmV0cmllc1N1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgIGlmICghcmV0cmllcykge1xuICAgICAgICAgICAgICAgIGVycm9ycyA9IG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpO1xuICAgICAgICAgICAgICAgIHJldHJpZXMgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHRoaXMubm90aWZpZXIpKGVycm9ycyk7XG4gICAgICAgICAgICAgICAgaWYgKHJldHJpZXMgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZXJyb3IuY2FsbCh0aGlzLCBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXRyaWVzU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCByZXRyaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnJldHJpZXNTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVBbmRSZWN5Y2xlKCk7XG4gICAgICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgICAgIHRoaXMucmV0cmllcyA9IHJldHJpZXM7XG4gICAgICAgICAgICB0aGlzLnJldHJpZXNTdWJzY3JpcHRpb24gPSByZXRyaWVzU3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgZXJyb3JzLm5leHQoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmV0cnlXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBlcnJvcnMgPSBfYS5lcnJvcnMsIHJldHJpZXNTdWJzY3JpcHRpb24gPSBfYS5yZXRyaWVzU3Vic2NyaXB0aW9uO1xuICAgICAgICBpZiAoZXJyb3JzKSB7XG4gICAgICAgICAgICBlcnJvcnMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmV0cmllc1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0cmllc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5yZXRyaWVzU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJldHJpZXMgPSBudWxsO1xuICAgIH07XG4gICAgUmV0cnlXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBlcnJvcnMgPSBfYS5lcnJvcnMsIHJldHJpZXMgPSBfYS5yZXRyaWVzLCByZXRyaWVzU3Vic2NyaXB0aW9uID0gX2EucmV0cmllc1N1YnNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBudWxsO1xuICAgICAgICB0aGlzLnJldHJpZXMgPSBudWxsO1xuICAgICAgICB0aGlzLnJldHJpZXNTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl91bnN1YnNjcmliZUFuZFJlY3ljbGUoKTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHRoaXMucmV0cmllcyA9IHJldHJpZXM7XG4gICAgICAgIHRoaXMucmV0cmllc1N1YnNjcmlwdGlvbiA9IHJldHJpZXNTdWJzY3JpcHRpb247XG4gICAgICAgIHRoaXMuc291cmNlLnN1YnNjcmliZSh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBSZXRyeVdoZW5TdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJldHJ5V2hlbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogQ29udmVydHMgYSBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZSBpbnRvIGEgZmlyc3Qtb3JkZXIgT2JzZXJ2YWJsZSBieVxuICogc3Vic2NyaWJpbmcgdG8gb25seSB0aGUgbW9zdCByZWNlbnRseSBlbWl0dGVkIG9mIHRob3NlIGlubmVyIE9ic2VydmFibGVzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5GbGF0dGVucyBhbiBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzIGJ5IGRyb3BwaW5nIHRoZVxuICogcHJldmlvdXMgaW5uZXIgT2JzZXJ2YWJsZSBvbmNlIGEgbmV3IG9uZSBhcHBlYXJzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3N3aXRjaC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgc3dpdGNoYCBzdWJzY3JpYmVzIHRvIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBPYnNlcnZhYmxlcywgYWxzbyBrbm93biBhcyBhXG4gKiBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZS4gRWFjaCB0aW1lIGl0IG9ic2VydmVzIG9uZSBvZiB0aGVzZSBlbWl0dGVkIGlubmVyXG4gKiBPYnNlcnZhYmxlcywgdGhlIG91dHB1dCBPYnNlcnZhYmxlIHN1YnNjcmliZXMgdG8gdGhlIGlubmVyIE9ic2VydmFibGUgYW5kXG4gKiBiZWdpbnMgZW1pdHRpbmcgdGhlIGl0ZW1zIGVtaXR0ZWQgYnkgdGhhdC4gU28gZmFyLCBpdCBiZWhhdmVzXG4gKiBsaWtlIHtAbGluayBtZXJnZUFsbH0uIEhvd2V2ZXIsIHdoZW4gYSBuZXcgaW5uZXIgT2JzZXJ2YWJsZSBpcyBlbWl0dGVkLFxuICogYHN3aXRjaGAgdW5zdWJzY3JpYmVzIGZyb20gdGhlIGVhcmxpZXItZW1pdHRlZCBpbm5lciBPYnNlcnZhYmxlIGFuZFxuICogc3Vic2NyaWJlcyB0byB0aGUgbmV3IGlubmVyIE9ic2VydmFibGUgYW5kIGJlZ2lucyBlbWl0dGluZyBpdGVtcyBmcm9tIGl0LiBJdFxuICogY29udGludWVzIHRvIGJlaGF2ZSBsaWtlIHRoaXMgZm9yIHN1YnNlcXVlbnQgaW5uZXIgT2JzZXJ2YWJsZXMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UmVydW4gYW4gaW50ZXJ2YWwgT2JzZXJ2YWJsZSBvbiBldmVyeSBjbGljayBldmVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiAvLyBFYWNoIGNsaWNrIGV2ZW50IGlzIG1hcHBlZCB0byBhbiBPYnNlcnZhYmxlIHRoYXQgdGlja3MgZXZlcnkgc2Vjb25kXG4gKiB2YXIgaGlnaGVyT3JkZXIgPSBjbGlja3MubWFwKChldikgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKSk7XG4gKiB2YXIgc3dpdGNoZWQgPSBoaWdoZXJPcmRlci5zd2l0Y2goKTtcbiAqIC8vIFRoZSBvdXRjb21lIGlzIHRoYXQgYHN3aXRjaGVkYCBpcyBlc3NlbnRpYWxseSBhIHRpbWVyIHRoYXQgcmVzdGFydHNcbiAqIC8vIG9uIGV2ZXJ5IGNsaWNrLiBUaGUgaW50ZXJ2YWwgT2JzZXJ2YWJsZXMgZnJvbSBvbGRlciBjbGlja3MgZG8gbm90IG1lcmdlXG4gKiAvLyB3aXRoIHRoZSBjdXJyZW50IGludGVydmFsIE9ic2VydmFibGUuXG4gKiBzd2l0Y2hlZC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgY29tYmluZUFsbH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdEFsbH1cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3R9XG4gKiBAc2VlIHtAbGluayBtZXJnZUFsbH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcFRvfVxuICogQHNlZSB7QGxpbmsgemlwQWxsfVxuICpcbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgaXRlbXMgZW1pdHRlZCBieSB0aGVcbiAqIE9ic2VydmFibGUgbW9zdCByZWNlbnRseSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2Qgc3dpdGNoXG4gKiBAbmFtZSBzd2l0Y2hcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIF9zd2l0Y2goKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgU3dpdGNoT3BlcmF0b3IoKSk7XG59XG5leHBvcnRzLl9zd2l0Y2ggPSBfc3dpdGNoO1xudmFyIFN3aXRjaE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTd2l0Y2hPcGVyYXRvcigpIHtcbiAgICB9XG4gICAgU3dpdGNoT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBTd2l0Y2hTdWJzY3JpYmVyKHN1YnNjcmliZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFN3aXRjaFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTd2l0Y2hTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN3aXRjaFN1YnNjcmliZXIoZGVzdGluYXRpb24pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gZmFsc2U7XG4gICAgfVxuICAgIFN3aXRjaFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVJbm5lcigpO1xuICAgICAgICB0aGlzLmFjdGl2ZSsrO1xuICAgICAgICB0aGlzLmFkZCh0aGlzLmlubmVyU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgU3dpdGNoU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hTdWJzY3JpYmVyLnByb3RvdHlwZS51bnN1YnNjcmliZUlubmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRoaXMuYWN0aXZlID4gMCA/IHRoaXMuYWN0aXZlIC0gMSA6IDA7XG4gICAgICAgIHZhciBpbm5lclN1YnNjcmlwdGlvbiA9IHRoaXMuaW5uZXJTdWJzY3JpcHRpb247XG4gICAgICAgIGlmIChpbm5lclN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgaW5uZXJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgfTtcbiAgICBTd2l0Y2hTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgIH07XG4gICAgU3dpdGNoU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVJbm5lcigpO1xuICAgICAgICBpZiAodGhpcy5oYXNDb21wbGV0ZWQgJiYgdGhpcy5hY3RpdmUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN3aXRjaFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dpdGNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUHJvamVjdHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSB3aGljaCBpcyBtZXJnZWQgaW4gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZSwgZW1pdHRpbmcgdmFsdWVzIG9ubHkgZnJvbSB0aGUgbW9zdCByZWNlbnRseSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TWFwcyBlYWNoIHZhbHVlIHRvIGFuIE9ic2VydmFibGUsIHRoZW4gZmxhdHRlbnMgYWxsIG9mXG4gKiB0aGVzZSBpbm5lciBPYnNlcnZhYmxlcyB1c2luZyB7QGxpbmsgc3dpdGNofS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9zd2l0Y2hNYXAucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgYmFzZWQgb24gYXBwbHlpbmcgYSBmdW5jdGlvbiB0aGF0IHlvdVxuICogc3VwcGx5IHRvIGVhY2ggaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgd2hlcmUgdGhhdCBmdW5jdGlvblxuICogcmV0dXJucyBhbiAoc28tY2FsbGVkIFwiaW5uZXJcIikgT2JzZXJ2YWJsZS4gRWFjaCB0aW1lIGl0IG9ic2VydmVzIG9uZSBvZiB0aGVzZVxuICogaW5uZXIgT2JzZXJ2YWJsZXMsIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiZWdpbnMgZW1pdHRpbmcgdGhlIGl0ZW1zIGVtaXR0ZWQgYnlcbiAqIHRoYXQgaW5uZXIgT2JzZXJ2YWJsZS4gV2hlbiBhIG5ldyBpbm5lciBPYnNlcnZhYmxlIGlzIGVtaXR0ZWQsIGBzd2l0Y2hNYXBgXG4gKiBzdG9wcyBlbWl0dGluZyBpdGVtcyBmcm9tIHRoZSBlYXJsaWVyLWVtaXR0ZWQgaW5uZXIgT2JzZXJ2YWJsZSBhbmQgYmVnaW5zXG4gKiBlbWl0dGluZyBpdGVtcyBmcm9tIHRoZSBuZXcgb25lLiBJdCBjb250aW51ZXMgdG8gYmVoYXZlIGxpa2UgdGhpcyBmb3JcbiAqIHN1YnNlcXVlbnQgaW5uZXIgT2JzZXJ2YWJsZXMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UmVydW4gYW4gaW50ZXJ2YWwgT2JzZXJ2YWJsZSBvbiBldmVyeSBjbGljayBldmVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLnN3aXRjaE1hcCgoZXYpID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXB9XG4gKiBAc2VlIHtAbGluayBleGhhdXN0TWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXB9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2h9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2hNYXBUb31cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCA/aW5kZXg6IG51bWJlcik6IE9ic2VydmFibGVJbnB1dH0gcHJvamVjdCBBIGZ1bmN0aW9uXG4gKiB0aGF0LCB3aGVuIGFwcGxpZWQgdG8gYW4gaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgcmV0dXJucyBhblxuICogT2JzZXJ2YWJsZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSwgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpOiBhbnl9IFtyZXN1bHRTZWxlY3Rvcl1cbiAqIEEgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJhc2VkIG9uIHRoZSB2YWx1ZXNcbiAqIGFuZCB0aGUgaW5kaWNlcyBvZiB0aGUgc291cmNlIChvdXRlcikgZW1pc3Npb24gYW5kIHRoZSBpbm5lciBPYnNlcnZhYmxlXG4gKiBlbWlzc2lvbi4gVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmU6XG4gKiAtIGBvdXRlclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiAtIGBvdXRlckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGVcbiAqIHByb2plY3Rpb24gZnVuY3Rpb24gKGFuZCB0aGUgb3B0aW9uYWwgYHJlc3VsdFNlbGVjdG9yYCkgdG8gZWFjaCBpdGVtIGVtaXR0ZWRcbiAqIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhbmQgdGFraW5nIG9ubHkgdGhlIHZhbHVlcyBmcm9tIHRoZSBtb3N0IHJlY2VudGx5XG4gKiBwcm9qZWN0ZWQgaW5uZXIgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2Qgc3dpdGNoTWFwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBzd2l0Y2hNYXAocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBTd2l0Y2hNYXBPcGVyYXRvcihwcm9qZWN0LCByZXN1bHRTZWxlY3RvcikpO1xufVxuZXhwb3J0cy5zd2l0Y2hNYXAgPSBzd2l0Y2hNYXA7XG52YXIgU3dpdGNoTWFwT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN3aXRjaE1hcE9wZXJhdG9yKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICB9XG4gICAgU3dpdGNoTWFwT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBTd2l0Y2hNYXBTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJvamVjdCwgdGhpcy5yZXN1bHRTZWxlY3RvcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFN3aXRjaE1hcE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU3dpdGNoTWFwU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN3aXRjaE1hcFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3dpdGNoTWFwU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByb2plY3QodmFsdWUsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lubmVyU3ViKHJlc3VsdCwgdmFsdWUsIGluZGV4KTtcbiAgICB9O1xuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9pbm5lclN1YiA9IGZ1bmN0aW9uIChyZXN1bHQsIHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIgaW5uZXJTdWJzY3JpcHRpb24gPSB0aGlzLmlubmVyU3Vic2NyaXB0aW9uO1xuICAgICAgICBpZiAoaW5uZXJTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGlubmVyU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGQodGhpcy5pbm5lclN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgcmVzdWx0LCB2YWx1ZSwgaW5kZXgpKTtcbiAgICB9O1xuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlubmVyU3Vic2NyaXB0aW9uID0gdGhpcy5pbm5lclN1YnNjcmlwdGlvbjtcbiAgICAgICAgaWYgKCFpbm5lclN1YnNjcmlwdGlvbiB8fCBpbm5lclN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbm5lclN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB0aGlzLnJlbW92ZShpbm5lclN1Yik7XG4gICAgICAgIHRoaXMuaW5uZXJTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyeU5vdGlmeU5leHQob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl90cnlOb3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucmVzdWx0U2VsZWN0b3Iob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFN3aXRjaE1hcFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dpdGNoTWFwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yXzEgPSByZXF1aXJlKCcuLi91dGlsL0FyZ3VtZW50T3V0T2ZSYW5nZUVycm9yJyk7XG52YXIgRW1wdHlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0VtcHR5T2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBFbWl0cyBvbmx5IHRoZSBmaXJzdCBgY291bnRgIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+VGFrZXMgdGhlIGZpcnN0IGBjb3VudGAgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSwgdGhlblxuICogY29tcGxldGVzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3Rha2UucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHRha2VgIHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG9ubHkgdGhlIGZpcnN0IGBjb3VudGAgdmFsdWVzIGVtaXR0ZWRcbiAqIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gSWYgdGhlIHNvdXJjZSBlbWl0cyBmZXdlciB0aGFuIGBjb3VudGAgdmFsdWVzIHRoZW5cbiAqIGFsbCBvZiBpdHMgdmFsdWVzIGFyZSBlbWl0dGVkLiBBZnRlciB0aGF0LCBpdCBjb21wbGV0ZXMsIHJlZ2FyZGxlc3MgaWYgdGhlXG4gKiBzb3VyY2UgY29tcGxldGVzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlRha2UgdGhlIGZpcnN0IDUgc2Vjb25kcyBvZiBhbiBpbmZpbml0ZSAxLXNlY29uZCBpbnRlcnZhbCBPYnNlcnZhYmxlPC9jYXB0aW9uPlxuICogdmFyIGludGVydmFsID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciBmaXZlID0gaW50ZXJ2YWwudGFrZSg1KTtcbiAqIGZpdmUuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIHRha2VMYXN0fVxuICogQHNlZSB7QGxpbmsgdGFrZVVudGlsfVxuICogQHNlZSB7QGxpbmsgdGFrZVdoaWxlfVxuICogQHNlZSB7QGxpbmsgc2tpcH1cbiAqXG4gKiBAdGhyb3dzIHtBcmd1bWVudE91dE9mUmFuZ2VFcnJvcn0gV2hlbiB1c2luZyBgdGFrZShpKWAsIGl0IGRlbGl2ZXJzIGFuXG4gKiBBcmd1bWVudE91dE9yUmFuZ2VFcnJvciB0byB0aGUgT2JzZXJ2ZXIncyBgZXJyb3JgIGNhbGxiYWNrIGlmIGBpIDwgMGAuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IFRoZSBtYXhpbXVtIG51bWJlciBvZiBgbmV4dGAgdmFsdWVzIHRvIGVtaXQuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgb25seSB0aGUgZmlyc3QgYGNvdW50YFxuICogdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBvciBhbGwgb2YgdGhlIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2VcbiAqIGlmIHRoZSBzb3VyY2UgZW1pdHMgZmV3ZXIgdGhhbiBgY291bnRgIHZhbHVlcy5cbiAqIEBtZXRob2QgdGFrZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gdGFrZShjb3VudCkge1xuICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IEVtcHR5T2JzZXJ2YWJsZV8xLkVtcHR5T2JzZXJ2YWJsZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlmdChuZXcgVGFrZU9wZXJhdG9yKGNvdW50KSk7XG4gICAgfVxufVxuZXhwb3J0cy50YWtlID0gdGFrZTtcbnZhciBUYWtlT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRha2VPcGVyYXRvcih0b3RhbCkge1xuICAgICAgICB0aGlzLnRvdGFsID0gdG90YWw7XG4gICAgICAgIGlmICh0aGlzLnRvdGFsIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yXzEuQXJndW1lbnRPdXRPZlJhbmdlRXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVGFrZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGFrZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy50b3RhbCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRha2VPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFRha2VTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFrZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFrZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIHRvdGFsKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICB9XG4gICAgVGFrZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciB0b3RhbCA9IHRoaXMudG90YWw7XG4gICAgICAgIHZhciBjb3VudCA9ICsrdGhpcy5jb3VudDtcbiAgICAgICAgaWYgKGNvdW50IDw9IHRvdGFsKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNvdW50ID09PSB0b3RhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUYWtlU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRha2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIEVtaXRzIHRoZSB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgdW50aWwgYSBgbm90aWZpZXJgXG4gKiBPYnNlcnZhYmxlIGVtaXRzIGEgdmFsdWUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkxldHMgdmFsdWVzIHBhc3MgdW50aWwgYSBzZWNvbmQgT2JzZXJ2YWJsZSxcbiAqIGBub3RpZmllcmAsIGVtaXRzIHNvbWV0aGluZy4gVGhlbiwgaXQgY29tcGxldGVzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3Rha2VVbnRpbC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgdGFrZVVudGlsYCBzdWJzY3JpYmVzIGFuZCBiZWdpbnMgbWlycm9yaW5nIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gSXQgYWxzb1xuICogbW9uaXRvcnMgYSBzZWNvbmQgT2JzZXJ2YWJsZSwgYG5vdGlmaWVyYCB0aGF0IHlvdSBwcm92aWRlLiBJZiB0aGUgYG5vdGlmaWVyYFxuICogZW1pdHMgYSB2YWx1ZSBvciBhIGNvbXBsZXRlIG5vdGlmaWNhdGlvbiwgdGhlIG91dHB1dCBPYnNlcnZhYmxlIHN0b3BzXG4gKiBtaXJyb3JpbmcgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGFuZCBjb21wbGV0ZXMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+VGljayBldmVyeSBzZWNvbmQgdW50aWwgdGhlIGZpcnN0IGNsaWNrIGhhcHBlbnM8L2NhcHRpb24+XG4gKiB2YXIgaW50ZXJ2YWwgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBpbnRlcnZhbC50YWtlVW50aWwoY2xpY2tzKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgdGFrZX1cbiAqIEBzZWUge0BsaW5rIHRha2VMYXN0fVxuICogQHNlZSB7QGxpbmsgdGFrZVdoaWxlfVxuICogQHNlZSB7QGxpbmsgc2tpcH1cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGV9IG5vdGlmaWVyIFRoZSBPYnNlcnZhYmxlIHdob3NlIGZpcnN0IGVtaXR0ZWQgdmFsdWUgd2lsbFxuICogY2F1c2UgdGhlIG91dHB1dCBPYnNlcnZhYmxlIG9mIGB0YWtlVW50aWxgIHRvIHN0b3AgZW1pdHRpbmcgdmFsdWVzIGZyb20gdGhlXG4gKiBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgdmFsdWVzIGZyb20gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSB1bnRpbCBzdWNoIHRpbWUgYXMgYG5vdGlmaWVyYCBlbWl0cyBpdHMgZmlyc3QgdmFsdWUuXG4gKiBAbWV0aG9kIHRha2VVbnRpbFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gdGFrZVVudGlsKG5vdGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgVGFrZVVudGlsT3BlcmF0b3Iobm90aWZpZXIpKTtcbn1cbmV4cG9ydHMudGFrZVVudGlsID0gdGFrZVVudGlsO1xudmFyIFRha2VVbnRpbE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWtlVW50aWxPcGVyYXRvcihub3RpZmllcikge1xuICAgICAgICB0aGlzLm5vdGlmaWVyID0gbm90aWZpZXI7XG4gICAgfVxuICAgIFRha2VVbnRpbE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGFrZVVudGlsU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm5vdGlmaWVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFrZVVudGlsT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBUYWtlVW50aWxTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFrZVVudGlsU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWtlVW50aWxTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBub3RpZmllcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMubm90aWZpZXIgPSBub3RpZmllcjtcbiAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBub3RpZmllcikpO1xuICAgIH1cbiAgICBUYWtlVW50aWxTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICB9O1xuICAgIFRha2VVbnRpbFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBub29wXG4gICAgfTtcbiAgICByZXR1cm4gVGFrZVVudGlsU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWtlVW50aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xuLyoqXG4gKiBFbWl0cyBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB0aGVuIGlnbm9yZXMgc3Vic2VxdWVudCBzb3VyY2VcbiAqIHZhbHVlcyBmb3IgYGR1cmF0aW9uYCBtaWxsaXNlY29uZHMsIHRoZW4gcmVwZWF0cyB0aGlzIHByb2Nlc3MuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkxldHMgYSB2YWx1ZSBwYXNzLCB0aGVuIGlnbm9yZXMgc291cmNlIHZhbHVlcyBmb3IgdGhlXG4gKiBuZXh0IGBkdXJhdGlvbmAgbWlsbGlzZWNvbmRzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3Rocm90dGxlVGltZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgdGhyb3R0bGVUaW1lYCBlbWl0cyB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZVxuICogd2hlbiBpdHMgaW50ZXJuYWwgdGltZXIgaXMgZGlzYWJsZWQsIGFuZCBpZ25vcmVzIHNvdXJjZSB2YWx1ZXMgd2hlbiB0aGUgdGltZXJcbiAqIGlzIGVuYWJsZWQuIEluaXRpYWxseSwgdGhlIHRpbWVyIGlzIGRpc2FibGVkLiBBcyBzb29uIGFzIHRoZSBmaXJzdCBzb3VyY2VcbiAqIHZhbHVlIGFycml2ZXMsIGl0IGlzIGZvcndhcmRlZCB0byB0aGUgb3V0cHV0IE9ic2VydmFibGUsIGFuZCB0aGVuIHRoZSB0aW1lclxuICogaXMgZW5hYmxlZC4gQWZ0ZXIgYGR1cmF0aW9uYCBtaWxsaXNlY29uZHMgKG9yIHRoZSB0aW1lIHVuaXQgZGV0ZXJtaW5lZFxuICogaW50ZXJuYWxseSBieSB0aGUgb3B0aW9uYWwgYHNjaGVkdWxlcmApIGhhcyBwYXNzZWQsIHRoZSB0aW1lciBpcyBkaXNhYmxlZCxcbiAqIGFuZCB0aGlzIHByb2Nlc3MgcmVwZWF0cyBmb3IgdGhlIG5leHQgc291cmNlIHZhbHVlLiBPcHRpb25hbGx5IHRha2VzIGFcbiAqIHtAbGluayBJU2NoZWR1bGVyfSBmb3IgbWFuYWdpbmcgdGltZXJzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgY2xpY2tzIGF0IGEgcmF0ZSBvZiBhdCBtb3N0IG9uZSBjbGljayBwZXIgc2Vjb25kPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MudGhyb3R0bGVUaW1lKDEwMDApO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBhdWRpdFRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZVRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWxheX1cbiAqIEBzZWUge0BsaW5rIHNhbXBsZVRpbWV9XG4gKiBAc2VlIHtAbGluayB0aHJvdHRsZX1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gVGltZSB0byB3YWl0IGJlZm9yZSBlbWl0dGluZyBhbm90aGVyIHZhbHVlIGFmdGVyXG4gKiBlbWl0dGluZyB0aGUgbGFzdCB2YWx1ZSwgbWVhc3VyZWQgaW4gbWlsbGlzZWNvbmRzIG9yIHRoZSB0aW1lIHVuaXQgZGV0ZXJtaW5lZFxuICogaW50ZXJuYWxseSBieSB0aGUgb3B0aW9uYWwgYHNjaGVkdWxlcmAuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1hc3luY10gVGhlIHtAbGluayBJU2NoZWR1bGVyfSB0byB1c2UgZm9yXG4gKiBtYW5hZ2luZyB0aGUgdGltZXJzIHRoYXQgaGFuZGxlIHRoZSBzYW1wbGluZy5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBwZXJmb3JtcyB0aGUgdGhyb3R0bGUgb3BlcmF0aW9uIHRvXG4gKiBsaW1pdCB0aGUgcmF0ZSBvZiBlbWlzc2lvbnMgZnJvbSB0aGUgc291cmNlLlxuICogQG1ldGhvZCB0aHJvdHRsZVRpbWVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlVGltZShkdXJhdGlvbiwgc2NoZWR1bGVyKSB7XG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7IH1cbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBUaHJvdHRsZVRpbWVPcGVyYXRvcihkdXJhdGlvbiwgc2NoZWR1bGVyKSk7XG59XG5leHBvcnRzLnRocm90dGxlVGltZSA9IHRocm90dGxlVGltZTtcbnZhciBUaHJvdHRsZVRpbWVPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGhyb3R0bGVUaW1lT3BlcmF0b3IoZHVyYXRpb24sIHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICBUaHJvdHRsZVRpbWVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFRocm90dGxlVGltZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5kdXJhdGlvbiwgdGhpcy5zY2hlZHVsZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBUaHJvdHRsZVRpbWVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFRocm90dGxlVGltZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaHJvdHRsZVRpbWVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRocm90dGxlVGltZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGR1cmF0aW9uLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICBUaHJvdHRsZVRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMudGhyb3R0bGVkKSB7XG4gICAgICAgICAgICB0aGlzLmFkZCh0aGlzLnRocm90dGxlZCA9IHRoaXMuc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoTmV4dCwgdGhpcy5kdXJhdGlvbiwgeyBzdWJzY3JpYmVyOiB0aGlzIH0pKTtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRocm90dGxlVGltZVN1YnNjcmliZXIucHJvdG90eXBlLmNsZWFyVGhyb3R0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aHJvdHRsZWQgPSB0aGlzLnRocm90dGxlZDtcbiAgICAgICAgaWYgKHRocm90dGxlZCkge1xuICAgICAgICAgICAgdGhyb3R0bGVkLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZSh0aHJvdHRsZWQpO1xuICAgICAgICAgICAgdGhpcy50aHJvdHRsZWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVGhyb3R0bGVUaW1lU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmZ1bmN0aW9uIGRpc3BhdGNoTmV4dChhcmcpIHtcbiAgICB2YXIgc3Vic2NyaWJlciA9IGFyZy5zdWJzY3JpYmVyO1xuICAgIHN1YnNjcmliZXIuY2xlYXJUaHJvdHRsZSgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhyb3R0bGVUaW1lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQ29tYmluZXMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdpdGggb3RoZXIgT2JzZXJ2YWJsZXMgdG8gY3JlYXRlIGFuIE9ic2VydmFibGVcbiAqIHdob3NlIHZhbHVlcyBhcmUgY2FsY3VsYXRlZCBmcm9tIHRoZSBsYXRlc3QgdmFsdWVzIG9mIGVhY2gsIG9ubHkgd2hlbiB0aGVcbiAqIHNvdXJjZSBlbWl0cy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+V2hlbmV2ZXIgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGVtaXRzIGEgdmFsdWUsIGl0XG4gKiBjb21wdXRlcyBhIGZvcm11bGEgdXNpbmcgdGhhdCB2YWx1ZSBwbHVzIHRoZSBsYXRlc3QgdmFsdWVzIGZyb20gb3RoZXIgaW5wdXRcbiAqIE9ic2VydmFibGVzLCB0aGVuIGVtaXRzIHRoZSBvdXRwdXQgb2YgdGhhdCBmb3JtdWxhLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3dpdGhMYXRlc3RGcm9tLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGB3aXRoTGF0ZXN0RnJvbWAgY29tYmluZXMgZWFjaCB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSAodGhlXG4gKiBpbnN0YW5jZSkgd2l0aCB0aGUgbGF0ZXN0IHZhbHVlcyBmcm9tIHRoZSBvdGhlciBpbnB1dCBPYnNlcnZhYmxlcyBvbmx5IHdoZW5cbiAqIHRoZSBzb3VyY2UgZW1pdHMgYSB2YWx1ZSwgb3B0aW9uYWxseSB1c2luZyBhIGBwcm9qZWN0YCBmdW5jdGlvbiB0byBkZXRlcm1pbmVcbiAqIHRoZSB2YWx1ZSB0byBiZSBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS4gQWxsIGlucHV0IE9ic2VydmFibGVzIG11c3RcbiAqIGVtaXQgYXQgbGVhc3Qgb25lIHZhbHVlIGJlZm9yZSB0aGUgb3V0cHV0IE9ic2VydmFibGUgd2lsbCBlbWl0IGEgdmFsdWUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+T24gZXZlcnkgY2xpY2sgZXZlbnQsIGVtaXQgYW4gYXJyYXkgd2l0aCB0aGUgbGF0ZXN0IHRpbWVyIGV2ZW50IHBsdXMgdGhlIGNsaWNrIGV2ZW50PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciB0aW1lciA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLndpdGhMYXRlc3RGcm9tKHRpbWVyKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgY29tYmluZUxhdGVzdH1cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGVJbnB1dH0gb3RoZXIgQW4gaW5wdXQgT2JzZXJ2YWJsZSB0byBjb21iaW5lIHdpdGggdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZS4gTW9yZSB0aGFuIG9uZSBpbnB1dCBPYnNlcnZhYmxlcyBtYXkgYmUgZ2l2ZW4gYXMgYXJndW1lbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvamVjdF0gUHJvamVjdGlvbiBmdW5jdGlvbiBmb3IgY29tYmluaW5nIHZhbHVlc1xuICogdG9nZXRoZXIuIFJlY2VpdmVzIGFsbCB2YWx1ZXMgaW4gb3JkZXIgb2YgdGhlIE9ic2VydmFibGVzIHBhc3NlZCwgd2hlcmUgdGhlXG4gKiBmaXJzdCBwYXJhbWV0ZXIgaXMgYSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gKGUuZy5cbiAqIGBhLndpdGhMYXRlc3RGcm9tKGIsIGMsIChhMSwgYjEsIGMxKSA9PiBhMSArIGIxICsgYzEpYCkuIElmIHRoaXMgaXMgbm90XG4gKiBwYXNzZWQsIGFycmF5cyB3aWxsIGJlIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBvZiBwcm9qZWN0ZWQgdmFsdWVzIGZyb20gdGhlIG1vc3QgcmVjZW50XG4gKiB2YWx1ZXMgZnJvbSBlYWNoIGlucHV0IE9ic2VydmFibGUsIG9yIGFuIGFycmF5IG9mIHRoZSBtb3N0IHJlY2VudCB2YWx1ZXMgZnJvbVxuICogZWFjaCBpbnB1dCBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCB3aXRoTGF0ZXN0RnJvbVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gd2l0aExhdGVzdEZyb20oKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgcHJvamVjdDtcbiAgICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm9qZWN0ID0gYXJncy5wb3AoKTtcbiAgICB9XG4gICAgdmFyIG9ic2VydmFibGVzID0gYXJncztcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBXaXRoTGF0ZXN0RnJvbU9wZXJhdG9yKG9ic2VydmFibGVzLCBwcm9qZWN0KSk7XG59XG5leHBvcnRzLndpdGhMYXRlc3RGcm9tID0gd2l0aExhdGVzdEZyb207XG52YXIgV2l0aExhdGVzdEZyb21PcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV2l0aExhdGVzdEZyb21PcGVyYXRvcihvYnNlcnZhYmxlcywgcHJvamVjdCkge1xuICAgICAgICB0aGlzLm9ic2VydmFibGVzID0gb2JzZXJ2YWJsZXM7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgfVxuICAgIFdpdGhMYXRlc3RGcm9tT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBXaXRoTGF0ZXN0RnJvbVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5vYnNlcnZhYmxlcywgdGhpcy5wcm9qZWN0KSk7XG4gICAgfTtcbiAgICByZXR1cm4gV2l0aExhdGVzdEZyb21PcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFdpdGhMYXRlc3RGcm9tU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFdpdGhMYXRlc3RGcm9tU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXaXRoTGF0ZXN0RnJvbVN1YnNjcmliZXIoZGVzdGluYXRpb24sIG9ic2VydmFibGVzLCBwcm9qZWN0KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlcyA9IG9ic2VydmFibGVzO1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLnRvUmVzcG9uZCA9IFtdO1xuICAgICAgICB2YXIgbGVuID0gb2JzZXJ2YWJsZXMubGVuZ3RoO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnRvUmVzcG9uZC5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvYnNlcnZhYmxlID0gb2JzZXJ2YWJsZXNbaV07XG4gICAgICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIG9ic2VydmFibGUsIG9ic2VydmFibGUsIGkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBXaXRoTGF0ZXN0RnJvbVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy52YWx1ZXNbb3V0ZXJJbmRleF0gPSBpbm5lclZhbHVlO1xuICAgICAgICB2YXIgdG9SZXNwb25kID0gdGhpcy50b1Jlc3BvbmQ7XG4gICAgICAgIGlmICh0b1Jlc3BvbmQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGZvdW5kID0gdG9SZXNwb25kLmluZGV4T2Yob3V0ZXJJbmRleCk7XG4gICAgICAgICAgICBpZiAoZm91bmQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdG9SZXNwb25kLnNwbGljZShmb3VuZCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdpdGhMYXRlc3RGcm9tU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIG5vb3BcbiAgICB9O1xuICAgIFdpdGhMYXRlc3RGcm9tU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMudG9SZXNwb25kLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbdmFsdWVdLmNvbmNhdCh0aGlzLnZhbHVlcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9qZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJ5UHJvamVjdChhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyLnByb3RvdHlwZS5fdHJ5UHJvamVjdCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByb2plY3QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFdpdGhMYXRlc3RGcm9tU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aXRoTGF0ZXN0RnJvbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIEFycmF5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9BcnJheU9ic2VydmFibGUnKTtcbnZhciBpc0FycmF5XzEgPSByZXF1aXJlKCcuLi91dGlsL2lzQXJyYXknKTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xudmFyIGl0ZXJhdG9yXzEgPSByZXF1aXJlKCcuLi9zeW1ib2wvaXRlcmF0b3InKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIEBwYXJhbSBvYnNlcnZhYmxlc1xuICogQHJldHVybiB7T2JzZXJ2YWJsZTxSPn1cbiAqIEBtZXRob2QgemlwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB6aXBQcm90bygpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYnNlcnZhYmxlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGlmdC5jYWxsKHppcFN0YXRpYy5hcHBseSh2b2lkIDAsIFt0aGlzXS5jb25jYXQob2JzZXJ2YWJsZXMpKSk7XG59XG5leHBvcnRzLnppcFByb3RvID0gemlwUHJvdG87XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBDb21iaW5lcyBtdWx0aXBsZSBPYnNlcnZhYmxlcyB0byBjcmVhdGUgYW4gT2JzZXJ2YWJsZSB3aG9zZSB2YWx1ZXMgYXJlIGNhbGN1bGF0ZWQgZnJvbSB0aGUgdmFsdWVzLCBpbiBvcmRlciwgb2YgZWFjaFxuICogb2YgaXRzIGlucHV0IE9ic2VydmFibGVzLlxuICpcbiAqIElmIHRoZSBsYXRlc3QgcGFyYW1ldGVyIGlzIGEgZnVuY3Rpb24sIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBjb21wdXRlIHRoZSBjcmVhdGVkIHZhbHVlIGZyb20gdGhlIGlucHV0IHZhbHVlcy5cbiAqIE90aGVyd2lzZSwgYW4gYXJyYXkgb2YgdGhlIGlucHV0IHZhbHVlcyBpcyByZXR1cm5lZC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db21iaW5lIGFnZSBhbmQgbmFtZSBmcm9tIGRpZmZlcmVudCBzb3VyY2VzPC9jYXB0aW9uPlxuICpcbiAqIGxldCBhZ2UkID0gT2JzZXJ2YWJsZS5vZjxudW1iZXI+KDI3LCAyNSwgMjkpO1xuICogbGV0IG5hbWUkID0gT2JzZXJ2YWJsZS5vZjxzdHJpbmc+KCdGb28nLCAnQmFyJywgJ0JlZXInKTtcbiAqIGxldCBpc0RldiQgPSBPYnNlcnZhYmxlLm9mPGJvb2xlYW4+KHRydWUsIHRydWUsIGZhbHNlKTtcbiAqXG4gKiBPYnNlcnZhYmxlXG4gKiAgICAgLnppcChhZ2UkLFxuICogICAgICAgICAgbmFtZSQsXG4gKiAgICAgICAgICBpc0RldiQsXG4gKiAgICAgICAgICAoYWdlOiBudW1iZXIsIG5hbWU6IHN0cmluZywgaXNEZXY6IGJvb2xlYW4pID0+ICh7IGFnZSwgbmFtZSwgaXNEZXYgfSkpXG4gKiAgICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBvdXRwdXRzXG4gKiAvLyB7IGFnZTogMjcsIG5hbWU6ICdGb28nLCBpc0RldjogdHJ1ZSB9XG4gKiAvLyB7IGFnZTogMjUsIG5hbWU6ICdCYXInLCBpc0RldjogdHJ1ZSB9XG4gKiAvLyB7IGFnZTogMjksIG5hbWU6ICdCZWVyJywgaXNEZXY6IGZhbHNlIH1cbiAqXG4gKiBAcGFyYW0gb2JzZXJ2YWJsZXNcbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj59XG4gKiBAc3RhdGljIHRydWVcbiAqIEBuYW1lIHppcFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gemlwU3RhdGljKCkge1xuICAgIHZhciBvYnNlcnZhYmxlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9ic2VydmFibGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgcHJvamVjdCA9IG9ic2VydmFibGVzW29ic2VydmFibGVzLmxlbmd0aCAtIDFdO1xuICAgIGlmICh0eXBlb2YgcHJvamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvYnNlcnZhYmxlcy5wb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcnJheU9ic2VydmFibGVfMS5BcnJheU9ic2VydmFibGUob2JzZXJ2YWJsZXMpLmxpZnQobmV3IFppcE9wZXJhdG9yKHByb2plY3QpKTtcbn1cbmV4cG9ydHMuemlwU3RhdGljID0gemlwU3RhdGljO1xudmFyIFppcE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBaaXBPcGVyYXRvcihwcm9qZWN0KSB7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgfVxuICAgIFppcE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgWmlwU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QpKTtcbiAgICB9O1xuICAgIHJldHVybiBaaXBPcGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLlppcE9wZXJhdG9yID0gWmlwT3BlcmF0b3I7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFppcFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhaaXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFppcFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByb2plY3QsIHZhbHVlcykge1xuICAgICAgICBpZiAodmFsdWVzID09PSB2b2lkIDApIHsgdmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuaXRlcmF0b3JzID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlID0gMDtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gKHR5cGVvZiBwcm9qZWN0ID09PSAnZnVuY3Rpb24nKSA/IHByb2plY3QgOiBudWxsO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgICB9XG4gICAgWmlwU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9ycyA9IHRoaXMuaXRlcmF0b3JzO1xuICAgICAgICBpZiAoaXNBcnJheV8xLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBpdGVyYXRvcnMucHVzaChuZXcgU3RhdGljQXJyYXlJdGVyYXRvcih2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZVtpdGVyYXRvcl8xLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaXRlcmF0b3JzLnB1c2gobmV3IFN0YXRpY0l0ZXJhdG9yKHZhbHVlW2l0ZXJhdG9yXzEuaXRlcmF0b3JdKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZXJhdG9ycy5wdXNoKG5ldyBaaXBCdWZmZXJJdGVyYXRvcih0aGlzLmRlc3RpbmF0aW9uLCB0aGlzLCB2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpdGVyYXRvcnMgPSB0aGlzLml0ZXJhdG9ycztcbiAgICAgICAgdmFyIGxlbiA9IGl0ZXJhdG9ycy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZSA9IGxlbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JzW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLnN0aWxsVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoaXRlcmF0b3Iuc3Vic2NyaWJlKGl0ZXJhdG9yLCBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZS0tOyAvLyBub3QgYW4gb2JzZXJ2YWJsZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlJbmFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUtLTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFppcFN1YnNjcmliZXIucHJvdG90eXBlLmNoZWNrSXRlcmF0b3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXRlcmF0b3JzID0gdGhpcy5pdGVyYXRvcnM7XG4gICAgICAgIHZhciBsZW4gPSBpdGVyYXRvcnMubGVuZ3RoO1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICAvLyBhYm9ydCBpZiBub3QgYWxsIG9mIHRoZW0gaGF2ZSB2YWx1ZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JzW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvci5oYXNWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXRlcmF0b3IuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hvdWxkQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JzW2ldO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiBpdCdzIGNvbXBsZXRlZCBub3cgdGhhdCB5b3UndmUgZ290dGVuXG4gICAgICAgICAgICAvLyB0aGUgbmV4dCB2YWx1ZS5cbiAgICAgICAgICAgIGlmIChpdGVyYXRvci5oYXNDb21wbGV0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHNob3VsZENvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJncy5wdXNoKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvamVjdCkge1xuICAgICAgICAgICAgdGhpcy5fdHJ5UHJvamVjdChhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZENvbXBsZXRlKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fdHJ5UHJvamVjdCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByb2plY3QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFppcFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLlppcFN1YnNjcmliZXIgPSBaaXBTdWJzY3JpYmVyO1xudmFyIFN0YXRpY0l0ZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0aWNJdGVyYXRvcihpdGVyYXRvcikge1xuICAgICAgICB0aGlzLml0ZXJhdG9yID0gaXRlcmF0b3I7XG4gICAgICAgIHRoaXMubmV4dFJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICB9XG4gICAgU3RhdGljSXRlcmF0b3IucHJvdG90eXBlLmhhc1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFN0YXRpY0l0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5uZXh0UmVzdWx0O1xuICAgICAgICB0aGlzLm5leHRSZXN1bHQgPSB0aGlzLml0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFN0YXRpY0l0ZXJhdG9yLnByb3RvdHlwZS5oYXNDb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXh0UmVzdWx0ID0gdGhpcy5uZXh0UmVzdWx0O1xuICAgICAgICByZXR1cm4gbmV4dFJlc3VsdCAmJiBuZXh0UmVzdWx0LmRvbmU7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGljSXRlcmF0b3I7XG59KCkpO1xudmFyIFN0YXRpY0FycmF5SXRlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRpY0FycmF5SXRlcmF0b3IoYXJyYXkpIHtcbiAgICAgICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICB9XG4gICAgU3RhdGljQXJyYXlJdGVyYXRvci5wcm90b3R5cGVbaXRlcmF0b3JfMS5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU3RhdGljQXJyYXlJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgICAgcmV0dXJuIGkgPCB0aGlzLmxlbmd0aCA/IHsgdmFsdWU6IGFycmF5W2ldLCBkb25lOiBmYWxzZSB9IDogeyB2YWx1ZTogbnVsbCwgZG9uZTogdHJ1ZSB9O1xuICAgIH07XG4gICAgU3RhdGljQXJyYXlJdGVyYXRvci5wcm90b3R5cGUuaGFzVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aCA+IHRoaXMuaW5kZXg7XG4gICAgfTtcbiAgICBTdGF0aWNBcnJheUl0ZXJhdG9yLnByb3RvdHlwZS5oYXNDb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aCA9PT0gdGhpcy5pbmRleDtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0aWNBcnJheUl0ZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgWmlwQnVmZmVySXRlcmF0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhaaXBCdWZmZXJJdGVyYXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBaaXBCdWZmZXJJdGVyYXRvcihkZXN0aW5hdGlvbiwgcGFyZW50LCBvYnNlcnZhYmxlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZSA9IG9ic2VydmFibGU7XG4gICAgICAgIHRoaXMuc3RpbGxVbnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmlzQ29tcGxldGUgPSBmYWxzZTtcbiAgICB9XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlW2l0ZXJhdG9yXzEuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8vIE5PVEU6IHRoZXJlIGlzIGFjdHVhbGx5IGEgbmFtZSBjb2xsaXNpb24gaGVyZSB3aXRoIFN1YnNjcmliZXIubmV4dCBhbmQgSXRlcmF0b3IubmV4dFxuICAgIC8vICAgIHRoaXMgaXMgbGVnaXQgYmVjYXVzZSBgbmV4dCgpYCB3aWxsIG5ldmVyIGJlIGNhbGxlZCBieSBhIHN1YnNjcmlwdGlvbiBpbiB0aGlzIGNhc2UuXG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDAgJiYgdGhpcy5pc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbnVsbCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGJ1ZmZlci5zaGlmdCgpLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGUuaGFzVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5sZW5ndGggPiAwO1xuICAgIH07XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLmhhc0NvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmlzQ29tcGxldGU7XG4gICAgfTtcbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmlzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQubm90aWZ5SW5hY3RpdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaChpbm5lclZhbHVlKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuY2hlY2tJdGVyYXRvcnMoKTtcbiAgICB9O1xuICAgIFppcEJ1ZmZlckl0ZXJhdG9yLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHRoaXMub2JzZXJ2YWJsZSwgdGhpcywgaW5kZXgpO1xuICAgIH07XG4gICAgcmV0dXJuIFppcEJ1ZmZlckl0ZXJhdG9yO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXppcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaXB0aW9uJyk7XG4vKipcbiAqIEEgdW5pdCBvZiB3b3JrIHRvIGJlIGV4ZWN1dGVkIGluIGEge0BsaW5rIFNjaGVkdWxlcn0uIEFuIGFjdGlvbiBpcyB0eXBpY2FsbHlcbiAqIGNyZWF0ZWQgZnJvbSB3aXRoaW4gYSBTY2hlZHVsZXIgYW5kIGFuIFJ4SlMgdXNlciBkb2VzIG5vdCBuZWVkIHRvIGNvbmNlcm5cbiAqIHRoZW1zZWx2ZXMgYWJvdXQgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBhbiBBY3Rpb24uXG4gKlxuICogYGBgdHNcbiAqIGNsYXNzIEFjdGlvbjxUPiBleHRlbmRzIFN1YnNjcmlwdGlvbiB7XG4gKiAgIG5ldyAoc2NoZWR1bGVyOiBTY2hlZHVsZXIsIHdvcms6IChzdGF0ZT86IFQpID0+IHZvaWQpO1xuICogICBzY2hlZHVsZShzdGF0ZT86IFQsIGRlbGF5OiBudW1iZXIgPSAwKTogU3Vic2NyaXB0aW9uO1xuICogfVxuICogYGBgXG4gKlxuICogQGNsYXNzIEFjdGlvbjxUPlxuICovXG52YXIgQWN0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjdGlvbihzY2hlZHVsZXIsIHdvcmspIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyB0aGlzIGFjdGlvbiBvbiBpdHMgcGFyZW50IFNjaGVkdWxlciBmb3IgZXhlY3V0aW9uLiBNYXkgYmUgcGFzc2VkXG4gICAgICogc29tZSBjb250ZXh0IG9iamVjdCwgYHN0YXRlYC4gTWF5IGhhcHBlbiBhdCBzb21lIHBvaW50IGluIHRoZSBmdXR1cmUsXG4gICAgICogYWNjb3JkaW5nIHRvIHRoZSBgZGVsYXlgIHBhcmFtZXRlciwgaWYgc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7VH0gW3N0YXRlXSBTb21lIGNvbnRleHR1YWwgZGF0YSB0aGF0IHRoZSBgd29ya2AgZnVuY3Rpb24gdXNlcyB3aGVuXG4gICAgICogY2FsbGVkIGJ5IHRoZSBTY2hlZHVsZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheV0gVGltZSB0byB3YWl0IGJlZm9yZSBleGVjdXRpbmcgdGhlIHdvcmssIHdoZXJlIHRoZVxuICAgICAqIHRpbWUgdW5pdCBpcyBpbXBsaWNpdCBhbmQgZGVmaW5lZCBieSB0aGUgU2NoZWR1bGVyLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgQWN0aW9uLnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIEFjdGlvbjtcbn0oU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKSk7XG5leHBvcnRzLkFjdGlvbiA9IEFjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFjdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvcm9vdCcpO1xudmFyIEFjdGlvbl8xID0gcmVxdWlyZSgnLi9BY3Rpb24nKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgQXN5bmNBY3Rpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBc3luY0FjdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBc3luY0FjdGlvbihzY2hlZHVsZXIsIHdvcmspIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc2NoZWR1bGVyLCB3b3JrKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMud29yayA9IHdvcms7XG4gICAgICAgIHRoaXMucGVuZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsd2F5cyByZXBsYWNlIHRoZSBjdXJyZW50IHN0YXRlIHdpdGggdGhlIG5ldyBzdGF0ZS5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAvLyBTZXQgdGhlIHBlbmRpbmcgZmxhZyBpbmRpY2F0aW5nIHRoYXQgdGhpcyBhY3Rpb24gaGFzIGJlZW4gc2NoZWR1bGVkLCBvclxuICAgICAgICAvLyBoYXMgcmVjdXJzaXZlbHkgcmVzY2hlZHVsZWQgaXRzZWxmLlxuICAgICAgICB0aGlzLnBlbmRpbmcgPSB0cnVlO1xuICAgICAgICB2YXIgaWQgPSB0aGlzLmlkO1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEltcG9ydGFudCBpbXBsZW1lbnRhdGlvbiBub3RlOlxuICAgICAgICAvL1xuICAgICAgICAvLyBBY3Rpb25zIG9ubHkgZXhlY3V0ZSBvbmNlIGJ5IGRlZmF1bHQsIHVubGVzcyByZXNjaGVkdWxlZCBmcm9tIHdpdGhpbiB0aGVcbiAgICAgICAgLy8gc2NoZWR1bGVkIGNhbGxiYWNrLiBUaGlzIGFsbG93cyB1cyB0byBpbXBsZW1lbnQgc2luZ2xlIGFuZCByZXBlYXRcbiAgICAgICAgLy8gYWN0aW9ucyB2aWEgdGhlIHNhbWUgY29kZSBwYXRoLCB3aXRob3V0IGFkZGluZyBBUEkgc3VyZmFjZSBhcmVhLCBhcyB3ZWxsXG4gICAgICAgIC8vIGFzIG1pbWljIHRyYWRpdGlvbmFsIHJlY3Vyc2lvbiBidXQgYWNyb3NzIGFzeW5jaHJvbm91cyBib3VuZGFyaWVzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBIb3dldmVyLCBKUyBydW50aW1lcyBhbmQgdGltZXJzIGRpc3Rpbmd1aXNoIGJldHdlZW4gaW50ZXJ2YWxzIGFjaGlldmVkIGJ5XG4gICAgICAgIC8vIHNlcmlhbCBgc2V0VGltZW91dGAgY2FsbHMgdnMuIGEgc2luZ2xlIGBzZXRJbnRlcnZhbGAgY2FsbC4gQW4gaW50ZXJ2YWwgb2ZcbiAgICAgICAgLy8gc2VyaWFsIGBzZXRUaW1lb3V0YCBjYWxscyBjYW4gYmUgaW5kaXZpZHVhbGx5IGRlbGF5ZWQsIHdoaWNoIGRlbGF5c1xuICAgICAgICAvLyBzY2hlZHVsaW5nIHRoZSBuZXh0IGBzZXRUaW1lb3V0YCwgYW5kIHNvIG9uLiBgc2V0SW50ZXJ2YWxgIGF0dGVtcHRzIHRvXG4gICAgICAgIC8vIGd1YXJhbnRlZSB0aGUgaW50ZXJ2YWwgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkIG1vcmUgcHJlY2lzZWx5IHRvIHRoZVxuICAgICAgICAvLyBpbnRlcnZhbCBwZXJpb2QsIHJlZ2FyZGxlc3Mgb2YgbG9hZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlcmVmb3JlLCB3ZSB1c2UgYHNldEludGVydmFsYCB0byBzY2hlZHVsZSBzaW5nbGUgYW5kIHJlcGVhdCBhY3Rpb25zLlxuICAgICAgICAvLyBJZiB0aGUgYWN0aW9uIHJlc2NoZWR1bGVzIGl0c2VsZiB3aXRoIHRoZSBzYW1lIGRlbGF5LCB0aGUgaW50ZXJ2YWwgaXMgbm90XG4gICAgICAgIC8vIGNhbmNlbGVkLiBJZiB0aGUgYWN0aW9uIGRvZXNuJ3QgcmVzY2hlZHVsZSwgb3IgcmVzY2hlZHVsZXMgd2l0aCBhXG4gICAgICAgIC8vIGRpZmZlcmVudCBkZWxheSwgdGhlIGludGVydmFsIHdpbGwgYmUgY2FuY2VsZWQgYWZ0ZXIgc2NoZWR1bGVkIGNhbGxiYWNrXG4gICAgICAgIC8vIGV4ZWN1dGlvbi5cbiAgICAgICAgLy9cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSB0aGlzLnJlY3ljbGVBc3luY0lkKHNjaGVkdWxlciwgaWQsIGRlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgICAgIC8vIElmIHRoaXMgYWN0aW9uIGhhcyBhbHJlYWR5IGFuIGFzeW5jIElkLCBkb24ndCByZXF1ZXN0IGEgbmV3IG9uZS5cbiAgICAgICAgdGhpcy5pZCA9IHRoaXMuaWQgfHwgdGhpcy5yZXF1ZXN0QXN5bmNJZChzY2hlZHVsZXIsIHRoaXMuaWQsIGRlbGF5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUucmVxdWVzdEFzeW5jSWQgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBpZCwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIHJldHVybiByb290XzEucm9vdC5zZXRJbnRlcnZhbChzY2hlZHVsZXIuZmx1c2guYmluZChzY2hlZHVsZXIsIHRoaXMpLCBkZWxheSk7XG4gICAgfTtcbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUucmVjeWNsZUFzeW5jSWQgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBpZCwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIC8vIElmIHRoaXMgYWN0aW9uIGlzIHJlc2NoZWR1bGVkIHdpdGggdGhlIHNhbWUgZGVsYXkgdGltZSwgZG9uJ3QgY2xlYXIgdGhlIGludGVydmFsIGlkLlxuICAgICAgICBpZiAoZGVsYXkgIT09IG51bGwgJiYgdGhpcy5kZWxheSA9PT0gZGVsYXkgJiYgdGhpcy5wZW5kaW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgaWYgdGhlIGFjdGlvbidzIGRlbGF5IHRpbWUgaXMgZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgZGVsYXksXG4gICAgICAgIC8vIG9yIHRoZSBhY3Rpb24gaGFzIGJlZW4gcmVzY2hlZHVsZWQgYmVmb3JlIGl0J3MgZXhlY3V0ZWQsIGNsZWFyIHRoZSBpbnRlcnZhbCBpZFxuICAgICAgICByZXR1cm4gcm9vdF8xLnJvb3QuY2xlYXJJbnRlcnZhbChpZCkgJiYgdW5kZWZpbmVkIHx8IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEltbWVkaWF0ZWx5IGV4ZWN1dGVzIHRoaXMgYWN0aW9uIGFuZCB0aGUgYHdvcmtgIGl0IGNvbnRhaW5zLlxuICAgICAqIEByZXR1cm4ge2FueX1cbiAgICAgKi9cbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdleGVjdXRpbmcgYSBjYW5jZWxsZWQgYWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHZhciBlcnJvciA9IHRoaXMuX2V4ZWN1dGUoc3RhdGUsIGRlbGF5KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wZW5kaW5nID09PSBmYWxzZSAmJiB0aGlzLmlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIERlcXVldWUgaWYgdGhlIGFjdGlvbiBkaWRuJ3QgcmVzY2hlZHVsZSBpdHNlbGYuIERvbid0IGNhbGxcbiAgICAgICAgICAgIC8vIHVuc3Vic2NyaWJlKCksIGJlY2F1c2UgdGhlIGFjdGlvbiBjb3VsZCByZXNjaGVkdWxlIGxhdGVyLlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6XG4gICAgICAgICAgICAvLyBgYGBcbiAgICAgICAgICAgIC8vIHNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiBkb1dvcmsoY291bnRlcikge1xuICAgICAgICAgICAgLy8gICAvKiAuLi4gSSdtIGEgYnVzeSB3b3JrZXIgYmVlIC4uLiAqL1xuICAgICAgICAgICAgLy8gICB2YXIgb3JpZ2luYWxBY3Rpb24gPSB0aGlzO1xuICAgICAgICAgICAgLy8gICAvKiB3YWl0IDEwMG1zIGJlZm9yZSByZXNjaGVkdWxpbmcgdGhlIGFjdGlvbiAqL1xuICAgICAgICAgICAgLy8gICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vICAgICBvcmlnaW5hbEFjdGlvbi5zY2hlZHVsZShjb3VudGVyICsgMSk7XG4gICAgICAgICAgICAvLyAgIH0sIDEwMCk7XG4gICAgICAgICAgICAvLyB9LCAxMDAwKTtcbiAgICAgICAgICAgIC8vIGBgYFxuICAgICAgICAgICAgdGhpcy5pZCA9IHRoaXMucmVjeWNsZUFzeW5jSWQodGhpcy5zY2hlZHVsZXIsIHRoaXMuaWQsIG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUuX2V4ZWN1dGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlbGF5KSB7XG4gICAgICAgIHZhciBlcnJvcmVkID0gZmFsc2U7XG4gICAgICAgIHZhciBlcnJvclZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy53b3JrKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3JlZCA9IHRydWU7XG4gICAgICAgICAgICBlcnJvclZhbHVlID0gISFlICYmIGUgfHwgbmV3IEVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcmVkKSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JWYWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5pZDtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICB2YXIgYWN0aW9ucyA9IHNjaGVkdWxlci5hY3Rpb25zO1xuICAgICAgICB2YXIgaW5kZXggPSBhY3Rpb25zLmluZGV4T2YodGhpcyk7XG4gICAgICAgIHRoaXMud29yayA9IG51bGw7XG4gICAgICAgIHRoaXMuZGVsYXkgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gbnVsbDtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgYWN0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gdGhpcy5yZWN5Y2xlQXN5bmNJZChzY2hlZHVsZXIsIGlkLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFzeW5jQWN0aW9uO1xufShBY3Rpb25fMS5BY3Rpb24pKTtcbmV4cG9ydHMuQXN5bmNBY3Rpb24gPSBBc3luY0FjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzeW5jQWN0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuLi9TY2hlZHVsZXInKTtcbnZhciBBc3luY1NjaGVkdWxlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFzeW5jU2NoZWR1bGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFzeW5jU2NoZWR1bGVyKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciB0aGUgU2NoZWR1bGVyIGlzIGN1cnJlbnRseSBleGVjdXRpbmcgYSBiYXRjaCBvZlxuICAgICAgICAgKiBxdWV1ZWQgYWN0aW9ucy5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaW50ZXJuYWwgSUQgdXNlZCB0byB0cmFjayB0aGUgbGF0ZXN0IGFzeW5jaHJvbm91cyB0YXNrIHN1Y2ggYXMgdGhvc2VcbiAgICAgICAgICogY29taW5nIGZyb20gYHNldFRpbWVvdXRgLCBgc2V0SW50ZXJ2YWxgLCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCwgYW5kXG4gICAgICAgICAqIG90aGVycy5cbiAgICAgICAgICogQHR5cGUge2FueX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2NoZWR1bGVkID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBBc3luY1NjaGVkdWxlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHZhciBhY3Rpb25zID0gdGhpcy5hY3Rpb25zO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChhY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgPSBhY3Rpb24uZXhlY3V0ZShhY3Rpb24uc3RhdGUsIGFjdGlvbi5kZWxheSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoYWN0aW9uID0gYWN0aW9ucy5zaGlmdCgpKTsgLy8gZXhoYXVzdCB0aGUgc2NoZWR1bGVyIHF1ZXVlXG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgd2hpbGUgKGFjdGlvbiA9IGFjdGlvbnMuc2hpZnQoKSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBc3luY1NjaGVkdWxlcjtcbn0oU2NoZWR1bGVyXzEuU2NoZWR1bGVyKSk7XG5leHBvcnRzLkFzeW5jU2NoZWR1bGVyID0gQXN5bmNTY2hlZHVsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bc3luY1NjaGVkdWxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi91dGlsL3Jvb3QnKTtcbmZ1bmN0aW9uIHN5bWJvbEl0ZXJhdG9yUG9ueWZpbGwocm9vdCkge1xuICAgIHZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoIVN5bWJvbC5pdGVyYXRvcikge1xuICAgICAgICAgICAgU3ltYm9sLml0ZXJhdG9yID0gU3ltYm9sKCdpdGVyYXRvciBwb2x5ZmlsbCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTeW1ib2wuaXRlcmF0b3I7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBbZm9yIE1vemlsbGEgR2Vja28gMjctMzU6XShodHRwczovL216bC5sYS8yZXdFMXpDKVxuICAgICAgICB2YXIgU2V0XzEgPSByb290LlNldDtcbiAgICAgICAgaWYgKFNldF8xICYmIHR5cGVvZiBuZXcgU2V0XzEoKVsnQEBpdGVyYXRvciddID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0BAaXRlcmF0b3InO1xuICAgICAgICB9XG4gICAgICAgIHZhciBNYXBfMSA9IHJvb3QuTWFwO1xuICAgICAgICAvLyByZXF1aXJlZCBmb3IgY29tcGF0YWJpbGl0eSB3aXRoIGVzNi1zaGltXG4gICAgICAgIGlmIChNYXBfMSkge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhNYXBfMS5wcm90b3R5cGUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgLy8gYWNjb3JkaW5nIHRvIHNwZWMsIE1hcC5wcm90b3R5cGVbQEBpdGVyYXRvcl0gYW5kIE1hcC5vcm90b3R5cGUuZW50cmllcyBtdXN0IGJlIGVxdWFsLlxuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdlbnRyaWVzJyAmJiBrZXkgIT09ICdzaXplJyAmJiBNYXBfMS5wcm90b3R5cGVba2V5XSA9PT0gTWFwXzEucHJvdG90eXBlWydlbnRyaWVzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdAQGl0ZXJhdG9yJztcbiAgICB9XG59XG5leHBvcnRzLnN5bWJvbEl0ZXJhdG9yUG9ueWZpbGwgPSBzeW1ib2xJdGVyYXRvclBvbnlmaWxsO1xuZXhwb3J0cy5pdGVyYXRvciA9IHN5bWJvbEl0ZXJhdG9yUG9ueWZpbGwocm9vdF8xLnJvb3QpO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2UgaXRlcmF0b3IgaW5zdGVhZFxuICovXG5leHBvcnRzLiQkaXRlcmF0b3IgPSBleHBvcnRzLml0ZXJhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXRlcmF0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9yb290Jyk7XG5mdW5jdGlvbiBnZXRTeW1ib2xPYnNlcnZhYmxlKGNvbnRleHQpIHtcbiAgICB2YXIgJCRvYnNlcnZhYmxlO1xuICAgIHZhciBTeW1ib2wgPSBjb250ZXh0LlN5bWJvbDtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoU3ltYm9sLm9ic2VydmFibGUpIHtcbiAgICAgICAgICAgICQkb2JzZXJ2YWJsZSA9IFN5bWJvbC5vYnNlcnZhYmxlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgJCRvYnNlcnZhYmxlID0gU3ltYm9sKCdvYnNlcnZhYmxlJyk7XG4gICAgICAgICAgICBTeW1ib2wub2JzZXJ2YWJsZSA9ICQkb2JzZXJ2YWJsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgJCRvYnNlcnZhYmxlID0gJ0BAb2JzZXJ2YWJsZSc7XG4gICAgfVxuICAgIHJldHVybiAkJG9ic2VydmFibGU7XG59XG5leHBvcnRzLmdldFN5bWJvbE9ic2VydmFibGUgPSBnZXRTeW1ib2xPYnNlcnZhYmxlO1xuZXhwb3J0cy5vYnNlcnZhYmxlID0gZ2V0U3ltYm9sT2JzZXJ2YWJsZShyb290XzEucm9vdCk7XG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSBvYnNlcnZhYmxlIGluc3RlYWRcbiAqL1xuZXhwb3J0cy4kJG9ic2VydmFibGUgPSBleHBvcnRzLm9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvcm9vdCcpO1xudmFyIFN5bWJvbCA9IHJvb3RfMS5yb290LlN5bWJvbDtcbmV4cG9ydHMucnhTdWJzY3JpYmVyID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5mb3IgPT09ICdmdW5jdGlvbicpID9cbiAgICBTeW1ib2wuZm9yKCdyeFN1YnNjcmliZXInKSA6ICdAQHJ4U3Vic2NyaWJlcic7XG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSByeFN1YnNjcmliZXIgaW5zdGVhZFxuICovXG5leHBvcnRzLiQkcnhTdWJzY3JpYmVyID0gZXhwb3J0cy5yeFN1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yeFN1YnNjcmliZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gYW4gZWxlbWVudCB3YXMgcXVlcmllZCBhdCBhIGNlcnRhaW4gaW5kZXggb2YgYW5cbiAqIE9ic2VydmFibGUsIGJ1dCBubyBzdWNoIGluZGV4IG9yIHBvc2l0aW9uIGV4aXN0cyBpbiB0aGF0IHNlcXVlbmNlLlxuICpcbiAqIEBzZWUge0BsaW5rIGVsZW1lbnRBdH1cbiAqIEBzZWUge0BsaW5rIHRha2V9XG4gKiBAc2VlIHtAbGluayB0YWtlTGFzdH1cbiAqXG4gKiBAY2xhc3MgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JcbiAqL1xudmFyIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IoKSB7XG4gICAgICAgIHZhciBlcnIgPSBfc3VwZXIuY2FsbCh0aGlzLCAnYXJndW1lbnQgb3V0IG9mIHJhbmdlJyk7XG4gICAgICAgIHRoaXMubmFtZSA9IGVyci5uYW1lID0gJ0FyZ3VtZW50T3V0T2ZSYW5nZUVycm9yJztcbiAgICAgICAgdGhpcy5zdGFjayA9IGVyci5zdGFjaztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IgPSBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIGFuIGFjdGlvbiBpcyBpbnZhbGlkIGJlY2F1c2UgdGhlIG9iamVjdCBoYXMgYmVlblxuICogdW5zdWJzY3JpYmVkLlxuICpcbiAqIEBzZWUge0BsaW5rIFN1YmplY3R9XG4gKiBAc2VlIHtAbGluayBCZWhhdmlvclN1YmplY3R9XG4gKlxuICogQGNsYXNzIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXG4gKi9cbnZhciBPYmplY3RVbnN1YnNjcmliZWRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE9iamVjdFVuc3Vic2NyaWJlZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCkge1xuICAgICAgICB2YXIgZXJyID0gX3N1cGVyLmNhbGwodGhpcywgJ29iamVjdCB1bnN1YnNjcmliZWQnKTtcbiAgICAgICAgdGhpcy5uYW1lID0gZXJyLm5hbWUgPSAnT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3InO1xuICAgICAgICB0aGlzLnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5PYmplY3RVbnN1YnNjcmliZWRFcnJvciA9IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gb25lIG9yIG1vcmUgZXJyb3JzIGhhdmUgb2NjdXJyZWQgZHVyaW5nIHRoZVxuICogYHVuc3Vic2NyaWJlYCBvZiBhIHtAbGluayBTdWJzY3JpcHRpb259LlxuICovXG52YXIgVW5zdWJzY3JpcHRpb25FcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFVuc3Vic2NyaXB0aW9uRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVW5zdWJzY3JpcHRpb25FcnJvcihlcnJvcnMpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB2YXIgZXJyID0gRXJyb3IuY2FsbCh0aGlzLCBlcnJvcnMgP1xuICAgICAgICAgICAgZXJyb3JzLmxlbmd0aCArIFwiIGVycm9ycyBvY2N1cnJlZCBkdXJpbmcgdW5zdWJzY3JpcHRpb246XFxuICBcIiArIGVycm9ycy5tYXAoZnVuY3Rpb24gKGVyciwgaSkgeyByZXR1cm4gKChpICsgMSkgKyBcIikgXCIgKyBlcnIudG9TdHJpbmcoKSk7IH0pLmpvaW4oJ1xcbiAgJykgOiAnJyk7XG4gICAgICAgIHRoaXMubmFtZSA9IGVyci5uYW1lID0gJ1Vuc3Vic2NyaXB0aW9uRXJyb3InO1xuICAgICAgICB0aGlzLnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIFVuc3Vic2NyaXB0aW9uRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLlVuc3Vic2NyaXB0aW9uRXJyb3IgPSBVbnN1YnNjcmlwdGlvbkVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VW5zdWJzY3JpcHRpb25FcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcbiAgICByZXR1cm4geCAhPSBudWxsICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0Jztcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzT2JqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gbm90KHByZWQsIHRoaXNBcmcpIHtcbiAgICBmdW5jdGlvbiBub3RQcmVkKCkge1xuICAgICAgICByZXR1cm4gIShub3RQcmVkLnByZWQuYXBwbHkobm90UHJlZC50aGlzQXJnLCBhcmd1bWVudHMpKTtcbiAgICB9XG4gICAgbm90UHJlZC5wcmVkID0gcHJlZDtcbiAgICBub3RQcmVkLnRoaXNBcmcgPSB0aGlzQXJnO1xuICAgIHJldHVybiBub3RQcmVkO1xufVxuZXhwb3J0cy5ub3QgPSBub3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pZiAodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cud2luZG93ID09PSB3aW5kb3cpIHtcbiAgICBleHBvcnRzLnJvb3QgPSB3aW5kb3c7XG59XG5lbHNlIGlmICh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmLnNlbGYgPT09IHNlbGYpIHtcbiAgICBleHBvcnRzLnJvb3QgPSBzZWxmO1xufVxuZWxzZSBpZiAodHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwuZ2xvYmFsID09PSBnbG9iYWwpIHtcbiAgICBleHBvcnRzLnJvb3QgPSBnbG9iYWw7XG59XG5lbHNlIHtcbiAgICAvLyBXb3JrYXJvdW5kIENsb3N1cmUgQ29tcGlsZXIgcmVzdHJpY3Rpb246IFRoZSBib2R5IG9mIGEgZ29vZy5tb2R1bGUgY2Fubm90IHVzZSB0aHJvdy5cbiAgICAvLyBUaGlzIGlzIG5lZWRlZCB3aGVuIHVzZWQgd2l0aCBhbmd1bGFyL3RzaWNrbGUgd2hpY2ggaW5zZXJ0cyBhIGdvb2cubW9kdWxlIHN0YXRlbWVudC5cbiAgICAvLyBXcmFwIGluIElJRkVcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1J4SlMgY291bGQgbm90IGZpbmQgYW55IGdsb2JhbCBjb250ZXh0ICh3aW5kb3csIHNlbGYsIGdsb2JhbCknKTtcbiAgICB9KSgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm9vdC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTcgRmxvcmlhbiBLbGFtcGZlclxuLy8gTGljZW5zZWQgdW5kZXIgTUlUXG5cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuXG4vKipcbiAqIENoZWNrcyB0byBzZWUgaWYgdGhlIHVybCBpcyBleHRlcm5hbFxuICpcbiAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgIHVybCAtIHVybCBiZWluZyBldmFsdWF0ZWRcbiAqIEBzZWUgICAgIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjIzODM1MS9mYXN0ZXN0LXdheS10by1kZXRlY3QtZXh0ZXJuYWwtdXJsc1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFeHRlcm5hbCh1cmwpIHtcbiAgY29uc3QgbWF0Y2ggPSB1cmwubWF0Y2goL14oW146XFwvPyNdKzopPyg/OlxcL1xcLyhbXlxcLz8jXSopKT8oW14/I10rKT8oXFw/W14jXSopPygjLiopPy8pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG5cbiAgaWYgKHR5cGVvZiBtYXRjaFsxXSA9PT0gJ3N0cmluZycgJiZcbiAgICAgIG1hdGNoWzFdLmxlbmd0aCA+IDAgJiZcbiAgICAgIG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgIT09IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbFxuICAgICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgcG9ydCA9IHsgaHR0cDogODAsIGh0dHBzOiA0NDMgfVt3aW5kb3cubG9jYXRpb24ucHJvdG9jb2xdO1xuXG4gIGlmICh0eXBlb2YgbWF0Y2hbMl0gPT09ICdzdHJpbmcnICYmXG4gICAgbWF0Y2hbMl0ubGVuZ3RoID4gMCAmJlxuICAgIG1hdGNoWzJdLnJlcGxhY2UobmV3IFJlZ0V4cChgOigke3BvcnR9KT8kYCksICcnKSAhPT0gd2luZG93LmxvY2F0aW9uLmhvc3QpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBTdHJpcHMgdGhlIGhhc2ggZnJvbSBhIHVybCBhbmQgcmV0dXJucyB0aGUgbmV3IGhyZWZcbiAqXG4gKiBAcGFyYW0gICB7c3RyaW5nfSAgICBocmVmIC0gdXJsIGJlaW5nIGV2YWx1YXRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBIYXNoKGhyZWYpIHtcbiAgcmV0dXJuIGhyZWYucmVwbGFjZSgvIy4qLywgJycpO1xufVxuXG4vKipcbiAqIENoZWNrcyB0byBzZWUgaWYgdGhlIHVybCBpcyBhbiBpbnRlcm5hbCBoYXNoXG4gKlxuICogQHBhcmFtICAge3N0cmluZ30gICAgaHJlZiAtIHVybCBiZWluZyBldmFsdWF0ZWRcbiAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgIHByZXYgLSBwcmV2aW91cyB1cmwgKG9wdGlvbmFsKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNIYXNoKGhyZWYsIHByZXYpIHtcbiAgY29uc3QgcCA9IHByZXYgfHwgd2luZG93LmxvY2F0aW9uLmhyZWY7XG5cbiAgY29uc3QgaGFzSGFzaCA9IGhyZWYuaW5kZXhPZignIycpID4gLTE7XG4gIGNvbnN0IHNhbWVQYXRoID0gc3RyaXBIYXNoKGhyZWYpID09PSBzdHJpcEhhc2gocCk7XG5cbiAgcmV0dXJuIChoYXNIYXNoICYmIHNhbWVQYXRoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoZXMoZWwsIHNlbGVjdG9yKSB7XG4gIHJldHVybiAoZWwubWF0Y2hlcyB8fCBlbC5tYXRjaGVzU2VsZWN0b3IgfHwgZWwubXNNYXRjaGVzU2VsZWN0b3IgfHwgZWwubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgZWwud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGVsLm9NYXRjaGVzU2VsZWN0b3IpLmNhbGwoZWwsIHNlbGVjdG9yKTtcbiAgLy8gaWYgKCFtYXRjaGVzLm1lbW8pIHtcbiAgLy8gICBtYXRjaGVzLm1lbW8gPVxuICAvLyAgICAgZWwubWF0Y2hlcyB8fFxuICAvLyAgICAgZWwubWF0Y2hlc1NlbGVjdG9yIHx8XG4gIC8vICAgICBlbC5tc01hdGNoZXNTZWxlY3RvciB8fFxuICAvLyAgICAgZWwubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG4gIC8vICAgICBlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcbiAgLy8gICAgIGVsLm9NYXRjaGVzU2VsZWN0b3I7XG4gIC8vIH1cbiAgLy8gcmV0dXJuIG1hdGNoZXMubWVtby5jYWxsKGVsLCBzZWxlY3Rvcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBxdWVyeVNlbGVjdG9ySW52KGVsLCBzZWxlY3Rvcikge1xuICBsZXQgY3VyciA9IGVsO1xuICB3aGlsZSAoY3VyciAhPT0gZG9jdW1lbnQgJiYgY3VyciAhPT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgaWYgKG1hdGNoZXMoY3Vyciwgc2VsZWN0b3IpKSByZXR1cm4gY3VycjtcbiAgICBjdXJyID0gY3Vyci5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENoZWNrcyB0byBzZWUgaWYgd2Ugc2hvdWxkIGJlIGxvYWRpbmcgdGhpcyBVUkxcbiAqXG4gKiBAcGFyYW0gICB7c3RyaW5nfSAgICB1cmwgLSB1cmwgYmVpbmcgZXZhbHVhdGVkXG4gKiBAcGFyYW0gICB7c3RyaW5nfSAgICBibGFja2xpc3QgLSBqcXVlcnkgc2VsZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZExvYWRBbmNob3IoYW5jaG9yLCBibGFja2xpc3QsIGhyZWZSZWdleCkge1xuICBjb25zdCBocmVmID0gYW5jaG9yLmhyZWY7XG4gIC8vIFVSTCB3aWxsIG9ubHkgYmUgbG9hZGVkIGlmIGl0J3Mgbm90IGFuIGV4dGVybmFsIGxpbmssIGhhc2gsIG9yXG4gIC8vIGJsYWNrbGlzdGVkXG4gIHJldHVybiAoXG4gICAgIWlzRXh0ZXJuYWwoaHJlZikgJiZcbiAgICAhaXNIYXNoKGhyZWYpICYmXG4gICAgIW1hdGNoZXMoYW5jaG9yLCBibGFja2xpc3QpICYmXG4gICAgYW5jaG9yLnRhcmdldCA9PT0gJycgJiYgKFxuICAgICAgaHJlZlJlZ2V4ID09PSBudWxsIHx8XG4gICAgICBocmVmLnNlYXJjaChocmVmUmVnZXgpICE9PSAtMVxuICAgIClcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjcm9sbEhlaWdodCgpIHtcbiAgY29uc3QgaCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgY29uc3QgYiA9IGRvY3VtZW50LmJvZHk7XG4gIGNvbnN0IHNoID0gJ3Njcm9sbEhlaWdodCc7XG4gIHJldHVybiBoW3NoXSB8fCBiW3NoXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjcm9sbExlZnQoKSB7XG4gIHJldHVybiB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2Nyb2xsVG9wKCkge1xuICByZXR1cm4gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwSW50ZXJ2YWwoaW5pdCwgZXhwKSB7XG4gIHJldHVybiBPYnNlcnZhYmxlLmNyZWF0ZSgob2JzZXJ2ZXIpID0+IHtcbiAgICBsZXQgbiA9IGluaXQ7XG4gICAgbGV0IGlkO1xuXG4gICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIG9ic2VydmVyLm5leHQobik7XG4gICAgICBuICo9IGV4cDtcbiAgICAgIGlkID0gc2V0VGltZW91dChuZXh0LCBuKTtcbiAgICB9XG5cbiAgICBpZCA9IHNldFRpbWVvdXQobmV4dCwgbik7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICB9O1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZyYWdtZW50RnJvbVN0cmluZyhzdHJIVE1MKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVSYW5nZSgpLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChzdHJIVE1MKTtcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgMjAxNyBGbG9yaWFuIEtsYW1wZmVyXG4vLyBMaWNlbnNlZCB1bmRlciBNSVRcblxuLypcbmVzbGludC1kaXNhYmxlXG5pbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXMsXG5pbXBvcnQvbm8tdW5yZXNvbHZlZCxcbmltcG9ydC9leHRlbnNpb25zLFxubm8tY29uc29sZVxuKi9cblxuLy8gY29uc3QgSlNfRkVBVFVSRVMgPSBbXG4vLyAgICdmbi9hcnJheS9mb3ItZWFjaCcsXG4vLyAgICdmbi9mdW5jdGlvbi9iaW5kJyxcbi8vICAgJ2ZuL251bWJlci9jb25zdHJ1Y3RvcicsXG4vLyAgICdmbi9vYmplY3QvYXNzaWduJyxcbi8vICAgJ2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHknLFxuLy8gICAnZm4vb2JqZWN0L2tleXMnLFxuLy8gXTtcbi8vXG4vLyBjb25zdCBNT0RFUk5JWlJfVEVTVFMgPSBbXG4vLyAgICdjdXN0b21ldmVudCcsXG4vLyAgICdkb2N1bWVudGZyYWdtZW50Jyxcbi8vICAgJ2V2ZW50bGlzdGVuZXInLFxuLy8gICAnaGlzdG9yeScsXG4vLyAgICdyZXF1ZXN0YW5pbWF0aW9uZnJhbWUnLFxuLy8gICAncXVlcnlzZWxlY3RvcicsXG4vLyBdO1xuXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuXG5pbXBvcnQgJ3J4anMvYWRkL29ic2VydmFibGUvZGVmZXInO1xuaW1wb3J0ICdyeGpzL2FkZC9vYnNlcnZhYmxlL2Zyb20nO1xuaW1wb3J0ICdyeGpzL2FkZC9vYnNlcnZhYmxlL2Zyb21FdmVudCc7XG5pbXBvcnQgJ3J4anMvYWRkL29ic2VydmFibGUvbWVyZ2UnO1xuaW1wb3J0ICdyeGpzL2FkZC9vYnNlcnZhYmxlL29mJztcbmltcG9ydCAncnhqcy9hZGQvb2JzZXJ2YWJsZS90aHJvdyc7XG5pbXBvcnQgJ3J4anMvYWRkL29ic2VydmFibGUvdGltZXInO1xuXG5pbXBvcnQgJ3J4anMvYWRkL29ic2VydmFibGUvZG9tL2FqYXgnO1xuXG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL2NhdGNoJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvY29uY2F0TWFwJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvZGVib3VuY2VUaW1lJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvZGVsYXknO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL2RvJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvZmlsdGVyJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvbWFwJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvbWVyZ2VNYXAnO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9wYXJ0aXRpb24nO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9yZXRyeVdoZW4nO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9zaGFyZSc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3N0YXJ0V2l0aCc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3N3aXRjaCc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3N3aXRjaE1hcCc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3Rha2UnO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci90YWtlVW50aWwnO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci90aHJvdHRsZVRpbWUnO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci93aXRoTGF0ZXN0RnJvbSc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3ppcCc7XG5cbmltcG9ydCBjb21wb25lbnRDb3JlIGZyb20gJ3ktY29tcG9uZW50L3NyYy9jb21wb25lbnQtY29yZSc7XG5cbmltcG9ydCB7XG4gIHNob3VsZExvYWRBbmNob3IsXG4gIGdldFNjcm9sbFRvcCxcbiAgZ2V0U2Nyb2xsSGVpZ2h0LFxuICBleHBJbnRlcnZhbCxcbiAgZnJhZ21lbnRGcm9tU3RyaW5nLFxufSBmcm9tICcuLi9jb21tb24nO1xuXG5pbXBvcnQgeyBQdXNoLCBIaW50LCBQb3AgfSBmcm9tICcuL2tpbmQnO1xuXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5wYXVzZVdpdGggPSBmdW5jdGlvbiBwYXVzZVdpdGgocGF1c2VyJCkge1xuICByZXR1cm4gdGhpcy53aXRoTGF0ZXN0RnJvbShwYXVzZXIkKVxuICAgICAgLmZpbHRlcigoWywgcGF1c2VkXSkgPT4gcGF1c2VkID09PSBmYWxzZSlcbiAgICAgIC5tYXAoKFt4XSkgPT4geCk7XG59O1xuXG4vLyB+IG1peGluIHB1c2hTdGF0ZUNvcmUgd2l0aCBjb21wb25lbnRDb3JlIHsgLi4uXG5leHBvcnQgZGVmYXVsdCBDID0+IGNsYXNzIGV4dGVuZHMgY29tcG9uZW50Q29yZShDKSB7XG5cbiAgLy8gQG92ZXJyaWRlXG4gIGdldENvbXBvbmVudE5hbWUoKSB7XG4gICAgcmV0dXJuICd5LXB1c2gtc3RhdGUnO1xuICB9XG5cbiAgLy8gQG92ZXJyaWRlXG4gIGRlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZXBsYWNlSWRzOiBbXSxcbiAgICAgIGxpbmtTZWxlY3RvcjogJ2FbaHJlZl0nLFxuICAgICAgc2Nyb2xsUmVzdG9yYXRpb246IGZhbHNlLFxuICAgICAgaHJlZlJlZ2V4OiBudWxsLFxuICAgICAgYmxhY2tsaXN0OiAnLm5vLXB1c2gtc3RhdGUnLFxuICAgICAgZHVyYXRpb246IDAsXG4gICAgICBub1BvcER1cmF0aW9uOiB0cnVlLFxuICAgIH07XG4gIH1cblxuICAvLyBAb3ZlcnJpZGVcbiAgc2lkZUVmZmVjdHMoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLy8gQG92ZXJyaWRlXG4gIHN0YXJ0SGlzdG9yeSgpIHtcbiAgICB0aGlzLmNoZWNrUHJlQ29uZGl0aW9uKCk7XG4gICAgdGhpcy5zZXR1cFNjcm9sbFJlc3RvcmF0aW9uKCk7XG4gICAgdGhpcy5jYWNoZVRpdGxlRWxlbWVudCgpO1xuICAgIHRoaXMuc2V0dXBPYnNlcnZhYmxlcygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY2hlY2tQcmVDb25kaXRpb24oKSB7XG4gICAgaWYgKHRoaXMucmVwbGFjZUlkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnN0IGlkID0gdGhpcy5lbC5pZDtcbiAgICAgIGlmIChpZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYE5vIHJlcGxhY2UgaWRzIHByb3ZpZGVkLiBXaWxsIHJlcGxhY2UgZW50aXJlIGNvbnRlbnQgb2YgIyR7aWR9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcignTm8gcmVwbGFjZSBpZHMgcHJvdmlkZWQgbm9yIGRvZXMgdGhpcyBjb21wb25lbnQgaGF2ZSBhbmQgaWQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzZXR1cFNjcm9sbFJlc3RvcmF0aW9uKCkge1xuICAgIGlmICgnc2Nyb2xsUmVzdG9yYXRpb24nIGluIGhpc3RvcnkpIHtcbiAgICAgIGhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSB0aGlzLnNjcm9sbFJlc3RvcmF0aW9uID8gJ21hbnVhbCcgOiAnYXV0byc7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTY3JvbGxQb3NpdGlvbigpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB0aGlzLnVwZGF0ZUhpc3RvcnlTdGF0ZS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIGNhY2hlVGl0bGVFbGVtZW50KCkge1xuICAgIHRoaXMudGl0bGVFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcigndGl0bGUnKSB8fCB7fTtcbiAgfVxuXG4gIGJpbmRQdXNoRXZlbnRzKGxpbmskKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbUV2ZW50cyhsaW5rJCwgJ2NsaWNrJylcbiAgICAgIC5tYXAoZXZlbnQgPT4gbmV3IFB1c2goZXZlbnQpKVxuICAgICAgLmZpbHRlcihraW5kID0+IHRoaXMuaXNQYWdlQ2hhbmdlRXZlbnQoa2luZCkpXG4gICAgICAuZG8oKHsgZXZlbnQgfSkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZUhpc3RvcnlTdGF0ZSgpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSk7XG4gIH1cblxuICBiaW5kSGludEV2ZW50cyhsaW5rJCkge1xuICAgIHJldHVybiBPYnNlcnZhYmxlLm1lcmdlKFxuICAgICAgICB0aGlzLmZyb21FdmVudHMobGluayQsICdtb3VzZWVudGVyJyksXG4gICAgICAgIHRoaXMuZnJvbUV2ZW50cyhsaW5rJCwgJ3RvdWNoc3RhcnQnKSxcbiAgICAgICAgdGhpcy5mcm9tRXZlbnRzKGxpbmskLCAnZm9jdXMnKSxcbiAgICAgIClcbiAgICAgIC5tYXAoZXZlbnQgPT4gbmV3IEhpbnQoZXZlbnQpKVxuICAgICAgLmZpbHRlcihraW5kID0+IHRoaXMuaXNQYWdlQ2hhbmdlQW5jaG9yKGtpbmQpKTtcbiAgfVxuXG4gIGJpbmRQb3BzdGF0ZUV2ZW50KCkge1xuICAgIHJldHVybiBPYnNlcnZhYmxlLmZyb21FdmVudCh3aW5kb3csICdwb3BzdGF0ZScpXG4gICAgICAubWFwKGV2ZW50ID0+IG5ldyBQb3AoZXZlbnQpKVxuICAgICAgLmZpbHRlcigoKSA9PiB3aW5kb3cuaGlzdG9yeS5zdGF0ZSAhPSBudWxsKTtcbiAgfVxuXG4gIGxpbmtPYnNlcnZhYmxlKCkge1xuICAgIHJldHVybiBPYnNlcnZhYmxlLm9mKHRoaXMuZWwucXVlcnlTZWxlY3RvckFsbCh0aGlzLmxpbmtTZWxlY3RvcikpO1xuICB9XG5cbiAgZnJvbUV2ZW50cyhsaW5rJCwgZXZlbnQpIHtcbiAgICByZXR1cm4gbGluayQubWVyZ2VNYXAobGluayA9PiBPYnNlcnZhYmxlLmZyb21FdmVudChsaW5rLCBldmVudCkpO1xuICB9XG5cbiAgZmV0Y2hQYWdlKGtpbmQpIHtcbiAgICByZXR1cm4gT2JzZXJ2YWJsZVxuICAgICAgLmFqYXgodGhpcy5ocmVmVG9BamF4KGtpbmQpKVxuICAgICAgLm1hcCgoeyByZXNwb25zZSB9KSA9PiBPYmplY3QuYXNzaWduKGtpbmQsIHsgcmVzcG9uc2UgfSkpXG4gICAgICAuY2F0Y2goZXJyb3IgPT4gdGhpcy5yZWNvdmVySWZSZXNwb25zZShraW5kLCBlcnJvcikpXG4gICAgICAucmV0cnlXaGVuKCgpID0+IE9ic2VydmFibGUubWVyZ2UoXG4gICAgICAgICAgT2JzZXJ2YWJsZS5mcm9tRXZlbnQod2luZG93LCAnb25saW5lJyksXG4gICAgICAgICAgZXhwSW50ZXJ2YWwoMTAwMCwgMikpXG4gICAgICAgIC5kbyh0aGlzLm9uUmV0cnkuYmluZCh0aGlzLCBraW5kKSkpO1xuICB9XG5cbiAgaHJlZlRvQWpheCh7IGhyZWYgfSkge1xuICAgIHJldHVybiB7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgdXJsOiBocmVmLFxuICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgfTtcbiAgfVxuXG4gIHJlY292ZXJJZlJlc3BvbnNlKGtpbmQsIGVycm9yKSB7XG4gICAgY29uc3QgeyBzdGF0dXMsIHhociB9ID0gZXJyb3I7XG5cbiAgICBpZiAoeGhyICYmIHN0YXR1cyAmJiBzdGF0dXMgPiA0MDApIHtcbiAgICAgIC8vIFJlY292ZXIgd2l0aCBlcnJvciBwYWdlIHJldHVybmVkIGZyb20gc2VydmVyLlxuICAgICAgLy8gTk9URTogVGhpcyBhc3N1bWVzIGVycm9yIHBhZ2UgY29udGFpbnMgdGhlIHNhbWUgaWRzIGFzIHRoZSBvdGhlciBwYWdlcy4uLlxuICAgICAgcmV0dXJuIE9ic2VydmFibGUub2YoT2JqZWN0LmFzc2lnbihraW5kLCB7IHJlc3BvbnNlOiB4aHIucmVzcG9uc2UgfSkpO1xuICAgIH1cblxuICAgIC8vIGVsc2VcbiAgICB0aGlzLm9uRXJyb3IoT2JqZWN0LmFzc2lnbihraW5kLCBlcnJvcikpO1xuICAgIHJldHVybiBPYnNlcnZhYmxlLnRocm93KGVycm9yKTtcbiAgfVxuXG4gIHNldHVwT2JzZXJ2YWJsZXMoKSB7XG4gICAgLy8gU2VlIGByZW5ld0V2ZW50TGlzdGVuZXJzYFxuICAgIC8vIFRPRE86IFBvc3NpYmxlIHdpdGhvdXQgc3ViamVjdHM/XG4gICAgdGhpcy5wdXNoJCQgPSBuZXcgU3ViamVjdCgpO1xuICAgIHRoaXMuaGludCQkID0gbmV3IFN1YmplY3QoKTtcblxuICAgIGNvbnN0IHB1c2gkID0gdGhpcy5wdXNoJCQuc3dpdGNoKClcbiAgICAgIC8vIFRPRE86IFRoaXMgcHJldmVudHMgYSB3aG9sZSBjbGFzcyBvZiBjb25jdXJyZW5jeSBidWdzLFxuICAgICAgLy8gVGhpcyBpcyBub3QgYW4gaXNzdWUgZm9yIGZhc3QgYW5pbWF0aW9ucyAoYW5kIHByZXZlbnRzIGFjY2lkZW50aWFsIGRvdWJsZSB0YXBwaW5nKVxuICAgICAgLy8gSWRlYWxseSB0aGUgVUkgaXMgZnVsbHkgcmVwc29uc2l2ZSBhdCBhbGwgdGltZXMgdGhvdWdoLi5cbiAgICAgIC8vIE5vdGUgdGhhdCBzcGFtbWluZyB0aGUgYmFjay9mb3J3YXJkIGJ1dHRvbiBpcyBzdGlsbCBwb3NzaWJsZSAob25seSBhZmZlY3RzIGBwdXNoJGApXG4gICAgICAudGhyb3R0bGVUaW1lKHRoaXMuZHVyYXRpb24gKyAxMDApO1xuXG4gICAgY29uc3QgcG9wJCA9IHRoaXMuYmluZFBvcHN0YXRlRXZlbnQoKTtcblxuICAgIC8vIERlZmluaXRpdmUgcGFnZSBjaGFuZ2UgKGkuZS4gZWl0aGVyIHB1c2ggb3IgcG9wIGV2ZW50KVxuICAgIHRoaXMucGFnZSQgPSBPYnNlcnZhYmxlLm1lcmdlKHB1c2gkLCBwb3AkKS5zaGFyZSgpO1xuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBwcmVmZXRjaCAoaS5lLiB1c2UgYmFuZHdpZHRoKSBmb3IgYSBfcHJvYmFiaWxpc3RpY18gcGFnZSBsb2FkLFxuICAgIC8vIHdoaWxlIGEgX2RlZmluaXRpdmVfIHBhZ2UgbG9hZCBpcyBnb2luZyBvbiA9PiBgcGF1c2VyJGAgc3RyZWFtLlxuICAgIC8vIE5lZWRzIHRvIGJlIGRlZmVycmVkIGIvYyBvZiBcImN5Y2xpY2FsXCIgZGVwZW5kZW5jeS5cbiAgICBjb25zdCBwYXVzZXIkID0gT2JzZXJ2YWJsZS5kZWZlcigoKSA9PlxuICAgICAgT2JzZXJ2YWJsZS5tZXJnZShcbiAgICAgICAgLy8gQSBwYWdlIGNoYW5nZSBldmVudCBtZWFucyB3ZSB3YW50IHRvIHBhdXNlIHByZWZldGNoaW5nXG4gICAgICAgIHRoaXMucGFnZSQubWFwKCgpID0+IHRydWUpLFxuICAgICAgICAvLyBBIHJlbmRlciBjb21wbGV0ZSBldmVudCBtZWFucyB3ZSB3YW50IHRvIHJlc3VtZSBwcmVmZXRjaGluZ1xuICAgICAgICB0aGlzLnJlbmRlciQubWFwKCgpID0+IGZhbHNlKSxcbiAgICAgIClcbiAgICAgICAgLy8gU3RhcnQgd2l0aCBwcmVmZXRjaGluZ1xuICAgICAgICAuc3RhcnRXaXRoKGZhbHNlKSxcbiAgICApO1xuXG4gICAgLy8gVGhlIHN0cmVhbSBvZiBoaW50IChwcmVmZXRjaCkgZXZlbnRzLCBwb3NzaWJseSBwYXVzZWQuXG4gICAgdGhpcy5oaW50JCA9IHRoaXMuaGludCQkLnN3aXRjaCgpLnBhdXNlV2l0aChwYXVzZXIkKTtcblxuICAgIC8vIFRoZSBzdHJlYW0gb2YgKHByZS0pZmV0Y2ggZXZlbnRzLlxuICAgIC8vIEluY2x1ZGVzIGRlZmluaXRpdmUgcGFnZSBjaGFuZ2UgZXZlbnRzIGRvIGRlYWwgd2l0aCB1bmV4cGVjdGVkIHBhZ2UgY2hhbmdlcy5cbiAgICB0aGlzLnByZWZldGNoJCA9IE9ic2VydmFibGUubWVyZ2UodGhpcy5oaW50JCwgdGhpcy5wYWdlJClcbiAgICAgIC5kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCgnaHJlZicpIC8vIERvbid0IGFib3J0IGEgcmVxdWVzdCBpZiB0aGUgdXNlciBcImppZ2dsZXNcIiBvdmVyIGEgbGlua1xuICAgICAgLnN3aXRjaE1hcChraW5kID0+IHRoaXMuZmV0Y2hQYWdlKGtpbmQpKVxuICAgICAgLmNhdGNoKChlcnIsIGNhdWdodCkgPT4gY2F1Z2h0KVxuICAgICAgLnN0YXJ0V2l0aCh7fSkgLy8gU3RhcnQgd2l0aCBzb21lIHZhbHVlIHNvIGB3aXRoTGF0ZXN0RnJvbWAgYmVsb3cgZG9lc24ndCBcImJsb2NrXCJcbiAgICAgIC5zaGFyZSgpO1xuXG4gICAgdGhpcy5yZW5kZXIkID0gdGhpcy5wYWdlJFxuICAgICAgLmRvKHRoaXMub25TdGFydC5iaW5kKHRoaXMpKVxuICAgICAgLndpdGhMYXRlc3RGcm9tKHRoaXMucHJlZmV0Y2gkKVxuICAgICAgLnN3aXRjaE1hcCh0aGlzLmdldFJlc3BvbnNlLmJpbmQodGhpcykpXG4gICAgICAubWFwKHRoaXMucmVzcG9uc2VUb0NvbnRlbnQuYmluZCh0aGlzKSlcbiAgICAgIC5kbyh0aGlzLm9uUmVhZHkuYmluZCh0aGlzKSlcbiAgICAgIC5kbyh0aGlzLnVwZGF0ZURPTS5iaW5kKHRoaXMpKVxuICAgICAgLmRvKHRoaXMucmVzZXRTY3JvbGxQb3N0aW9uLmJpbmQodGhpcykpXG4gICAgICAuZG8odGhpcy5vbkFmdGVyLmJpbmQodGhpcykpXG4gICAgICAuY2F0Y2goKGVycm9yLCBjYXVnaHQpID0+IHtcbiAgICAgICAgdGhpcy5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIHJldHVybiBjYXVnaHQ7XG4gICAgICB9KVxuICAgICAgLy8gYHNoYXJlYGluZyB0aGUgc3RyZWFtIGJldHdlZW4gdGhlIHN1YnNjcmlwdGlvbiBiZWxvdyBhbmQgYHBhdXNlciRgLlxuICAgICAgLnNoYXJlKCk7XG5cbiAgICB0aGlzLnJlbmRlciRcbiAgICAgIC8vIFJlbmV3aW5nIGV2ZW50IGxpc3RlbmVycyBhZnRlciBET00gdXBkYXRlL2xheW91dC9wYWludGluZyBpcyBjb21wbGV0ZVxuICAgICAgLy8gSEFDSzogZG9uJ3QgdXNlIHRpbWUsIHVzZSBvdXRzaWRlIG9ic2VydmFibGUgaW5zdGVhZD9cbiAgICAgIC5kZWJvdW5jZVRpbWUodGhpcy5kdXJhdGlvbilcbiAgICAgIC5kbyh0aGlzLnJlbmV3RXZlbnRMaXN0ZW5lcnMuYmluZCh0aGlzKSlcbiAgICAgIC5zdWJzY3JpYmUoKTtcblxuICAgIC8vIEFkZCBzY3JpcHQgdGFncyBvbmUgYnkgb25lICh1bmxlc3MgdGhleSBhcmUgbWFyZWtkIGBhc3luY2ApXG4gICAgLy8gVGhpcyBzaW11bGF0ZXMgdGhlIGJlaGF2aW9yIG9mIGEgZnJlc2ggcGFnZSBsb2FkXG4gICAgdGhpcy5yZW5kZXIkXG4gICAgICAuc3dpdGNoTWFwKHRoaXMucmVpbnNlcnRTY3JpcHRUYWdzLmJpbmQodGhpcykpXG4gICAgICAuZG8odGhpcy5vbkxvYWQuYmluZCh0aGlzKSlcbiAgICAgIC5jYXRjaCgoZXJyb3IsIGNhdWdodCkgPT4ge1xuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIGNhdWdodDtcbiAgICAgIH0pXG4gICAgICAuc3Vic2NyaWJlKCk7XG5cbiAgICAvLyBGaXJlIGBwcm9ncmVzc2AgZXZlbnQgd2hlbiBmZXRjaGluZyB0YWtlcyBsb25nZXIgdGhhbiBgdGhpcy5kdXJhdGlvbmAuXG4gICAgdGhpcy5wYWdlJFxuICAgICAgLy8gSEFDSzogYWRkIHNvbWUgdGltZSwganRic1xuICAgICAgLnN3aXRjaE1hcCgoKSA9PiBPYnNlcnZhYmxlLnRpbWVyKHRoaXMuZHVyYXRpb24gKyAyMDApXG4gICAgICAgIC5kbyh0aGlzLm9uQW5pbWF0aW9uRW5kLmJpbmQodGhpcykpXG4gICAgICAgIC50YWtlVW50aWwodGhpcy5yZW5kZXIkKSlcbiAgICAgIC5kbyh0aGlzLm9uUHJvZ3Jlc3MuYmluZCh0aGlzKSlcbiAgICAgIC5jYXRjaCgoZXJyb3IsIGNhdWdodCkgPT4ge1xuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIGNhdWdodDtcbiAgICAgIH0pXG4gICAgICAuc3Vic2NyaWJlKCk7XG5cbiAgICAvLyBTdGFydCBwdWxsaW5nIHZhbHVlc1xuICAgIHRoaXMucmVuZGVyJC5zdWJzY3JpYmUoKTtcblxuICAgIHRoaXMub25Mb2FkKHt9KTtcblxuICAgIC8vIFB1c2ggc3RyZWFtcyBpbnRvIGBwdXNoJCRgIGFuZCBgaGludCQkYFxuICAgIHRoaXMucmVuZXdFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgZ2V0UmVzcG9uc2UoW2tpbmQsIHByZWZldGNoXSkge1xuICAgIGxldCByZXM7XG5cbiAgICAvLyBQcmVmZXRjaCBhbHJlYWR5IGNvbXBsZXRlLCB1c2UgcmVzdWx0XG4gICAgaWYgKGtpbmQuaHJlZiA9PT0gcHJlZmV0Y2guaHJlZikge1xuICAgICAgcmVzID0gT2JzZXJ2YWJsZS5vZihPYmplY3QuYXNzaWduKGtpbmQsIHsgcmVzcG9uc2U6IHByZWZldGNoLnJlc3BvbnNlIH0pKTtcblxuICAgICAgaWYgKGtpbmQgaW5zdGFuY2VvZiBQdXNoIHx8ICF0aGlzLm5vUG9wRHVyYXRpb24pIHtcbiAgICAgICAgLy8gSEFDSzogYWRkIHNvbWUgZXh0cmEgdGltZSB0byBwcmV2ZW50ICdmbGlja2VyaW5nJ1xuICAgICAgICAvLyBpZGVhbGx5LCB3ZSdkIGxpa2UgdG8gdGFrZSBhbiBhbmltYXRpb24gb2JzZXJ2YWJsZSBhcyBpbnB1dCBpbnN0ZWFkXG4gICAgICAgIHJlcyA9IHJlcy5kZWxheSh0aGlzLmR1cmF0aW9uICsgMTAwKTtcbiAgICAgIH1cbiAgICAvLyBQcmVmZXRjaCBpbiBwcm9ncmVzcywgdXNlIG5leHQgcmVzdWx0ICh0aGlzIGlzIHdoeSBgcHJlZmV0Y2gkYCBoYWQgdG8gYmUgYHNoYXJlYGQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IHRoaXMucHJlZmV0Y2gkLnRha2UoMSlcbiAgICAgICAgLm1hcChmZXRjaCA9PiBPYmplY3QuYXNzaWduKGtpbmQsIHsgcmVzcG9uc2U6IGZldGNoLnJlc3BvbnNlIH0pKTtcblxuICAgICAgaWYgKGtpbmQgaW5zdGFuY2VvZiBQdXNoIHx8ICF0aGlzLm5vUG9wRHVyYXRpb24pIHtcbiAgICAgICAgLy8gSEFDSzogYWRkIHNvbWUgZXh0cmEgdGltZSB0byBwcmV2ZW50ICdmbGlja2VyaW5nJ1xuICAgICAgICAvLyBpZGVhbGx5LCB3ZSdkIGxpa2UgdG8gdGFrZSBhbiBhbmltYXRpb24gb2JzZXJ2YWJsZSBhcyBpbnB1dCBpbnN0ZWFkXG4gICAgICAgIHJlcyA9IHJlcy56aXAoT2JzZXJ2YWJsZS50aW1lcih0aGlzLmR1cmF0aW9uICsgMTAwKSwgeCA9PiB4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgcmVzcG9uc2VUb0NvbnRlbnQoc3BvbmdlKSB7XG4gICAgY29uc3QgeyByZXNwb25zZSB9ID0gc3BvbmdlO1xuXG4gICAgY29uc3QgZG9jdW1lbnRGcmFnbWVudCA9IGZyYWdtZW50RnJvbVN0cmluZyhyZXNwb25zZSk7XG4gICAgY29uc3QgdGl0bGUgPSB0aGlzLmdldFRpdGxlRnJvbURvY3VtZW50RnJhZ21lbnQoZG9jdW1lbnRGcmFnbWVudCk7XG4gICAgY29uc3QgY29udGVudCA9IHRoaXMuZ2V0Q29udGVudEZyb21Eb2N1bWVudEZyYWdtZW50KGRvY3VtZW50RnJhZ21lbnQpO1xuICAgIGNvbnN0IHNjcmlwdHMgPSB0aGlzLnRlbXBSZW1vdmVTY3JpcHRUYWdzKGNvbnRlbnQpO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oc3BvbmdlLCB7IHRpdGxlLCBjb250ZW50LCBzY3JpcHRzIH0pO1xuICB9XG5cbiAgdXBkYXRlRE9NKHNwb25nZSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGhyZWYsIHRpdGxlLCBjb250ZW50IH0gPSBzcG9uZ2U7XG5cbiAgICAgIGlmIChzcG9uZ2UgaW5zdGFuY2VvZiBQdXNoKSB7XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IGlkOiB0aGlzLmNvbXBvbmVudE5hbWUgfSwgdGl0bGUsIGhyZWYpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRpdGxlRWxlbWVudC50ZXh0Q29udGVudCA9IHRpdGxlO1xuICAgICAgdGhpcy5yZXBsYWNlQ29udGVudChjb250ZW50KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihzcG9uZ2UsIHsgZXJyb3IgfSk7XG4gICAgfVxuICB9XG5cbiAgdGVtcFJlbW92ZVNjcmlwdFRhZ3MoY29udGVudCkge1xuICAgIGNvbnN0IHNjcmlwdHMgPSBbXTtcblxuICAgIGNvbnRlbnQuZm9yRWFjaChkb2NmcmFnID0+XG4gICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGRvY2ZyYWcucXVlcnlTZWxlY3RvckFsbCgnc2NyaXB0JyksIChzY3JpcHQpID0+IHtcbiAgICAgICAgY29uc3QgcGFpciA9IFtzY3JpcHQsIHNjcmlwdC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nXTtcbiAgICAgICAgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgc2NyaXB0cy5wdXNoKHBhaXIpO1xuICAgICAgfSkpO1xuXG4gICAgcmV0dXJuIHNjcmlwdHM7XG4gIH1cblxuICBpbnNlcnRTY3JpcHQoW3NjcmlwdCwgcmVmXSkge1xuICAgIHJldHVybiBzY3JpcHQuc3JjICE9PSAnJyA/XG4gICAgICBPYnNlcnZhYmxlLmNyZWF0ZSgob2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoeCkgPT4ge1xuICAgICAgICAgIG9ic2VydmVyLm5leHQoeCk7XG4gICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKHgpID0+IHtcbiAgICAgICAgICBvYnNlcnZlci5lcnJvcih4KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVmLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgcmVmLm5leHRFbGVtZW50U2libGluZyk7XG4gICAgICB9KSA6XG4gICAgICBPYnNlcnZhYmxlLm9mKHt9KVxuICAgICAgICAuZG8oKCkgPT4ge1xuICAgICAgICAgIHJlZi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzY3JpcHQsIHJlZi5uZXh0RWxlbWVudFNpYmxpbmcpO1xuICAgICAgICB9KTtcbiAgfVxuXG4gIHJlaW5zZXJ0U2NyaXB0VGFncyh7IHNjcmlwdHMgfSkge1xuICAgIGlmIChzY3JpcHRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIE9ic2VydmFibGUub2Yoe30pO1xuICAgIHJldHVybiBPYnNlcnZhYmxlLmZyb20oc2NyaXB0cykuY29uY2F0TWFwKHRoaXMuaW5zZXJ0U2NyaXB0KTtcblxuICAgIC8vIFRPRE86IHRoZSBjb2RlIGJlbG93IGRvZXMgbm90IGd1YXJhbnRlZSB0aGF0IGEgc2NyaXB0IHRhZyBoYXMgbG9hZGVkIGJlZm9yZSBhIGBhc3luY2Agb25lXG4gICAgLy8gY29uc3QgW3NjcmlwdCQsIGFzeW5jU2NyaXB0JF0gPSBPYnNlcnZhYmxlLmZyb20oc2NyaXB0cylcbiAgICAvLyAgIC5wYXJ0aXRpb24oKFtzY3JpcHRdKSA9PiBzY3JpcHQuYXN5bmMgIT09ICcnKTtcbiAgICAvL1xuICAgIC8vIHJldHVybiBPYnNlcnZhYmxlLm1lcmdlKFxuICAgIC8vICAgICBzY3JpcHQkLmNvbmNhdE1hcCh0aGlzLmluc2VydFNjcmlwdCksXG4gICAgLy8gICAgIGFzeW5jU2NyaXB0JC5tZXJnZU1hcCh0aGlzLmluc2VydFNjcmlwdCksXG4gICAgLy8gICApO1xuICB9XG5cbiAgcmVuZXdFdmVudExpc3RlbmVycygpIHtcbiAgICBjb25zdCBsaW5rJCA9IHRoaXMubGlua09ic2VydmFibGUoKTtcbiAgICB0aGlzLnB1c2gkJC5uZXh0KHRoaXMuYmluZFB1c2hFdmVudHMobGluayQpKTtcbiAgICB0aGlzLmhpbnQkJC5uZXh0KHRoaXMuYmluZEhpbnRFdmVudHMobGluayQpKTtcbiAgfVxuXG4gIGlzUGFnZUNoYW5nZUV2ZW50KGtpbmQpIHtcbiAgICBjb25zdCB7IGV2ZW50IH0gPSBraW5kO1xuICAgIHJldHVybiAoXG4gICAgICAhZXZlbnQubWV0YUtleSAmJlxuICAgICAgIWV2ZW50LmN0cmxLZXkgJiZcbiAgICAgIHRoaXMuaXNQYWdlQ2hhbmdlQW5jaG9yKGtpbmQpXG4gICAgKTtcbiAgfVxuXG4gIGlzUGFnZUNoYW5nZUFuY2hvcih7IGV2ZW50OiB7IGN1cnJlbnRUYXJnZXQ6IGFuY2hvciB9IH0pIHtcbiAgICByZXR1cm4gKFxuICAgICAgYW5jaG9yICE9IG51bGwgJiZcbiAgICAgIHNob3VsZExvYWRBbmNob3IoYW5jaG9yLCB0aGlzLmJsYWNrbGlzdCwgdGhpcy5ocmVmUmVnZXgpXG4gICAgKTtcbiAgfVxuXG4gIGdldFRpdGxlRnJvbURvY3VtZW50RnJhZ21lbnQoZG9jdW1lbnRGcmFnbWVudCkge1xuICAgIHJldHVybiAoZG9jdW1lbnRGcmFnbWVudC5xdWVyeVNlbGVjdG9yKCd0aXRsZScpIHx8IHt9KS50ZXh0Q29udGVudDtcbiAgfVxuXG4gIGdldENvbnRlbnRGcm9tRG9jdW1lbnRGcmFnbWVudChkb2N1bWVudEZyYWdtZW50KSB7XG4gICAgaWYgKHRoaXMucmVwbGFjZUlkcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXBsYWNlSWRzLm1hcChpZCA9PiBkb2N1bWVudEZyYWdtZW50LnF1ZXJ5U2VsZWN0b3IoYCMke2lkfWApKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9jdW1lbnRGcmFnbWVudC5xdWVyeVNlbGVjdG9yKGAjJHt0aGlzLmVsLmlkfWApO1xuICB9XG5cbiAgcmVwbGFjZUNvbnRlbnQoY29udGVudCkge1xuICAgIGlmICh0aGlzLnJlcGxhY2VJZHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5yZXBsYWNlQ29udGVudEJ5SWRzKGNvbnRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlcGxhY2VDb250ZW50V2hvbGVzYWxlKGNvbnRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJlcGxhY2VDb250ZW50QnlJZHMoZWxlbWVudHMpIHtcbiAgICBjb25zdCBvbGRFbGVtZW50cyA9IHRoaXMucmVwbGFjZUlkc1xuICAgICAgLm1hcChpZCA9PiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkpO1xuXG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChvbGRFbGVtZW50cywgKG9sZEVsZW1lbnQpID0+IHtcbiAgICAgIG9sZEVsZW1lbnQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZWxlbWVudHMuc2hpZnQoKSwgb2xkRWxlbWVudCk7XG4gICAgfSk7XG4gIH1cblxuICByZXBsYWNlQ29udGVudFdob2xlc2FsZShjb250ZW50KSB7XG4gICAgdGhpcy5lbC5pbm5lckhUTUwgPSBjb250ZW50LmlubmVySFRNTDtcbiAgfVxuXG4gIHNhdmVTY3JvbGxQb3NpdGlvbihzdGF0ZSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHN0YXRlLCB7XG4gICAgICBzY3JvbGxUb3A6IGdldFNjcm9sbFRvcCgpLFxuICAgICAgc2Nyb2xsSGVpZ2h0OiBnZXRTY3JvbGxIZWlnaHQoKSxcbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZUhpc3RvcnlTdGF0ZSgpIHtcbiAgICBsZXQgc3RhdGUgPSBoaXN0b3J5LnN0YXRlIHx8IHsgaWQ6IHRoaXMuY29tcG9uZW50TmFtZSB9O1xuICAgIHN0YXRlID0gdGhpcy5zY3JvbGxSZXN0b3JhdGlvbiA/IHRoaXMuc2F2ZVNjcm9sbFBvc2l0aW9uKHN0YXRlKSA6IHN0YXRlO1xuICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKHN0YXRlLCBkb2N1bWVudC50aXRsZSwgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICB9XG5cbiAgc2V0U2Nyb2xsUG9zaXRpb24oKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBoaXN0b3J5LnN0YXRlIHx8IHt9O1xuICAgIGRvY3VtZW50LmJvZHkuc3R5bGUubWluSGVpZ2h0ID0gYCR7c3RhdGUuc2Nyb2xsSGVpZ2h0IHx8IDB9cHhgO1xuICAgIGlmIChzdGF0ZS5zY3JvbGxUb3AgIT0gbnVsbCkgd2luZG93LnNjcm9sbCh3aW5kb3cucGFnZVhPZmZzZXQsIHN0YXRlLnNjcm9sbFRvcCk7XG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS5taW5IZWlnaHQgPSAnJztcbiAgfVxuXG4gIHJlc2V0U2Nyb2xsUG9zdGlvbihzcG9uZ2UpIHtcbiAgICBpZiAodGhpcy5zY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgaWYgKHNwb25nZSBpbnN0YW5jZW9mIFBvcCkge1xuICAgICAgICB0aGlzLnNldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25TdGFydChzcG9uZ2UpIHtcbiAgICBjb25zdCB7IGhyZWYgfSA9IHNwb25nZTtcblxuICAgIGlmIChzcG9uZ2UgaW5zdGFuY2VvZiBQdXNoKSB7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoeyBpZDogdGhpcy5jb21wb25lbnROYW1lIH0sICcnLCBocmVmKTtcbiAgICB9XG5cbiAgICB0aGlzLmZpcmVFdmVudCgnc3RhcnQnLCB7IGRldGFpbDogc3BvbmdlIH0pO1xuICB9XG5cbiAgb25SZWFkeShzcG9uZ2UpIHtcbiAgICB0aGlzLmZpcmVFdmVudCgncmVhZHknLCB7IGRldGFpbDogc3BvbmdlIH0pO1xuICB9XG5cbiAgb25BZnRlcihzcG9uZ2UpIHtcbiAgICB0aGlzLmZpcmVFdmVudCgnYWZ0ZXInLCB7IGRldGFpbDogc3BvbmdlIH0pO1xuICB9XG5cbiAgb25FcnJvcihlcnIpIHtcbiAgICB0aGlzLmZpcmVFdmVudCgnZXJyb3InLCB7IGRldGFpbDogZXJyIH0pO1xuICB9XG5cbiAgb25Qcm9ncmVzcyhzcG9uZ2UpIHtcbiAgICB0aGlzLmZpcmVFdmVudCgncHJvZ3Jlc3MnLCB7IGRldGFpbDogc3BvbmdlIH0pO1xuICB9XG5cbiAgb25SZXRyeShzcG9uZ2UpIHtcbiAgICB0aGlzLmZpcmVFdmVudCgncmV0cnknLCB7IGRldGFpbDogc3BvbmdlIH0pO1xuICB9XG5cbiAgb25BbmltYXRpb25FbmQoeCkge1xuICAgIHRoaXMuZmlyZUV2ZW50KCdhbmltYXRpb25lbmQnLCB7IGRldGFpbDogeCB9KTtcbiAgfVxuXG4gIG9uTG9hZCh4KSB7XG4gICAgdGhpcy5maXJlRXZlbnQoJ2xvYWQnLCB7IGRldGFpbDogeCB9KTtcbiAgfVxufTtcbiIsIi8vIENvcHlyaWdodCAoYykgMjAxNyBGbG9yaWFuIEtsYW1wZmVyXG4vLyBMaWNlbnNlZCB1bmRlciBNSVRcblxuZXhwb3J0IGNsYXNzIEtpbmQge1xuICBjb25zdHJ1Y3RvcihldmVudCkge1xuICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUHVzaCBleHRlbmRzIEtpbmQge1xuICBjb25zdHJ1Y3RvcihldmVudCkge1xuICAgIHN1cGVyKGV2ZW50KTtcbiAgICB0aGlzLmhyZWYgPSBldmVudC5jdXJyZW50VGFyZ2V0LmhyZWY7XG4gIH1cblxuICBnZXQgdHlwZSgpIHsgcmV0dXJuICdwdXNoJzsgfVxufVxuXG5leHBvcnQgY2xhc3MgSGludCBleHRlbmRzIEtpbmQge1xuICBjb25zdHJ1Y3RvcihldmVudCkge1xuICAgIHN1cGVyKGV2ZW50KTtcbiAgICB0aGlzLmhyZWYgPSBldmVudC5jdXJyZW50VGFyZ2V0LmhyZWY7XG4gIH1cblxuICBnZXQgdHlwZSgpIHsgcmV0dXJuICdoaW50JzsgfVxufVxuXG5leHBvcnQgY2xhc3MgUG9wIGV4dGVuZHMgS2luZCB7XG4gIGNvbnN0cnVjdG9yKGV2ZW50KSB7XG4gICAgc3VwZXIoZXZlbnQpO1xuICAgIHRoaXMuaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7IHJldHVybiAncG9wJzsgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDE3IEZsb3JpYW4gS2xhbXBmZXJcbi8vIExpY2Vuc2VkIHVuZGVyIE1JVFxuXG5pbXBvcnQgcHVzaFN0YXRlQ29yZSBmcm9tICcuLi9jb3JlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHVzaFN0YXRlIGV4dGVuZHMgcHVzaFN0YXRlQ29yZSgpIHtcbiAgY29uc3RydWN0b3IoZWwsIHByb3BzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNldHVwQ29tcG9uZW50KGVsLCBwcm9wcyk7XG4gIH1cblxuICAvLyBAb3ZlcnJpZGVcbiAgc2V0dXBET00oZWwpIHtcbiAgICBpZiAoIWVsKSB0aHJvdyBFcnJvcignTm8gZWxlbWVudCBwcm92aWRlZCcpO1xuICAgIHJldHVybiBlbDtcbiAgfVxufVxuIl19
